   1              	 .cpu cortex-m0
   2              	 .fpu softvfp
   3              	 .eabi_attribute 20,1
   4              	 .eabi_attribute 21,1
   5              	 .eabi_attribute 23,3
   6              	 .eabi_attribute 24,1
   7              	 .eabi_attribute 25,1
   8              	 .eabi_attribute 26,1
   9              	 .eabi_attribute 30,6
  10              	 .eabi_attribute 34,0
  11              	 .eabi_attribute 18,4
  12              	 .code 16
  13              	 .file "xmc_vadc.c"
  14              	 .text
  15              	.Ltext0:
  16              	 .cfi_sections .debug_frame
  17              	 .section .text.XMC_VADC_GLOBAL_EnableModule,"ax",%progbits
  18              	 .align 2
  19              	 .global XMC_VADC_GLOBAL_EnableModule
  20              	 .code 16
  21              	 .thumb_func
  23              	XMC_VADC_GLOBAL_EnableModule:
  24              	.LFB90:
  25              	 .file 1 "../Libraries/XMCLib/src/xmc_vadc.c"
   1:../Libraries/XMCLib/src/xmc_vadc.c **** /**
   2:../Libraries/XMCLib/src/xmc_vadc.c ****  * @file xmc_vadc.c
   3:../Libraries/XMCLib/src/xmc_vadc.c ****  * @date 2016-06-17
   4:../Libraries/XMCLib/src/xmc_vadc.c ****  *
   5:../Libraries/XMCLib/src/xmc_vadc.c ****  * @cond
   6:../Libraries/XMCLib/src/xmc_vadc.c ****  **************************************************************************************************
   7:../Libraries/XMCLib/src/xmc_vadc.c ****  * XMClib v2.1.18 - XMC Peripheral Driver Library 
   8:../Libraries/XMCLib/src/xmc_vadc.c ****  *
   9:../Libraries/XMCLib/src/xmc_vadc.c ****  * Copyright (c) 2015-2018, Infineon Technologies AG
  10:../Libraries/XMCLib/src/xmc_vadc.c ****  * All rights reserved.                        
  11:../Libraries/XMCLib/src/xmc_vadc.c ****  *                                             
  12:../Libraries/XMCLib/src/xmc_vadc.c ****  * Redistribution and use in source and binary forms, with or without modification,are permitted pr
  13:../Libraries/XMCLib/src/xmc_vadc.c ****  * following conditions are met:   
  14:../Libraries/XMCLib/src/xmc_vadc.c ****  *                                                                              
  15:../Libraries/XMCLib/src/xmc_vadc.c ****  * Redistributions of source code must retain the above copyright notice, this list of conditions a
  16:../Libraries/XMCLib/src/xmc_vadc.c ****  * disclaimer.                        
  17:../Libraries/XMCLib/src/xmc_vadc.c ****  * 
  18:../Libraries/XMCLib/src/xmc_vadc.c ****  * Redistributions in binary form must reproduce the above copyright notice, this list of condition
  19:../Libraries/XMCLib/src/xmc_vadc.c ****  * disclaimer in the documentation and/or other materials provided with the distribution.          
  20:../Libraries/XMCLib/src/xmc_vadc.c ****  * 
  21:../Libraries/XMCLib/src/xmc_vadc.c ****  * Neither the name of the copyright holders nor the names of its contributors may be used to endor
  22:../Libraries/XMCLib/src/xmc_vadc.c ****  * products derived from this software without specific prior written permission.                  
  23:../Libraries/XMCLib/src/xmc_vadc.c ****  *                                                                              
  24:../Libraries/XMCLib/src/xmc_vadc.c ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR I
  25:../Libraries/XMCLib/src/xmc_vadc.c ****  * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTI
  26:../Libraries/XMCLib/src/xmc_vadc.c ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, IN
  27:../Libraries/XMCLib/src/xmc_vadc.c ****  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBS
  28:../Libraries/XMCLib/src/xmc_vadc.c ****  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THE
  29:../Libraries/XMCLib/src/xmc_vadc.c ****  * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
  30:../Libraries/XMCLib/src/xmc_vadc.c ****  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                            
  31:../Libraries/XMCLib/src/xmc_vadc.c ****  *                                                                              
  32:../Libraries/XMCLib/src/xmc_vadc.c ****  * To improve the quality of the software, users are encouraged to share modifications, enhancement
  33:../Libraries/XMCLib/src/xmc_vadc.c ****  * Infineon Technologies AG dave@infineon.com).                                                    
  34:../Libraries/XMCLib/src/xmc_vadc.c ****  **************************************************************************************************
  35:../Libraries/XMCLib/src/xmc_vadc.c ****  *
  36:../Libraries/XMCLib/src/xmc_vadc.c ****  * Change History
  37:../Libraries/XMCLib/src/xmc_vadc.c ****  * --------------
  38:../Libraries/XMCLib/src/xmc_vadc.c ****  *
  39:../Libraries/XMCLib/src/xmc_vadc.c ****  * 2015-02-15:
  40:../Libraries/XMCLib/src/xmc_vadc.c ****  *     - Initial <br>
  41:../Libraries/XMCLib/src/xmc_vadc.c ****  *      
  42:../Libraries/XMCLib/src/xmc_vadc.c ****  * 2015-02-20:
  43:../Libraries/XMCLib/src/xmc_vadc.c ****  *     - Revised for XMC1201 device.<br>
  44:../Libraries/XMCLib/src/xmc_vadc.c ****  *   
  45:../Libraries/XMCLib/src/xmc_vadc.c ****  * 2015-04-27:
  46:../Libraries/XMCLib/src/xmc_vadc.c ****  *     - Added new APIs for SHS.<br>
  47:../Libraries/XMCLib/src/xmc_vadc.c ****  *     - Added New APIs for trigger edge selection.<BR>
  48:../Libraries/XMCLib/src/xmc_vadc.c ****  *     - Added new APIs for Queue flush entries, boundary selection, Boundary node pointer.<BR>
  49:../Libraries/XMCLib/src/xmc_vadc.c ****  *     - Revised GatingMode APIs and EMUX Control Init API.<BR>
  50:../Libraries/XMCLib/src/xmc_vadc.c ****  *
  51:../Libraries/XMCLib/src/xmc_vadc.c ****  * 2015-06-20:
  52:../Libraries/XMCLib/src/xmc_vadc.c ****  *     - Removed version macros and declaration of GetDriverVersion API
  53:../Libraries/XMCLib/src/xmc_vadc.c ****  *
  54:../Libraries/XMCLib/src/xmc_vadc.c ****  * 2015-06-25:
  55:../Libraries/XMCLib/src/xmc_vadc.c ****  *     - BFL configuration in channel initialization fixed.
  56:../Libraries/XMCLib/src/xmc_vadc.c ****  *
  57:../Libraries/XMCLib/src/xmc_vadc.c ****  * 2015-07-28:
  58:../Libraries/XMCLib/src/xmc_vadc.c ****  *     - CLOCK_GATING_SUPPORTED and PERIPHERAL_RESET_SUPPORTED macros used
  59:../Libraries/XMCLib/src/xmc_vadc.c ****  *     - Clubbed the macro definitions for XMC13 XMC12 and XMC14
  60:../Libraries/XMCLib/src/xmc_vadc.c ****  *     - Clubbed the macro definitions for XMC44 XMC47 and XMC48
  61:../Libraries/XMCLib/src/xmc_vadc.c ****  *     - New APIs Created.
  62:../Libraries/XMCLib/src/xmc_vadc.c ****  *           - XMC_VADC_GLOBAL_SetIndividualBoundary
  63:../Libraries/XMCLib/src/xmc_vadc.c ****  *           - XMC_VADC_GROUP_SetIndividualBoundary
  64:../Libraries/XMCLib/src/xmc_vadc.c ****  *           - XMC_VADC_GROUP_GetAlias
  65:../Libraries/XMCLib/src/xmc_vadc.c ****  *           - XMC_VADC_GROUP_GetInputClass
  66:../Libraries/XMCLib/src/xmc_vadc.c ****  *           - XMC_VADC_GROUP_ChannelSetIclass
  67:../Libraries/XMCLib/src/xmc_vadc.c ****  *           - XMC_VADC_GROUP_ChannelGetResultAlignment
  68:../Libraries/XMCLib/src/xmc_vadc.c ****  *           - XMC_VADC_GROUP_ChannelGetInputClass
  69:../Libraries/XMCLib/src/xmc_vadc.c ****  *           - XMC_VADC_GROUP_SetResultSubtractionValue
  70:../Libraries/XMCLib/src/xmc_vadc.c ****  *
  71:../Libraries/XMCLib/src/xmc_vadc.c ****  * 2015-12-01:
  72:../Libraries/XMCLib/src/xmc_vadc.c ****  *     - Fixed the analog calibration voltage for XMC1100 to external reference upper supply range.
  73:../Libraries/XMCLib/src/xmc_vadc.c ****  *     - Fixed the XMC_VADC_GLOBAL_StartupCalibration() for XMC1100.
  74:../Libraries/XMCLib/src/xmc_vadc.c ****  *
  75:../Libraries/XMCLib/src/xmc_vadc.c ****  * 2016-06-17:
  76:../Libraries/XMCLib/src/xmc_vadc.c ****  *     - New macros added XMC_VADC_SHS_FULL_SET_REG, XMC_VADC_RESULT_PRIORITY_AVAILABLE 
  77:../Libraries/XMCLib/src/xmc_vadc.c ****  *       and XMC_VADC_SYNCTR_START_LOCATION
  78:../Libraries/XMCLib/src/xmc_vadc.c ****  *     - New Enum added XMC_VADC_SHS_GAIN_LEVEL_t and XMC_VADC_SYNCTR_EVAL_t
  79:../Libraries/XMCLib/src/xmc_vadc.c ****  *     - Fixed the EVAL configuration in API XMC_VADC_GROUP_CheckSlaveReadiness and XMC_VADC_GROUP_
  80:../Libraries/XMCLib/src/xmc_vadc.c ****  *     - New APIs added are:
  81:../Libraries/XMCLib/src/xmc_vadc.c ****  *           - XMC_VADC_GROUP_SetSyncSlaveReadySignal
  82:../Libraries/XMCLib/src/xmc_vadc.c ****  *           - XMC_VADC_GROUP_ChannelGetAssertedEvents
  83:../Libraries/XMCLib/src/xmc_vadc.c ****  *           - XMC_VADC_GROUP_GetAssertedResultEvents
  84:../Libraries/XMCLib/src/xmc_vadc.c ****  *           - XMC_VADC_GROUP_SetResultRegPriority
  85:../Libraries/XMCLib/src/xmc_vadc.c ****  *           - XMC_VADC_GROUP_SetSyncReadySignal
  86:../Libraries/XMCLib/src/xmc_vadc.c ****  *           - XMC_VADC_GROUP_GetSyncReadySignal
  87:../Libraries/XMCLib/src/xmc_vadc.c ****  *           - XMC_VADC_GROUP_GetResultRegPriority
  88:../Libraries/XMCLib/src/xmc_vadc.c ****  *
  89:../Libraries/XMCLib/src/xmc_vadc.c ****  * 2017-01-11:
  90:../Libraries/XMCLib/src/xmc_vadc.c ****  *     - Fix assertion in XMC_VADC_GROUP_CheckSlaveReadiness() and XMC_VADC_GROUP_IgnoreSlaveReadin
  91:../Libraries/XMCLib/src/xmc_vadc.c ****  *
  92:../Libraries/XMCLib/src/xmc_vadc.c ****  * @endcond 
  93:../Libraries/XMCLib/src/xmc_vadc.c ****  *
  94:../Libraries/XMCLib/src/xmc_vadc.c ****  */
  95:../Libraries/XMCLib/src/xmc_vadc.c **** 
  96:../Libraries/XMCLib/src/xmc_vadc.c **** /**************************************************************************************************
  97:../Libraries/XMCLib/src/xmc_vadc.c ****  * HEADER FILES
  98:../Libraries/XMCLib/src/xmc_vadc.c ****  **************************************************************************************************
  99:../Libraries/XMCLib/src/xmc_vadc.c **** #include <xmc_vadc.h>
 100:../Libraries/XMCLib/src/xmc_vadc.c **** 
 101:../Libraries/XMCLib/src/xmc_vadc.c **** /**************************************************************************************************
 102:../Libraries/XMCLib/src/xmc_vadc.c ****  * MACROS
 103:../Libraries/XMCLib/src/xmc_vadc.c ****  **************************************************************************************************
 104:../Libraries/XMCLib/src/xmc_vadc.c **** #define XMC_VADC_MAX_ICLASS_SET          (2U)  /**< Defines the maximum number of conversion parame
 105:../Libraries/XMCLib/src/xmc_vadc.c **** #define XMC_VADC_NUM_EMUX_INTERFACES     (2U)  /**< Defines the maximum number of external multiple
 106:../Libraries/XMCLib/src/xmc_vadc.c **** 
 107:../Libraries/XMCLib/src/xmc_vadc.c **** #define XMC_VADC_RESULT_LEFT_ALIGN_10BIT (2U)  /**< Defines the 10 bit converted result register le
 108:../Libraries/XMCLib/src/xmc_vadc.c ****                                                     is used in the XMC_VADC_GLOBAL_SetCompareValue(
 109:../Libraries/XMCLib/src/xmc_vadc.c **** 
 110:../Libraries/XMCLib/src/xmc_vadc.c **** #define XMC_VADC_SYNCTR_START_LOCATION (3U)  /**< Defines the location in SYNCTR needed for calcula
 111:../Libraries/XMCLib/src/xmc_vadc.c **** /**************************************************************************************************
 112:../Libraries/XMCLib/src/xmc_vadc.c ****  * ENUMS
 113:../Libraries/XMCLib/src/xmc_vadc.c ****  **************************************************************************************************
 114:../Libraries/XMCLib/src/xmc_vadc.c **** 
 115:../Libraries/XMCLib/src/xmc_vadc.c **** /**************************************************************************************************
 116:../Libraries/XMCLib/src/xmc_vadc.c ****  * DATA STRUCTURES
 117:../Libraries/XMCLib/src/xmc_vadc.c ****  **************************************************************************************************
 118:../Libraries/XMCLib/src/xmc_vadc.c **** 
 119:../Libraries/XMCLib/src/xmc_vadc.c **** /**************************************************************************************************
 120:../Libraries/XMCLib/src/xmc_vadc.c ****  * GLOBAL DATA
 121:../Libraries/XMCLib/src/xmc_vadc.c ****  **************************************************************************************************
 122:../Libraries/XMCLib/src/xmc_vadc.c **** 
 123:../Libraries/XMCLib/src/xmc_vadc.c **** #if (XMC_VADC_GROUP_AVAILABLE == 1U)
 124:../Libraries/XMCLib/src/xmc_vadc.c **** 
 125:../Libraries/XMCLib/src/xmc_vadc.c **** #if (XMC_VADC_MAXIMUM_NUM_GROUPS == 4U) 
 126:../Libraries/XMCLib/src/xmc_vadc.c **** static VADC_G_TypeDef *const g_xmc_vadc_group_array[XMC_VADC_MAXIMUM_NUM_GROUPS] = {(VADC_G_TypeDef
 127:../Libraries/XMCLib/src/xmc_vadc.c ****                                                                                     (VADC_G_TypeDef
 128:../Libraries/XMCLib/src/xmc_vadc.c ****                                                                                     (VADC_G_TypeDef
 129:../Libraries/XMCLib/src/xmc_vadc.c ****                                                                                     (VADC_G_TypeDef
 130:../Libraries/XMCLib/src/xmc_vadc.c **** #else
 131:../Libraries/XMCLib/src/xmc_vadc.c **** static VADC_G_TypeDef *const g_xmc_vadc_group_array[XMC_VADC_MAXIMUM_NUM_GROUPS] = {(VADC_G_TypeDef
 132:../Libraries/XMCLib/src/xmc_vadc.c ****                                                                                     (VADC_G_TypeDef
 133:../Libraries/XMCLib/src/xmc_vadc.c **** #endif
 134:../Libraries/XMCLib/src/xmc_vadc.c **** 
 135:../Libraries/XMCLib/src/xmc_vadc.c **** #endif 
 136:../Libraries/XMCLib/src/xmc_vadc.c **** 
 137:../Libraries/XMCLib/src/xmc_vadc.c **** /**************************************************************************************************
 138:../Libraries/XMCLib/src/xmc_vadc.c ****  * LOCAL ROUTINES
 139:../Libraries/XMCLib/src/xmc_vadc.c ****  **************************************************************************************************
 140:../Libraries/XMCLib/src/xmc_vadc.c **** 
 141:../Libraries/XMCLib/src/xmc_vadc.c **** /**************************************************************************************************
 142:../Libraries/XMCLib/src/xmc_vadc.c ****  * API IMPLEMENTATION
 143:../Libraries/XMCLib/src/xmc_vadc.c ****  **************************************************************************************************
 144:../Libraries/XMCLib/src/xmc_vadc.c **** 
 145:../Libraries/XMCLib/src/xmc_vadc.c **** /*API to enable the VADC Module*/
 146:../Libraries/XMCLib/src/xmc_vadc.c **** void XMC_VADC_GLOBAL_EnableModule(void)
 147:../Libraries/XMCLib/src/xmc_vadc.c **** {
  26              	 .loc 1 147 0
  27              	 .cfi_startproc
  28 0000 80B5     	 push {r7,lr}
  29              	.LCFI0:
  30              	 .cfi_def_cfa_offset 8
  31              	 .cfi_offset 7,-8
  32              	 .cfi_offset 14,-4
  33 0002 00AF     	 add r7,sp,#0
  34              	.LCFI1:
  35              	 .cfi_def_cfa_register 7
 148:../Libraries/XMCLib/src/xmc_vadc.c ****   /*
 149:../Libraries/XMCLib/src/xmc_vadc.c ****    * Enable Out of Range Comparator for ADC channels pins P2.2to P2.9. This hack is applicable only
 150:../Libraries/XMCLib/src/xmc_vadc.c ****    * and in particular the G11 step.
 151:../Libraries/XMCLib/src/xmc_vadc.c ****    *
 152:../Libraries/XMCLib/src/xmc_vadc.c ****    * Please refer to the XMC1000 Errata sheet V1.4 released 2014-06 Errata ID : ADC_AI.003 Additona
 153:../Libraries/XMCLib/src/xmc_vadc.c ****    * function
 154:../Libraries/XMCLib/src/xmc_vadc.c ****    */
 155:../Libraries/XMCLib/src/xmc_vadc.c **** 
 156:../Libraries/XMCLib/src/xmc_vadc.c **** #if defined (COMPARATOR)
 157:../Libraries/XMCLib/src/xmc_vadc.c ****   COMPARATOR->ORCCTRL = (uint32_t)0xFF;
 158:../Libraries/XMCLib/src/xmc_vadc.c **** #endif
 159:../Libraries/XMCLib/src/xmc_vadc.c **** 
 160:../Libraries/XMCLib/src/xmc_vadc.c **** #if defined(CLOCK_GATING_SUPPORTED)
 161:../Libraries/XMCLib/src/xmc_vadc.c ****     XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_VADC);
  36              	 .loc 1 161 0
  37 0004 0120     	 mov r0,#1
  38 0006 FFF7FEFF 	 bl XMC_SCU_CLOCK_UngatePeripheralClock
 162:../Libraries/XMCLib/src/xmc_vadc.c **** #endif
 163:../Libraries/XMCLib/src/xmc_vadc.c **** 
 164:../Libraries/XMCLib/src/xmc_vadc.c **** #if defined(PERIPHERAL_RESET_SUPPORTED)
 165:../Libraries/XMCLib/src/xmc_vadc.c ****   /* Reset the Hardware */
 166:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_SCU_RESET_DeassertPeripheralReset((XMC_SCU_PERIPHERAL_RESET_t)XMC_SCU_PERIPHERAL_RESET_VADC )
 167:../Libraries/XMCLib/src/xmc_vadc.c **** #endif
 168:../Libraries/XMCLib/src/xmc_vadc.c **** }
  39              	 .loc 1 168 0
  40 000a BD46     	 mov sp,r7
  41              	 
  42 000c 80BD     	 pop {r7,pc}
  43              	 .cfi_endproc
  44              	.LFE90:
  46 000e C046     	 .section .text.XMC_VADC_GLOBAL_DisableModule,"ax",%progbits
  47              	 .align 2
  48              	 .global XMC_VADC_GLOBAL_DisableModule
  49              	 .code 16
  50              	 .thumb_func
  52              	XMC_VADC_GLOBAL_DisableModule:
  53              	.LFB91:
 169:../Libraries/XMCLib/src/xmc_vadc.c **** 
 170:../Libraries/XMCLib/src/xmc_vadc.c **** /*API to Disable the VADC Module*/
 171:../Libraries/XMCLib/src/xmc_vadc.c **** void XMC_VADC_GLOBAL_DisableModule(void)
 172:../Libraries/XMCLib/src/xmc_vadc.c **** {
  54              	 .loc 1 172 0
  55              	 .cfi_startproc
  56 0000 80B5     	 push {r7,lr}
  57              	.LCFI2:
  58              	 .cfi_def_cfa_offset 8
  59              	 .cfi_offset 7,-8
  60              	 .cfi_offset 14,-4
  61 0002 00AF     	 add r7,sp,#0
  62              	.LCFI3:
  63              	 .cfi_def_cfa_register 7
 173:../Libraries/XMCLib/src/xmc_vadc.c **** #if defined(PERIPHERAL_RESET_SUPPORTED)
 174:../Libraries/XMCLib/src/xmc_vadc.c ****   /* Reset the Hardware */
 175:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_SCU_RESET_AssertPeripheralReset((XMC_SCU_PERIPHERAL_RESET_t)XMC_SCU_PERIPHERAL_RESET_VADC );
 176:../Libraries/XMCLib/src/xmc_vadc.c **** #endif
 177:../Libraries/XMCLib/src/xmc_vadc.c **** 
 178:../Libraries/XMCLib/src/xmc_vadc.c **** #if defined(CLOCK_GATING_SUPPORTED)
 179:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_SCU_CLOCK_GatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_VADC);
  64              	 .loc 1 179 0
  65 0004 0120     	 mov r0,#1
  66 0006 FFF7FEFF 	 bl XMC_SCU_CLOCK_GatePeripheralClock
 180:../Libraries/XMCLib/src/xmc_vadc.c **** #endif
 181:../Libraries/XMCLib/src/xmc_vadc.c **** 
 182:../Libraries/XMCLib/src/xmc_vadc.c **** }
  67              	 .loc 1 182 0
  68 000a BD46     	 mov sp,r7
  69              	 
  70 000c 80BD     	 pop {r7,pc}
  71              	 .cfi_endproc
  72              	.LFE91:
  74 000e C046     	 .section .text.XMC_VADC_GLOBAL_Init,"ax",%progbits
  75              	 .align 2
  76              	 .global XMC_VADC_GLOBAL_Init
  77              	 .code 16
  78              	 .thumb_func
  80              	XMC_VADC_GLOBAL_Init:
  81              	.LFB92:
 183:../Libraries/XMCLib/src/xmc_vadc.c **** 
 184:../Libraries/XMCLib/src/xmc_vadc.c **** 
 185:../Libraries/XMCLib/src/xmc_vadc.c **** /* API to initialize global resources */
 186:../Libraries/XMCLib/src/xmc_vadc.c **** void XMC_VADC_GLOBAL_Init(XMC_VADC_GLOBAL_t *const global_ptr, const XMC_VADC_GLOBAL_CONFIG_t *conf
 187:../Libraries/XMCLib/src/xmc_vadc.c **** {
  82              	 .loc 1 187 0
  83              	 .cfi_startproc
  84 0000 80B5     	 push {r7,lr}
  85              	.LCFI4:
  86              	 .cfi_def_cfa_offset 8
  87              	 .cfi_offset 7,-8
  88              	 .cfi_offset 14,-4
  89 0002 84B0     	 sub sp,sp,#16
  90              	.LCFI5:
  91              	 .cfi_def_cfa_offset 24
  92 0004 00AF     	 add r7,sp,#0
  93              	.LCFI6:
  94              	 .cfi_def_cfa_register 7
  95 0006 7860     	 str r0,[r7,#4]
  96 0008 3960     	 str r1,[r7]
 188:../Libraries/XMCLib/src/xmc_vadc.c **** #if (XMC_VADC_GROUP_AVAILABLE == 0U)
 189:../Libraries/XMCLib/src/xmc_vadc.c ****   uint32_t reg;
 190:../Libraries/XMCLib/src/xmc_vadc.c **** #endif
 191:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GLOBAL_Init:Wrong Module Pointer", (global_ptr == VADC))
 192:../Libraries/XMCLib/src/xmc_vadc.c **** 
 193:../Libraries/XMCLib/src/xmc_vadc.c ****   /* Enable the VADC module*/
 194:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_VADC_GLOBAL_EnableModule();
  97              	 .loc 1 194 0
  98 000a FFF7FEFF 	 bl XMC_VADC_GLOBAL_EnableModule
 195:../Libraries/XMCLib/src/xmc_vadc.c **** 
 196:../Libraries/XMCLib/src/xmc_vadc.c ****   global_ptr->CLC = (uint32_t)(config->clc);
  99              	 .loc 1 196 0
 100 000e 3B68     	 ldr r3,[r7]
 101 0010 1A69     	 ldr r2,[r3,#16]
 102 0012 7B68     	 ldr r3,[r7,#4]
 103 0014 1A60     	 str r2,[r3]
 197:../Libraries/XMCLib/src/xmc_vadc.c **** 
 198:../Libraries/XMCLib/src/xmc_vadc.c ****   /* Clock configuration */
 199:../Libraries/XMCLib/src/xmc_vadc.c **** 
 200:../Libraries/XMCLib/src/xmc_vadc.c **** #if (XMC_VADC_GROUP_AVAILABLE == 1U)
 201:../Libraries/XMCLib/src/xmc_vadc.c ****   global_ptr->GLOBCFG  = (uint32_t)(config->clock_config.globcfg | (uint32_t)(VADC_GLOBCFG_DIVWC_Ms
 202:../Libraries/XMCLib/src/xmc_vadc.c **** #endif
 203:../Libraries/XMCLib/src/xmc_vadc.c **** 
 204:../Libraries/XMCLib/src/xmc_vadc.c ****   /* ICLASS-0 configuration */
 205:../Libraries/XMCLib/src/xmc_vadc.c ****   global_ptr->GLOBICLASS[0] = (uint32_t)(config->class0.globiclass);
 104              	 .loc 1 205 0
 105 0016 3B68     	 ldr r3,[r7]
 106 0018 5A68     	 ldr r2,[r3,#4]
 107 001a 7B68     	 ldr r3,[r7,#4]
 108 001c A021     	 mov r1,#160
 109 001e 5A50     	 str r2,[r3,r1]
 206:../Libraries/XMCLib/src/xmc_vadc.c **** 
 207:../Libraries/XMCLib/src/xmc_vadc.c ****   /* ICLASS-1 configuration */
 208:../Libraries/XMCLib/src/xmc_vadc.c ****   global_ptr->GLOBICLASS[1] = (uint32_t)(config->class1.globiclass);
 110              	 .loc 1 208 0
 111 0020 3B68     	 ldr r3,[r7]
 112 0022 9A68     	 ldr r2,[r3,#8]
 113 0024 7B68     	 ldr r3,[r7,#4]
 114 0026 A421     	 mov r1,#164
 115 0028 5A50     	 str r2,[r3,r1]
 209:../Libraries/XMCLib/src/xmc_vadc.c **** 
 210:../Libraries/XMCLib/src/xmc_vadc.c **** 
 211:../Libraries/XMCLib/src/xmc_vadc.c ****   /*Result generation related configuration */
 212:../Libraries/XMCLib/src/xmc_vadc.c ****   global_ptr->GLOBRCR = (uint32_t)(config->globrcr);
 116              	 .loc 1 212 0
 117 002a 3B68     	 ldr r3,[r7]
 118 002c D968     	 ldr r1,[r3,#12]
 119 002e 7A68     	 ldr r2,[r7,#4]
 120 0030 A023     	 mov r3,#160
 121 0032 9B00     	 lsl r3,r3,#2
 122 0034 D150     	 str r1,[r2,r3]
 213:../Libraries/XMCLib/src/xmc_vadc.c **** 
 214:../Libraries/XMCLib/src/xmc_vadc.c **** #if (XMC_VADC_BOUNDARY_AVAILABLE == 1U)
 215:../Libraries/XMCLib/src/xmc_vadc.c **** 
 216:../Libraries/XMCLib/src/xmc_vadc.c ****   /* Boundaries */
 217:../Libraries/XMCLib/src/xmc_vadc.c ****   global_ptr->GLOBBOUND = (uint32_t)(config->globbound);
 218:../Libraries/XMCLib/src/xmc_vadc.c **** 
 219:../Libraries/XMCLib/src/xmc_vadc.c **** #endif
 220:../Libraries/XMCLib/src/xmc_vadc.c **** 
 221:../Libraries/XMCLib/src/xmc_vadc.c ****   /* Configure the SHS register that are needed for XMC11xx devices*/
 222:../Libraries/XMCLib/src/xmc_vadc.c **** #if (XMC_VADC_GROUP_AVAILABLE == 0U)
 223:../Libraries/XMCLib/src/xmc_vadc.c **** 
 224:../Libraries/XMCLib/src/xmc_vadc.c ****   /* Enabling the Analog part of the converter*/
 225:../Libraries/XMCLib/src/xmc_vadc.c ****   reg = SHS0->SHSCFG  | SHS_SHSCFG_SCWC_Msk;
 123              	 .loc 1 225 0
 124 0036 094B     	 ldr r3,.L4
 125 0038 1B6C     	 ldr r3,[r3,#64]
 126 003a 8022     	 mov r2,#128
 127 003c 1202     	 lsl r2,r2,#8
 128 003e 1343     	 orr r3,r2
 129 0040 FB60     	 str r3,[r7,#12]
 226:../Libraries/XMCLib/src/xmc_vadc.c ****   reg &= ~(SHS_SHSCFG_ANOFF_Msk);
 130              	 .loc 1 226 0
 131 0042 FB68     	 ldr r3,[r7,#12]
 132 0044 064A     	 ldr r2,.L4+4
 133 0046 1340     	 and r3,r2
 134 0048 FB60     	 str r3,[r7,#12]
 227:../Libraries/XMCLib/src/xmc_vadc.c ****   SHS0->SHSCFG = reg;
 135              	 .loc 1 227 0
 136 004a 044B     	 ldr r3,.L4
 137 004c FA68     	 ldr r2,[r7,#12]
 138 004e 1A64     	 str r2,[r3,#64]
 228:../Libraries/XMCLib/src/xmc_vadc.c **** 
 229:../Libraries/XMCLib/src/xmc_vadc.c ****   /* From the Errata sheet of XMC1100 V1.7*/
 230:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_VADC_CONV_ENABLE_FOR_XMC11 = 1U;
 139              	 .loc 1 230 0
 140 0050 044B     	 ldr r3,.L4+8
 141 0052 0122     	 mov r2,#1
 142 0054 1A60     	 str r2,[r3]
 231:../Libraries/XMCLib/src/xmc_vadc.c **** #endif
 232:../Libraries/XMCLib/src/xmc_vadc.c **** 
 233:../Libraries/XMCLib/src/xmc_vadc.c **** }
 143              	 .loc 1 233 0
 144 0056 BD46     	 mov sp,r7
 145 0058 04B0     	 add sp,sp,#16
 146              	 
 147 005a 80BD     	 pop {r7,pc}
 148              	.L5:
 149              	 .align 2
 150              	.L4:
 151 005c 00400348 	 .word 1208172544
 152 0060 FFEFFFFF 	 .word -4097
 153 0064 00050140 	 .word 1073808640
 154              	 .cfi_endproc
 155              	.LFE92:
 157              	 .section .text.XMC_VADC_GLOBAL_InputClassInit,"ax",%progbits
 158              	 .align 2
 159              	 .global XMC_VADC_GLOBAL_InputClassInit
 160              	 .code 16
 161              	 .thumb_func
 163              	XMC_VADC_GLOBAL_InputClassInit:
 164              	.LFB93:
 234:../Libraries/XMCLib/src/xmc_vadc.c **** 
 235:../Libraries/XMCLib/src/xmc_vadc.c **** /* API to Set the Global IClass registers*/
 236:../Libraries/XMCLib/src/xmc_vadc.c **** void XMC_VADC_GLOBAL_InputClassInit(XMC_VADC_GLOBAL_t *const global_ptr, const XMC_VADC_GLOBAL_CLAS
 237:../Libraries/XMCLib/src/xmc_vadc.c ****                                           const XMC_VADC_GROUP_CONV_t conv_type, const uint32_t set
 238:../Libraries/XMCLib/src/xmc_vadc.c **** {
 165              	 .loc 1 238 0
 166              	 .cfi_startproc
 167 0000 80B5     	 push {r7,lr}
 168              	.LCFI7:
 169              	 .cfi_def_cfa_offset 8
 170              	 .cfi_offset 7,-8
 171              	 .cfi_offset 14,-4
 172 0002 84B0     	 sub sp,sp,#16
 173              	.LCFI8:
 174              	 .cfi_def_cfa_offset 24
 175 0004 00AF     	 add r7,sp,#0
 176              	.LCFI9:
 177              	 .cfi_def_cfa_register 7
 178 0006 F860     	 str r0,[r7,#12]
 179 0008 B960     	 str r1,[r7,#8]
 180 000a 3B60     	 str r3,[r7]
 181 000c FB1D     	 add r3,r7,#7
 182 000e 1A70     	 strb r2,[r3]
 239:../Libraries/XMCLib/src/xmc_vadc.c **** 
 240:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GLOBAL_InputClassInit:Wrong Module Pointer", (global_ptr == VADC))
 241:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GLOBAL_InputClassInit:Wrong Conversion Type", ((conv_type) <= XMC_VADC_GROUP
 242:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GLOBAL_InputClassInit:Wrong ICLASS set number", (set_num < XMC_VADC_MAX_ICLA
 243:../Libraries/XMCLib/src/xmc_vadc.c **** 
 244:../Libraries/XMCLib/src/xmc_vadc.c **** #if(XMC_VADC_EMUX_AVAILABLE == 1U)
 245:../Libraries/XMCLib/src/xmc_vadc.c ****   if (conv_type == XMC_VADC_GROUP_CONV_STD )
 246:../Libraries/XMCLib/src/xmc_vadc.c ****   {
 247:../Libraries/XMCLib/src/xmc_vadc.c **** #endif
 248:../Libraries/XMCLib/src/xmc_vadc.c ****     global_ptr->GLOBICLASS[set_num] = config.globiclass &
 183              	 .loc 1 248 0
 184 0010 BB68     	 ldr r3,[r7,#8]
 185 0012 054A     	 ldr r2,.L7
 186 0014 1340     	 and r3,r2
 187 0016 191C     	 mov r1,r3
 188 0018 FB68     	 ldr r3,[r7,#12]
 189 001a 3A68     	 ldr r2,[r7]
 190 001c 2832     	 add r2,r2,#40
 191 001e 9200     	 lsl r2,r2,#2
 192 0020 D150     	 str r1,[r2,r3]
 249:../Libraries/XMCLib/src/xmc_vadc.c ****                                       (uint32_t)(VADC_GLOBICLASS_CMS_Msk | VADC_GLOBICLASS_STCS_Msk
 250:../Libraries/XMCLib/src/xmc_vadc.c **** #if(XMC_VADC_EMUX_AVAILABLE == 1U)
 251:../Libraries/XMCLib/src/xmc_vadc.c ****   }
 252:../Libraries/XMCLib/src/xmc_vadc.c ****   else
 253:../Libraries/XMCLib/src/xmc_vadc.c ****   {
 254:../Libraries/XMCLib/src/xmc_vadc.c ****     global_ptr->GLOBICLASS[set_num] = config.globiclass & (uint32_t)(VADC_GLOBICLASS_CME_Msk | VADC
 255:../Libraries/XMCLib/src/xmc_vadc.c ****   }
 256:../Libraries/XMCLib/src/xmc_vadc.c **** #endif
 257:../Libraries/XMCLib/src/xmc_vadc.c **** }
 193              	 .loc 1 257 0
 194 0022 BD46     	 mov sp,r7
 195 0024 04B0     	 add sp,sp,#16
 196              	 
 197 0026 80BD     	 pop {r7,pc}
 198              	.L8:
 199              	 .align 2
 200              	.L7:
 201 0028 1F070000 	 .word 1823
 202              	 .cfi_endproc
 203              	.LFE93:
 205              	 .section .text.XMC_VADC_GLOBAL_StartupCalibration,"ax",%progbits
 206              	 .align 2
 207              	 .global XMC_VADC_GLOBAL_StartupCalibration
 208              	 .code 16
 209              	 .thumb_func
 211              	XMC_VADC_GLOBAL_StartupCalibration:
 212              	.LFB94:
 258:../Libraries/XMCLib/src/xmc_vadc.c **** 
 259:../Libraries/XMCLib/src/xmc_vadc.c **** /* API to enable startup calibration feature */
 260:../Libraries/XMCLib/src/xmc_vadc.c **** void XMC_VADC_GLOBAL_StartupCalibration(XMC_VADC_GLOBAL_t *const global_ptr)
 261:../Libraries/XMCLib/src/xmc_vadc.c **** {
 213              	 .loc 1 261 0
 214              	 .cfi_startproc
 215 0000 80B5     	 push {r7,lr}
 216              	.LCFI10:
 217              	 .cfi_def_cfa_offset 8
 218              	 .cfi_offset 7,-8
 219              	 .cfi_offset 14,-4
 220 0002 82B0     	 sub sp,sp,#8
 221              	.LCFI11:
 222              	 .cfi_def_cfa_offset 16
 223 0004 00AF     	 add r7,sp,#0
 224              	.LCFI12:
 225              	 .cfi_def_cfa_register 7
 226 0006 7860     	 str r0,[r7,#4]
 262:../Libraries/XMCLib/src/xmc_vadc.c **** #if (XMC_VADC_GROUP_AVAILABLE == 1U)
 263:../Libraries/XMCLib/src/xmc_vadc.c ****   uint8_t i;
 264:../Libraries/XMCLib/src/xmc_vadc.c ****   VADC_G_TypeDef *group_ptr;
 265:../Libraries/XMCLib/src/xmc_vadc.c **** #endif
 266:../Libraries/XMCLib/src/xmc_vadc.c ****   
 267:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GLOBAL_StartupCalibration:Wrong Module Pointer", (global_ptr == VADC))
 268:../Libraries/XMCLib/src/xmc_vadc.c **** 
 269:../Libraries/XMCLib/src/xmc_vadc.c ****   global_ptr->GLOBCFG |= (uint32_t)VADC_GLOBCFG_SUCAL_Msk;
 227              	 .loc 1 269 0
 228 0008 7B68     	 ldr r3,[r7,#4]
 229 000a 8022     	 mov r2,#128
 230 000c 9B58     	 ldr r3,[r3,r2]
 231 000e 8022     	 mov r2,#128
 232 0010 1206     	 lsl r2,r2,#24
 233 0012 1A43     	 orr r2,r3
 234 0014 7B68     	 ldr r3,[r7,#4]
 235 0016 8021     	 mov r1,#128
 236 0018 5A50     	 str r2,[r3,r1]
 270:../Libraries/XMCLib/src/xmc_vadc.c **** 
 271:../Libraries/XMCLib/src/xmc_vadc.c **** #if (XMC_VADC_GROUP_AVAILABLE == 1U)
 272:../Libraries/XMCLib/src/xmc_vadc.c ****   /* Loop until all active groups finish calibration */
 273:../Libraries/XMCLib/src/xmc_vadc.c ****   for(i=0U; i<XMC_VADC_MAXIMUM_NUM_GROUPS; i++)
 274:../Libraries/XMCLib/src/xmc_vadc.c ****   {
 275:../Libraries/XMCLib/src/xmc_vadc.c ****     group_ptr = g_xmc_vadc_group_array[i];
 276:../Libraries/XMCLib/src/xmc_vadc.c ****     if ( (group_ptr->ARBCFG) & (uint32_t)VADC_G_ARBCFG_ANONS_Msk)
 277:../Libraries/XMCLib/src/xmc_vadc.c ****     {
 278:../Libraries/XMCLib/src/xmc_vadc.c ****       /* This group is active. Loop until it finishes calibration */
 279:../Libraries/XMCLib/src/xmc_vadc.c ****       while((group_ptr->ARBCFG) & (uint32_t)VADC_G_ARBCFG_CAL_Msk)
 280:../Libraries/XMCLib/src/xmc_vadc.c ****       {
 281:../Libraries/XMCLib/src/xmc_vadc.c ****         /* NOP */
 282:../Libraries/XMCLib/src/xmc_vadc.c ****       }
 283:../Libraries/XMCLib/src/xmc_vadc.c ****     }
 284:../Libraries/XMCLib/src/xmc_vadc.c ****   }
 285:../Libraries/XMCLib/src/xmc_vadc.c **** #else
 286:../Libraries/XMCLib/src/xmc_vadc.c ****   /* Loop until it finishes calibration */
 287:../Libraries/XMCLib/src/xmc_vadc.c ****   while ((((SHS0->SHSCFG) & (uint32_t)SHS_SHSCFG_STATE_Msk) >> (uint32_t)SHS_SHSCFG_STATE_Pos) ==
 237              	 .loc 1 287 0
 238 001a C046     	 mov r8,r8
 239              	.L10:
 240              	 .loc 1 287 0 is_stmt 0 discriminator 1
 241 001c 034B     	 ldr r3,.L11
 242 001e 1B6C     	 ldr r3,[r3,#64]
 243 0020 1B0F     	 lsr r3,r3,#28
 244 0022 032B     	 cmp r3,#3
 245 0024 FAD0     	 beq .L10
 288:../Libraries/XMCLib/src/xmc_vadc.c ****          XMC_VADC_SHS_START_UP_CAL_ACTIVE )
 289:../Libraries/XMCLib/src/xmc_vadc.c ****   {
 290:../Libraries/XMCLib/src/xmc_vadc.c ****     /* NOP */
 291:../Libraries/XMCLib/src/xmc_vadc.c ****   }
 292:../Libraries/XMCLib/src/xmc_vadc.c **** #endif
 293:../Libraries/XMCLib/src/xmc_vadc.c **** }
 246              	 .loc 1 293 0 is_stmt 1
 247 0026 BD46     	 mov sp,r7
 248 0028 02B0     	 add sp,sp,#8
 249              	 
 250 002a 80BD     	 pop {r7,pc}
 251              	.L12:
 252              	 .align 2
 253              	.L11:
 254 002c 00400348 	 .word 1208172544
 255              	 .cfi_endproc
 256              	.LFE94:
 258              	 .section .text.XMC_VADC_GLOBAL_SetCompareValue,"ax",%progbits
 259              	 .align 2
 260              	 .global XMC_VADC_GLOBAL_SetCompareValue
 261              	 .code 16
 262              	 .thumb_func
 264              	XMC_VADC_GLOBAL_SetCompareValue:
 265              	.LFB95:
 294:../Libraries/XMCLib/src/xmc_vadc.c **** 
 295:../Libraries/XMCLib/src/xmc_vadc.c **** /* API to set boudaries for result of conversion. Should the boundaries be violated, interrupts are
 296:../Libraries/XMCLib/src/xmc_vadc.c **** #if (XMC_VADC_BOUNDARY_AVAILABLE == 1U)
 297:../Libraries/XMCLib/src/xmc_vadc.c **** void XMC_VADC_GLOBAL_SetBoundaries(XMC_VADC_GLOBAL_t *const global_ptr,
 298:../Libraries/XMCLib/src/xmc_vadc.c ****                                    const uint32_t boundary0,
 299:../Libraries/XMCLib/src/xmc_vadc.c ****                                    const uint32_t boundary1)
 300:../Libraries/XMCLib/src/xmc_vadc.c **** {
 301:../Libraries/XMCLib/src/xmc_vadc.c ****   uint32_t globbound;
 302:../Libraries/XMCLib/src/xmc_vadc.c **** 
 303:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GLOBAL_SetBoundaries:Wrong Module Pointer", (global_ptr == VADC))
 304:../Libraries/XMCLib/src/xmc_vadc.c **** 
 305:../Libraries/XMCLib/src/xmc_vadc.c ****   globbound = 0U;
 306:../Libraries/XMCLib/src/xmc_vadc.c ****   globbound |= (uint32_t) (boundary0 << VADC_GLOBBOUND_BOUNDARY0_Pos);
 307:../Libraries/XMCLib/src/xmc_vadc.c ****   globbound |= (uint32_t) (boundary1 << VADC_GLOBBOUND_BOUNDARY1_Pos);
 308:../Libraries/XMCLib/src/xmc_vadc.c **** 
 309:../Libraries/XMCLib/src/xmc_vadc.c ****   global_ptr->GLOBBOUND = globbound;
 310:../Libraries/XMCLib/src/xmc_vadc.c **** }
 311:../Libraries/XMCLib/src/xmc_vadc.c **** 
 312:../Libraries/XMCLib/src/xmc_vadc.c **** /* API to set an individual boundary for conversion results */
 313:../Libraries/XMCLib/src/xmc_vadc.c **** void XMC_VADC_GLOBAL_SetIndividualBoundary(XMC_VADC_GLOBAL_t *const global_ptr,
 314:../Libraries/XMCLib/src/xmc_vadc.c ****                                            const XMC_VADC_CHANNEL_BOUNDARY_t selection,
 315:../Libraries/XMCLib/src/xmc_vadc.c ****                                            const uint16_t boundary_value)
 316:../Libraries/XMCLib/src/xmc_vadc.c **** {
 317:../Libraries/XMCLib/src/xmc_vadc.c **** 
 318:../Libraries/XMCLib/src/xmc_vadc.c ****   uint32_t globbound;
 319:../Libraries/XMCLib/src/xmc_vadc.c **** 
 320:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GLOBAL_SetBoundaries:Wrong Module Pointer", (global_ptr == VADC))
 321:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GLOBAL_SetBoundaries:Wrong Boundary Selection",
 322:../Libraries/XMCLib/src/xmc_vadc.c ****              ((XMC_VADC_CHANNEL_BOUNDARY_GLOBAL_BOUND0 == selection) ||
 323:../Libraries/XMCLib/src/xmc_vadc.c ****               (XMC_VADC_CHANNEL_BOUNDARY_GLOBAL_BOUND1 == selection)))
 324:../Libraries/XMCLib/src/xmc_vadc.c **** 
 325:../Libraries/XMCLib/src/xmc_vadc.c ****   /* Program the Boundary registers */
 326:../Libraries/XMCLib/src/xmc_vadc.c ****   globbound = global_ptr->GLOBBOUND;
 327:../Libraries/XMCLib/src/xmc_vadc.c **** 
 328:../Libraries/XMCLib/src/xmc_vadc.c ****   if (XMC_VADC_CHANNEL_BOUNDARY_GLOBAL_BOUND0 == selection)
 329:../Libraries/XMCLib/src/xmc_vadc.c ****   {
 330:../Libraries/XMCLib/src/xmc_vadc.c ****     globbound &= ~((uint32_t) VADC_GLOBBOUND_BOUNDARY0_Msk);
 331:../Libraries/XMCLib/src/xmc_vadc.c ****     globbound |= (uint32_t) ((uint32_t) boundary_value << VADC_GLOBBOUND_BOUNDARY0_Pos);
 332:../Libraries/XMCLib/src/xmc_vadc.c ****   }
 333:../Libraries/XMCLib/src/xmc_vadc.c ****   else if (XMC_VADC_CHANNEL_BOUNDARY_GLOBAL_BOUND1 == selection)
 334:../Libraries/XMCLib/src/xmc_vadc.c ****   {
 335:../Libraries/XMCLib/src/xmc_vadc.c ****     globbound &= ~((uint32_t) VADC_GLOBBOUND_BOUNDARY1_Msk);
 336:../Libraries/XMCLib/src/xmc_vadc.c ****     globbound |= (uint32_t) ((uint32_t) boundary_value << VADC_GLOBBOUND_BOUNDARY1_Pos);
 337:../Libraries/XMCLib/src/xmc_vadc.c ****   }
 338:../Libraries/XMCLib/src/xmc_vadc.c ****   else
 339:../Libraries/XMCLib/src/xmc_vadc.c ****   {
 340:../Libraries/XMCLib/src/xmc_vadc.c ****     /* For MISRA*/
 341:../Libraries/XMCLib/src/xmc_vadc.c ****   }
 342:../Libraries/XMCLib/src/xmc_vadc.c ****   global_ptr->GLOBBOUND = globbound;
 343:../Libraries/XMCLib/src/xmc_vadc.c **** 
 344:../Libraries/XMCLib/src/xmc_vadc.c **** }
 345:../Libraries/XMCLib/src/xmc_vadc.c **** 
 346:../Libraries/XMCLib/src/xmc_vadc.c **** #endif
 347:../Libraries/XMCLib/src/xmc_vadc.c **** 
 348:../Libraries/XMCLib/src/xmc_vadc.c **** /* API to set compare value for the result register. Result of conversion is compared against this 
 349:../Libraries/XMCLib/src/xmc_vadc.c **** void XMC_VADC_GLOBAL_SetCompareValue(XMC_VADC_GLOBAL_t *const global_ptr, const XMC_VADC_RESULT_SIZ
 350:../Libraries/XMCLib/src/xmc_vadc.c **** {
 266              	 .loc 1 350 0
 267              	 .cfi_startproc
 268 0000 80B5     	 push {r7,lr}
 269              	.LCFI13:
 270              	 .cfi_def_cfa_offset 8
 271              	 .cfi_offset 7,-8
 272              	 .cfi_offset 14,-4
 273 0002 82B0     	 sub sp,sp,#8
 274              	.LCFI14:
 275              	 .cfi_def_cfa_offset 16
 276 0004 00AF     	 add r7,sp,#0
 277              	.LCFI15:
 278              	 .cfi_def_cfa_register 7
 279 0006 7860     	 str r0,[r7,#4]
 280 0008 0A1C     	 mov r2,r1
 281 000a BB1C     	 add r3,r7,#2
 282 000c 1A80     	 strh r2,[r3]
 351:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GLOBAL_SetCompareValue:Wrong Module Pointer", (global_ptr == VADC))
 352:../Libraries/XMCLib/src/xmc_vadc.c **** 
 353:../Libraries/XMCLib/src/xmc_vadc.c ****   global_ptr->GLOBRES &= ~((uint32_t)VADC_GLOBRES_RESULT_Msk);
 283              	 .loc 1 353 0
 284 000e 7A68     	 ldr r2,[r7,#4]
 285 0010 C023     	 mov r3,#192
 286 0012 9B00     	 lsl r3,r3,#2
 287 0014 D358     	 ldr r3,[r2,r3]
 288 0016 1B0C     	 lsr r3,r3,#16
 289 0018 1904     	 lsl r1,r3,#16
 290 001a 7A68     	 ldr r2,[r7,#4]
 291 001c C023     	 mov r3,#192
 292 001e 9B00     	 lsl r3,r3,#2
 293 0020 D150     	 str r1,[r2,r3]
 354:../Libraries/XMCLib/src/xmc_vadc.c ****   global_ptr->GLOBRES |= (uint32_t)((uint32_t)compare_val << XMC_VADC_RESULT_LEFT_ALIGN_10BIT);
 294              	 .loc 1 354 0
 295 0022 7A68     	 ldr r2,[r7,#4]
 296 0024 C023     	 mov r3,#192
 297 0026 9B00     	 lsl r3,r3,#2
 298 0028 D258     	 ldr r2,[r2,r3]
 299 002a BB1C     	 add r3,r7,#2
 300 002c 1B88     	 ldrh r3,[r3]
 301 002e 9B00     	 lsl r3,r3,#2
 302 0030 1A43     	 orr r2,r3
 303 0032 111C     	 mov r1,r2
 304 0034 7A68     	 ldr r2,[r7,#4]
 305 0036 C023     	 mov r3,#192
 306 0038 9B00     	 lsl r3,r3,#2
 307 003a D150     	 str r1,[r2,r3]
 355:../Libraries/XMCLib/src/xmc_vadc.c **** }
 308              	 .loc 1 355 0
 309 003c BD46     	 mov sp,r7
 310 003e 02B0     	 add sp,sp,#8
 311              	 
 312 0040 80BD     	 pop {r7,pc}
 313              	 .cfi_endproc
 314              	.LFE95:
 316 0042 C046     	 .section .text.XMC_VADC_GLOBAL_GetCompareResult,"ax",%progbits
 317              	 .align 2
 318              	 .global XMC_VADC_GLOBAL_GetCompareResult
 319              	 .code 16
 320              	 .thumb_func
 322              	XMC_VADC_GLOBAL_GetCompareResult:
 323              	.LFB96:
 356:../Libraries/XMCLib/src/xmc_vadc.c **** 
 357:../Libraries/XMCLib/src/xmc_vadc.c **** /* API to retrieve the result of comparison */
 358:../Libraries/XMCLib/src/xmc_vadc.c **** XMC_VADC_FAST_COMPARE_t XMC_VADC_GLOBAL_GetCompareResult(XMC_VADC_GLOBAL_t *const global_ptr)
 359:../Libraries/XMCLib/src/xmc_vadc.c **** {
 324              	 .loc 1 359 0
 325              	 .cfi_startproc
 326 0000 80B5     	 push {r7,lr}
 327              	.LCFI16:
 328              	 .cfi_def_cfa_offset 8
 329              	 .cfi_offset 7,-8
 330              	 .cfi_offset 14,-4
 331 0002 84B0     	 sub sp,sp,#16
 332              	.LCFI17:
 333              	 .cfi_def_cfa_offset 24
 334 0004 00AF     	 add r7,sp,#0
 335              	.LCFI18:
 336              	 .cfi_def_cfa_register 7
 337 0006 7860     	 str r0,[r7,#4]
 360:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_VADC_FAST_COMPARE_t result;
 361:../Libraries/XMCLib/src/xmc_vadc.c ****   uint32_t res;
 362:../Libraries/XMCLib/src/xmc_vadc.c **** 
 363:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GLOBAL_GetCompareResult:Wrong Module Pointer", (global_ptr == VADC))
 364:../Libraries/XMCLib/src/xmc_vadc.c **** 
 365:../Libraries/XMCLib/src/xmc_vadc.c ****   res = global_ptr->GLOBRES;
 338              	 .loc 1 365 0
 339 0008 7A68     	 ldr r2,[r7,#4]
 340 000a C023     	 mov r3,#192
 341 000c 9B00     	 lsl r3,r3,#2
 342 000e D358     	 ldr r3,[r2,r3]
 343 0010 BB60     	 str r3,[r7,#8]
 366:../Libraries/XMCLib/src/xmc_vadc.c **** 
 367:../Libraries/XMCLib/src/xmc_vadc.c ****   if (res & (uint32_t)VADC_GLOBRES_VF_Msk)
 344              	 .loc 1 367 0
 345 0012 BB68     	 ldr r3,[r7,#8]
 346 0014 002B     	 cmp r3,#0
 347 0016 08DA     	 bge .L15
 368:../Libraries/XMCLib/src/xmc_vadc.c ****   {
 369:../Libraries/XMCLib/src/xmc_vadc.c ****     result = (XMC_VADC_FAST_COMPARE_t)((uint32_t)(res >> (uint32_t)VADC_GLOBRES_FCR_Pos) & (uint32_
 348              	 .loc 1 369 0
 349 0018 BB68     	 ldr r3,[r7,#8]
 350 001a 9B0F     	 lsr r3,r3,#30
 351 001c DAB2     	 uxtb r2,r3
 352 001e 0F23     	 mov r3,#15
 353 0020 FB18     	 add r3,r7,r3
 354 0022 0121     	 mov r1,#1
 355 0024 0A40     	 and r2,r1
 356 0026 1A70     	 strb r2,[r3]
 357 0028 03E0     	 b .L16
 358              	.L15:
 370:../Libraries/XMCLib/src/xmc_vadc.c ****   }
 371:../Libraries/XMCLib/src/xmc_vadc.c ****   else
 372:../Libraries/XMCLib/src/xmc_vadc.c ****   {
 373:../Libraries/XMCLib/src/xmc_vadc.c ****     result = XMC_VADC_FAST_COMPARE_UNKNOWN;
 359              	 .loc 1 373 0
 360 002a 0F23     	 mov r3,#15
 361 002c FB18     	 add r3,r7,r3
 362 002e 0222     	 mov r2,#2
 363 0030 1A70     	 strb r2,[r3]
 364              	.L16:
 374:../Libraries/XMCLib/src/xmc_vadc.c ****   }
 375:../Libraries/XMCLib/src/xmc_vadc.c **** 
 376:../Libraries/XMCLib/src/xmc_vadc.c ****   return result;
 365              	 .loc 1 376 0
 366 0032 0F23     	 mov r3,#15
 367 0034 FB18     	 add r3,r7,r3
 368 0036 1B78     	 ldrb r3,[r3]
 377:../Libraries/XMCLib/src/xmc_vadc.c **** }
 369              	 .loc 1 377 0
 370 0038 181C     	 mov r0,r3
 371 003a BD46     	 mov sp,r7
 372 003c 04B0     	 add sp,sp,#16
 373              	 
 374 003e 80BD     	 pop {r7,pc}
 375              	 .cfi_endproc
 376              	.LFE96:
 378              	 .section .text.XMC_VADC_GLOBAL_SetResultEventInterruptNode,"ax",%progbits
 379              	 .align 2
 380              	 .global XMC_VADC_GLOBAL_SetResultEventInterruptNode
 381              	 .code 16
 382              	 .thumb_func
 384              	XMC_VADC_GLOBAL_SetResultEventInterruptNode:
 385              	.LFB97:
 378:../Libraries/XMCLib/src/xmc_vadc.c **** 
 379:../Libraries/XMCLib/src/xmc_vadc.c **** /* Bind one of the four groups to one of the two EMUX interfaces */
 380:../Libraries/XMCLib/src/xmc_vadc.c **** #if (XMC_VADC_EMUX_AVAILABLE == 1U)
 381:../Libraries/XMCLib/src/xmc_vadc.c **** void XMC_VADC_GLOBAL_BindGroupToEMux(XMC_VADC_GLOBAL_t *const global_ptr, const uint32_t emuxif, co
 382:../Libraries/XMCLib/src/xmc_vadc.c **** {
 383:../Libraries/XMCLib/src/xmc_vadc.c ****   uint32_t mask;
 384:../Libraries/XMCLib/src/xmc_vadc.c ****   uint32_t pos;
 385:../Libraries/XMCLib/src/xmc_vadc.c **** 
 386:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GLOBAL_BindGroupToEMux:Wrong Module Pointer", (global_ptr == VADC))
 387:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GLOBAL_BindGroupToEMux:Wrong EMUX Group", (emuxif < XMC_VADC_NUM_EMUX_INTERF
 388:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GLOBAL_BindGroupToEMux:Wrong VADC Group", (group < XMC_VADC_MAXIMUM_NUM_GROU
 389:../Libraries/XMCLib/src/xmc_vadc.c **** 
 390:../Libraries/XMCLib/src/xmc_vadc.c ****   if (0U == emuxif)
 391:../Libraries/XMCLib/src/xmc_vadc.c ****   {
 392:../Libraries/XMCLib/src/xmc_vadc.c ****     pos  = (uint32_t)VADC_EMUXSEL_EMUXGRP0_Pos;
 393:../Libraries/XMCLib/src/xmc_vadc.c ****     mask = (uint32_t)VADC_EMUXSEL_EMUXGRP0_Msk;
 394:../Libraries/XMCLib/src/xmc_vadc.c ****   }
 395:../Libraries/XMCLib/src/xmc_vadc.c ****   else
 396:../Libraries/XMCLib/src/xmc_vadc.c ****   {
 397:../Libraries/XMCLib/src/xmc_vadc.c ****     pos  = (uint32_t)VADC_EMUXSEL_EMUXGRP1_Pos;
 398:../Libraries/XMCLib/src/xmc_vadc.c ****     mask = (uint32_t)VADC_EMUXSEL_EMUXGRP1_Msk;
 399:../Libraries/XMCLib/src/xmc_vadc.c ****   }
 400:../Libraries/XMCLib/src/xmc_vadc.c **** 
 401:../Libraries/XMCLib/src/xmc_vadc.c ****   global_ptr->EMUXSEL &= ~(mask);
 402:../Libraries/XMCLib/src/xmc_vadc.c ****   global_ptr->EMUXSEL |= (uint32_t) (group << pos);
 403:../Libraries/XMCLib/src/xmc_vadc.c **** 
 404:../Libraries/XMCLib/src/xmc_vadc.c **** }
 405:../Libraries/XMCLib/src/xmc_vadc.c **** #endif 
 406:../Libraries/XMCLib/src/xmc_vadc.c **** 
 407:../Libraries/XMCLib/src/xmc_vadc.c **** /* API to bind result event with a service request line */
 408:../Libraries/XMCLib/src/xmc_vadc.c **** void XMC_VADC_GLOBAL_SetResultEventInterruptNode(XMC_VADC_GLOBAL_t *const global_ptr, XMC_VADC_SR_t
 409:../Libraries/XMCLib/src/xmc_vadc.c **** {
 386              	 .loc 1 409 0
 387              	 .cfi_startproc
 388 0000 80B5     	 push {r7,lr}
 389              	.LCFI19:
 390              	 .cfi_def_cfa_offset 8
 391              	 .cfi_offset 7,-8
 392              	 .cfi_offset 14,-4
 393 0002 84B0     	 sub sp,sp,#16
 394              	.LCFI20:
 395              	 .cfi_def_cfa_offset 24
 396 0004 00AF     	 add r7,sp,#0
 397              	.LCFI21:
 398              	 .cfi_def_cfa_register 7
 399 0006 7860     	 str r0,[r7,#4]
 400 0008 0A1C     	 mov r2,r1
 401 000a FB1C     	 add r3,r7,#3
 402 000c 1A70     	 strb r2,[r3]
 410:../Libraries/XMCLib/src/xmc_vadc.c ****   uint32_t node;
 411:../Libraries/XMCLib/src/xmc_vadc.c ****   
 412:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GLOBAL_SetResultEventInterruptNode:Wrong Module Pointer", (global_ptr == VAD
 413:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GLOBAL_SetResultEventInterruptNode:Wrong SR Number", (sr <= XMC_VADC_SR_SHAR
 414:../Libraries/XMCLib/src/xmc_vadc.c **** 
 415:../Libraries/XMCLib/src/xmc_vadc.c ****   if (sr >= XMC_VADC_SR_SHARED_SR0)
 403              	 .loc 1 415 0
 404 000e FB1C     	 add r3,r7,#3
 405 0010 1B78     	 ldrb r3,[r3]
 406 0012 032B     	 cmp r3,#3
 407 0014 04D9     	 bls .L19
 416:../Libraries/XMCLib/src/xmc_vadc.c ****   {
 417:../Libraries/XMCLib/src/xmc_vadc.c ****     node = (uint32_t)sr - (uint32_t)XMC_VADC_SR_SHARED_SR0;
 408              	 .loc 1 417 0
 409 0016 FB1C     	 add r3,r7,#3
 410 0018 1B78     	 ldrb r3,[r3]
 411 001a 043B     	 sub r3,r3,#4
 412 001c FB60     	 str r3,[r7,#12]
 413 001e 02E0     	 b .L20
 414              	.L19:
 418:../Libraries/XMCLib/src/xmc_vadc.c ****   }
 419:../Libraries/XMCLib/src/xmc_vadc.c ****   else
 420:../Libraries/XMCLib/src/xmc_vadc.c ****   {
 421:../Libraries/XMCLib/src/xmc_vadc.c ****     node = (uint32_t)sr;
 415              	 .loc 1 421 0
 416 0020 FB1C     	 add r3,r7,#3
 417 0022 1B78     	 ldrb r3,[r3]
 418 0024 FB60     	 str r3,[r7,#12]
 419              	.L20:
 422:../Libraries/XMCLib/src/xmc_vadc.c ****   }
 423:../Libraries/XMCLib/src/xmc_vadc.c **** 
 424:../Libraries/XMCLib/src/xmc_vadc.c ****   global_ptr->GLOBEVNP &= ~((uint32_t)VADC_GLOBEVNP_REV0NP_Msk);
 420              	 .loc 1 424 0
 421 0026 7A68     	 ldr r2,[r7,#4]
 422 0028 A023     	 mov r3,#160
 423 002a 5B00     	 lsl r3,r3,#1
 424 002c D358     	 ldr r3,[r2,r3]
 425 002e 0B4A     	 ldr r2,.L21
 426 0030 1340     	 and r3,r2
 427 0032 191C     	 mov r1,r3
 428 0034 7A68     	 ldr r2,[r7,#4]
 429 0036 A023     	 mov r3,#160
 430 0038 5B00     	 lsl r3,r3,#1
 431 003a D150     	 str r1,[r2,r3]
 425:../Libraries/XMCLib/src/xmc_vadc.c ****   global_ptr->GLOBEVNP |= (uint32_t)(node << VADC_GLOBEVNP_REV0NP_Pos);
 432              	 .loc 1 425 0
 433 003c 7A68     	 ldr r2,[r7,#4]
 434 003e A023     	 mov r3,#160
 435 0040 5B00     	 lsl r3,r3,#1
 436 0042 D258     	 ldr r2,[r2,r3]
 437 0044 FB68     	 ldr r3,[r7,#12]
 438 0046 1B04     	 lsl r3,r3,#16
 439 0048 1A43     	 orr r2,r3
 440 004a 111C     	 mov r1,r2
 441 004c 7A68     	 ldr r2,[r7,#4]
 442 004e A023     	 mov r3,#160
 443 0050 5B00     	 lsl r3,r3,#1
 444 0052 D150     	 str r1,[r2,r3]
 426:../Libraries/XMCLib/src/xmc_vadc.c **** }
 445              	 .loc 1 426 0
 446 0054 BD46     	 mov sp,r7
 447 0056 04B0     	 add sp,sp,#16
 448              	 
 449 0058 80BD     	 pop {r7,pc}
 450              	.L22:
 451 005a C046     	 .align 2
 452              	.L21:
 453 005c FFFFF0FF 	 .word -983041
 454              	 .cfi_endproc
 455              	.LFE97:
 457              	 .section .text.XMC_VADC_GLOBAL_BackgroundSetReqSrcEventInterruptNode,"ax",%progbits
 458              	 .align 2
 459              	 .global XMC_VADC_GLOBAL_BackgroundSetReqSrcEventInterruptNode
 460              	 .code 16
 461              	 .thumb_func
 463              	XMC_VADC_GLOBAL_BackgroundSetReqSrcEventInterruptNode:
 464              	.LFB98:
 427:../Libraries/XMCLib/src/xmc_vadc.c **** 
 428:../Libraries/XMCLib/src/xmc_vadc.c **** /* API to bind request source event with a service request line */
 429:../Libraries/XMCLib/src/xmc_vadc.c **** void XMC_VADC_GLOBAL_BackgroundSetReqSrcEventInterruptNode(XMC_VADC_GLOBAL_t *const global_ptr, XMC
 430:../Libraries/XMCLib/src/xmc_vadc.c **** {
 465              	 .loc 1 430 0
 466              	 .cfi_startproc
 467 0000 80B5     	 push {r7,lr}
 468              	.LCFI22:
 469              	 .cfi_def_cfa_offset 8
 470              	 .cfi_offset 7,-8
 471              	 .cfi_offset 14,-4
 472 0002 84B0     	 sub sp,sp,#16
 473              	.LCFI23:
 474              	 .cfi_def_cfa_offset 24
 475 0004 00AF     	 add r7,sp,#0
 476              	.LCFI24:
 477              	 .cfi_def_cfa_register 7
 478 0006 7860     	 str r0,[r7,#4]
 479 0008 0A1C     	 mov r2,r1
 480 000a FB1C     	 add r3,r7,#3
 481 000c 1A70     	 strb r2,[r3]
 431:../Libraries/XMCLib/src/xmc_vadc.c ****   uint32_t node;
 432:../Libraries/XMCLib/src/xmc_vadc.c ****   
 433:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GLOBAL_BackgroundSetReqSrcEventInterruptNode:Wrong Module Pointer", (global_
 434:../Libraries/XMCLib/src/xmc_vadc.c **** 
 435:../Libraries/XMCLib/src/xmc_vadc.c ****   if (sr >= XMC_VADC_SR_SHARED_SR0)
 482              	 .loc 1 435 0
 483 000e FB1C     	 add r3,r7,#3
 484 0010 1B78     	 ldrb r3,[r3]
 485 0012 032B     	 cmp r3,#3
 486 0014 04D9     	 bls .L24
 436:../Libraries/XMCLib/src/xmc_vadc.c ****   {
 437:../Libraries/XMCLib/src/xmc_vadc.c ****     node = (uint32_t)sr - (uint32_t)XMC_VADC_SR_SHARED_SR0;
 487              	 .loc 1 437 0
 488 0016 FB1C     	 add r3,r7,#3
 489 0018 1B78     	 ldrb r3,[r3]
 490 001a 043B     	 sub r3,r3,#4
 491 001c FB60     	 str r3,[r7,#12]
 492 001e 02E0     	 b .L25
 493              	.L24:
 438:../Libraries/XMCLib/src/xmc_vadc.c ****   }
 439:../Libraries/XMCLib/src/xmc_vadc.c ****   else
 440:../Libraries/XMCLib/src/xmc_vadc.c ****   {
 441:../Libraries/XMCLib/src/xmc_vadc.c ****     node = (uint32_t)sr;
 494              	 .loc 1 441 0
 495 0020 FB1C     	 add r3,r7,#3
 496 0022 1B78     	 ldrb r3,[r3]
 497 0024 FB60     	 str r3,[r7,#12]
 498              	.L25:
 442:../Libraries/XMCLib/src/xmc_vadc.c ****   }
 443:../Libraries/XMCLib/src/xmc_vadc.c **** 
 444:../Libraries/XMCLib/src/xmc_vadc.c ****   global_ptr->GLOBEVNP &= ~((uint32_t)VADC_GLOBEVNP_SEV0NP_Msk);
 499              	 .loc 1 444 0
 500 0026 7A68     	 ldr r2,[r7,#4]
 501 0028 A023     	 mov r3,#160
 502 002a 5B00     	 lsl r3,r3,#1
 503 002c D358     	 ldr r3,[r2,r3]
 504 002e 0F22     	 mov r2,#15
 505 0030 9343     	 bic r3,r2
 506 0032 191C     	 mov r1,r3
 507 0034 7A68     	 ldr r2,[r7,#4]
 508 0036 A023     	 mov r3,#160
 509 0038 5B00     	 lsl r3,r3,#1
 510 003a D150     	 str r1,[r2,r3]
 445:../Libraries/XMCLib/src/xmc_vadc.c ****   global_ptr->GLOBEVNP |= (uint32_t) (node << VADC_GLOBEVNP_SEV0NP_Pos);
 511              	 .loc 1 445 0
 512 003c 7A68     	 ldr r2,[r7,#4]
 513 003e A023     	 mov r3,#160
 514 0040 5B00     	 lsl r3,r3,#1
 515 0042 D258     	 ldr r2,[r2,r3]
 516 0044 FB68     	 ldr r3,[r7,#12]
 517 0046 1A43     	 orr r2,r3
 518 0048 111C     	 mov r1,r2
 519 004a 7A68     	 ldr r2,[r7,#4]
 520 004c A023     	 mov r3,#160
 521 004e 5B00     	 lsl r3,r3,#1
 522 0050 D150     	 str r1,[r2,r3]
 446:../Libraries/XMCLib/src/xmc_vadc.c **** }
 523              	 .loc 1 446 0
 524 0052 BD46     	 mov sp,r7
 525 0054 04B0     	 add sp,sp,#16
 526              	 
 527 0056 80BD     	 pop {r7,pc}
 528              	 .cfi_endproc
 529              	.LFE98:
 531              	 .section .text.XMC_VADC_GLOBAL_SHS_Init,"ax",%progbits
 532              	 .align 2
 533              	 .global XMC_VADC_GLOBAL_SHS_Init
 534              	 .code 16
 535              	 .thumb_func
 537              	XMC_VADC_GLOBAL_SHS_Init:
 538              	.LFB99:
 447:../Libraries/XMCLib/src/xmc_vadc.c **** 
 448:../Libraries/XMCLib/src/xmc_vadc.c **** /* API to initialize an instance of group of VADC hardware */
 449:../Libraries/XMCLib/src/xmc_vadc.c **** #if (XMC_VADC_GROUP_AVAILABLE == 1U)  
 450:../Libraries/XMCLib/src/xmc_vadc.c **** void XMC_VADC_GROUP_Init( XMC_VADC_GROUP_t *const group_ptr, const XMC_VADC_GROUP_CONFIG_t *config)
 451:../Libraries/XMCLib/src/xmc_vadc.c **** {
 452:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GROUP_Init:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
 453:../Libraries/XMCLib/src/xmc_vadc.c **** 
 454:../Libraries/XMCLib/src/xmc_vadc.c ****   /* Program the input classes */
 455:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_VADC_GROUP_InputClassInit(group_ptr, config->class0, XMC_VADC_GROUP_CONV_STD, 0U);
 456:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_VADC_GROUP_InputClassInit(group_ptr, config->class0, XMC_VADC_GROUP_CONV_EMUX, 0U);
 457:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_VADC_GROUP_InputClassInit(group_ptr, config->class1, XMC_VADC_GROUP_CONV_STD, 1U);
 458:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_VADC_GROUP_InputClassInit(group_ptr, config->class1, XMC_VADC_GROUP_CONV_EMUX, 1U);
 459:../Libraries/XMCLib/src/xmc_vadc.c **** 
 460:../Libraries/XMCLib/src/xmc_vadc.c ****   group_ptr->ARBCFG = config->g_arbcfg;
 461:../Libraries/XMCLib/src/xmc_vadc.c **** 
 462:../Libraries/XMCLib/src/xmc_vadc.c ****   group_ptr->BOUND = config->g_bound;
 463:../Libraries/XMCLib/src/xmc_vadc.c **** 
 464:../Libraries/XMCLib/src/xmc_vadc.c ****   /* External mux configuration */
 465:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_VADC_GROUP_ExternalMuxControlInit(group_ptr,config->emux_config);
 466:../Libraries/XMCLib/src/xmc_vadc.c **** 
 467:../Libraries/XMCLib/src/xmc_vadc.c **** }
 468:../Libraries/XMCLib/src/xmc_vadc.c **** 
 469:../Libraries/XMCLib/src/xmc_vadc.c **** /* API to program conversion characteristics */
 470:../Libraries/XMCLib/src/xmc_vadc.c **** void XMC_VADC_GROUP_InputClassInit(XMC_VADC_GROUP_t *const group_ptr, const XMC_VADC_GROUP_CLASS_t 
 471:../Libraries/XMCLib/src/xmc_vadc.c ****                                           const XMC_VADC_GROUP_CONV_t conv_type, const uint32_t set
 472:../Libraries/XMCLib/src/xmc_vadc.c **** {
 473:../Libraries/XMCLib/src/xmc_vadc.c ****   uint32_t        conv_class;
 474:../Libraries/XMCLib/src/xmc_vadc.c ****   uint32_t        conv_mode_pos;
 475:../Libraries/XMCLib/src/xmc_vadc.c ****   uint32_t        sample_time_pos;
 476:../Libraries/XMCLib/src/xmc_vadc.c ****   uint32_t        conv_mode_mask;
 477:../Libraries/XMCLib/src/xmc_vadc.c ****   uint32_t        sample_time_mask;
 478:../Libraries/XMCLib/src/xmc_vadc.c ****   uint32_t        sample_time;
 479:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_VADC_CONVMODE_t conv_mode;
 480:../Libraries/XMCLib/src/xmc_vadc.c **** 
 481:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GROUP_InputClassInit:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_pt
 482:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GROUP_InputClassInit:Wrong Conversion Type", ((conv_type) <= XMC_VADC_GROUP_
 483:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GROUP_InputClassInit:Wrong ICLASS set number", (set_num < XMC_VADC_MAX_ICLAS
 484:../Libraries/XMCLib/src/xmc_vadc.c **** 
 485:../Libraries/XMCLib/src/xmc_vadc.c ****   /* 
 486:../Libraries/XMCLib/src/xmc_vadc.c ****    * Obtain the mask and position macros of the parameters based on what is being requested - Stand
 487:../Libraries/XMCLib/src/xmc_vadc.c ****    * external mux channels.
 488:../Libraries/XMCLib/src/xmc_vadc.c ****    */
 489:../Libraries/XMCLib/src/xmc_vadc.c ****   if (XMC_VADC_GROUP_CONV_STD == conv_type)
 490:../Libraries/XMCLib/src/xmc_vadc.c ****   {
 491:../Libraries/XMCLib/src/xmc_vadc.c ****     conv_mode_pos    = (uint32_t) VADC_G_ICLASS_CMS_Pos;
 492:../Libraries/XMCLib/src/xmc_vadc.c ****     conv_mode_mask   = (uint32_t) VADC_G_ICLASS_CMS_Msk;
 493:../Libraries/XMCLib/src/xmc_vadc.c ****     sample_time_pos  = (uint32_t) VADC_G_ICLASS_STCS_Pos;
 494:../Libraries/XMCLib/src/xmc_vadc.c ****     sample_time_mask = (uint32_t) VADC_G_ICLASS_STCS_Msk;
 495:../Libraries/XMCLib/src/xmc_vadc.c ****     sample_time      = (uint32_t) config.sample_time_std_conv;
 496:../Libraries/XMCLib/src/xmc_vadc.c ****     conv_mode        = (XMC_VADC_CONVMODE_t)config.conversion_mode_standard;
 497:../Libraries/XMCLib/src/xmc_vadc.c ****   }
 498:../Libraries/XMCLib/src/xmc_vadc.c ****   else
 499:../Libraries/XMCLib/src/xmc_vadc.c ****   {
 500:../Libraries/XMCLib/src/xmc_vadc.c ****     conv_mode_pos    = (uint32_t) VADC_G_ICLASS_CME_Pos;
 501:../Libraries/XMCLib/src/xmc_vadc.c ****     conv_mode_mask   = (uint32_t) VADC_G_ICLASS_CME_Msk;
 502:../Libraries/XMCLib/src/xmc_vadc.c ****     sample_time_pos  = (uint32_t) VADC_G_ICLASS_STCE_Pos;
 503:../Libraries/XMCLib/src/xmc_vadc.c ****     sample_time_mask = (uint32_t) VADC_G_ICLASS_STCE_Msk;
 504:../Libraries/XMCLib/src/xmc_vadc.c ****     sample_time      = (uint32_t) config.sampling_phase_emux_channel;
 505:../Libraries/XMCLib/src/xmc_vadc.c ****     conv_mode        = (XMC_VADC_CONVMODE_t)config.conversion_mode_emux;
 506:../Libraries/XMCLib/src/xmc_vadc.c ****   }
 507:../Libraries/XMCLib/src/xmc_vadc.c **** 
 508:../Libraries/XMCLib/src/xmc_vadc.c ****   /* Determine the class */
 509:../Libraries/XMCLib/src/xmc_vadc.c ****   conv_class  = group_ptr->ICLASS[set_num];
 510:../Libraries/XMCLib/src/xmc_vadc.c **** 
 511:../Libraries/XMCLib/src/xmc_vadc.c ****   /* Program the class register */
 512:../Libraries/XMCLib/src/xmc_vadc.c ****   conv_class &= ~(conv_mode_mask);
 513:../Libraries/XMCLib/src/xmc_vadc.c ****   conv_class |= (uint32_t)((uint32_t) conv_mode << conv_mode_pos);
 514:../Libraries/XMCLib/src/xmc_vadc.c ****   conv_class &= ~(sample_time_mask);
 515:../Libraries/XMCLib/src/xmc_vadc.c ****   conv_class |= (uint32_t)(sample_time <<  sample_time_pos);
 516:../Libraries/XMCLib/src/xmc_vadc.c ****   group_ptr->ICLASS[set_num] = conv_class;
 517:../Libraries/XMCLib/src/xmc_vadc.c **** }
 518:../Libraries/XMCLib/src/xmc_vadc.c **** 
 519:../Libraries/XMCLib/src/xmc_vadc.c **** /* API which sets the power mode of analog converter of a VADC group */
 520:../Libraries/XMCLib/src/xmc_vadc.c **** void XMC_VADC_GROUP_SetPowerMode(XMC_VADC_GROUP_t *const group_ptr, const XMC_VADC_GROUP_POWERMODE_
 521:../Libraries/XMCLib/src/xmc_vadc.c **** {
 522:../Libraries/XMCLib/src/xmc_vadc.c ****   uint32_t arbcfg;
 523:../Libraries/XMCLib/src/xmc_vadc.c **** 
 524:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GROUP_SetPowerMode:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr)
 525:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GROUP_SetPowerMode:Wrong Power Mode", (power_mode <= XMC_VADC_GROUP_POWERMOD
 526:../Libraries/XMCLib/src/xmc_vadc.c **** 
 527:../Libraries/XMCLib/src/xmc_vadc.c ****   arbcfg = group_ptr->ARBCFG;
 528:../Libraries/XMCLib/src/xmc_vadc.c **** 
 529:../Libraries/XMCLib/src/xmc_vadc.c ****   arbcfg &= ~((uint32_t)VADC_G_ARBCFG_ANONC_Msk);
 530:../Libraries/XMCLib/src/xmc_vadc.c ****   arbcfg |= (uint32_t)power_mode;
 531:../Libraries/XMCLib/src/xmc_vadc.c **** 
 532:../Libraries/XMCLib/src/xmc_vadc.c ****   group_ptr->ARBCFG = arbcfg;
 533:../Libraries/XMCLib/src/xmc_vadc.c **** }
 534:../Libraries/XMCLib/src/xmc_vadc.c **** 
 535:../Libraries/XMCLib/src/xmc_vadc.c **** /* API which programs a group as a slave group during sync conversions */
 536:../Libraries/XMCLib/src/xmc_vadc.c **** void XMC_VADC_GROUP_SetSyncSlave(XMC_VADC_GROUP_t *const group_ptr, uint32_t master_grp, uint32_t s
 537:../Libraries/XMCLib/src/xmc_vadc.c **** {
 538:../Libraries/XMCLib/src/xmc_vadc.c ****   uint32_t synctr;
 539:../Libraries/XMCLib/src/xmc_vadc.c ****   #if (XMC_VADC_MULTIPLE_SLAVEGROUPS == 1U )
 540:../Libraries/XMCLib/src/xmc_vadc.c ****   #endif
 541:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GROUP_SetSyncSlave:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr)
 542:../Libraries/XMCLib/src/xmc_vadc.c ****   
 543:../Libraries/XMCLib/src/xmc_vadc.c ****   #if (XMC_VADC_MULTIPLE_SLAVEGROUPS == 1U )
 544:../Libraries/XMCLib/src/xmc_vadc.c **** 
 545:../Libraries/XMCLib/src/xmc_vadc.c ****   /* Determine the coding of SYNCTR */
 546:../Libraries/XMCLib/src/xmc_vadc.c ****   if (slave_grp > master_grp)
 547:../Libraries/XMCLib/src/xmc_vadc.c ****   {
 548:../Libraries/XMCLib/src/xmc_vadc.c ****     master_grp = master_grp + 1U;
 549:../Libraries/XMCLib/src/xmc_vadc.c ****   }
 550:../Libraries/XMCLib/src/xmc_vadc.c ****   #endif
 551:../Libraries/XMCLib/src/xmc_vadc.c ****   
 552:../Libraries/XMCLib/src/xmc_vadc.c ****   /* Program SYNCTR */
 553:../Libraries/XMCLib/src/xmc_vadc.c ****   synctr = group_ptr->SYNCTR;
 554:../Libraries/XMCLib/src/xmc_vadc.c ****   synctr   &= ~((uint32_t)VADC_G_SYNCTR_STSEL_Msk);
 555:../Libraries/XMCLib/src/xmc_vadc.c ****   synctr   |= master_grp;
 556:../Libraries/XMCLib/src/xmc_vadc.c ****   group_ptr->SYNCTR = synctr;
 557:../Libraries/XMCLib/src/xmc_vadc.c **** }
 558:../Libraries/XMCLib/src/xmc_vadc.c **** 
 559:../Libraries/XMCLib/src/xmc_vadc.c **** /* API which programs a group as a master group during sync conversions */
 560:../Libraries/XMCLib/src/xmc_vadc.c **** void XMC_VADC_GROUP_SetSyncMaster(XMC_VADC_GROUP_t *const group_ptr)
 561:../Libraries/XMCLib/src/xmc_vadc.c **** {
 562:../Libraries/XMCLib/src/xmc_vadc.c ****   uint32_t synctr;
 563:../Libraries/XMCLib/src/xmc_vadc.c **** 
 564:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GROUP_SetSyncMaster:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr
 565:../Libraries/XMCLib/src/xmc_vadc.c **** 
 566:../Libraries/XMCLib/src/xmc_vadc.c ****   synctr = group_ptr->SYNCTR;
 567:../Libraries/XMCLib/src/xmc_vadc.c ****   synctr   &= ~((uint32_t)VADC_G_SYNCTR_STSEL_Msk);
 568:../Libraries/XMCLib/src/xmc_vadc.c ****   group_ptr->SYNCTR = synctr;
 569:../Libraries/XMCLib/src/xmc_vadc.c **** }
 570:../Libraries/XMCLib/src/xmc_vadc.c **** 
 571:../Libraries/XMCLib/src/xmc_vadc.c **** /* API to enable checking of readiness of slaves before a synchronous conversion request is issued 
 572:../Libraries/XMCLib/src/xmc_vadc.c **** void XMC_VADC_GROUP_CheckSlaveReadiness(XMC_VADC_GROUP_t *const group_ptr, uint32_t slave_group)
 573:../Libraries/XMCLib/src/xmc_vadc.c **** {
 574:../Libraries/XMCLib/src/xmc_vadc.c ****   uint32_t i,master_grp_num;
 575:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GROUP_CheckSlaveReadiness:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(gro
 576:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GROUP_CheckSlaveReadiness:Wrong Slave group", ((slave_group >= 0) && (slave_
 577:../Libraries/XMCLib/src/xmc_vadc.c **** 
 578:../Libraries/XMCLib/src/xmc_vadc.c ****   master_grp_num =0;
 579:../Libraries/XMCLib/src/xmc_vadc.c ****   for(i=0; i<XMC_VADC_MAXIMUM_NUM_GROUPS; i++)
 580:../Libraries/XMCLib/src/xmc_vadc.c ****   {
 581:../Libraries/XMCLib/src/xmc_vadc.c ****     if(g_xmc_vadc_group_array[i] == group_ptr)
 582:../Libraries/XMCLib/src/xmc_vadc.c ****     {
 583:../Libraries/XMCLib/src/xmc_vadc.c ****       master_grp_num = i;
 584:../Libraries/XMCLib/src/xmc_vadc.c ****     }
 585:../Libraries/XMCLib/src/xmc_vadc.c ****   }
 586:../Libraries/XMCLib/src/xmc_vadc.c **** 
 587:../Libraries/XMCLib/src/xmc_vadc.c **** 
 588:../Libraries/XMCLib/src/xmc_vadc.c ****   if(slave_group < master_grp_num)
 589:../Libraries/XMCLib/src/xmc_vadc.c ****   {
 590:../Libraries/XMCLib/src/xmc_vadc.c ****     slave_group++;
 591:../Libraries/XMCLib/src/xmc_vadc.c ****   }
 592:../Libraries/XMCLib/src/xmc_vadc.c ****   group_ptr->SYNCTR |= (1U << (slave_group + XMC_VADC_SYNCTR_START_LOCATION));
 593:../Libraries/XMCLib/src/xmc_vadc.c **** }
 594:../Libraries/XMCLib/src/xmc_vadc.c **** 
 595:../Libraries/XMCLib/src/xmc_vadc.c **** /* API to disable checking of readiness of slaves during synchronous conversions */
 596:../Libraries/XMCLib/src/xmc_vadc.c **** void XMC_VADC_GROUP_IgnoreSlaveReadiness(XMC_VADC_GROUP_t *const group_ptr, uint32_t slave_group)
 597:../Libraries/XMCLib/src/xmc_vadc.c **** {
 598:../Libraries/XMCLib/src/xmc_vadc.c ****   uint32_t i,master_grp_num;
 599:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GROUP_IgnoreSlaveReadiness:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(gr
 600:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GROUP_IgnoreSlaveReadiness:Wrong Slave group", ((slave_group >= 0) && (slave
 601:../Libraries/XMCLib/src/xmc_vadc.c **** 
 602:../Libraries/XMCLib/src/xmc_vadc.c ****   master_grp_num =0;
 603:../Libraries/XMCLib/src/xmc_vadc.c ****   for(i=0; i<XMC_VADC_MAXIMUM_NUM_GROUPS; i++)
 604:../Libraries/XMCLib/src/xmc_vadc.c ****   {
 605:../Libraries/XMCLib/src/xmc_vadc.c **** 	  if(g_xmc_vadc_group_array[i] == group_ptr)
 606:../Libraries/XMCLib/src/xmc_vadc.c **** 	  {
 607:../Libraries/XMCLib/src/xmc_vadc.c **** 	    master_grp_num = i;
 608:../Libraries/XMCLib/src/xmc_vadc.c **** 	  }
 609:../Libraries/XMCLib/src/xmc_vadc.c ****   }
 610:../Libraries/XMCLib/src/xmc_vadc.c **** 
 611:../Libraries/XMCLib/src/xmc_vadc.c ****   if(slave_group < master_grp_num)
 612:../Libraries/XMCLib/src/xmc_vadc.c ****   {
 613:../Libraries/XMCLib/src/xmc_vadc.c **** 	  slave_group++;
 614:../Libraries/XMCLib/src/xmc_vadc.c ****   }
 615:../Libraries/XMCLib/src/xmc_vadc.c ****   group_ptr->SYNCTR &= ~(1U << (slave_group + XMC_VADC_SYNCTR_START_LOCATION));
 616:../Libraries/XMCLib/src/xmc_vadc.c **** }
 617:../Libraries/XMCLib/src/xmc_vadc.c **** 
 618:../Libraries/XMCLib/src/xmc_vadc.c **** /* API to configure EVAL bit in the slave groups*/
 619:../Libraries/XMCLib/src/xmc_vadc.c **** void XMC_VADC_GROUP_SetSyncSlaveReadySignal(XMC_VADC_GROUP_t *const group_ptr,
 620:../Libraries/XMCLib/src/xmc_vadc.c ****                                             uint32_t eval_waiting_group,
 621:../Libraries/XMCLib/src/xmc_vadc.c ****                                             uint32_t eval_origin_group)
 622:../Libraries/XMCLib/src/xmc_vadc.c **** {
 623:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GROUP_SetSyncSlaveReadySignal:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR
 624:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GROUP_SetSyncSlaveReadySignal:Wrong Group numbers", (eval_waiting_group == e
 625:../Libraries/XMCLib/src/xmc_vadc.c **** 
 626:../Libraries/XMCLib/src/xmc_vadc.c ****   if(eval_origin_group < eval_waiting_group)
 627:../Libraries/XMCLib/src/xmc_vadc.c ****   {
 628:../Libraries/XMCLib/src/xmc_vadc.c **** 	  eval_origin_group++;
 629:../Libraries/XMCLib/src/xmc_vadc.c ****   }
 630:../Libraries/XMCLib/src/xmc_vadc.c ****   group_ptr->SYNCTR |= (1U << (eval_origin_group + XMC_VADC_SYNCTR_START_LOCATION));
 631:../Libraries/XMCLib/src/xmc_vadc.c **** }
 632:../Libraries/XMCLib/src/xmc_vadc.c **** 
 633:../Libraries/XMCLib/src/xmc_vadc.c **** 
 634:../Libraries/XMCLib/src/xmc_vadc.c **** /* API to enable the synchronous conversion feature - Applicable only to kernel configured as maste
 635:../Libraries/XMCLib/src/xmc_vadc.c **** void XMC_VADC_GROUP_EnableChannelSyncRequest(XMC_VADC_GROUP_t *const group_ptr, const uint32_t ch_n
 636:../Libraries/XMCLib/src/xmc_vadc.c **** {
 637:../Libraries/XMCLib/src/xmc_vadc.c ****   uint32_t synctr;
 638:../Libraries/XMCLib/src/xmc_vadc.c **** 
 639:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GROUP_EnableChannelSyncRequest:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PT
 640:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GROUP_EnableChannelSyncRequest:Wrong Channel Number",
 641:../Libraries/XMCLib/src/xmc_vadc.c ****              ((ch_num) < XMC_VADC_NUM_CHANNELS_PER_GROUP))
 642:../Libraries/XMCLib/src/xmc_vadc.c **** 
 643:../Libraries/XMCLib/src/xmc_vadc.c ****   synctr  = group_ptr->SYNCTR;
 644:../Libraries/XMCLib/src/xmc_vadc.c **** 
 645:../Libraries/XMCLib/src/xmc_vadc.c ****   if (!(synctr &  (uint32_t)VADC_G_SYNCTR_STSEL_Msk))
 646:../Libraries/XMCLib/src/xmc_vadc.c ****   {
 647:../Libraries/XMCLib/src/xmc_vadc.c ****     group_ptr->CHCTR[ch_num] |= (uint32_t)((uint32_t)1 << VADC_G_CHCTR_SYNC_Pos);
 648:../Libraries/XMCLib/src/xmc_vadc.c ****   }
 649:../Libraries/XMCLib/src/xmc_vadc.c **** }
 650:../Libraries/XMCLib/src/xmc_vadc.c **** 
 651:../Libraries/XMCLib/src/xmc_vadc.c **** /* API to disable synchronous conversion feature */
 652:../Libraries/XMCLib/src/xmc_vadc.c **** void XMC_VADC_GROUP_DisableChannelSyncRequest(XMC_VADC_GROUP_t *const group_ptr, const uint32_t ch_
 653:../Libraries/XMCLib/src/xmc_vadc.c **** {
 654:../Libraries/XMCLib/src/xmc_vadc.c ****   uint32_t    synctr;
 655:../Libraries/XMCLib/src/xmc_vadc.c **** 
 656:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GROUP_DisableChannelSyncRequest:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_P
 657:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GROUP_DisableChannelSyncRequest:Wrong Channel Number",
 658:../Libraries/XMCLib/src/xmc_vadc.c ****              ((ch_num) < XMC_VADC_NUM_CHANNELS_PER_GROUP))
 659:../Libraries/XMCLib/src/xmc_vadc.c **** 
 660:../Libraries/XMCLib/src/xmc_vadc.c ****   synctr  = group_ptr->SYNCTR;
 661:../Libraries/XMCLib/src/xmc_vadc.c **** 
 662:../Libraries/XMCLib/src/xmc_vadc.c ****   if (synctr &  (uint32_t)VADC_G_SYNCTR_STSEL_Msk)
 663:../Libraries/XMCLib/src/xmc_vadc.c ****   {
 664:../Libraries/XMCLib/src/xmc_vadc.c ****     group_ptr->CHCTR[ch_num] &= ~((uint32_t)VADC_G_CHCTR_SYNC_Msk);
 665:../Libraries/XMCLib/src/xmc_vadc.c ****   }
 666:../Libraries/XMCLib/src/xmc_vadc.c **** }
 667:../Libraries/XMCLib/src/xmc_vadc.c **** 
 668:../Libraries/XMCLib/src/xmc_vadc.c **** /* API to retrieve the converter state - Idle vs Busy */ 
 669:../Libraries/XMCLib/src/xmc_vadc.c **** XMC_VADC_GROUP_STATE_t XMC_VADC_GROUP_IsConverterBusy(XMC_VADC_GROUP_t *const group_ptr)
 670:../Libraries/XMCLib/src/xmc_vadc.c **** {
 671:../Libraries/XMCLib/src/xmc_vadc.c ****   uint32_t      arbcfg;
 672:../Libraries/XMCLib/src/xmc_vadc.c **** 
 673:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GROUP_IsConverterBusy:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_p
 674:../Libraries/XMCLib/src/xmc_vadc.c **** 
 675:../Libraries/XMCLib/src/xmc_vadc.c ****   arbcfg  = group_ptr->ARBCFG;
 676:../Libraries/XMCLib/src/xmc_vadc.c ****   arbcfg &= (uint32_t)VADC_G_ARBCFG_BUSY_Msk;
 677:../Libraries/XMCLib/src/xmc_vadc.c ****   arbcfg = arbcfg >> VADC_G_ARBCFG_BUSY_Pos;
 678:../Libraries/XMCLib/src/xmc_vadc.c **** 
 679:../Libraries/XMCLib/src/xmc_vadc.c ****   return( (XMC_VADC_GROUP_STATE_t)arbcfg);
 680:../Libraries/XMCLib/src/xmc_vadc.c **** }
 681:../Libraries/XMCLib/src/xmc_vadc.c **** 
 682:../Libraries/XMCLib/src/xmc_vadc.c **** /* API to set boundaries for conversion results */
 683:../Libraries/XMCLib/src/xmc_vadc.c **** void XMC_VADC_GROUP_SetBoundaries(XMC_VADC_GROUP_t *const group_ptr, const uint32_t boundary0, cons
 684:../Libraries/XMCLib/src/xmc_vadc.c **** {
 685:../Libraries/XMCLib/src/xmc_vadc.c ****   uint32_t bound;
 686:../Libraries/XMCLib/src/xmc_vadc.c **** 
 687:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GROUP_SetBoundaries:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr
 688:../Libraries/XMCLib/src/xmc_vadc.c **** 
 689:../Libraries/XMCLib/src/xmc_vadc.c ****   /* Program the Boundary registers */
 690:../Libraries/XMCLib/src/xmc_vadc.c ****   bound  = group_ptr->BOUND;
 691:../Libraries/XMCLib/src/xmc_vadc.c ****   bound &= ~((uint32_t) VADC_G_BOUND_BOUNDARY0_Msk);
 692:../Libraries/XMCLib/src/xmc_vadc.c ****   bound &= ~((uint32_t) VADC_G_BOUND_BOUNDARY1_Msk);
 693:../Libraries/XMCLib/src/xmc_vadc.c ****   bound |= (uint32_t) ((uint32_t) boundary0 << VADC_G_BOUND_BOUNDARY0_Pos);
 694:../Libraries/XMCLib/src/xmc_vadc.c ****   bound |= (uint32_t) ((uint32_t) boundary1 << VADC_G_BOUND_BOUNDARY1_Pos);
 695:../Libraries/XMCLib/src/xmc_vadc.c ****   group_ptr->BOUND = bound;
 696:../Libraries/XMCLib/src/xmc_vadc.c **** }
 697:../Libraries/XMCLib/src/xmc_vadc.c **** 
 698:../Libraries/XMCLib/src/xmc_vadc.c **** /* API to set an individual boundary for conversion results */
 699:../Libraries/XMCLib/src/xmc_vadc.c **** void XMC_VADC_GROUP_SetIndividualBoundary(XMC_VADC_GROUP_t *const group_ptr,
 700:../Libraries/XMCLib/src/xmc_vadc.c ****                                           const XMC_VADC_CHANNEL_BOUNDARY_t selection,
 701:../Libraries/XMCLib/src/xmc_vadc.c ****                                           const uint16_t boundary_value)
 702:../Libraries/XMCLib/src/xmc_vadc.c **** {
 703:../Libraries/XMCLib/src/xmc_vadc.c **** 
 704:../Libraries/XMCLib/src/xmc_vadc.c ****   uint32_t bound;
 705:../Libraries/XMCLib/src/xmc_vadc.c **** 
 706:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GROUP_SetIndividualBoundary:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(g
 707:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GROUP_SetIndividualBoundary:Wrong Boundary Selection",
 708:../Libraries/XMCLib/src/xmc_vadc.c ****                ((XMC_VADC_CHANNEL_BOUNDARY_GROUP_BOUND0 == selection) ||
 709:../Libraries/XMCLib/src/xmc_vadc.c ****                 (XMC_VADC_CHANNEL_BOUNDARY_GROUP_BOUND1 == selection)))
 710:../Libraries/XMCLib/src/xmc_vadc.c **** 
 711:../Libraries/XMCLib/src/xmc_vadc.c ****   /* Program the Boundary registers */
 712:../Libraries/XMCLib/src/xmc_vadc.c ****   bound  = group_ptr->BOUND;
 713:../Libraries/XMCLib/src/xmc_vadc.c ****   if (XMC_VADC_CHANNEL_BOUNDARY_GROUP_BOUND0 == selection)
 714:../Libraries/XMCLib/src/xmc_vadc.c ****   {
 715:../Libraries/XMCLib/src/xmc_vadc.c ****     bound &= ~((uint32_t) VADC_G_BOUND_BOUNDARY0_Msk);
 716:../Libraries/XMCLib/src/xmc_vadc.c ****     bound |= (uint32_t) ((uint32_t) boundary_value << VADC_G_BOUND_BOUNDARY0_Pos);
 717:../Libraries/XMCLib/src/xmc_vadc.c ****   }
 718:../Libraries/XMCLib/src/xmc_vadc.c ****   else if (XMC_VADC_CHANNEL_BOUNDARY_GROUP_BOUND1 == selection)
 719:../Libraries/XMCLib/src/xmc_vadc.c ****   {
 720:../Libraries/XMCLib/src/xmc_vadc.c ****     bound &= ~((uint32_t) VADC_G_BOUND_BOUNDARY1_Msk);
 721:../Libraries/XMCLib/src/xmc_vadc.c ****     bound |= (uint32_t) ((uint32_t) boundary_value << VADC_G_BOUND_BOUNDARY1_Pos);
 722:../Libraries/XMCLib/src/xmc_vadc.c ****   }
 723:../Libraries/XMCLib/src/xmc_vadc.c ****   else
 724:../Libraries/XMCLib/src/xmc_vadc.c ****   {
 725:../Libraries/XMCLib/src/xmc_vadc.c ****     /* For MISRA*/
 726:../Libraries/XMCLib/src/xmc_vadc.c ****   }
 727:../Libraries/XMCLib/src/xmc_vadc.c ****   group_ptr->BOUND = bound;
 728:../Libraries/XMCLib/src/xmc_vadc.c **** 
 729:../Libraries/XMCLib/src/xmc_vadc.c **** }
 730:../Libraries/XMCLib/src/xmc_vadc.c **** 
 731:../Libraries/XMCLib/src/xmc_vadc.c **** /* Manually assert service request (Interrupt) to NVIC */
 732:../Libraries/XMCLib/src/xmc_vadc.c **** void XMC_VADC_GROUP_TriggerServiceRequest(XMC_VADC_GROUP_t *const group_ptr,
 733:../Libraries/XMCLib/src/xmc_vadc.c ****                                           const uint32_t sr_num,
 734:../Libraries/XMCLib/src/xmc_vadc.c ****                                           const XMC_VADC_GROUP_IRQ_t type)
 735:../Libraries/XMCLib/src/xmc_vadc.c **** {
 736:../Libraries/XMCLib/src/xmc_vadc.c ****   uint32_t sract;
 737:../Libraries/XMCLib/src/xmc_vadc.c **** 
 738:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GROUP_TriggerServiceRequest:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(g
 739:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GROUP_TriggerServiceRequest:Wrong SR number", (sr_num <= XMC_VADC_SR_SHARED_
 740:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GROUP_TriggerServiceRequest:Wrong SR type", ((type)<= XMC_VADC_GROUP_IRQ_SHA
 741:../Libraries/XMCLib/src/xmc_vadc.c **** 
 742:../Libraries/XMCLib/src/xmc_vadc.c ****   sract = group_ptr->SRACT;
 743:../Libraries/XMCLib/src/xmc_vadc.c **** 
 744:../Libraries/XMCLib/src/xmc_vadc.c ****   if (XMC_VADC_GROUP_IRQ_KERNEL == type)
 745:../Libraries/XMCLib/src/xmc_vadc.c ****   {
 746:../Libraries/XMCLib/src/xmc_vadc.c ****     sract |= (uint32_t)((uint32_t)1 << sr_num);
 747:../Libraries/XMCLib/src/xmc_vadc.c ****   }
 748:../Libraries/XMCLib/src/xmc_vadc.c ****   else
 749:../Libraries/XMCLib/src/xmc_vadc.c ****   {
 750:../Libraries/XMCLib/src/xmc_vadc.c ****     sract |= (uint32_t)((uint32_t)1 << (sr_num + (uint32_t)8));
 751:../Libraries/XMCLib/src/xmc_vadc.c ****   }
 752:../Libraries/XMCLib/src/xmc_vadc.c **** 
 753:../Libraries/XMCLib/src/xmc_vadc.c ****   group_ptr->SRACT = sract;
 754:../Libraries/XMCLib/src/xmc_vadc.c **** }
 755:../Libraries/XMCLib/src/xmc_vadc.c **** 
 756:../Libraries/XMCLib/src/xmc_vadc.c **** #if XMC_VADC_BOUNDARY_FLAG_SELECT == 1U
 757:../Libraries/XMCLib/src/xmc_vadc.c **** 
 758:../Libraries/XMCLib/src/xmc_vadc.c **** /* API to set the SR line for the Boundary flag node pointer*/
 759:../Libraries/XMCLib/src/xmc_vadc.c **** void XMC_VADC_GROUP_SetBoundaryEventInterruptNode(XMC_VADC_GROUP_t *const group_ptr,
 760:../Libraries/XMCLib/src/xmc_vadc.c ****                                                                   const uint8_t boundary_flag_num,
 761:../Libraries/XMCLib/src/xmc_vadc.c ****                                                                   const XMC_VADC_BOUNDARY_NODE_t sr
 762:../Libraries/XMCLib/src/xmc_vadc.c **** {
 763:../Libraries/XMCLib/src/xmc_vadc.c ****   uint32_t flag_pos;
 764:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GROUP_SetBoundaryEventInterruptNode:Wrong Group Pointer", XMC_VADC_CHECK_GRO
 765:../Libraries/XMCLib/src/xmc_vadc.c **** 
 766:../Libraries/XMCLib/src/xmc_vadc.c ****   /* Program the GxBFLNP */
 767:../Libraries/XMCLib/src/xmc_vadc.c ****   flag_pos = (uint32_t)boundary_flag_num << (uint32_t)2;
 768:../Libraries/XMCLib/src/xmc_vadc.c ****   group_ptr->BFLNP &= ~((uint32_t)VADC_G_BFLNP_BFL0NP_Msk << flag_pos);
 769:../Libraries/XMCLib/src/xmc_vadc.c ****   group_ptr->BFLNP |= (uint32_t)sr << flag_pos;
 770:../Libraries/XMCLib/src/xmc_vadc.c **** }
 771:../Libraries/XMCLib/src/xmc_vadc.c **** 
 772:../Libraries/XMCLib/src/xmc_vadc.c **** #endif
 773:../Libraries/XMCLib/src/xmc_vadc.c **** 
 774:../Libraries/XMCLib/src/xmc_vadc.c **** #endif
 775:../Libraries/XMCLib/src/xmc_vadc.c **** 
 776:../Libraries/XMCLib/src/xmc_vadc.c **** #if(XMC_VADC_SHS_AVAILABLE == 1U)
 777:../Libraries/XMCLib/src/xmc_vadc.c **** 
 778:../Libraries/XMCLib/src/xmc_vadc.c **** /* API to Initialize the Sample and hold features*/
 779:../Libraries/XMCLib/src/xmc_vadc.c **** void XMC_VADC_GLOBAL_SHS_Init(XMC_VADC_GLOBAL_SHS_t *const shs_ptr, const XMC_VADC_GLOBAL_SHS_CONFI
 780:../Libraries/XMCLib/src/xmc_vadc.c **** {
 539              	 .loc 1 780 0
 540              	 .cfi_startproc
 541 0000 80B5     	 push {r7,lr}
 542              	.LCFI25:
 543              	 .cfi_def_cfa_offset 8
 544              	 .cfi_offset 7,-8
 545              	 .cfi_offset 14,-4
 546 0002 82B0     	 sub sp,sp,#8
 547              	.LCFI26:
 548              	 .cfi_def_cfa_offset 16
 549 0004 00AF     	 add r7,sp,#0
 550              	.LCFI27:
 551              	 .cfi_def_cfa_register 7
 552 0006 7860     	 str r0,[r7,#4]
 553 0008 3960     	 str r1,[r7]
 781:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GLOBAL_SHS_Init:Wrong SHS Pointer", (shs_ptr == (XMC_VADC_GLOBAL_SHS_t*)(voi
 782:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GLOBAL_SHS_Init:Wrong Index number",(config == (XMC_VADC_GLOBAL_SHS_CONFIG_t
 783:../Libraries/XMCLib/src/xmc_vadc.c **** 
 784:../Libraries/XMCLib/src/xmc_vadc.c ****   /* Initialize the SHS Configuration register*/
 785:../Libraries/XMCLib/src/xmc_vadc.c ****   shs_ptr->SHSCFG = (uint32_t)((uint32_t)config->shscfg | (uint32_t)SHS_SHSCFG_SCWC_Msk);
 554              	 .loc 1 785 0
 555 000a 3B68     	 ldr r3,[r7]
 556 000c 1B68     	 ldr r3,[r3]
 557 000e 8022     	 mov r2,#128
 558 0010 1202     	 lsl r2,r2,#8
 559 0012 1A43     	 orr r2,r3
 560 0014 7B68     	 ldr r3,[r7,#4]
 561 0016 1A64     	 str r2,[r3,#64]
 786:../Libraries/XMCLib/src/xmc_vadc.c **** 
 787:../Libraries/XMCLib/src/xmc_vadc.c **** #if(XMC_VADC_SHS_FULL_SET_REG == 1U)
 788:../Libraries/XMCLib/src/xmc_vadc.c ****   /* Select the Calibration order*/
 789:../Libraries/XMCLib/src/xmc_vadc.c ****   shs_ptr->CALCTR &= ~((uint32_t)SHS_CALCTR_CALORD_Msk);
 790:../Libraries/XMCLib/src/xmc_vadc.c ****   shs_ptr->CALCTR |=  (uint32_t) ((uint32_t)config->calibration_order << SHS_CALCTR_CALORD_Pos);
 791:../Libraries/XMCLib/src/xmc_vadc.c **** #endif
 792:../Libraries/XMCLib/src/xmc_vadc.c **** }
 562              	 .loc 1 792 0
 563 0018 BD46     	 mov sp,r7
 564 001a 02B0     	 add sp,sp,#8
 565              	 
 566 001c 80BD     	 pop {r7,pc}
 567              	 .cfi_endproc
 568              	.LFE99:
 570 001e C046     	 .section .text.XMC_VADC_GLOBAL_SHS_SetGainFactor,"ax",%progbits
 571              	 .align 2
 572              	 .global XMC_VADC_GLOBAL_SHS_SetGainFactor
 573              	 .code 16
 574              	 .thumb_func
 576              	XMC_VADC_GLOBAL_SHS_SetGainFactor:
 577              	.LFB100:
 793:../Libraries/XMCLib/src/xmc_vadc.c **** 
 794:../Libraries/XMCLib/src/xmc_vadc.c **** #if(XMC_VADC_SHS_FULL_SET_REG == 1U)
 795:../Libraries/XMCLib/src/xmc_vadc.c **** /* API to enable the accelerated mode of conversion */
 796:../Libraries/XMCLib/src/xmc_vadc.c **** void XMC_VADC_GLOBAL_SHS_EnableAcceleratedMode(XMC_VADC_GLOBAL_SHS_t *const shs_ptr, XMC_VADC_GROUP
 797:../Libraries/XMCLib/src/xmc_vadc.c **** {
 798:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GLOBAL_SHS_EnableAcceleratedMode:Wrong SHS Pointer",
 799:../Libraries/XMCLib/src/xmc_vadc.c ****              (shs_ptr == (XMC_VADC_GLOBAL_SHS_t*)(void*)SHS0))
 800:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GLOBAL_SHS_EnableAcceleratedMode:Wrong Index number",(group_num <= XMC_VADC_
 801:../Libraries/XMCLib/src/xmc_vadc.c **** 
 802:../Libraries/XMCLib/src/xmc_vadc.c ****   /* Set the converted to Accelerated mode from compatible mode*/
 803:../Libraries/XMCLib/src/xmc_vadc.c ****   if (group_num == XMC_VADC_GROUP_INDEX_0 )
 804:../Libraries/XMCLib/src/xmc_vadc.c ****   {
 805:../Libraries/XMCLib/src/xmc_vadc.c ****     shs_ptr->TIMCFG0 |= (uint32_t)SHS_TIMCFG0_AT_Msk;
 806:../Libraries/XMCLib/src/xmc_vadc.c ****   }
 807:../Libraries/XMCLib/src/xmc_vadc.c ****   else if (group_num == XMC_VADC_GROUP_INDEX_1 )
 808:../Libraries/XMCLib/src/xmc_vadc.c ****   {
 809:../Libraries/XMCLib/src/xmc_vadc.c ****     shs_ptr->TIMCFG1 |= (uint32_t)SHS_TIMCFG1_AT_Msk;
 810:../Libraries/XMCLib/src/xmc_vadc.c ****   }
 811:../Libraries/XMCLib/src/xmc_vadc.c ****   else
 812:../Libraries/XMCLib/src/xmc_vadc.c ****   {
 813:../Libraries/XMCLib/src/xmc_vadc.c ****     /* for MISRA*/
 814:../Libraries/XMCLib/src/xmc_vadc.c ****   }
 815:../Libraries/XMCLib/src/xmc_vadc.c **** }
 816:../Libraries/XMCLib/src/xmc_vadc.c **** 
 817:../Libraries/XMCLib/src/xmc_vadc.c **** /* API to disable the accelerated mode of conversion */
 818:../Libraries/XMCLib/src/xmc_vadc.c **** void XMC_VADC_GLOBAL_SHS_DisableAcceleratedMode(XMC_VADC_GLOBAL_SHS_t *const shs_ptr, XMC_VADC_GROU
 819:../Libraries/XMCLib/src/xmc_vadc.c **** {
 820:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GLOBAL_SHS_DisableAcceleratedMode:Wrong SHS Pointer",
 821:../Libraries/XMCLib/src/xmc_vadc.c ****              (shs_ptr == (XMC_VADC_GLOBAL_SHS_t*)(void*)SHS0))
 822:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GLOBAL_SHS_DisableAcceleratedMode:Wrong Index number",(group_num <= XMC_VADC
 823:../Libraries/XMCLib/src/xmc_vadc.c **** 
 824:../Libraries/XMCLib/src/xmc_vadc.c ****   /* Set the converted to Accelerated mode from compatible mode*/
 825:../Libraries/XMCLib/src/xmc_vadc.c ****   if (group_num == XMC_VADC_GROUP_INDEX_0 )
 826:../Libraries/XMCLib/src/xmc_vadc.c ****   {
 827:../Libraries/XMCLib/src/xmc_vadc.c ****     shs_ptr->TIMCFG0 &= ~(uint32_t)SHS_TIMCFG0_AT_Msk;
 828:../Libraries/XMCLib/src/xmc_vadc.c ****   }
 829:../Libraries/XMCLib/src/xmc_vadc.c ****   else if (group_num == XMC_VADC_GROUP_INDEX_1 )
 830:../Libraries/XMCLib/src/xmc_vadc.c ****   {
 831:../Libraries/XMCLib/src/xmc_vadc.c ****     shs_ptr->TIMCFG1 &= ~(uint32_t)SHS_TIMCFG1_AT_Msk;
 832:../Libraries/XMCLib/src/xmc_vadc.c ****   }
 833:../Libraries/XMCLib/src/xmc_vadc.c ****   else
 834:../Libraries/XMCLib/src/xmc_vadc.c ****   {
 835:../Libraries/XMCLib/src/xmc_vadc.c ****     /* for MISRA*/
 836:../Libraries/XMCLib/src/xmc_vadc.c ****   }
 837:../Libraries/XMCLib/src/xmc_vadc.c **** }
 838:../Libraries/XMCLib/src/xmc_vadc.c **** 
 839:../Libraries/XMCLib/src/xmc_vadc.c **** /* API to set the Short sample time of the Sample and hold module*/
 840:../Libraries/XMCLib/src/xmc_vadc.c **** void XMC_VADC_GLOBAL_SHS_SetShortSampleTime(XMC_VADC_GLOBAL_SHS_t *const shs_ptr,
 841:../Libraries/XMCLib/src/xmc_vadc.c ****                                             XMC_VADC_GROUP_INDEX_t group_num,
 842:../Libraries/XMCLib/src/xmc_vadc.c ****                                             uint8_t sst_value)
 843:../Libraries/XMCLib/src/xmc_vadc.c **** {
 844:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GLOBAL_SHS_SetShortSampleTime:Wrong SHS Pointer",
 845:../Libraries/XMCLib/src/xmc_vadc.c ****              (shs_ptr == (XMC_VADC_GLOBAL_SHS_t*)(void*)SHS0))
 846:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GLOBAL_SHS_SetShortSampleTime:Wrong Index number",(group_num <= XMC_VADC_GRO
 847:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GLOBAL_SHS_SetShortSampleTime:Wrong SST value",(sst_value < 64U))
 848:../Libraries/XMCLib/src/xmc_vadc.c **** 
 849:../Libraries/XMCLib/src/xmc_vadc.c ****   /* Set the short sample time for the Accelerated mode of operation*/
 850:../Libraries/XMCLib/src/xmc_vadc.c ****   if (group_num == XMC_VADC_GROUP_INDEX_0 )
 851:../Libraries/XMCLib/src/xmc_vadc.c ****   {
 852:../Libraries/XMCLib/src/xmc_vadc.c ****     shs_ptr->TIMCFG0 &= ~((uint32_t)SHS_TIMCFG0_SST_Msk);
 853:../Libraries/XMCLib/src/xmc_vadc.c ****     shs_ptr->TIMCFG0 |= (uint32_t)((uint32_t)sst_value << SHS_TIMCFG0_SST_Pos );
 854:../Libraries/XMCLib/src/xmc_vadc.c ****   }
 855:../Libraries/XMCLib/src/xmc_vadc.c ****   else if (group_num == XMC_VADC_GROUP_INDEX_1 )
 856:../Libraries/XMCLib/src/xmc_vadc.c ****   {
 857:../Libraries/XMCLib/src/xmc_vadc.c ****     shs_ptr->TIMCFG1 &= ~((uint32_t)SHS_TIMCFG1_SST_Msk);
 858:../Libraries/XMCLib/src/xmc_vadc.c ****     shs_ptr->TIMCFG1 |= (uint32_t)((uint32_t)sst_value << SHS_TIMCFG1_SST_Pos );
 859:../Libraries/XMCLib/src/xmc_vadc.c ****   }
 860:../Libraries/XMCLib/src/xmc_vadc.c ****   else
 861:../Libraries/XMCLib/src/xmc_vadc.c ****   {
 862:../Libraries/XMCLib/src/xmc_vadc.c ****   /* for MISRA*/
 863:../Libraries/XMCLib/src/xmc_vadc.c ****   }
 864:../Libraries/XMCLib/src/xmc_vadc.c **** }
 865:../Libraries/XMCLib/src/xmc_vadc.c **** #endif
 866:../Libraries/XMCLib/src/xmc_vadc.c **** 
 867:../Libraries/XMCLib/src/xmc_vadc.c **** /* API to set the gain factor of the Sample and hold module*/
 868:../Libraries/XMCLib/src/xmc_vadc.c **** void XMC_VADC_GLOBAL_SHS_SetGainFactor(XMC_VADC_GLOBAL_SHS_t *const shs_ptr,
 869:../Libraries/XMCLib/src/xmc_vadc.c ****                                        uint8_t gain_value,
 870:../Libraries/XMCLib/src/xmc_vadc.c ****                                        XMC_VADC_GROUP_INDEX_t group_num,
 871:../Libraries/XMCLib/src/xmc_vadc.c ****                                        uint8_t ch_num)
 872:../Libraries/XMCLib/src/xmc_vadc.c **** {
 578              	 .loc 1 872 0
 579              	 .cfi_startproc
 580 0000 90B5     	 push {r4,r7,lr}
 581              	.LCFI28:
 582              	 .cfi_def_cfa_offset 12
 583              	 .cfi_offset 4,-12
 584              	 .cfi_offset 7,-8
 585              	 .cfi_offset 14,-4
 586 0002 85B0     	 sub sp,sp,#20
 587              	.LCFI29:
 588              	 .cfi_def_cfa_offset 32
 589 0004 00AF     	 add r7,sp,#0
 590              	.LCFI30:
 591              	 .cfi_def_cfa_register 7
 592 0006 7860     	 str r0,[r7,#4]
 593 0008 0C1C     	 mov r4,r1
 594 000a 101C     	 mov r0,r2
 595 000c 191C     	 mov r1,r3
 596 000e FB1C     	 add r3,r7,#3
 597 0010 221C     	 add r2,r4,#0
 598 0012 1A70     	 strb r2,[r3]
 599 0014 BB1C     	 add r3,r7,#2
 600 0016 021C     	 add r2,r0,#0
 601 0018 1A70     	 strb r2,[r3]
 602 001a 7B1C     	 add r3,r7,#1
 603 001c 0A1C     	 add r2,r1,#0
 604 001e 1A70     	 strb r2,[r3]
 873:../Libraries/XMCLib/src/xmc_vadc.c ****   uint32_t ch_mask;
 874:../Libraries/XMCLib/src/xmc_vadc.c **** 
 875:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GLOBAL_SHS_SetGainFactor:Wrong SHS Pointer", (shs_ptr == (XMC_VADC_GLOBAL_SH
 876:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GLOBAL_SHS_SetGainFactor:Wrong Index number",(group_num <= XMC_VADC_GROUP_IN
 877:../Libraries/XMCLib/src/xmc_vadc.c **** 
 878:../Libraries/XMCLib/src/xmc_vadc.c ****   /*Calculate location of channel bit-field*/
 879:../Libraries/XMCLib/src/xmc_vadc.c ****   ch_mask = ((uint32_t)ch_num << (uint32_t)2);
 605              	 .loc 1 879 0
 606 0020 7B1C     	 add r3,r7,#1
 607 0022 1B78     	 ldrb r3,[r3]
 608 0024 9B00     	 lsl r3,r3,#2
 609 0026 FB60     	 str r3,[r7,#12]
 880:../Libraries/XMCLib/src/xmc_vadc.c ****   if (group_num == XMC_VADC_GROUP_INDEX_0 )
 610              	 .loc 1 880 0
 611 0028 BB1C     	 add r3,r7,#2
 612 002a 1B78     	 ldrb r3,[r3]
 613 002c 002B     	 cmp r3,#0
 614 002e 1ED1     	 bne .L28
 881:../Libraries/XMCLib/src/xmc_vadc.c ****   {
 882:../Libraries/XMCLib/src/xmc_vadc.c ****     shs_ptr->GNCTR00 &= ~((uint32_t)SHS_GNCTR00_GAIN0_Msk << ch_mask) ;
 615              	 .loc 1 882 0
 616 0030 7A68     	 ldr r2,[r7,#4]
 617 0032 C023     	 mov r3,#192
 618 0034 5B00     	 lsl r3,r3,#1
 619 0036 D358     	 ldr r3,[r2,r3]
 620 0038 FA68     	 ldr r2,[r7,#12]
 621 003a 0F21     	 mov r1,#15
 622 003c 9140     	 lsl r1,r1,r2
 623 003e 0A1C     	 mov r2,r1
 624 0040 D243     	 mvn r2,r2
 625 0042 1A40     	 and r2,r3
 626 0044 111C     	 mov r1,r2
 627 0046 7A68     	 ldr r2,[r7,#4]
 628 0048 C023     	 mov r3,#192
 629 004a 5B00     	 lsl r3,r3,#1
 630 004c D150     	 str r1,[r2,r3]
 883:../Libraries/XMCLib/src/xmc_vadc.c ****     shs_ptr->GNCTR00 |=  ((uint32_t)gain_value << ch_mask);
 631              	 .loc 1 883 0
 632 004e 7A68     	 ldr r2,[r7,#4]
 633 0050 C023     	 mov r3,#192
 634 0052 5B00     	 lsl r3,r3,#1
 635 0054 D258     	 ldr r2,[r2,r3]
 636 0056 FB1C     	 add r3,r7,#3
 637 0058 1978     	 ldrb r1,[r3]
 638 005a FB68     	 ldr r3,[r7,#12]
 639 005c 9940     	 lsl r1,r1,r3
 640 005e 0B1C     	 mov r3,r1
 641 0060 1A43     	 orr r2,r3
 642 0062 111C     	 mov r1,r2
 643 0064 7A68     	 ldr r2,[r7,#4]
 644 0066 C023     	 mov r3,#192
 645 0068 5B00     	 lsl r3,r3,#1
 646 006a D150     	 str r1,[r2,r3]
 647 006c 21E0     	 b .L27
 648              	.L28:
 884:../Libraries/XMCLib/src/xmc_vadc.c ****   }
 885:../Libraries/XMCLib/src/xmc_vadc.c ****   else if (group_num == XMC_VADC_GROUP_INDEX_1 )
 649              	 .loc 1 885 0
 650 006e BB1C     	 add r3,r7,#2
 651 0070 1B78     	 ldrb r3,[r3]
 652 0072 012B     	 cmp r3,#1
 653 0074 1DD1     	 bne .L27
 886:../Libraries/XMCLib/src/xmc_vadc.c ****   {
 887:../Libraries/XMCLib/src/xmc_vadc.c ****     shs_ptr->GNCTR10 &= ~((uint32_t)SHS_GNCTR10_GAIN0_Msk << ch_mask);
 654              	 .loc 1 887 0
 655 0076 7A68     	 ldr r2,[r7,#4]
 656 0078 C823     	 mov r3,#200
 657 007a 5B00     	 lsl r3,r3,#1
 658 007c D358     	 ldr r3,[r2,r3]
 659 007e FA68     	 ldr r2,[r7,#12]
 660 0080 0F21     	 mov r1,#15
 661 0082 9140     	 lsl r1,r1,r2
 662 0084 0A1C     	 mov r2,r1
 663 0086 D243     	 mvn r2,r2
 664 0088 1A40     	 and r2,r3
 665 008a 111C     	 mov r1,r2
 666 008c 7A68     	 ldr r2,[r7,#4]
 667 008e C823     	 mov r3,#200
 668 0090 5B00     	 lsl r3,r3,#1
 669 0092 D150     	 str r1,[r2,r3]
 888:../Libraries/XMCLib/src/xmc_vadc.c ****     shs_ptr->GNCTR10 |=  ((uint32_t)gain_value << ch_mask);
 670              	 .loc 1 888 0
 671 0094 7A68     	 ldr r2,[r7,#4]
 672 0096 C823     	 mov r3,#200
 673 0098 5B00     	 lsl r3,r3,#1
 674 009a D258     	 ldr r2,[r2,r3]
 675 009c FB1C     	 add r3,r7,#3
 676 009e 1978     	 ldrb r1,[r3]
 677 00a0 FB68     	 ldr r3,[r7,#12]
 678 00a2 9940     	 lsl r1,r1,r3
 679 00a4 0B1C     	 mov r3,r1
 680 00a6 1A43     	 orr r2,r3
 681 00a8 111C     	 mov r1,r2
 682 00aa 7A68     	 ldr r2,[r7,#4]
 683 00ac C823     	 mov r3,#200
 684 00ae 5B00     	 lsl r3,r3,#1
 685 00b0 D150     	 str r1,[r2,r3]
 686              	.L27:
 889:../Libraries/XMCLib/src/xmc_vadc.c ****   }
 890:../Libraries/XMCLib/src/xmc_vadc.c ****   else
 891:../Libraries/XMCLib/src/xmc_vadc.c ****   {
 892:../Libraries/XMCLib/src/xmc_vadc.c ****     /* for MISRA*/
 893:../Libraries/XMCLib/src/xmc_vadc.c ****   }
 894:../Libraries/XMCLib/src/xmc_vadc.c **** }
 687              	 .loc 1 894 0
 688 00b2 BD46     	 mov sp,r7
 689 00b4 05B0     	 add sp,sp,#20
 690              	 
 691 00b6 90BD     	 pop {r4,r7,pc}
 692              	 .cfi_endproc
 693              	.LFE100:
 695              	 .section .text.XMC_VADC_GLOBAL_SHS_SetSigmaDeltaLoop,"ax",%progbits
 696              	 .align 2
 697              	 .global XMC_VADC_GLOBAL_SHS_SetSigmaDeltaLoop
 698              	 .code 16
 699              	 .thumb_func
 701              	XMC_VADC_GLOBAL_SHS_SetSigmaDeltaLoop:
 702              	.LFB101:
 895:../Libraries/XMCLib/src/xmc_vadc.c **** 
 896:../Libraries/XMCLib/src/xmc_vadc.c **** #if(XMC_VADC_SHS_FULL_SET_REG == 1U)
 897:../Libraries/XMCLib/src/xmc_vadc.c **** /* API to enable the gain and offset calibration of the Sample and hold module*/
 898:../Libraries/XMCLib/src/xmc_vadc.c **** void XMC_VADC_GLOBAL_SHS_EnableGainAndOffsetCalibrations(XMC_VADC_GLOBAL_SHS_t *const shs_ptr,
 899:../Libraries/XMCLib/src/xmc_vadc.c ****                                                          XMC_VADC_GROUP_INDEX_t group_num)
 900:../Libraries/XMCLib/src/xmc_vadc.c **** {
 901:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GLOBAL_SHS_EnableGainAndOffsetCalibrations:Wrong SHS Pointer",
 902:../Libraries/XMCLib/src/xmc_vadc.c ****              (shs_ptr == (XMC_VADC_GLOBAL_SHS_t*)(void*)SHS0))
 903:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GLOBAL_SHS_EnableGainAndOffsetCalibrations:Wrong group selected",
 904:../Libraries/XMCLib/src/xmc_vadc.c ****              (group_num <= (uint32_t)XMC_VADC_GROUP_INDEX_1))
 905:../Libraries/XMCLib/src/xmc_vadc.c **** 
 906:../Libraries/XMCLib/src/xmc_vadc.c ****   /* Enable gain and offset calibration*/
 907:../Libraries/XMCLib/src/xmc_vadc.c ****   if ( XMC_VADC_GROUP_INDEX_0 == group_num)
 908:../Libraries/XMCLib/src/xmc_vadc.c ****   {
 909:../Libraries/XMCLib/src/xmc_vadc.c ****     shs_ptr->CALOC0 &= ~((uint32_t)SHS_CALOC0_DISCAL_Msk);
 910:../Libraries/XMCLib/src/xmc_vadc.c ****   }
 911:../Libraries/XMCLib/src/xmc_vadc.c ****   else if ( XMC_VADC_GROUP_INDEX_1 == group_num)
 912:../Libraries/XMCLib/src/xmc_vadc.c ****   {
 913:../Libraries/XMCLib/src/xmc_vadc.c ****     shs_ptr->CALOC1 &= ~((uint32_t)SHS_CALOC1_DISCAL_Msk);
 914:../Libraries/XMCLib/src/xmc_vadc.c ****   }
 915:../Libraries/XMCLib/src/xmc_vadc.c ****   else
 916:../Libraries/XMCLib/src/xmc_vadc.c ****   {
 917:../Libraries/XMCLib/src/xmc_vadc.c ****     /* for MISRA */
 918:../Libraries/XMCLib/src/xmc_vadc.c ****   }
 919:../Libraries/XMCLib/src/xmc_vadc.c **** }
 920:../Libraries/XMCLib/src/xmc_vadc.c **** 
 921:../Libraries/XMCLib/src/xmc_vadc.c **** /* API to enable the gain and offset calibration of the Sample and hold module*/
 922:../Libraries/XMCLib/src/xmc_vadc.c **** void XMC_VADC_GLOBAL_SHS_DisableGainAndOffsetCalibrations(XMC_VADC_GLOBAL_SHS_t *const shs_ptr,
 923:../Libraries/XMCLib/src/xmc_vadc.c ****                                                           XMC_VADC_GROUP_INDEX_t group_num)
 924:../Libraries/XMCLib/src/xmc_vadc.c **** {
 925:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GLOBAL_SHS_DisableGainAndOffsetCalibrations:Wrong SHS Pointer",
 926:../Libraries/XMCLib/src/xmc_vadc.c ****                (shs_ptr == (XMC_VADC_GLOBAL_SHS_t*)(void*)SHS0))
 927:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GLOBAL_SHS_DisableGainAndOffsetCalibrations:Wrong group selected",
 928:../Libraries/XMCLib/src/xmc_vadc.c ****             (group_num <= (uint32_t)XMC_VADC_GROUP_INDEX_1))
 929:../Libraries/XMCLib/src/xmc_vadc.c **** 
 930:../Libraries/XMCLib/src/xmc_vadc.c ****   if ( XMC_VADC_GROUP_INDEX_0 == group_num)
 931:../Libraries/XMCLib/src/xmc_vadc.c ****   {
 932:../Libraries/XMCLib/src/xmc_vadc.c ****     shs_ptr->CALOC0 |= (uint32_t)SHS_CALOC0_DISCAL_Msk;
 933:../Libraries/XMCLib/src/xmc_vadc.c ****   }
 934:../Libraries/XMCLib/src/xmc_vadc.c ****   else if ( XMC_VADC_GROUP_INDEX_1 == group_num)
 935:../Libraries/XMCLib/src/xmc_vadc.c ****   {
 936:../Libraries/XMCLib/src/xmc_vadc.c ****     shs_ptr->CALOC1 |= (uint32_t)SHS_CALOC1_DISCAL_Msk;
 937:../Libraries/XMCLib/src/xmc_vadc.c ****   }
 938:../Libraries/XMCLib/src/xmc_vadc.c ****   else
 939:../Libraries/XMCLib/src/xmc_vadc.c ****   {
 940:../Libraries/XMCLib/src/xmc_vadc.c ****     /* for MISRA */
 941:../Libraries/XMCLib/src/xmc_vadc.c ****   }
 942:../Libraries/XMCLib/src/xmc_vadc.c **** }
 943:../Libraries/XMCLib/src/xmc_vadc.c **** 
 944:../Libraries/XMCLib/src/xmc_vadc.c **** /* API to get the offset calibration value of the Sample and hold module*/
 945:../Libraries/XMCLib/src/xmc_vadc.c **** uint8_t XMC_VADC_GLOBAL_SHS_GetOffsetCalibrationValue(XMC_VADC_GLOBAL_SHS_t *const shs_ptr,
 946:../Libraries/XMCLib/src/xmc_vadc.c ****                                                       XMC_VADC_GROUP_INDEX_t group_num,
 947:../Libraries/XMCLib/src/xmc_vadc.c ****                                                       XMC_VADC_SHS_GAIN_LEVEL_t gain_level)
 948:../Libraries/XMCLib/src/xmc_vadc.c **** {
 949:../Libraries/XMCLib/src/xmc_vadc.c ****   uint32_t calibration_value;
 950:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GLOBAL_SHS_GetOffsetCalibrationValue:Wrong SHS Pointer",
 951:../Libraries/XMCLib/src/xmc_vadc.c ****                (shs_ptr == (XMC_VADC_GLOBAL_SHS_t*)(void*)SHS0))
 952:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GLOBAL_SHS_GetOffsetCalibrationValue:Wrong Group number selected",
 953:../Libraries/XMCLib/src/xmc_vadc.c ****              (group_num == XMC_VADC_GROUP_INDEX_0)||(group_num == XMC_VADC_GROUP_INDEX_1))
 954:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GLOBAL_SHS_GetOffsetCalibrationValue:Wrong gain level selected",
 955:../Libraries/XMCLib/src/xmc_vadc.c ****              (gain_level == XMC_VADC_SHS_GAIN_LEVEL_0)||(gain_level == XMC_VADC_SHS_GAIN_LEVEL_1)||
 956:../Libraries/XMCLib/src/xmc_vadc.c ****              (gain_level == XMC_VADC_SHS_GAIN_LEVEL_2)||(gain_level == XMC_VADC_SHS_GAIN_LEVEL_3))
 957:../Libraries/XMCLib/src/xmc_vadc.c **** 
 958:../Libraries/XMCLib/src/xmc_vadc.c ****   calibration_value = 0U;
 959:../Libraries/XMCLib/src/xmc_vadc.c ****   if ( XMC_VADC_GROUP_INDEX_0 == group_num)
 960:../Libraries/XMCLib/src/xmc_vadc.c ****   {
 961:../Libraries/XMCLib/src/xmc_vadc.c ****     calibration_value = (shs_ptr->CALOC0 >> (uint32_t)gain_level) & (uint32_t)SHS_CALOC0_CALOFFVAL0
 962:../Libraries/XMCLib/src/xmc_vadc.c ****   }
 963:../Libraries/XMCLib/src/xmc_vadc.c ****   else if ( XMC_VADC_GROUP_INDEX_1 == group_num)
 964:../Libraries/XMCLib/src/xmc_vadc.c ****   {
 965:../Libraries/XMCLib/src/xmc_vadc.c ****     calibration_value = (shs_ptr->CALOC1 >> (uint32_t)gain_level) & (uint32_t)SHS_CALOC1_CALOFFVAL0
 966:../Libraries/XMCLib/src/xmc_vadc.c ****   }
 967:../Libraries/XMCLib/src/xmc_vadc.c ****   else
 968:../Libraries/XMCLib/src/xmc_vadc.c ****   {
 969:../Libraries/XMCLib/src/xmc_vadc.c ****     /* for MISRA */
 970:../Libraries/XMCLib/src/xmc_vadc.c ****   }
 971:../Libraries/XMCLib/src/xmc_vadc.c ****   return ((uint8_t)calibration_value);
 972:../Libraries/XMCLib/src/xmc_vadc.c **** }
 973:../Libraries/XMCLib/src/xmc_vadc.c **** 
 974:../Libraries/XMCLib/src/xmc_vadc.c **** /* API to set the offset calibration value of the Sample and hold module*/
 975:../Libraries/XMCLib/src/xmc_vadc.c **** void XMC_VADC_GLOBAL_SHS_SetOffsetCalibrationValue(XMC_VADC_GLOBAL_SHS_t *const shs_ptr,
 976:../Libraries/XMCLib/src/xmc_vadc.c ****                                                    XMC_VADC_GROUP_INDEX_t group_num,
 977:../Libraries/XMCLib/src/xmc_vadc.c ****                                                    XMC_VADC_SHS_GAIN_LEVEL_t gain_level,
 978:../Libraries/XMCLib/src/xmc_vadc.c ****                                                    uint8_t offset_calibration_value)
 979:../Libraries/XMCLib/src/xmc_vadc.c **** {
 980:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GLOBAL_SHS_SetOffsetCalibrationValue:Wrong SHS Pointer",
 981:../Libraries/XMCLib/src/xmc_vadc.c ****                (shs_ptr == (XMC_VADC_GLOBAL_SHS_t*)(void*)SHS0))
 982:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GLOBAL_SHS_SetOffsetCalibrationValue:Wrong Group number selected",
 983:../Libraries/XMCLib/src/xmc_vadc.c ****              (group_num == XMC_VADC_GROUP_INDEX_0)||(group_num == XMC_VADC_GROUP_INDEX_1))
 984:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GLOBAL_SHS_SetOffsetCalibrationValue:Wrong gain level selected",
 985:../Libraries/XMCLib/src/xmc_vadc.c ****              (gain_level == XMC_VADC_SHS_GAIN_LEVEL_0)||(gain_level == XMC_VADC_SHS_GAIN_LEVEL_1)||
 986:../Libraries/XMCLib/src/xmc_vadc.c ****              (gain_level == XMC_VADC_SHS_GAIN_LEVEL_2)||(gain_level == XMC_VADC_SHS_GAIN_LEVEL_3))
 987:../Libraries/XMCLib/src/xmc_vadc.c **** 
 988:../Libraries/XMCLib/src/xmc_vadc.c ****   if ( XMC_VADC_GROUP_INDEX_0 == group_num)
 989:../Libraries/XMCLib/src/xmc_vadc.c ****   {
 990:../Libraries/XMCLib/src/xmc_vadc.c ****     shs_ptr->CALOC0 = (shs_ptr->CALOC0  & ~((uint32_t)SHS_CALOC0_CALOFFVAL0_Msk << (uint32_t)gain_l
 991:../Libraries/XMCLib/src/xmc_vadc.c ****                       (uint32_t)SHS_CALOC0_OFFWC_Msk;
 992:../Libraries/XMCLib/src/xmc_vadc.c ****     shs_ptr->CALOC0 |=  ((uint32_t)offset_calibration_value << (uint32_t)gain_level) | (uint32_t)SH
 993:../Libraries/XMCLib/src/xmc_vadc.c ****   }
 994:../Libraries/XMCLib/src/xmc_vadc.c ****   else if ( XMC_VADC_GROUP_INDEX_1 == group_num)
 995:../Libraries/XMCLib/src/xmc_vadc.c ****   {
 996:../Libraries/XMCLib/src/xmc_vadc.c ****     shs_ptr->CALOC1 = (shs_ptr->CALOC1 & ~((uint32_t)SHS_CALOC1_CALOFFVAL0_Msk << (uint32_t)gain_le
 997:../Libraries/XMCLib/src/xmc_vadc.c ****                       (uint32_t)SHS_CALOC1_OFFWC_Msk;
 998:../Libraries/XMCLib/src/xmc_vadc.c ****     shs_ptr->CALOC1 |=  ((uint32_t)offset_calibration_value << (uint32_t)gain_level) | (uint32_t)SH
 999:../Libraries/XMCLib/src/xmc_vadc.c ****   }
1000:../Libraries/XMCLib/src/xmc_vadc.c ****   else
1001:../Libraries/XMCLib/src/xmc_vadc.c ****   {
1002:../Libraries/XMCLib/src/xmc_vadc.c ****     /* for MISRA */
1003:../Libraries/XMCLib/src/xmc_vadc.c ****   }
1004:../Libraries/XMCLib/src/xmc_vadc.c **** }
1005:../Libraries/XMCLib/src/xmc_vadc.c **** #endif
1006:../Libraries/XMCLib/src/xmc_vadc.c **** 
1007:../Libraries/XMCLib/src/xmc_vadc.c **** /* API to set the values of sigma delta loop of the Sample and hold module*/
1008:../Libraries/XMCLib/src/xmc_vadc.c **** void XMC_VADC_GLOBAL_SHS_SetSigmaDeltaLoop(XMC_VADC_GLOBAL_SHS_t *const shs_ptr,
1009:../Libraries/XMCLib/src/xmc_vadc.c ****                                            XMC_VADC_GROUP_INDEX_t group_num,
1010:../Libraries/XMCLib/src/xmc_vadc.c ****                                            XMC_VADC_SHS_LOOP_CH_t loop_select,
1011:../Libraries/XMCLib/src/xmc_vadc.c ****                                            uint8_t ch_num)
1012:../Libraries/XMCLib/src/xmc_vadc.c **** {
 703              	 .loc 1 1012 0
 704              	 .cfi_startproc
 705 0000 90B5     	 push {r4,r7,lr}
 706              	.LCFI31:
 707              	 .cfi_def_cfa_offset 12
 708              	 .cfi_offset 4,-12
 709              	 .cfi_offset 7,-8
 710              	 .cfi_offset 14,-4
 711 0002 83B0     	 sub sp,sp,#12
 712              	.LCFI32:
 713              	 .cfi_def_cfa_offset 24
 714 0004 00AF     	 add r7,sp,#0
 715              	.LCFI33:
 716              	 .cfi_def_cfa_register 7
 717 0006 7860     	 str r0,[r7,#4]
 718 0008 0C1C     	 mov r4,r1
 719 000a 101C     	 mov r0,r2
 720 000c 191C     	 mov r1,r3
 721 000e FB1C     	 add r3,r7,#3
 722 0010 221C     	 add r2,r4,#0
 723 0012 1A70     	 strb r2,[r3]
 724 0014 BB1C     	 add r3,r7,#2
 725 0016 021C     	 add r2,r0,#0
 726 0018 1A70     	 strb r2,[r3]
 727 001a 7B1C     	 add r3,r7,#1
 728 001c 0A1C     	 add r2,r1,#0
 729 001e 1A70     	 strb r2,[r3]
1013:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GLOBAL_SHS_SetSigmaDeltaLoop:Wrong SHS Pointer",
1014:../Libraries/XMCLib/src/xmc_vadc.c ****                (shs_ptr == (XMC_VADC_GLOBAL_SHS_t*)(void*)SHS0))
1015:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GLOBAL_SHS_SetSigmaDeltaLoop:Wrong Group number selected",
1016:../Libraries/XMCLib/src/xmc_vadc.c ****                (group_num == XMC_VADC_GROUP_INDEX_0)||(group_num == XMC_VADC_GROUP_INDEX_1))
1017:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GLOBAL_SHS_SetSigmaDeltaLoop:Wrong Delta sigma loop selected",
1018:../Libraries/XMCLib/src/xmc_vadc.c ****              (loop_select == XMC_VADC_SHS_LOOP_CH_0)||(loop_select == XMC_VADC_SHS_LOOP_CH_1))
1019:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GLOBAL_SHS_SetSigmaDeltaLoop:Wrong Channel Number",
1020:../Libraries/XMCLib/src/xmc_vadc.c ****              ((ch_num) < XMC_VADC_NUM_CHANNELS_PER_GROUP))
1021:../Libraries/XMCLib/src/xmc_vadc.c **** 
1022:../Libraries/XMCLib/src/xmc_vadc.c ****   shs_ptr->LOOP &= ~(((uint32_t)SHS_LOOP_LPCH0_Msk | (uint32_t)SHS_LOOP_LPSH0_Msk | (uint32_t)SHS_L
 730              	 .loc 1 1022 0
 731 0020 7B68     	 ldr r3,[r7,#4]
 732 0022 1B6D     	 ldr r3,[r3,#80]
1023:../Libraries/XMCLib/src/xmc_vadc.c ****                      << (uint32_t)loop_select);
 733              	 .loc 1 1023 0
 734 0024 BA1C     	 add r2,r7,#2
 735 0026 1278     	 ldrb r2,[r2]
 736 0028 0C49     	 ldr r1,.L31
 737 002a 9140     	 lsl r1,r1,r2
 738 002c 0A1C     	 mov r2,r1
1022:../Libraries/XMCLib/src/xmc_vadc.c ****                      << (uint32_t)loop_select);
 739              	 .loc 1 1022 0
 740 002e D243     	 mvn r2,r2
 741 0030 1A40     	 and r2,r3
 742 0032 7B68     	 ldr r3,[r7,#4]
 743 0034 1A65     	 str r2,[r3,#80]
1024:../Libraries/XMCLib/src/xmc_vadc.c ****   shs_ptr->LOOP |= ((uint32_t)ch_num | ((uint32_t)group_num << (uint32_t)SHS_LOOP_LPSH0_Pos)) << (u
 744              	 .loc 1 1024 0
 745 0036 7B68     	 ldr r3,[r7,#4]
 746 0038 1A6D     	 ldr r2,[r3,#80]
 747 003a 7B1C     	 add r3,r7,#1
 748 003c 1978     	 ldrb r1,[r3]
 749 003e FB1C     	 add r3,r7,#3
 750 0040 1B78     	 ldrb r3,[r3]
 751 0042 1B02     	 lsl r3,r3,#8
 752 0044 1943     	 orr r1,r3
 753 0046 BB1C     	 add r3,r7,#2
 754 0048 1B78     	 ldrb r3,[r3]
 755 004a 9940     	 lsl r1,r1,r3
 756 004c 0B1C     	 mov r3,r1
 757 004e 1A43     	 orr r2,r3
 758 0050 7B68     	 ldr r3,[r7,#4]
 759 0052 1A65     	 str r2,[r3,#80]
1025:../Libraries/XMCLib/src/xmc_vadc.c **** 
1026:../Libraries/XMCLib/src/xmc_vadc.c **** }
 760              	 .loc 1 1026 0
 761 0054 BD46     	 mov sp,r7
 762 0056 03B0     	 add sp,sp,#12
 763              	 
 764 0058 90BD     	 pop {r4,r7,pc}
 765              	.L32:
 766 005a C046     	 .align 2
 767              	.L31:
 768 005c 1F810000 	 .word 33055
 769              	 .cfi_endproc
 770              	.LFE101:
 772              	 .section .text.XMC_VADC_GLOBAL_BackgroundInit,"ax",%progbits
 773              	 .align 2
 774              	 .global XMC_VADC_GLOBAL_BackgroundInit
 775              	 .code 16
 776              	 .thumb_func
 778              	XMC_VADC_GLOBAL_BackgroundInit:
 779              	.LFB102:
1027:../Libraries/XMCLib/src/xmc_vadc.c **** 
1028:../Libraries/XMCLib/src/xmc_vadc.c **** #endif
1029:../Libraries/XMCLib/src/xmc_vadc.c **** 
1030:../Libraries/XMCLib/src/xmc_vadc.c **** #if (XMC_VADC_GSCAN_AVAILABLE == 1U)   
1031:../Libraries/XMCLib/src/xmc_vadc.c **** /* API to initialize the group scan hardware of a kernel */
1032:../Libraries/XMCLib/src/xmc_vadc.c **** void XMC_VADC_GROUP_ScanInit(XMC_VADC_GROUP_t *const group_ptr, const XMC_VADC_SCAN_CONFIG_t *confi
1033:../Libraries/XMCLib/src/xmc_vadc.c **** {
1034:../Libraries/XMCLib/src/xmc_vadc.c ****   uint32_t      reg;
1035:../Libraries/XMCLib/src/xmc_vadc.c **** 
1036:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GROUP_ScanInit:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
1037:../Libraries/XMCLib/src/xmc_vadc.c **** 
1038:../Libraries/XMCLib/src/xmc_vadc.c ****   /* All configurations have to be performed with the arbitration slot disabled */
1039:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_VADC_GROUP_ScanDisableArbitrationSlot(group_ptr);
1040:../Libraries/XMCLib/src/xmc_vadc.c ****   
1041:../Libraries/XMCLib/src/xmc_vadc.c ****   /* Read in the existing contents of arbitration priority register */
1042:../Libraries/XMCLib/src/xmc_vadc.c ****   reg = group_ptr->ARBPR;
1043:../Libraries/XMCLib/src/xmc_vadc.c **** 
1044:../Libraries/XMCLib/src/xmc_vadc.c ****   /* Program the priority of the request source */
1045:../Libraries/XMCLib/src/xmc_vadc.c ****   reg &= ~(uint32_t)VADC_G_ARBPR_PRIO1_Msk;
1046:../Libraries/XMCLib/src/xmc_vadc.c ****   reg |= (uint32_t)((uint32_t)config->req_src_priority << VADC_G_ARBPR_PRIO1_Pos);
1047:../Libraries/XMCLib/src/xmc_vadc.c ****   
1048:../Libraries/XMCLib/src/xmc_vadc.c ****   /* Program the start mode */
1049:../Libraries/XMCLib/src/xmc_vadc.c ****   if (XMC_VADC_STARTMODE_WFS != (XMC_VADC_STARTMODE_t)(config->conv_start_mode))
1050:../Libraries/XMCLib/src/xmc_vadc.c ****   {
1051:../Libraries/XMCLib/src/xmc_vadc.c ****     reg |= (uint32_t)(VADC_G_ARBPR_CSM1_Msk);
1052:../Libraries/XMCLib/src/xmc_vadc.c ****   }
1053:../Libraries/XMCLib/src/xmc_vadc.c **** 
1054:../Libraries/XMCLib/src/xmc_vadc.c ****   group_ptr->ARBPR = reg;
1055:../Libraries/XMCLib/src/xmc_vadc.c **** 
1056:../Libraries/XMCLib/src/xmc_vadc.c ****   group_ptr->ASCTRL = (uint32_t)(config->asctrl |(VADC_G_ASCTRL_XTWC_Msk) |(VADC_G_ASCTRL_GTWC_Msk)
1057:../Libraries/XMCLib/src/xmc_vadc.c ****                                                  (VADC_G_ASCTRL_TMWC_Msk));
1058:../Libraries/XMCLib/src/xmc_vadc.c **** 
1059:../Libraries/XMCLib/src/xmc_vadc.c ****   group_ptr->ASMR  = (uint32_t)((config->asmr)| (uint32_t)((uint32_t)XMC_VADC_GATEMODE_IGNORE << VA
1060:../Libraries/XMCLib/src/xmc_vadc.c ****   
1061:../Libraries/XMCLib/src/xmc_vadc.c ****   if (XMC_VADC_STARTMODE_CNR == (XMC_VADC_STARTMODE_t)(config->conv_start_mode))
1062:../Libraries/XMCLib/src/xmc_vadc.c ****   {
1063:../Libraries/XMCLib/src/xmc_vadc.c ****     group_ptr->ASMR |= (uint32_t)VADC_G_ASMR_RPTDIS_Msk;
1064:../Libraries/XMCLib/src/xmc_vadc.c ****   }
1065:../Libraries/XMCLib/src/xmc_vadc.c ****   
1066:../Libraries/XMCLib/src/xmc_vadc.c ****   /* Enable arbitration slot now */
1067:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_VADC_GROUP_ScanEnableArbitrationSlot(group_ptr);
1068:../Libraries/XMCLib/src/xmc_vadc.c ****   
1069:../Libraries/XMCLib/src/xmc_vadc.c **** }
1070:../Libraries/XMCLib/src/xmc_vadc.c **** 
1071:../Libraries/XMCLib/src/xmc_vadc.c **** /* API to select one of the 16 inputs as a trigger input for Group Scan request source */
1072:../Libraries/XMCLib/src/xmc_vadc.c **** void XMC_VADC_GROUP_ScanSelectTrigger(XMC_VADC_GROUP_t *const group_ptr, XMC_VADC_TRIGGER_INPUT_SEL
1073:../Libraries/XMCLib/src/xmc_vadc.c **** {
1074:../Libraries/XMCLib/src/xmc_vadc.c ****   uint32_t scanctrl;
1075:../Libraries/XMCLib/src/xmc_vadc.c **** 
1076:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GROUP_ScanSelectTrigger:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group
1077:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GROUP_ScanSelectTrigger:Wrong Trigger Port", ((trigger_input)< XMC_VADC_NUM_
1078:../Libraries/XMCLib/src/xmc_vadc.c **** 
1079:../Libraries/XMCLib/src/xmc_vadc.c ****   scanctrl      = group_ptr->ASCTRL;
1080:../Libraries/XMCLib/src/xmc_vadc.c ****   scanctrl     |= (uint32_t) VADC_G_ASCTRL_XTWC_Msk;
1081:../Libraries/XMCLib/src/xmc_vadc.c ****   scanctrl     &= ~((uint32_t)VADC_G_ASCTRL_XTSEL_Msk);
1082:../Libraries/XMCLib/src/xmc_vadc.c ****   scanctrl     |= (uint32_t)((uint32_t)trigger_input << VADC_G_ASCTRL_XTSEL_Pos);
1083:../Libraries/XMCLib/src/xmc_vadc.c ****   group_ptr->ASCTRL  = scanctrl;
1084:../Libraries/XMCLib/src/xmc_vadc.c **** }
1085:../Libraries/XMCLib/src/xmc_vadc.c **** 
1086:../Libraries/XMCLib/src/xmc_vadc.c **** /* Select a trigger edge*/
1087:../Libraries/XMCLib/src/xmc_vadc.c **** void XMC_VADC_GROUP_ScanSelectTriggerEdge(XMC_VADC_GROUP_t *const group_ptr, const XMC_VADC_TRIGGER
1088:../Libraries/XMCLib/src/xmc_vadc.c **** {
1089:../Libraries/XMCLib/src/xmc_vadc.c ****   uint32_t scanctrl;
1090:../Libraries/XMCLib/src/xmc_vadc.c **** 
1091:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GROUP_ScanSelectTriggerEdge:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(g
1092:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GROUP_ScanSelectTriggerEdge:Wrong Trigger Port", ((trigger_edge)<= XMC_VADC_
1093:../Libraries/XMCLib/src/xmc_vadc.c **** 
1094:../Libraries/XMCLib/src/xmc_vadc.c ****   scanctrl      = group_ptr->ASCTRL;
1095:../Libraries/XMCLib/src/xmc_vadc.c ****   scanctrl     |= (uint32_t) VADC_G_ASCTRL_XTWC_Msk;
1096:../Libraries/XMCLib/src/xmc_vadc.c ****   scanctrl     &= ~((uint32_t)VADC_G_ASCTRL_XTMODE_Msk);
1097:../Libraries/XMCLib/src/xmc_vadc.c ****   scanctrl     |= (uint32_t)((uint32_t)trigger_edge << VADC_G_ASCTRL_XTMODE_Pos);
1098:../Libraries/XMCLib/src/xmc_vadc.c ****   group_ptr->ASCTRL  = scanctrl;
1099:../Libraries/XMCLib/src/xmc_vadc.c **** }
1100:../Libraries/XMCLib/src/xmc_vadc.c **** 
1101:../Libraries/XMCLib/src/xmc_vadc.c **** /* API to select one of the 16 inputs as a trigger gating input for Group Scan request source */
1102:../Libraries/XMCLib/src/xmc_vadc.c **** void XMC_VADC_GROUP_ScanSelectGating(XMC_VADC_GROUP_t *const group_ptr, XMC_VADC_GATE_INPUT_SELECT_
1103:../Libraries/XMCLib/src/xmc_vadc.c **** {
1104:../Libraries/XMCLib/src/xmc_vadc.c ****   uint32_t scanctrl;
1105:../Libraries/XMCLib/src/xmc_vadc.c **** 
1106:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GROUP_ScanSelectGating:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_
1107:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GROUP_ScanSelectGating:Wrong Gating Port", ((gating_input)< XMC_VADC_NUM_POR
1108:../Libraries/XMCLib/src/xmc_vadc.c **** 
1109:../Libraries/XMCLib/src/xmc_vadc.c ****   scanctrl      = group_ptr->ASCTRL;
1110:../Libraries/XMCLib/src/xmc_vadc.c ****   scanctrl     |= (uint32_t)VADC_G_ASCTRL_GTWC_Msk;
1111:../Libraries/XMCLib/src/xmc_vadc.c ****   scanctrl     &= ~((uint32_t)VADC_G_ASCTRL_GTSEL_Msk);
1112:../Libraries/XMCLib/src/xmc_vadc.c ****   scanctrl     |= (uint32_t)((uint32_t)gating_input << VADC_G_ASCTRL_GTSEL_Pos);
1113:../Libraries/XMCLib/src/xmc_vadc.c ****   group_ptr->ASCTRL  = scanctrl;
1114:../Libraries/XMCLib/src/xmc_vadc.c **** }
1115:../Libraries/XMCLib/src/xmc_vadc.c **** 
1116:../Libraries/XMCLib/src/xmc_vadc.c **** /* API to stop an ongoing conversion of a sequence */
1117:../Libraries/XMCLib/src/xmc_vadc.c **** void XMC_VADC_GROUP_ScanSequenceAbort(XMC_VADC_GROUP_t *const group_ptr)
1118:../Libraries/XMCLib/src/xmc_vadc.c **** {
1119:../Libraries/XMCLib/src/xmc_vadc.c ****   uint32_t asctrl;
1120:../Libraries/XMCLib/src/xmc_vadc.c ****   bool arbitration_status;
1121:../Libraries/XMCLib/src/xmc_vadc.c **** 
1122:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GROUP_ScanSequenceAbort:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group
1123:../Libraries/XMCLib/src/xmc_vadc.c **** 
1124:../Libraries/XMCLib/src/xmc_vadc.c ****   /* To disable trigger and gating before abort*/
1125:../Libraries/XMCLib/src/xmc_vadc.c ****   asctrl = group_ptr->ASCTRL;
1126:../Libraries/XMCLib/src/xmc_vadc.c **** 
1127:../Libraries/XMCLib/src/xmc_vadc.c ****   group_ptr->ASCTRL =(0U | (uint32_t)VADC_G_ASCTRL_XTWC_Msk |
1128:../Libraries/XMCLib/src/xmc_vadc.c ****                                   (uint32_t)VADC_G_ASCTRL_GTWC_Msk | (uint32_t)VADC_G_ASCTRL_TMWC_M
1129:../Libraries/XMCLib/src/xmc_vadc.c **** 
1130:../Libraries/XMCLib/src/xmc_vadc.c ****   /* To disable Arbitration before abort*/
1131:../Libraries/XMCLib/src/xmc_vadc.c ****   arbitration_status = (bool)((uint32_t)(group_ptr->ARBPR >> VADC_G_ARBPR_ASEN1_Pos) & 1U);
1132:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_VADC_GROUP_ScanDisableArbitrationSlot(group_ptr);
1133:../Libraries/XMCLib/src/xmc_vadc.c **** 
1134:../Libraries/XMCLib/src/xmc_vadc.c ****   group_ptr->ASMR &= ~((uint32_t)VADC_G_ASMR_ENGT_Msk);
1135:../Libraries/XMCLib/src/xmc_vadc.c ****   group_ptr->ASMR |= (uint32_t)VADC_G_ASMR_CLRPND_Msk;
1136:../Libraries/XMCLib/src/xmc_vadc.c **** 
1137:../Libraries/XMCLib/src/xmc_vadc.c ****     /* Enable the arbitration slot 1*/
1138:../Libraries/XMCLib/src/xmc_vadc.c ****   group_ptr->ARBPR |= (uint32_t)((uint32_t)arbitration_status << VADC_G_ARBPR_ASEN1_Pos);
1139:../Libraries/XMCLib/src/xmc_vadc.c **** 
1140:../Libraries/XMCLib/src/xmc_vadc.c ****   /* Enable any disabled gating*/
1141:../Libraries/XMCLib/src/xmc_vadc.c ****   group_ptr->ASCTRL =(asctrl | (uint32_t)VADC_G_ASCTRL_XTWC_Msk |
1142:../Libraries/XMCLib/src/xmc_vadc.c ****                                   (uint32_t)VADC_G_ASCTRL_GTWC_Msk | (uint32_t)VADC_G_ASCTRL_TMWC_M
1143:../Libraries/XMCLib/src/xmc_vadc.c **** }
1144:../Libraries/XMCLib/src/xmc_vadc.c **** 
1145:../Libraries/XMCLib/src/xmc_vadc.c **** /* API to find out number of channels awaiting conversion */
1146:../Libraries/XMCLib/src/xmc_vadc.c **** uint32_t XMC_VADC_GROUP_ScanGetNumChannelsPending(XMC_VADC_GROUP_t *const group_ptr)
1147:../Libraries/XMCLib/src/xmc_vadc.c **** {
1148:../Libraries/XMCLib/src/xmc_vadc.c ****   uint32_t reg;
1149:../Libraries/XMCLib/src/xmc_vadc.c ****   uint32_t i;
1150:../Libraries/XMCLib/src/xmc_vadc.c ****   uint32_t count;
1151:../Libraries/XMCLib/src/xmc_vadc.c **** 
1152:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GROUP_ScanGetNumChannelsPending:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_P
1153:../Libraries/XMCLib/src/xmc_vadc.c **** 
1154:../Libraries/XMCLib/src/xmc_vadc.c **** 
1155:../Libraries/XMCLib/src/xmc_vadc.c ****   count = 0U;
1156:../Libraries/XMCLib/src/xmc_vadc.c **** 
1157:../Libraries/XMCLib/src/xmc_vadc.c ****   if (group_ptr->ASPND)
1158:../Libraries/XMCLib/src/xmc_vadc.c ****   {
1159:../Libraries/XMCLib/src/xmc_vadc.c ****     reg = group_ptr->ASPND;
1160:../Libraries/XMCLib/src/xmc_vadc.c **** 
1161:../Libraries/XMCLib/src/xmc_vadc.c ****     for(i=0U;i<XMC_VADC_NUM_CHANNELS_PER_GROUP;i++)
1162:../Libraries/XMCLib/src/xmc_vadc.c ****     {
1163:../Libraries/XMCLib/src/xmc_vadc.c ****       if (reg & 1U)
1164:../Libraries/XMCLib/src/xmc_vadc.c ****       {
1165:../Libraries/XMCLib/src/xmc_vadc.c ****         count++;
1166:../Libraries/XMCLib/src/xmc_vadc.c ****       }
1167:../Libraries/XMCLib/src/xmc_vadc.c ****       reg = (uint32_t)(reg >> (uint32_t)1);
1168:../Libraries/XMCLib/src/xmc_vadc.c ****     }
1169:../Libraries/XMCLib/src/xmc_vadc.c ****   }
1170:../Libraries/XMCLib/src/xmc_vadc.c **** 
1171:../Libraries/XMCLib/src/xmc_vadc.c ****   return count;
1172:../Libraries/XMCLib/src/xmc_vadc.c **** }
1173:../Libraries/XMCLib/src/xmc_vadc.c **** 
1174:../Libraries/XMCLib/src/xmc_vadc.c **** /* API to select a service request line (NVIC Node) for request source event */
1175:../Libraries/XMCLib/src/xmc_vadc.c **** void XMC_VADC_GROUP_ScanSetReqSrcEventInterruptNode(XMC_VADC_GROUP_t *const group_ptr, const XMC_VA
1176:../Libraries/XMCLib/src/xmc_vadc.c **** {
1177:../Libraries/XMCLib/src/xmc_vadc.c ****   uint32_t sevnp;
1178:../Libraries/XMCLib/src/xmc_vadc.c ****   sevnp = group_ptr->SEVNP;
1179:../Libraries/XMCLib/src/xmc_vadc.c **** 
1180:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GROUP_ScanSetReqSrcEventInterruptNode:Wrong Group Pointer", XMC_VADC_CHECK_G
1181:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GROUP_ScanSetReqSrcEventInterruptNode:Wrong Service Request", ((sr)  <= XMC_
1182:../Libraries/XMCLib/src/xmc_vadc.c **** 
1183:../Libraries/XMCLib/src/xmc_vadc.c ****   sevnp &= ~((uint32_t)VADC_G_SEVNP_SEV1NP_Msk);
1184:../Libraries/XMCLib/src/xmc_vadc.c ****   sevnp |= (uint32_t)((uint32_t)sr << VADC_G_SEVNP_SEV1NP_Pos);
1185:../Libraries/XMCLib/src/xmc_vadc.c **** 
1186:../Libraries/XMCLib/src/xmc_vadc.c ****   group_ptr->SEVNP = sevnp;
1187:../Libraries/XMCLib/src/xmc_vadc.c **** }
1188:../Libraries/XMCLib/src/xmc_vadc.c **** 
1189:../Libraries/XMCLib/src/xmc_vadc.c **** /* Removes the selected channel from conversion*/
1190:../Libraries/XMCLib/src/xmc_vadc.c **** void XMC_VADC_GROUP_ScanRemoveChannel(XMC_VADC_GROUP_t *const group_ptr, const uint32_t channel_num
1191:../Libraries/XMCLib/src/xmc_vadc.c **** {
1192:../Libraries/XMCLib/src/xmc_vadc.c ****   uint32_t assel;
1193:../Libraries/XMCLib/src/xmc_vadc.c **** 
1194:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GROUP_ScanRemoveChannel:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group
1195:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GROUP_ScanRemoveChannel:Wrong channel number", ((channel_num)< XMC_VADC_NUM_
1196:../Libraries/XMCLib/src/xmc_vadc.c **** 
1197:../Libraries/XMCLib/src/xmc_vadc.c ****   assel = group_ptr->ASSEL; 
1198:../Libraries/XMCLib/src/xmc_vadc.c ****   assel &= (~( 1 << channel_num));
1199:../Libraries/XMCLib/src/xmc_vadc.c ****   group_ptr->ASSEL  = assel;
1200:../Libraries/XMCLib/src/xmc_vadc.c **** }
1201:../Libraries/XMCLib/src/xmc_vadc.c **** #endif
1202:../Libraries/XMCLib/src/xmc_vadc.c **** 
1203:../Libraries/XMCLib/src/xmc_vadc.c **** /* API to initialize background scan request source hardware */
1204:../Libraries/XMCLib/src/xmc_vadc.c **** void XMC_VADC_GLOBAL_BackgroundInit(XMC_VADC_GLOBAL_t *const global_ptr, const XMC_VADC_BACKGROUND_
1205:../Libraries/XMCLib/src/xmc_vadc.c **** {
 780              	 .loc 1 1205 0
 781              	 .cfi_startproc
 782 0000 80B5     	 push {r7,lr}
 783              	.LCFI34:
 784              	 .cfi_def_cfa_offset 8
 785              	 .cfi_offset 7,-8
 786              	 .cfi_offset 14,-4
 787 0002 82B0     	 sub sp,sp,#8
 788              	.LCFI35:
 789              	 .cfi_def_cfa_offset 16
 790 0004 00AF     	 add r7,sp,#0
 791              	.LCFI36:
 792              	 .cfi_def_cfa_register 7
 793 0006 7860     	 str r0,[r7,#4]
 794 0008 3960     	 str r1,[r7]
1206:../Libraries/XMCLib/src/xmc_vadc.c ****   #if (XMC_VADC_GROUP_AVAILABLE ==1U)
1207:../Libraries/XMCLib/src/xmc_vadc.c ****   uint8_t i;
1208:../Libraries/XMCLib/src/xmc_vadc.c ****   uint32_t reg;
1209:../Libraries/XMCLib/src/xmc_vadc.c ****   uint32_t conv_start_mask;
1210:../Libraries/XMCLib/src/xmc_vadc.c ****   #endif
1211:../Libraries/XMCLib/src/xmc_vadc.c ****   
1212:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GLOBAL_BackgroundInit:Wrong Module Pointer", (global_ptr == VADC))
1213:../Libraries/XMCLib/src/xmc_vadc.c **** 
1214:../Libraries/XMCLib/src/xmc_vadc.c ****   #if (XMC_VADC_GROUP_AVAILABLE ==1U)
1215:../Libraries/XMCLib/src/xmc_vadc.c ****   for(i=(uint8_t)0; i < XMC_VADC_MAXIMUM_NUM_GROUPS; i++)
1216:../Libraries/XMCLib/src/xmc_vadc.c ****   {
1217:../Libraries/XMCLib/src/xmc_vadc.c ****     XMC_VADC_GROUP_BackgroundDisableArbitrationSlot((XMC_VADC_GROUP_t *)g_xmc_vadc_group_array[i]);
1218:../Libraries/XMCLib/src/xmc_vadc.c ****   }
1219:../Libraries/XMCLib/src/xmc_vadc.c ****   
1220:../Libraries/XMCLib/src/xmc_vadc.c ****   conv_start_mask = (uint32_t) 0;
1221:../Libraries/XMCLib/src/xmc_vadc.c ****   if (XMC_VADC_STARTMODE_WFS != (XMC_VADC_STARTMODE_t)config->conv_start_mode)
1222:../Libraries/XMCLib/src/xmc_vadc.c ****   {
1223:../Libraries/XMCLib/src/xmc_vadc.c ****     conv_start_mask = (uint32_t)VADC_G_ARBPR_CSM2_Msk;
1224:../Libraries/XMCLib/src/xmc_vadc.c ****   }
1225:../Libraries/XMCLib/src/xmc_vadc.c ****   
1226:../Libraries/XMCLib/src/xmc_vadc.c ****   for(i=0U; i < XMC_VADC_MAXIMUM_NUM_GROUPS; i++)
1227:../Libraries/XMCLib/src/xmc_vadc.c ****   {
1228:../Libraries/XMCLib/src/xmc_vadc.c ****     reg = g_xmc_vadc_group_array[i]->ARBPR;
1229:../Libraries/XMCLib/src/xmc_vadc.c **** 
1230:../Libraries/XMCLib/src/xmc_vadc.c ****     reg &= ~(uint32_t)(VADC_G_ARBPR_PRIO2_Msk);
1231:../Libraries/XMCLib/src/xmc_vadc.c **** 
1232:../Libraries/XMCLib/src/xmc_vadc.c ****     /* Program the priority of the request source */
1233:../Libraries/XMCLib/src/xmc_vadc.c ****     reg |= (uint32_t)((uint32_t)config->req_src_priority << VADC_G_ARBPR_PRIO2_Pos);
1234:../Libraries/XMCLib/src/xmc_vadc.c ****   
1235:../Libraries/XMCLib/src/xmc_vadc.c ****     /* Program the start mode */
1236:../Libraries/XMCLib/src/xmc_vadc.c ****     reg |= conv_start_mask;
1237:../Libraries/XMCLib/src/xmc_vadc.c **** 
1238:../Libraries/XMCLib/src/xmc_vadc.c ****     g_xmc_vadc_group_array[i]->ARBPR = reg;
1239:../Libraries/XMCLib/src/xmc_vadc.c ****   
1240:../Libraries/XMCLib/src/xmc_vadc.c ****   }
1241:../Libraries/XMCLib/src/xmc_vadc.c ****   #endif
1242:../Libraries/XMCLib/src/xmc_vadc.c **** 
1243:../Libraries/XMCLib/src/xmc_vadc.c ****   /* program BRSCTRL register */
1244:../Libraries/XMCLib/src/xmc_vadc.c ****   global_ptr->BRSCTRL = (uint32_t)(config->asctrl | (uint32_t)VADC_BRSCTRL_XTWC_Msk | (uint32_t)VAD
 795              	 .loc 1 1244 0
 796 000a 3B68     	 ldr r3,[r7]
 797 000c 5B68     	 ldr r3,[r3,#4]
 798 000e 094A     	 ldr r2,.L34
 799 0010 1A43     	 orr r2,r3
 800 0012 111C     	 mov r1,r2
 801 0014 7A68     	 ldr r2,[r7,#4]
 802 0016 8023     	 mov r3,#128
 803 0018 9B00     	 lsl r3,r3,#2
 804 001a D150     	 str r1,[r2,r3]
1245:../Libraries/XMCLib/src/xmc_vadc.c **** 
1246:../Libraries/XMCLib/src/xmc_vadc.c ****   /* program BRSMR register */
1247:../Libraries/XMCLib/src/xmc_vadc.c ****   global_ptr->BRSMR = (uint32_t)((config->asmr)| (uint32_t)((uint32_t)XMC_VADC_GATEMODE_IGNORE << V
 805              	 .loc 1 1247 0
 806 001c 3B68     	 ldr r3,[r7]
 807 001e 9B68     	 ldr r3,[r3,#8]
 808 0020 0122     	 mov r2,#1
 809 0022 1A43     	 orr r2,r3
 810 0024 111C     	 mov r1,r2
 811 0026 7A68     	 ldr r2,[r7,#4]
 812 0028 8123     	 mov r3,#129
 813 002a 9B00     	 lsl r3,r3,#2
 814 002c D150     	 str r1,[r2,r3]
1248:../Libraries/XMCLib/src/xmc_vadc.c ****   
1249:../Libraries/XMCLib/src/xmc_vadc.c **** #if (XMC_VADC_GROUP_AVAILABLE ==1U)
1250:../Libraries/XMCLib/src/xmc_vadc.c ****   if (XMC_VADC_STARTMODE_CNR == (XMC_VADC_STARTMODE_t)(config->conv_start_mode))
1251:../Libraries/XMCLib/src/xmc_vadc.c ****   {
1252:../Libraries/XMCLib/src/xmc_vadc.c ****     global_ptr->BRSMR |= (uint32_t)VADC_BRSMR_RPTDIS_Msk;
1253:../Libraries/XMCLib/src/xmc_vadc.c ****   }
1254:../Libraries/XMCLib/src/xmc_vadc.c **** #endif
1255:../Libraries/XMCLib/src/xmc_vadc.c ****   
1256:../Libraries/XMCLib/src/xmc_vadc.c ****   #if (XMC_VADC_GROUP_AVAILABLE ==1U)
1257:../Libraries/XMCLib/src/xmc_vadc.c ****   for(i=(uint8_t)0; i < XMC_VADC_MAXIMUM_NUM_GROUPS; i++)
1258:../Libraries/XMCLib/src/xmc_vadc.c ****   {
1259:../Libraries/XMCLib/src/xmc_vadc.c ****     XMC_VADC_GROUP_BackgroundEnableArbitrationSlot((XMC_VADC_GROUP_t *)g_xmc_vadc_group_array[i]);
1260:../Libraries/XMCLib/src/xmc_vadc.c ****   }
1261:../Libraries/XMCLib/src/xmc_vadc.c ****   #endif
1262:../Libraries/XMCLib/src/xmc_vadc.c ****   
1263:../Libraries/XMCLib/src/xmc_vadc.c **** }
 815              	 .loc 1 1263 0
 816 002e BD46     	 mov sp,r7
 817 0030 02B0     	 add sp,sp,#8
 818              	 
 819 0032 80BD     	 pop {r7,pc}
 820              	.L35:
 821              	 .align 2
 822              	.L34:
 823 0034 00808000 	 .word 8421376
 824              	 .cfi_endproc
 825              	.LFE102:
 827              	 .section .text.XMC_VADC_GLOBAL_BackgroundSelectTrigger,"ax",%progbits
 828              	 .align 2
 829              	 .global XMC_VADC_GLOBAL_BackgroundSelectTrigger
 830              	 .code 16
 831              	 .thumb_func
 833              	XMC_VADC_GLOBAL_BackgroundSelectTrigger:
 834              	.LFB103:
1264:../Libraries/XMCLib/src/xmc_vadc.c **** 
1265:../Libraries/XMCLib/src/xmc_vadc.c **** /* API to select one of the 16 inputs as a trigger for background scan request source */
1266:../Libraries/XMCLib/src/xmc_vadc.c **** void XMC_VADC_GLOBAL_BackgroundSelectTrigger(XMC_VADC_GLOBAL_t *const global_ptr, const uint32_t in
1267:../Libraries/XMCLib/src/xmc_vadc.c **** {
 835              	 .loc 1 1267 0
 836              	 .cfi_startproc
 837 0000 80B5     	 push {r7,lr}
 838              	.LCFI37:
 839              	 .cfi_def_cfa_offset 8
 840              	 .cfi_offset 7,-8
 841              	 .cfi_offset 14,-4
 842 0002 84B0     	 sub sp,sp,#16
 843              	.LCFI38:
 844              	 .cfi_def_cfa_offset 24
 845 0004 00AF     	 add r7,sp,#0
 846              	.LCFI39:
 847              	 .cfi_def_cfa_register 7
 848 0006 7860     	 str r0,[r7,#4]
 849 0008 3960     	 str r1,[r7]
1268:../Libraries/XMCLib/src/xmc_vadc.c ****   uint32_t scanctrl;
1269:../Libraries/XMCLib/src/xmc_vadc.c **** 
1270:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("VADC_BCKGND_SelectTriggerInput:Wrong Module Pointer", (global_ptr == VADC))
1271:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GLOBAL_BackgroundSelectTrigger:Wrong Trigger Port", ((input_num)< XMC_VADC_N
1272:../Libraries/XMCLib/src/xmc_vadc.c **** 
1273:../Libraries/XMCLib/src/xmc_vadc.c ****   
1274:../Libraries/XMCLib/src/xmc_vadc.c ****   scanctrl       = global_ptr->BRSCTRL;
 850              	 .loc 1 1274 0
 851 000a 7A68     	 ldr r2,[r7,#4]
 852 000c 8023     	 mov r3,#128
 853 000e 9B00     	 lsl r3,r3,#2
 854 0010 D358     	 ldr r3,[r2,r3]
 855 0012 FB60     	 str r3,[r7,#12]
1275:../Libraries/XMCLib/src/xmc_vadc.c ****   scanctrl      |= (uint32_t)VADC_BRSCTRL_XTWC_Msk;
 856              	 .loc 1 1275 0
 857 0014 FB68     	 ldr r3,[r7,#12]
 858 0016 8022     	 mov r2,#128
 859 0018 1202     	 lsl r2,r2,#8
 860 001a 1343     	 orr r3,r2
 861 001c FB60     	 str r3,[r7,#12]
1276:../Libraries/XMCLib/src/xmc_vadc.c ****   scanctrl      &= ~((uint32_t)VADC_BRSCTRL_XTSEL_Msk);
 862              	 .loc 1 1276 0
 863 001e FB68     	 ldr r3,[r7,#12]
 864 0020 074A     	 ldr r2,.L37
 865 0022 1340     	 and r3,r2
 866 0024 FB60     	 str r3,[r7,#12]
1277:../Libraries/XMCLib/src/xmc_vadc.c ****   scanctrl      |= (uint32_t)(input_num << VADC_BRSCTRL_XTSEL_Pos);
 867              	 .loc 1 1277 0
 868 0026 3B68     	 ldr r3,[r7]
 869 0028 1B02     	 lsl r3,r3,#8
 870 002a FA68     	 ldr r2,[r7,#12]
 871 002c 1343     	 orr r3,r2
 872 002e FB60     	 str r3,[r7,#12]
1278:../Libraries/XMCLib/src/xmc_vadc.c ****   global_ptr->BRSCTRL  = scanctrl;
 873              	 .loc 1 1278 0
 874 0030 7A68     	 ldr r2,[r7,#4]
 875 0032 8023     	 mov r3,#128
 876 0034 9B00     	 lsl r3,r3,#2
 877 0036 F968     	 ldr r1,[r7,#12]
 878 0038 D150     	 str r1,[r2,r3]
1279:../Libraries/XMCLib/src/xmc_vadc.c **** }
 879              	 .loc 1 1279 0
 880 003a BD46     	 mov sp,r7
 881 003c 04B0     	 add sp,sp,#16
 882              	 
 883 003e 80BD     	 pop {r7,pc}
 884              	.L38:
 885              	 .align 2
 886              	.L37:
 887 0040 FFF0FFFF 	 .word -3841
 888              	 .cfi_endproc
 889              	.LFE103:
 891              	 .section .text.XMC_VADC_GLOBAL_BackgroundSelectTriggerEdge,"ax",%progbits
 892              	 .align 2
 893              	 .global XMC_VADC_GLOBAL_BackgroundSelectTriggerEdge
 894              	 .code 16
 895              	 .thumb_func
 897              	XMC_VADC_GLOBAL_BackgroundSelectTriggerEdge:
 898              	.LFB104:
1280:../Libraries/XMCLib/src/xmc_vadc.c **** 
1281:../Libraries/XMCLib/src/xmc_vadc.c **** /* Select a trigger edge*/
1282:../Libraries/XMCLib/src/xmc_vadc.c **** void XMC_VADC_GLOBAL_BackgroundSelectTriggerEdge(XMC_VADC_GLOBAL_t *const global_ptr,
1283:../Libraries/XMCLib/src/xmc_vadc.c ****                                                  const XMC_VADC_TRIGGER_EDGE_t trigger_edge)
1284:../Libraries/XMCLib/src/xmc_vadc.c **** {
 899              	 .loc 1 1284 0
 900              	 .cfi_startproc
 901 0000 80B5     	 push {r7,lr}
 902              	.LCFI40:
 903              	 .cfi_def_cfa_offset 8
 904              	 .cfi_offset 7,-8
 905              	 .cfi_offset 14,-4
 906 0002 84B0     	 sub sp,sp,#16
 907              	.LCFI41:
 908              	 .cfi_def_cfa_offset 24
 909 0004 00AF     	 add r7,sp,#0
 910              	.LCFI42:
 911              	 .cfi_def_cfa_register 7
 912 0006 7860     	 str r0,[r7,#4]
 913 0008 0A1C     	 mov r2,r1
 914 000a FB1C     	 add r3,r7,#3
 915 000c 1A70     	 strb r2,[r3]
1285:../Libraries/XMCLib/src/xmc_vadc.c ****   uint32_t scanctrl;
1286:../Libraries/XMCLib/src/xmc_vadc.c **** 
1287:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GLOBAL_BackgroundSelectTriggerEdge:Wrong Global Pointer", (global_ptr == VAD
1288:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GLOBAL_BackgroundSelectTriggerEdge:Wrong Trigger Port",
1289:../Libraries/XMCLib/src/xmc_vadc.c ****             ((trigger_edge)<= XMC_VADC_TRIGGER_EDGE_ANY))
1290:../Libraries/XMCLib/src/xmc_vadc.c **** 
1291:../Libraries/XMCLib/src/xmc_vadc.c ****   scanctrl      = global_ptr->BRSCTRL;
 916              	 .loc 1 1291 0
 917 000e 7A68     	 ldr r2,[r7,#4]
 918 0010 8023     	 mov r3,#128
 919 0012 9B00     	 lsl r3,r3,#2
 920 0014 D358     	 ldr r3,[r2,r3]
 921 0016 FB60     	 str r3,[r7,#12]
1292:../Libraries/XMCLib/src/xmc_vadc.c ****   scanctrl     |= (uint32_t) VADC_BRSCTRL_XTWC_Msk;
 922              	 .loc 1 1292 0
 923 0018 FB68     	 ldr r3,[r7,#12]
 924 001a 8022     	 mov r2,#128
 925 001c 1202     	 lsl r2,r2,#8
 926 001e 1343     	 orr r3,r2
 927 0020 FB60     	 str r3,[r7,#12]
1293:../Libraries/XMCLib/src/xmc_vadc.c ****   scanctrl     &= ~((uint32_t)VADC_BRSCTRL_XTMODE_Msk);
 928              	 .loc 1 1293 0
 929 0022 FB68     	 ldr r3,[r7,#12]
 930 0024 084A     	 ldr r2,.L40
 931 0026 1340     	 and r3,r2
 932 0028 FB60     	 str r3,[r7,#12]
1294:../Libraries/XMCLib/src/xmc_vadc.c ****   scanctrl     |= (uint32_t)((uint32_t)trigger_edge << VADC_BRSCTRL_XTMODE_Pos);
 933              	 .loc 1 1294 0
 934 002a FB1C     	 add r3,r7,#3
 935 002c 1B78     	 ldrb r3,[r3]
 936 002e 5B03     	 lsl r3,r3,#13
 937 0030 FA68     	 ldr r2,[r7,#12]
 938 0032 1343     	 orr r3,r2
 939 0034 FB60     	 str r3,[r7,#12]
1295:../Libraries/XMCLib/src/xmc_vadc.c ****   global_ptr->BRSCTRL  = scanctrl;
 940              	 .loc 1 1295 0
 941 0036 7A68     	 ldr r2,[r7,#4]
 942 0038 8023     	 mov r3,#128
 943 003a 9B00     	 lsl r3,r3,#2
 944 003c F968     	 ldr r1,[r7,#12]
 945 003e D150     	 str r1,[r2,r3]
1296:../Libraries/XMCLib/src/xmc_vadc.c **** }
 946              	 .loc 1 1296 0
 947 0040 BD46     	 mov sp,r7
 948 0042 04B0     	 add sp,sp,#16
 949              	 
 950 0044 80BD     	 pop {r7,pc}
 951              	.L41:
 952 0046 C046     	 .align 2
 953              	.L40:
 954 0048 FF9FFFFF 	 .word -24577
 955              	 .cfi_endproc
 956              	.LFE104:
 958              	 .section .text.XMC_VADC_GLOBAL_BackgroundSelectGating,"ax",%progbits
 959              	 .align 2
 960              	 .global XMC_VADC_GLOBAL_BackgroundSelectGating
 961              	 .code 16
 962              	 .thumb_func
 964              	XMC_VADC_GLOBAL_BackgroundSelectGating:
 965              	.LFB105:
1297:../Libraries/XMCLib/src/xmc_vadc.c **** 
1298:../Libraries/XMCLib/src/xmc_vadc.c **** 
1299:../Libraries/XMCLib/src/xmc_vadc.c **** /* API to select one of the 16 inputs as a trigger gate for background scan request source */
1300:../Libraries/XMCLib/src/xmc_vadc.c **** void XMC_VADC_GLOBAL_BackgroundSelectGating(XMC_VADC_GLOBAL_t *const global_ptr, const uint32_t inp
1301:../Libraries/XMCLib/src/xmc_vadc.c **** {
 966              	 .loc 1 1301 0
 967              	 .cfi_startproc
 968 0000 80B5     	 push {r7,lr}
 969              	.LCFI43:
 970              	 .cfi_def_cfa_offset 8
 971              	 .cfi_offset 7,-8
 972              	 .cfi_offset 14,-4
 973 0002 84B0     	 sub sp,sp,#16
 974              	.LCFI44:
 975              	 .cfi_def_cfa_offset 24
 976 0004 00AF     	 add r7,sp,#0
 977              	.LCFI45:
 978              	 .cfi_def_cfa_register 7
 979 0006 7860     	 str r0,[r7,#4]
 980 0008 3960     	 str r1,[r7]
1302:../Libraries/XMCLib/src/xmc_vadc.c ****   uint32_t scanctrl;
1303:../Libraries/XMCLib/src/xmc_vadc.c **** 
1304:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GLOBAL_BackgroundSelectGating:Wrong Module Pointer", (global_ptr == VADC))
1305:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GLOBAL_BackgroundSelectGating:Wrong Gating Port", ((input_num)< XMC_VADC_NUM
1306:../Libraries/XMCLib/src/xmc_vadc.c **** 
1307:../Libraries/XMCLib/src/xmc_vadc.c ****   scanctrl       = global_ptr->BRSCTRL;
 981              	 .loc 1 1307 0
 982 000a 7A68     	 ldr r2,[r7,#4]
 983 000c 8023     	 mov r3,#128
 984 000e 9B00     	 lsl r3,r3,#2
 985 0010 D358     	 ldr r3,[r2,r3]
 986 0012 FB60     	 str r3,[r7,#12]
1308:../Libraries/XMCLib/src/xmc_vadc.c ****   scanctrl      |= (uint32_t)VADC_BRSCTRL_GTWC_Msk;
 987              	 .loc 1 1308 0
 988 0014 FB68     	 ldr r3,[r7,#12]
 989 0016 8022     	 mov r2,#128
 990 0018 1204     	 lsl r2,r2,#16
 991 001a 1343     	 orr r3,r2
 992 001c FB60     	 str r3,[r7,#12]
1309:../Libraries/XMCLib/src/xmc_vadc.c ****   scanctrl      &= ~((uint32_t)VADC_BRSCTRL_GTSEL_Msk);
 993              	 .loc 1 1309 0
 994 001e FB68     	 ldr r3,[r7,#12]
 995 0020 074A     	 ldr r2,.L43
 996 0022 1340     	 and r3,r2
 997 0024 FB60     	 str r3,[r7,#12]
1310:../Libraries/XMCLib/src/xmc_vadc.c ****   scanctrl      |= (uint32_t)(input_num << VADC_BRSCTRL_GTSEL_Pos);
 998              	 .loc 1 1310 0
 999 0026 3B68     	 ldr r3,[r7]
 1000 0028 1B04     	 lsl r3,r3,#16
 1001 002a FA68     	 ldr r2,[r7,#12]
 1002 002c 1343     	 orr r3,r2
 1003 002e FB60     	 str r3,[r7,#12]
1311:../Libraries/XMCLib/src/xmc_vadc.c ****   global_ptr->BRSCTRL  = scanctrl;
 1004              	 .loc 1 1311 0
 1005 0030 7A68     	 ldr r2,[r7,#4]
 1006 0032 8023     	 mov r3,#128
 1007 0034 9B00     	 lsl r3,r3,#2
 1008 0036 F968     	 ldr r1,[r7,#12]
 1009 0038 D150     	 str r1,[r2,r3]
1312:../Libraries/XMCLib/src/xmc_vadc.c **** }
 1010              	 .loc 1 1312 0
 1011 003a BD46     	 mov sp,r7
 1012 003c 04B0     	 add sp,sp,#16
 1013              	 
 1014 003e 80BD     	 pop {r7,pc}
 1015              	.L44:
 1016              	 .align 2
 1017              	.L43:
 1018 0040 FFFFF0FF 	 .word -983041
 1019              	 .cfi_endproc
 1020              	.LFE105:
 1022              	 .section .text.XMC_VADC_GLOBAL_BackgroundAbortSequence,"ax",%progbits
 1023              	 .align 2
 1024              	 .global XMC_VADC_GLOBAL_BackgroundAbortSequence
 1025              	 .code 16
 1026              	 .thumb_func
 1028              	XMC_VADC_GLOBAL_BackgroundAbortSequence:
 1029              	.LFB106:
1313:../Libraries/XMCLib/src/xmc_vadc.c **** 
1314:../Libraries/XMCLib/src/xmc_vadc.c **** /* API to abort ongoing conversion of a sequence */
1315:../Libraries/XMCLib/src/xmc_vadc.c **** void XMC_VADC_GLOBAL_BackgroundAbortSequence(XMC_VADC_GLOBAL_t *const global_ptr)
1316:../Libraries/XMCLib/src/xmc_vadc.c **** {
 1030              	 .loc 1 1316 0
 1031              	 .cfi_startproc
 1032 0000 80B5     	 push {r7,lr}
 1033              	.LCFI46:
 1034              	 .cfi_def_cfa_offset 8
 1035              	 .cfi_offset 7,-8
 1036              	 .cfi_offset 14,-4
 1037 0002 84B0     	 sub sp,sp,#16
 1038              	.LCFI47:
 1039              	 .cfi_def_cfa_offset 24
 1040 0004 00AF     	 add r7,sp,#0
 1041              	.LCFI48:
 1042              	 .cfi_def_cfa_register 7
 1043 0006 7860     	 str r0,[r7,#4]
1317:../Libraries/XMCLib/src/xmc_vadc.c ****   uint32_t brsctrl;
1318:../Libraries/XMCLib/src/xmc_vadc.c **** #if (XMC_VADC_GROUP_AVAILABLE ==1U)
1319:../Libraries/XMCLib/src/xmc_vadc.c ****   uint32_t i;
1320:../Libraries/XMCLib/src/xmc_vadc.c ****   uint8_t grp_asen2_flag[XMC_VADC_MAXIMUM_NUM_GROUPS];
1321:../Libraries/XMCLib/src/xmc_vadc.c **** #endif
1322:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GLOBAL_BackgroundAbortSequence:Wrong Module Pointer", (global_ptr == VADC))
1323:../Libraries/XMCLib/src/xmc_vadc.c **** 
1324:../Libraries/XMCLib/src/xmc_vadc.c ****   /* To disable trigger and gating before abort*/
1325:../Libraries/XMCLib/src/xmc_vadc.c ****   brsctrl = global_ptr->BRSCTRL;
 1044              	 .loc 1 1325 0
 1045 0008 7A68     	 ldr r2,[r7,#4]
 1046 000a 8023     	 mov r3,#128
 1047 000c 9B00     	 lsl r3,r3,#2
 1048 000e D358     	 ldr r3,[r2,r3]
 1049 0010 FB60     	 str r3,[r7,#12]
1326:../Libraries/XMCLib/src/xmc_vadc.c **** 
1327:../Libraries/XMCLib/src/xmc_vadc.c ****   global_ptr->BRSCTRL =(0U | (uint32_t)VADC_BRSCTRL_XTWC_Msk | (uint32_t)VADC_BRSCTRL_GTWC_Msk);
 1050              	 .loc 1 1327 0
 1051 0012 7A68     	 ldr r2,[r7,#4]
 1052 0014 8023     	 mov r3,#128
 1053 0016 9B00     	 lsl r3,r3,#2
 1054 0018 0C49     	 ldr r1,.L46
 1055 001a D150     	 str r1,[r2,r3]
1328:../Libraries/XMCLib/src/xmc_vadc.c **** 
1329:../Libraries/XMCLib/src/xmc_vadc.c ****   /* Disable Background Request source */
1330:../Libraries/XMCLib/src/xmc_vadc.c **** 
1331:../Libraries/XMCLib/src/xmc_vadc.c **** #if (XMC_VADC_GROUP_AVAILABLE ==1U)
1332:../Libraries/XMCLib/src/xmc_vadc.c ****   for(i=(uint8_t)0; i < XMC_VADC_MAXIMUM_NUM_GROUPS; i++)
1333:../Libraries/XMCLib/src/xmc_vadc.c ****   {
1334:../Libraries/XMCLib/src/xmc_vadc.c ****     grp_asen2_flag[i] = (uint8_t)(g_xmc_vadc_group_array[i]->ARBPR >> VADC_G_ARBPR_ASEN2_Pos);
1335:../Libraries/XMCLib/src/xmc_vadc.c ****     XMC_VADC_GROUP_BackgroundDisableArbitrationSlot((XMC_VADC_GROUP_t *)g_xmc_vadc_group_array[i]);
1336:../Libraries/XMCLib/src/xmc_vadc.c ****   }
1337:../Libraries/XMCLib/src/xmc_vadc.c **** #endif
1338:../Libraries/XMCLib/src/xmc_vadc.c **** 
1339:../Libraries/XMCLib/src/xmc_vadc.c ****   /* Abort the ongoing sequence */
1340:../Libraries/XMCLib/src/xmc_vadc.c ****   global_ptr->BRSMR |= (uint32_t)VADC_BRSMR_CLRPND_Msk;
 1056              	 .loc 1 1340 0
 1057 001c 7A68     	 ldr r2,[r7,#4]
 1058 001e 8123     	 mov r3,#129
 1059 0020 9B00     	 lsl r3,r3,#2
 1060 0022 D358     	 ldr r3,[r2,r3]
 1061 0024 8022     	 mov r2,#128
 1062 0026 5200     	 lsl r2,r2,#1
 1063 0028 1A43     	 orr r2,r3
 1064 002a 111C     	 mov r1,r2
 1065 002c 7A68     	 ldr r2,[r7,#4]
 1066 002e 8123     	 mov r3,#129
 1067 0030 9B00     	 lsl r3,r3,#2
 1068 0032 D150     	 str r1,[r2,r3]
1341:../Libraries/XMCLib/src/xmc_vadc.c **** 
1342:../Libraries/XMCLib/src/xmc_vadc.c **** #if (XMC_VADC_GROUP_AVAILABLE ==1U)
1343:../Libraries/XMCLib/src/xmc_vadc.c ****   /* Enable Background Request source */
1344:../Libraries/XMCLib/src/xmc_vadc.c ****   for(i=(uint8_t)0; i < XMC_VADC_MAXIMUM_NUM_GROUPS; i++)
1345:../Libraries/XMCLib/src/xmc_vadc.c ****   {
1346:../Libraries/XMCLib/src/xmc_vadc.c ****     if ((uint8_t)1 == grp_asen2_flag[i])
1347:../Libraries/XMCLib/src/xmc_vadc.c ****     {
1348:../Libraries/XMCLib/src/xmc_vadc.c ****       XMC_VADC_GROUP_BackgroundEnableArbitrationSlot((XMC_VADC_GROUP_t*)g_xmc_vadc_group_array[i]);
1349:../Libraries/XMCLib/src/xmc_vadc.c ****     }
1350:../Libraries/XMCLib/src/xmc_vadc.c ****   }
1351:../Libraries/XMCLib/src/xmc_vadc.c **** #endif
1352:../Libraries/XMCLib/src/xmc_vadc.c **** 
1353:../Libraries/XMCLib/src/xmc_vadc.c ****   /* Re-enable any disabled trigger and gating*/
1354:../Libraries/XMCLib/src/xmc_vadc.c ****   global_ptr->BRSCTRL =(brsctrl | (uint32_t)VADC_BRSCTRL_XTWC_Msk | (uint32_t)VADC_BRSCTRL_GTWC_Msk
 1069              	 .loc 1 1354 0
 1070 0034 FB68     	 ldr r3,[r7,#12]
 1071 0036 054A     	 ldr r2,.L46
 1072 0038 1A43     	 orr r2,r3
 1073 003a 111C     	 mov r1,r2
 1074 003c 7A68     	 ldr r2,[r7,#4]
 1075 003e 8023     	 mov r3,#128
 1076 0040 9B00     	 lsl r3,r3,#2
 1077 0042 D150     	 str r1,[r2,r3]
1355:../Libraries/XMCLib/src/xmc_vadc.c **** }
 1078              	 .loc 1 1355 0
 1079 0044 BD46     	 mov sp,r7
 1080 0046 04B0     	 add sp,sp,#16
 1081              	 
 1082 0048 80BD     	 pop {r7,pc}
 1083              	.L47:
 1084 004a C046     	 .align 2
 1085              	.L46:
 1086 004c 00808000 	 .word 8421376
 1087              	 .cfi_endproc
 1088              	.LFE106:
 1090              	 .section .text.XMC_VADC_GLOBAL_BackgroundGetNumChannelsPending,"ax",%progbits
 1091              	 .align 2
 1092              	 .global XMC_VADC_GLOBAL_BackgroundGetNumChannelsPending
 1093              	 .code 16
 1094              	 .thumb_func
 1096              	XMC_VADC_GLOBAL_BackgroundGetNumChannelsPending:
 1097              	.LFB107:
1356:../Libraries/XMCLib/src/xmc_vadc.c **** 
1357:../Libraries/XMCLib/src/xmc_vadc.c **** /* API to determine how many channels are awaiting conversion */
1358:../Libraries/XMCLib/src/xmc_vadc.c **** uint32_t XMC_VADC_GLOBAL_BackgroundGetNumChannelsPending(XMC_VADC_GLOBAL_t *const global_ptr)
1359:../Libraries/XMCLib/src/xmc_vadc.c **** {
 1098              	 .loc 1 1359 0
 1099              	 .cfi_startproc
 1100 0000 80B5     	 push {r7,lr}
 1101              	.LCFI49:
 1102              	 .cfi_def_cfa_offset 8
 1103              	 .cfi_offset 7,-8
 1104              	 .cfi_offset 14,-4
 1105 0002 86B0     	 sub sp,sp,#24
 1106              	.LCFI50:
 1107              	 .cfi_def_cfa_offset 32
 1108 0004 00AF     	 add r7,sp,#0
 1109              	.LCFI51:
 1110              	 .cfi_def_cfa_register 7
 1111 0006 7860     	 str r0,[r7,#4]
1360:../Libraries/XMCLib/src/xmc_vadc.c ****   uint32_t reg;
1361:../Libraries/XMCLib/src/xmc_vadc.c ****   uint32_t i;
1362:../Libraries/XMCLib/src/xmc_vadc.c ****   uint32_t j;
1363:../Libraries/XMCLib/src/xmc_vadc.c ****   uint32_t count;
1364:../Libraries/XMCLib/src/xmc_vadc.c **** 
1365:../Libraries/XMCLib/src/xmc_vadc.c ****   XMC_ASSERT("XMC_VADC_GLOBAL_BackgroundGetNumChannelsPending:Wrong Module Pointer", (global_ptr ==
1366:../Libraries/XMCLib/src/xmc_vadc.c **** 
1367:../Libraries/XMCLib/src/xmc_vadc.c ****   count = 0U;
 1112              	 .loc 1 1367 0
 1113 0008 0023     	 mov r3,#0
 1114 000a BB60     	 str r3,[r7,#8]
1368:../Libraries/XMCLib/src/xmc_vadc.c ****   
1369:../Libraries/XMCLib/src/xmc_vadc.c ****   /* Loop through all groups and find out who is awaiting conversion */
1370:../Libraries/XMCLib/src/xmc_vadc.c ****   for(i = 0U; i < XMC_VADC_MAXIMUM_NUM_GROUPS; i++)
 1115              	 .loc 1 1370 0
 1116 000c 0023     	 mov r3,#0
 1117 000e 3B61     	 str r3,[r7,#16]
 1118 0010 22E0     	 b .L49
 1119              	.L54:
1371:../Libraries/XMCLib/src/xmc_vadc.c ****   {
1372:../Libraries/XMCLib/src/xmc_vadc.c ****     if (global_ptr->BRSSEL[i])
 1120              	 .loc 1 1372 0
 1121 0012 7B68     	 ldr r3,[r7,#4]
 1122 0014 3A69     	 ldr r2,[r7,#16]
 1123 0016 6032     	 add r2,r2,#96
 1124 0018 9200     	 lsl r2,r2,#2
 1125 001a D358     	 ldr r3,[r2,r3]
 1126 001c 002B     	 cmp r3,#0
 1127 001e 18D0     	 beq .L50
1373:../Libraries/XMCLib/src/xmc_vadc.c ****     {
1374:../Libraries/XMCLib/src/xmc_vadc.c ****       reg = global_ptr->BRSPND[i];
 1128              	 .loc 1 1374 0
 1129 0020 7B68     	 ldr r3,[r7,#4]
 1130 0022 3A69     	 ldr r2,[r7,#16]
 1131 0024 7032     	 add r2,r2,#112
 1132 0026 9200     	 lsl r2,r2,#2
 1133 0028 D358     	 ldr r3,[r2,r3]
 1134 002a 7B61     	 str r3,[r7,#20]
1375:../Libraries/XMCLib/src/xmc_vadc.c **** 
1376:../Libraries/XMCLib/src/xmc_vadc.c ****       for(j=0U;j<XMC_VADC_NUM_CHANNELS_PER_GROUP;j++)
 1135              	 .loc 1 1376 0
 1136 002c 0023     	 mov r3,#0
 1137 002e FB60     	 str r3,[r7,#12]
 1138 0030 0CE0     	 b .L51
 1139              	.L53:
1377:../Libraries/XMCLib/src/xmc_vadc.c ****       {
1378:../Libraries/XMCLib/src/xmc_vadc.c ****         if (reg & 1U)
 1140              	 .loc 1 1378 0
 1141 0032 7B69     	 ldr r3,[r7,#20]
 1142 0034 0122     	 mov r2,#1
 1143 0036 1340     	 and r3,r2
 1144 0038 02D0     	 beq .L52
1379:../Libraries/XMCLib/src/xmc_vadc.c ****         {
1380:../Libraries/XMCLib/src/xmc_vadc.c ****           count++;
 1145              	 .loc 1 1380 0
 1146 003a BB68     	 ldr r3,[r7,#8]
 1147 003c 0133     	 add r3,r3,#1
 1148 003e BB60     	 str r3,[r7,#8]
 1149              	.L52:
1381:../Libraries/XMCLib/src/xmc_vadc.c ****         }
1382:../Libraries/XMCLib/src/xmc_vadc.c **** 
1383:../Libraries/XMCLib/src/xmc_vadc.c ****         reg = reg >> 1U;
 1150              	 .loc 1 1383 0 discriminator 2
 1151 0040 7B69     	 ldr r3,[r7,#20]
 1152 0042 5B08     	 lsr r3,r3,#1
 1153 0044 7B61     	 str r3,[r7,#20]
1376:../Libraries/XMCLib/src/xmc_vadc.c ****       {
 1154              	 .loc 1 1376 0 discriminator 2
 1155 0046 FB68     	 ldr r3,[r7,#12]
 1156 0048 0133     	 add r3,r3,#1
 1157 004a FB60     	 str r3,[r7,#12]
 1158              	.L51:
1376:../Libraries/XMCLib/src/xmc_vadc.c ****       {
 1159              	 .loc 1 1376 0 is_stmt 0 discriminator 1
 1160 004c FB68     	 ldr r3,[r7,#12]
 1161 004e 072B     	 cmp r3,#7
 1162 0050 EFD9     	 bls .L53
 1163              	.L50:
1370:../Libraries/XMCLib/src/xmc_vadc.c ****   {
 1164              	 .loc 1 1370 0 is_stmt 1 discriminator 2
 1165 0052 3B69     	 ldr r3,[r7,#16]
 1166 0054 0133     	 add r3,r3,#1
 1167 0056 3B61     	 str r3,[r7,#16]
 1168              	.L49:
1370:../Libraries/XMCLib/src/xmc_vadc.c ****   {
 1169              	 .loc 1 1370 0 is_stmt 0 discriminator 1
 1170 0058 3B69     	 ldr r3,[r7,#16]
 1171 005a 012B     	 cmp r3,#1
 1172 005c D9D9     	 bls .L54
1384:../Libraries/XMCLib/src/xmc_vadc.c ****       }
1385:../Libraries/XMCLib/src/xmc_vadc.c ****     }
1386:../Libraries/XMCLib/src/xmc_vadc.c ****   }
1387:../Libraries/XMCLib/src/xmc_vadc.c **** 
1388:../Libraries/XMCLib/src/xmc_vadc.c ****   return count;
 1173              	 .loc 1 1388 0 is_stmt 1
 1174 005e BB68     	 ldr r3,[r7,#8]
1389:../Libraries/XMCLib/src/xmc_vadc.c **** }
 1175              	 .loc 1 1389 0
 1176 0060 181C     	 mov r0,r3
 1177 0062 BD46     	 mov sp,r7
 1178 0064 06B0     	 add sp,sp,#24
 1179              	 
 1180 0066 80BD     	 pop {r7,pc}
 1181              	 .cfi_endproc
 1182              	.LFE107:
 1184              	 .text
 1185              	.Letext0:
 1186              	 .file 2 "c:\\infineon\\tools\\dave ide\\4.5.0.202105191637\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\machine\\_default_types.h"
 1187              	 .file 3 "c:\\infineon\\tools\\dave ide\\4.5.0.202105191637\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\stdint.h"
 1188              	 .file 4 "C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Infineon/XMC1100_series/Include/XMC1100.h"
 1189              	 .file 5 "C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/XMCLib/inc/xmc_vadc.h"
 1190              	 .file 6 "C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/XMCLib/inc/xmc1_scu.h"
 1191              	 .file 7 "C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Infineon/XMC1100_series/Include/system_XMC1100.h"
DEFINED SYMBOLS
                            *ABS*:00000000 xmc_vadc.c
    {standard input}:18     .text.XMC_VADC_GLOBAL_EnableModule:00000000 $t
    {standard input}:23     .text.XMC_VADC_GLOBAL_EnableModule:00000000 XMC_VADC_GLOBAL_EnableModule
    {standard input}:47     .text.XMC_VADC_GLOBAL_DisableModule:00000000 $t
    {standard input}:52     .text.XMC_VADC_GLOBAL_DisableModule:00000000 XMC_VADC_GLOBAL_DisableModule
    {standard input}:75     .text.XMC_VADC_GLOBAL_Init:00000000 $t
    {standard input}:80     .text.XMC_VADC_GLOBAL_Init:00000000 XMC_VADC_GLOBAL_Init
    {standard input}:151    .text.XMC_VADC_GLOBAL_Init:0000005c $d
    {standard input}:158    .text.XMC_VADC_GLOBAL_InputClassInit:00000000 $t
    {standard input}:163    .text.XMC_VADC_GLOBAL_InputClassInit:00000000 XMC_VADC_GLOBAL_InputClassInit
    {standard input}:201    .text.XMC_VADC_GLOBAL_InputClassInit:00000028 $d
    {standard input}:206    .text.XMC_VADC_GLOBAL_StartupCalibration:00000000 $t
    {standard input}:211    .text.XMC_VADC_GLOBAL_StartupCalibration:00000000 XMC_VADC_GLOBAL_StartupCalibration
    {standard input}:254    .text.XMC_VADC_GLOBAL_StartupCalibration:0000002c $d
    {standard input}:259    .text.XMC_VADC_GLOBAL_SetCompareValue:00000000 $t
    {standard input}:264    .text.XMC_VADC_GLOBAL_SetCompareValue:00000000 XMC_VADC_GLOBAL_SetCompareValue
    {standard input}:317    .text.XMC_VADC_GLOBAL_GetCompareResult:00000000 $t
    {standard input}:322    .text.XMC_VADC_GLOBAL_GetCompareResult:00000000 XMC_VADC_GLOBAL_GetCompareResult
    {standard input}:379    .text.XMC_VADC_GLOBAL_SetResultEventInterruptNode:00000000 $t
    {standard input}:384    .text.XMC_VADC_GLOBAL_SetResultEventInterruptNode:00000000 XMC_VADC_GLOBAL_SetResultEventInterruptNode
    {standard input}:453    .text.XMC_VADC_GLOBAL_SetResultEventInterruptNode:0000005c $d
    {standard input}:458    .text.XMC_VADC_GLOBAL_BackgroundSetReqSrcEventInterruptNode:00000000 $t
    {standard input}:463    .text.XMC_VADC_GLOBAL_BackgroundSetReqSrcEventInterruptNode:00000000 XMC_VADC_GLOBAL_BackgroundSetReqSrcEventInterruptNode
    {standard input}:532    .text.XMC_VADC_GLOBAL_SHS_Init:00000000 $t
    {standard input}:537    .text.XMC_VADC_GLOBAL_SHS_Init:00000000 XMC_VADC_GLOBAL_SHS_Init
    {standard input}:571    .text.XMC_VADC_GLOBAL_SHS_SetGainFactor:00000000 $t
    {standard input}:576    .text.XMC_VADC_GLOBAL_SHS_SetGainFactor:00000000 XMC_VADC_GLOBAL_SHS_SetGainFactor
    {standard input}:696    .text.XMC_VADC_GLOBAL_SHS_SetSigmaDeltaLoop:00000000 $t
    {standard input}:701    .text.XMC_VADC_GLOBAL_SHS_SetSigmaDeltaLoop:00000000 XMC_VADC_GLOBAL_SHS_SetSigmaDeltaLoop
    {standard input}:768    .text.XMC_VADC_GLOBAL_SHS_SetSigmaDeltaLoop:0000005c $d
    {standard input}:773    .text.XMC_VADC_GLOBAL_BackgroundInit:00000000 $t
    {standard input}:778    .text.XMC_VADC_GLOBAL_BackgroundInit:00000000 XMC_VADC_GLOBAL_BackgroundInit
    {standard input}:823    .text.XMC_VADC_GLOBAL_BackgroundInit:00000034 $d
    {standard input}:828    .text.XMC_VADC_GLOBAL_BackgroundSelectTrigger:00000000 $t
    {standard input}:833    .text.XMC_VADC_GLOBAL_BackgroundSelectTrigger:00000000 XMC_VADC_GLOBAL_BackgroundSelectTrigger
    {standard input}:887    .text.XMC_VADC_GLOBAL_BackgroundSelectTrigger:00000040 $d
    {standard input}:892    .text.XMC_VADC_GLOBAL_BackgroundSelectTriggerEdge:00000000 $t
    {standard input}:897    .text.XMC_VADC_GLOBAL_BackgroundSelectTriggerEdge:00000000 XMC_VADC_GLOBAL_BackgroundSelectTriggerEdge
    {standard input}:954    .text.XMC_VADC_GLOBAL_BackgroundSelectTriggerEdge:00000048 $d
    {standard input}:959    .text.XMC_VADC_GLOBAL_BackgroundSelectGating:00000000 $t
    {standard input}:964    .text.XMC_VADC_GLOBAL_BackgroundSelectGating:00000000 XMC_VADC_GLOBAL_BackgroundSelectGating
    {standard input}:1018   .text.XMC_VADC_GLOBAL_BackgroundSelectGating:00000040 $d
    {standard input}:1023   .text.XMC_VADC_GLOBAL_BackgroundAbortSequence:00000000 $t
    {standard input}:1028   .text.XMC_VADC_GLOBAL_BackgroundAbortSequence:00000000 XMC_VADC_GLOBAL_BackgroundAbortSequence
    {standard input}:1086   .text.XMC_VADC_GLOBAL_BackgroundAbortSequence:0000004c $d
    {standard input}:1091   .text.XMC_VADC_GLOBAL_BackgroundGetNumChannelsPending:00000000 $t
    {standard input}:1096   .text.XMC_VADC_GLOBAL_BackgroundGetNumChannelsPending:00000000 XMC_VADC_GLOBAL_BackgroundGetNumChannelsPending
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
XMC_SCU_CLOCK_UngatePeripheralClock
XMC_SCU_CLOCK_GatePeripheralClock
