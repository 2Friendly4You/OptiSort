   1              	 .cpu cortex-m0
   2              	 .fpu softvfp
   3              	 .eabi_attribute 20,1
   4              	 .eabi_attribute 21,1
   5              	 .eabi_attribute 23,3
   6              	 .eabi_attribute 24,1
   7              	 .eabi_attribute 25,1
   8              	 .eabi_attribute 26,1
   9              	 .eabi_attribute 30,6
  10              	 .eabi_attribute 34,0
  11              	 .eabi_attribute 18,4
  12              	 .code 16
  13              	 .file "XMC1100-LibHaas.c"
  14              	 .text
  15              	.Ltext0:
  16              	 .cfi_sections .debug_frame
  17              	 .section .text.__NVIC_EnableIRQ,"ax",%progbits
  18              	 .align 2
  19              	 .code 16
  20              	 .thumb_func
  22              	__NVIC_EnableIRQ:
  23              	.LFB23:
  24              	 .file 1 "C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include/core_cm0.h"
   1:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** /**************************************************************************//**
   2:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****  * @file     core_cm0.h
   3:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****  * @brief    CMSIS Cortex-M0 Core Peripheral Access Layer Header File
   4:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****  * @version  V5.0.2
   5:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****  * @date     19. April 2017
   6:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****  ******************************************************************************/
   7:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** /*
   8:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****  * Copyright (c) 2009-2017 ARM Limited. All rights reserved.
   9:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****  *
  10:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****  * SPDX-License-Identifier: Apache-2.0
  11:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****  *
  12:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****  * Licensed under the Apache License, Version 2.0 (the License); you may
  13:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****  * not use this file except in compliance with the License.
  14:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****  * You may obtain a copy of the License at
  15:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****  *
  16:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****  * www.apache.org/licenses/LICENSE-2.0
  17:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****  *
  18:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****  * Unless required by applicable law or agreed to in writing, software
  19:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****  * distributed under the License is distributed on an AS IS BASIS, WITHOUT
  20:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  21:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****  * See the License for the specific language governing permissions and
  22:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****  * limitations under the License.
  23:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****  */
  24:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
  25:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #if   defined ( __ICCARM__ )
  26:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   #pragma system_include         /* treat file as system include file for MISRA check */
  27:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #elif defined (__clang__)
  28:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   #pragma clang system_header   /* treat file as system include file */
  29:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #endif
  30:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
  31:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #ifndef __CORE_CM0_H_GENERIC
  32:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define __CORE_CM0_H_GENERIC
  33:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
  34:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #include <stdint.h>
  35:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
  36:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #ifdef __cplusplus
  37:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****  extern "C" {
  38:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #endif
  39:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
  40:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** /**
  41:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
  42:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   CMSIS violates the following MISRA-C:2004 rules:
  43:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
  44:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****    \li Required Rule 8.5, object/function definition in header file.<br>
  45:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****      Function definitions in header files are used to allow 'inlining'.
  46:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
  47:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****    \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
  48:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****      Unions are used for effective representation of core registers.
  49:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
  50:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****    \li Advisory Rule 19.7, Function-like macro defined.<br>
  51:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****      Function-like macros are used to allow more efficient code.
  52:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****  */
  53:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
  54:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
  55:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** /*******************************************************************************
  56:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****  *                 CMSIS definitions
  57:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****  ******************************************************************************/
  58:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** /**
  59:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   \ingroup Cortex_M0
  60:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   @{
  61:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****  */
  62:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
  63:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #include "cmsis_version.h"
  64:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****  
  65:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** /*  CMSIS CM0 definitions */
  66:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define __CM0_CMSIS_VERSION_MAIN  (__CM_CMSIS_VERSION_MAIN)              /*!< \deprecated [31:16] C
  67:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define __CM0_CMSIS_VERSION_SUB   (__CM_CMSIS_VERSION_SUB)               /*!< \deprecated [15:0]  C
  68:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define __CM0_CMSIS_VERSION       ((__CM0_CMSIS_VERSION_MAIN << 16U) | \
  69:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****                                     __CM0_CMSIS_VERSION_SUB           )  /*!< \deprecated CMSIS HAL
  70:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
  71:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define __CORTEX_M                (0U)                                   /*!< Cortex-M Core */
  72:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
  73:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** /** __FPU_USED indicates whether an FPU is used or not.
  74:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****     This core does not support an FPU at all
  75:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** */
  76:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define __FPU_USED       0U
  77:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
  78:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #if defined ( __CC_ARM )
  79:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   #if defined __TARGET_FPU_VFP
  80:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
  81:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   #endif
  82:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
  83:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
  84:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   #if defined __ARM_PCS_VFP
  85:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
  86:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   #endif
  87:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
  88:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #elif defined ( __GNUC__ )
  89:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   #if defined (__VFP_FP__) && !defined(__SOFTFP__)
  90:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
  91:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   #endif
  92:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
  93:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #elif defined ( __ICCARM__ )
  94:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   #if defined __ARMVFP__
  95:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
  96:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   #endif
  97:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
  98:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #elif defined ( __TI_ARM__ )
  99:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   #if defined __TI_VFP_SUPPORT__
 100:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 101:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   #endif
 102:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 103:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #elif defined ( __TASKING__ )
 104:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   #if defined __FPU_VFP__
 105:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 106:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   #endif
 107:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 108:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #elif defined ( __CSMC__ )
 109:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   #if ( __CSMC__ & 0x400U)
 110:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 111:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   #endif
 112:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 113:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #endif
 114:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 115:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #include "cmsis_compiler.h"               /* CMSIS compiler specific defines */
 116:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 117:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 118:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #ifdef __cplusplus
 119:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** }
 120:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #endif
 121:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 122:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #endif /* __CORE_CM0_H_GENERIC */
 123:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 124:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #ifndef __CMSIS_GENERIC
 125:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 126:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #ifndef __CORE_CM0_H_DEPENDANT
 127:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define __CORE_CM0_H_DEPENDANT
 128:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 129:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #ifdef __cplusplus
 130:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****  extern "C" {
 131:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #endif
 132:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 133:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** /* check device defines and use defaults */
 134:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #if defined __CHECK_DEVICE_DEFINES
 135:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   #ifndef __CM0_REV
 136:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****     #define __CM0_REV               0x0000U
 137:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****     #warning "__CM0_REV not defined in device header file; using default!"
 138:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   #endif
 139:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 140:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   #ifndef __NVIC_PRIO_BITS
 141:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****     #define __NVIC_PRIO_BITS          2U
 142:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****     #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
 143:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   #endif
 144:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 145:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   #ifndef __Vendor_SysTickConfig
 146:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****     #define __Vendor_SysTickConfig    0U
 147:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****     #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
 148:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   #endif
 149:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #endif
 150:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 151:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** /* IO definitions (access restrictions to peripheral registers) */
 152:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** /**
 153:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****     \defgroup CMSIS_glob_defs CMSIS Global Defines
 154:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 155:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****     <strong>IO Type Qualifiers</strong> are used
 156:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****     \li to specify the access to peripheral variables.
 157:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****     \li for automatic generation of peripheral register debug information.
 158:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** */
 159:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #ifdef __cplusplus
 160:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   #define   __I     volatile             /*!< Defines 'read only' permissions */
 161:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #else
 162:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   #define   __I     volatile const       /*!< Defines 'read only' permissions */
 163:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #endif
 164:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define     __O     volatile             /*!< Defines 'write only' permissions */
 165:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define     __IO    volatile             /*!< Defines 'read / write' permissions */
 166:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 167:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** /* following defines should be used for structure members */
 168:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define     __IM     volatile const      /*! Defines 'read only' structure member permissions */
 169:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define     __OM     volatile            /*! Defines 'write only' structure member permissions */
 170:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define     __IOM    volatile            /*! Defines 'read / write' structure member permissions */
 171:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 172:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** /*@} end of group Cortex_M0 */
 173:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 174:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 175:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 176:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** /*******************************************************************************
 177:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****  *                 Register Abstraction
 178:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   Core Register contain:
 179:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   - Core Register
 180:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   - Core NVIC Register
 181:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   - Core SCB Register
 182:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   - Core SysTick Register
 183:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****  ******************************************************************************/
 184:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** /**
 185:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   \defgroup CMSIS_core_register Defines and Type Definitions
 186:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   \brief Type definitions and defines for Cortex-M processor based devices.
 187:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** */
 188:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 189:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** /**
 190:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   \ingroup    CMSIS_core_register
 191:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   \defgroup   CMSIS_CORE  Status and Control Registers
 192:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   \brief      Core Register type definitions.
 193:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   @{
 194:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****  */
 195:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 196:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** /**
 197:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   \brief  Union type to access the Application Program Status Register (APSR).
 198:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****  */
 199:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** typedef union
 200:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** {
 201:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   struct
 202:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   {
 203:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****     uint32_t _reserved0:28;              /*!< bit:  0..27  Reserved */
 204:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****     uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
 205:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****     uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
 206:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****     uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
 207:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****     uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
 208:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   } b;                                   /*!< Structure used for bit  access */
 209:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   uint32_t w;                            /*!< Type      used for word access */
 210:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** } APSR_Type;
 211:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 212:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** /* APSR Register Definitions */
 213:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define APSR_N_Pos                         31U                                            /*!< APSR
 214:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define APSR_N_Msk                         (1UL << APSR_N_Pos)                            /*!< APSR
 215:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 216:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define APSR_Z_Pos                         30U                                            /*!< APSR
 217:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define APSR_Z_Msk                         (1UL << APSR_Z_Pos)                            /*!< APSR
 218:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 219:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define APSR_C_Pos                         29U                                            /*!< APSR
 220:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define APSR_C_Msk                         (1UL << APSR_C_Pos)                            /*!< APSR
 221:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 222:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define APSR_V_Pos                         28U                                            /*!< APSR
 223:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define APSR_V_Msk                         (1UL << APSR_V_Pos)                            /*!< APSR
 224:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 225:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 226:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** /**
 227:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   \brief  Union type to access the Interrupt Program Status Register (IPSR).
 228:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****  */
 229:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** typedef union
 230:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** {
 231:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   struct
 232:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   {
 233:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****     uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
 234:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****     uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved */
 235:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   } b;                                   /*!< Structure used for bit  access */
 236:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   uint32_t w;                            /*!< Type      used for word access */
 237:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** } IPSR_Type;
 238:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 239:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** /* IPSR Register Definitions */
 240:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define IPSR_ISR_Pos                        0U                                            /*!< IPSR
 241:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define IPSR_ISR_Msk                       (0x1FFUL /*<< IPSR_ISR_Pos*/)                  /*!< IPSR
 242:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 243:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 244:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** /**
 245:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
 246:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****  */
 247:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** typedef union
 248:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** {
 249:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   struct
 250:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   {
 251:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****     uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
 252:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****     uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved */
 253:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****     uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0) */
 254:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****     uint32_t _reserved1:3;               /*!< bit: 25..27  Reserved */
 255:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****     uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
 256:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****     uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
 257:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****     uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
 258:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****     uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
 259:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   } b;                                   /*!< Structure used for bit  access */
 260:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   uint32_t w;                            /*!< Type      used for word access */
 261:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** } xPSR_Type;
 262:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 263:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** /* xPSR Register Definitions */
 264:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define xPSR_N_Pos                         31U                                            /*!< xPSR
 265:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define xPSR_N_Msk                         (1UL << xPSR_N_Pos)                            /*!< xPSR
 266:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 267:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define xPSR_Z_Pos                         30U                                            /*!< xPSR
 268:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define xPSR_Z_Msk                         (1UL << xPSR_Z_Pos)                            /*!< xPSR
 269:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 270:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define xPSR_C_Pos                         29U                                            /*!< xPSR
 271:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define xPSR_C_Msk                         (1UL << xPSR_C_Pos)                            /*!< xPSR
 272:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 273:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define xPSR_V_Pos                         28U                                            /*!< xPSR
 274:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define xPSR_V_Msk                         (1UL << xPSR_V_Pos)                            /*!< xPSR
 275:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 276:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define xPSR_T_Pos                         24U                                            /*!< xPSR
 277:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define xPSR_T_Msk                         (1UL << xPSR_T_Pos)                            /*!< xPSR
 278:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 279:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define xPSR_ISR_Pos                        0U                                            /*!< xPSR
 280:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define xPSR_ISR_Msk                       (0x1FFUL /*<< xPSR_ISR_Pos*/)                  /*!< xPSR
 281:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 282:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 283:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** /**
 284:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   \brief  Union type to access the Control Registers (CONTROL).
 285:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****  */
 286:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** typedef union
 287:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** {
 288:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   struct
 289:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   {
 290:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****     uint32_t _reserved0:1;               /*!< bit:      0  Reserved */
 291:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****     uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used */
 292:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****     uint32_t _reserved1:30;              /*!< bit:  2..31  Reserved */
 293:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   } b;                                   /*!< Structure used for bit  access */
 294:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   uint32_t w;                            /*!< Type      used for word access */
 295:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** } CONTROL_Type;
 296:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 297:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** /* CONTROL Register Definitions */
 298:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define CONTROL_SPSEL_Pos                   1U                                            /*!< CONT
 299:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define CONTROL_SPSEL_Msk                  (1UL << CONTROL_SPSEL_Pos)                     /*!< CONT
 300:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 301:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** /*@} end of group CMSIS_CORE */
 302:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 303:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 304:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** /**
 305:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   \ingroup    CMSIS_core_register
 306:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
 307:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   \brief      Type definitions for the NVIC Registers
 308:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   @{
 309:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****  */
 310:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 311:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** /**
 312:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
 313:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****  */
 314:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** typedef struct
 315:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** {
 316:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   __IOM uint32_t ISER[1U];               /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register */
 317:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****         uint32_t RESERVED0[31U];
 318:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   __IOM uint32_t ICER[1U];               /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register 
 319:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****         uint32_t RSERVED1[31U];
 320:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   __IOM uint32_t ISPR[1U];               /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register *
 321:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****         uint32_t RESERVED2[31U];
 322:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   __IOM uint32_t ICPR[1U];               /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register
 323:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****         uint32_t RESERVED3[31U];
 324:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****         uint32_t RESERVED4[64U];
 325:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   __IOM uint32_t IP[8U];                 /*!< Offset: 0x300 (R/W)  Interrupt Priority Register */
 326:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** }  NVIC_Type;
 327:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 328:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** /*@} end of group CMSIS_NVIC */
 329:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 330:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 331:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** /**
 332:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   \ingroup  CMSIS_core_register
 333:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   \defgroup CMSIS_SCB     System Control Block (SCB)
 334:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   \brief    Type definitions for the System Control Block Registers
 335:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   @{
 336:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****  */
 337:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 338:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** /**
 339:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   \brief  Structure type to access the System Control Block (SCB).
 340:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****  */
 341:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** typedef struct
 342:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** {
 343:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   __IM  uint32_t CPUID;                  /*!< Offset: 0x000 (R/ )  CPUID Base Register */
 344:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   __IOM uint32_t ICSR;                   /*!< Offset: 0x004 (R/W)  Interrupt Control and State Regi
 345:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****         uint32_t RESERVED0;
 346:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   __IOM uint32_t AIRCR;                  /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset 
 347:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   __IOM uint32_t SCR;                    /*!< Offset: 0x010 (R/W)  System Control Register */
 348:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   __IOM uint32_t CCR;                    /*!< Offset: 0x014 (R/W)  Configuration Control Register *
 349:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****         uint32_t RESERVED1;
 350:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   __IOM uint32_t SHP[2U];                /*!< Offset: 0x01C (R/W)  System Handlers Priority Registe
 351:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   __IOM uint32_t SHCSR;                  /*!< Offset: 0x024 (R/W)  System Handler Control and State
 352:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** } SCB_Type;
 353:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 354:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** /* SCB CPUID Register Definitions */
 355:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_CPUID_IMPLEMENTER_Pos          24U                                            /*!< SCB 
 356:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB 
 357:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 358:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_CPUID_VARIANT_Pos              20U                                            /*!< SCB 
 359:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB 
 360:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 361:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_CPUID_ARCHITECTURE_Pos         16U                                            /*!< SCB 
 362:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB 
 363:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 364:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_CPUID_PARTNO_Pos                4U                                            /*!< SCB 
 365:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB 
 366:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 367:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_CPUID_REVISION_Pos              0U                                            /*!< SCB 
 368:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_CPUID_REVISION_Msk             (0xFUL /*<< SCB_CPUID_REVISION_Pos*/)          /*!< SCB 
 369:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 370:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** /* SCB Interrupt Control State Register Definitions */
 371:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_ICSR_NMIPENDSET_Pos            31U                                            /*!< SCB 
 372:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB 
 373:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 374:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_ICSR_PENDSVSET_Pos             28U                                            /*!< SCB 
 375:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB 
 376:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 377:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_ICSR_PENDSVCLR_Pos             27U                                            /*!< SCB 
 378:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB 
 379:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 380:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_ICSR_PENDSTSET_Pos             26U                                            /*!< SCB 
 381:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB 
 382:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 383:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_ICSR_PENDSTCLR_Pos             25U                                            /*!< SCB 
 384:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB 
 385:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 386:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_ICSR_ISRPREEMPT_Pos            23U                                            /*!< SCB 
 387:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB 
 388:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 389:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_ICSR_ISRPENDING_Pos            22U                                            /*!< SCB 
 390:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB 
 391:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 392:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_ICSR_VECTPENDING_Pos           12U                                            /*!< SCB 
 393:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB 
 394:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 395:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_ICSR_VECTACTIVE_Pos             0U                                            /*!< SCB 
 396:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL /*<< SCB_ICSR_VECTACTIVE_Pos*/)       /*!< SCB 
 397:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 398:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** /* SCB Application Interrupt and Reset Control Register Definitions */
 399:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_AIRCR_VECTKEY_Pos              16U                                            /*!< SCB 
 400:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB 
 401:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 402:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_AIRCR_VECTKEYSTAT_Pos          16U                                            /*!< SCB 
 403:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB 
 404:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 405:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_AIRCR_ENDIANESS_Pos            15U                                            /*!< SCB 
 406:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB 
 407:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 408:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_AIRCR_SYSRESETREQ_Pos           2U                                            /*!< SCB 
 409:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB 
 410:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 411:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_AIRCR_VECTCLRACTIVE_Pos         1U                                            /*!< SCB 
 412:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB 
 413:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 414:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** /* SCB System Control Register Definitions */
 415:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_SCR_SEVONPEND_Pos               4U                                            /*!< SCB 
 416:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB 
 417:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 418:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_SCR_SLEEPDEEP_Pos               2U                                            /*!< SCB 
 419:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB 
 420:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 421:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_SCR_SLEEPONEXIT_Pos             1U                                            /*!< SCB 
 422:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB 
 423:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 424:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** /* SCB Configuration Control Register Definitions */
 425:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_CCR_STKALIGN_Pos                9U                                            /*!< SCB 
 426:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB 
 427:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 428:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_CCR_UNALIGN_TRP_Pos             3U                                            /*!< SCB 
 429:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB 
 430:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 431:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** /* SCB System Handler Control and State Register Definitions */
 432:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_SHCSR_SVCALLPENDED_Pos         15U                                            /*!< SCB 
 433:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB 
 434:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 435:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** /*@} end of group CMSIS_SCB */
 436:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 437:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 438:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** /**
 439:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   \ingroup  CMSIS_core_register
 440:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
 441:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   \brief    Type definitions for the System Timer Registers.
 442:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   @{
 443:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****  */
 444:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 445:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** /**
 446:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   \brief  Structure type to access the System Timer (SysTick).
 447:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****  */
 448:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** typedef struct
 449:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** {
 450:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  SysTick Control and Status Regis
 451:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   __IOM uint32_t LOAD;                   /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register */
 452:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   __IOM uint32_t VAL;                    /*!< Offset: 0x008 (R/W)  SysTick Current Value Register *
 453:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   __IM  uint32_t CALIB;                  /*!< Offset: 0x00C (R/ )  SysTick Calibration Register */
 454:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** } SysTick_Type;
 455:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 456:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** /* SysTick Control / Status Register Definitions */
 457:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define SysTick_CTRL_COUNTFLAG_Pos         16U                                            /*!< SysT
 458:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysT
 459:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 460:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define SysTick_CTRL_CLKSOURCE_Pos          2U                                            /*!< SysT
 461:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysT
 462:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 463:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define SysTick_CTRL_TICKINT_Pos            1U                                            /*!< SysT
 464:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysT
 465:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 466:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define SysTick_CTRL_ENABLE_Pos             0U                                            /*!< SysT
 467:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define SysTick_CTRL_ENABLE_Msk            (1UL /*<< SysTick_CTRL_ENABLE_Pos*/)           /*!< SysT
 468:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 469:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** /* SysTick Reload Register Definitions */
 470:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define SysTick_LOAD_RELOAD_Pos             0U                                            /*!< SysT
 471:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL /*<< SysTick_LOAD_RELOAD_Pos*/)    /*!< SysT
 472:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 473:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** /* SysTick Current Register Definitions */
 474:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define SysTick_VAL_CURRENT_Pos             0U                                            /*!< SysT
 475:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL /*<< SysTick_VAL_CURRENT_Pos*/)    /*!< SysT
 476:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 477:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** /* SysTick Calibration Register Definitions */
 478:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define SysTick_CALIB_NOREF_Pos            31U                                            /*!< SysT
 479:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysT
 480:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 481:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define SysTick_CALIB_SKEW_Pos             30U                                            /*!< SysT
 482:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysT
 483:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 484:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define SysTick_CALIB_TENMS_Pos             0U                                            /*!< SysT
 485:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL /*<< SysTick_CALIB_TENMS_Pos*/)    /*!< SysT
 486:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 487:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** /*@} end of group CMSIS_SysTick */
 488:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 489:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 490:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** /**
 491:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   \ingroup  CMSIS_core_register
 492:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
 493:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   \brief    Cortex-M0 Core Debug Registers (DCB registers, SHCSR, and DFSR) are only accessible ove
 494:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****             Therefore they are not covered by the Cortex-M0 header file.
 495:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   @{
 496:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****  */
 497:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** /*@} end of group CMSIS_CoreDebug */
 498:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 499:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 500:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** /**
 501:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   \ingroup    CMSIS_core_register
 502:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   \defgroup   CMSIS_core_bitfield     Core register bit field macros
 503:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   \brief      Macros for use with bit field definitions (xxx_Pos, xxx_Msk).
 504:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   @{
 505:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****  */
 506:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 507:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** /**
 508:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   \brief   Mask and shift a bit field value for use in a register bit range.
 509:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   \param[in] field  Name of the register bit field.
 510:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   \param[in] value  Value of the bit field. This parameter is interpreted as an uint32_t type.
 511:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   \return           Masked and shifted value.
 512:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** */
 513:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define _VAL2FLD(field, value)    (((uint32_t)(value) << field ## _Pos) & field ## _Msk)
 514:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 515:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** /**
 516:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   \brief     Mask and shift a register value to extract a bit filed value.
 517:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   \param[in] field  Name of the register bit field.
 518:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   \param[in] value  Value of register. This parameter is interpreted as an uint32_t type.
 519:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   \return           Masked and shifted bit field value.
 520:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** */
 521:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define _FLD2VAL(field, value)    (((uint32_t)(value) & field ## _Msk) >> field ## _Pos)
 522:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 523:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** /*@} end of group CMSIS_core_bitfield */
 524:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 525:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 526:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** /**
 527:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   \ingroup    CMSIS_core_register
 528:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   \defgroup   CMSIS_core_base     Core Definitions
 529:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   \brief      Definitions for base addresses, unions, and structures.
 530:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   @{
 531:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****  */
 532:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 533:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** /* Memory mapping of Core Hardware */
 534:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Bas
 535:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address */
 536:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address */
 537:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Bas
 538:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 539:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct
 540:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration st
 541:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struc
 542:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 543:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 544:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** /*@} */
 545:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 546:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 547:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 548:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** /*******************************************************************************
 549:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****  *                Hardware Abstraction Layer
 550:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   Core Function Interface contains:
 551:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   - Core NVIC Functions
 552:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   - Core SysTick Functions
 553:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   - Core Register Access Functions
 554:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****  ******************************************************************************/
 555:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** /**
 556:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
 557:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** */
 558:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 559:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 560:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 561:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** /* ##########################   NVIC functions  #################################### */
 562:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** /**
 563:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   \ingroup  CMSIS_Core_FunctionInterface
 564:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   \defgroup CMSIS_Core_NVICFunctions NVIC Functions
 565:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   \brief    Functions that manage interrupts and exceptions via the NVIC.
 566:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   @{
 567:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****  */
 568:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 569:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #ifdef CMSIS_NVIC_VIRTUAL
 570:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   #ifndef CMSIS_NVIC_VIRTUAL_HEADER_FILE
 571:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****     #define CMSIS_NVIC_VIRTUAL_HEADER_FILE "cmsis_nvic_virtual.h"
 572:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   #endif
 573:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   #include CMSIS_NVIC_VIRTUAL_HEADER_FILE
 574:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #else
 575:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** /*#define NVIC_SetPriorityGrouping    __NVIC_SetPriorityGrouping   not available for Cortex-M0 */
 576:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** /*#define NVIC_GetPriorityGrouping    __NVIC_GetPriorityGrouping   not available for Cortex-M0 */
 577:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   #define NVIC_EnableIRQ              __NVIC_EnableIRQ
 578:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   #define NVIC_GetEnableIRQ           __NVIC_GetEnableIRQ
 579:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   #define NVIC_DisableIRQ             __NVIC_DisableIRQ
 580:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   #define NVIC_GetPendingIRQ          __NVIC_GetPendingIRQ
 581:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   #define NVIC_SetPendingIRQ          __NVIC_SetPendingIRQ
 582:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   #define NVIC_ClearPendingIRQ        __NVIC_ClearPendingIRQ
 583:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** /*#define NVIC_GetActive              __NVIC_GetActive             not available for Cortex-M0 */
 584:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   #define NVIC_SetPriority            __NVIC_SetPriority
 585:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   #define NVIC_GetPriority            __NVIC_GetPriority
 586:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   #define NVIC_SystemReset            __NVIC_SystemReset
 587:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #endif /* CMSIS_NVIC_VIRTUAL */
 588:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 589:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #ifdef CMSIS_VECTAB_VIRTUAL
 590:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   #ifndef CMSIS_VECTAB_VIRTUAL_HEADER_FILE
 591:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****     #define CMSIS_VECTAB_VIRTUAL_HEADER_FILE "cmsis_vectab_virtual.h"
 592:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   #endif
 593:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   #include CMSIS_VECTAB_VIRTUAL_HEADER_FILE
 594:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #else
 595:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   #define NVIC_SetVector              __NVIC_SetVector
 596:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   #define NVIC_GetVector              __NVIC_GetVector
 597:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #endif  /* (CMSIS_VECTAB_VIRTUAL) */
 598:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 599:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define NVIC_USER_IRQ_OFFSET          16
 600:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 601:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 602:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** /* Interrupt Priorities are WORD accessible only under ARMv6M                   */
 603:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** /* The following MACROS handle generation of the register offset and byte masks */
 604:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define _BIT_SHIFT(IRQn)         (  ((((uint32_t)(int32_t)(IRQn))         )      &  0x03UL) * 8UL)
 605:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define _SHP_IDX(IRQn)           ( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >>    2UL)      )
 606:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** #define _IP_IDX(IRQn)            (   (((uint32_t)(int32_t)(IRQn))                >>    2UL)      )
 607:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 608:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 609:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** /**
 610:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   \brief   Enable Interrupt
 611:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   \details Enables a device specific interrupt in the NVIC interrupt controller.
 612:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   \param [in]      IRQn  Device specific interrupt number.
 613:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   \note    IRQn must not be negative.
 614:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****  */
 615:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** __STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
 616:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** {
  25              	 .loc 1 616 0
  26              	 .cfi_startproc
  27 0000 80B5     	 push {r7,lr}
  28              	.LCFI0:
  29              	 .cfi_def_cfa_offset 8
  30              	 .cfi_offset 7,-8
  31              	 .cfi_offset 14,-4
  32 0002 82B0     	 sub sp,sp,#8
  33              	.LCFI1:
  34              	 .cfi_def_cfa_offset 16
  35 0004 00AF     	 add r7,sp,#0
  36              	.LCFI2:
  37              	 .cfi_def_cfa_register 7
  38 0006 021C     	 mov r2,r0
  39 0008 FB1D     	 add r3,r7,#7
  40 000a 1A70     	 strb r2,[r3]
 617:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   if ((int32_t)(IRQn) >= 0)
  41              	 .loc 1 617 0
  42 000c FB1D     	 add r3,r7,#7
  43 000e 1B78     	 ldrb r3,[r3]
  44 0010 7F2B     	 cmp r3,#127
  45 0012 09D8     	 bhi .L1
 618:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   {
 619:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****     NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
  46              	 .loc 1 619 0
  47 0014 064B     	 ldr r3,.L3
  48 0016 FA1D     	 add r2,r7,#7
  49 0018 1278     	 ldrb r2,[r2]
  50 001a 111C     	 mov r1,r2
  51 001c 1F22     	 mov r2,#31
  52 001e 0A40     	 and r2,r1
  53 0020 0121     	 mov r1,#1
  54 0022 9140     	 lsl r1,r1,r2
  55 0024 0A1C     	 mov r2,r1
  56 0026 1A60     	 str r2,[r3]
  57              	.L1:
 620:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   }
 621:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** }
  58              	 .loc 1 621 0
  59 0028 BD46     	 mov sp,r7
  60 002a 02B0     	 add sp,sp,#8
  61              	 
  62 002c 80BD     	 pop {r7,pc}
  63              	.L4:
  64 002e C046     	 .align 2
  65              	.L3:
  66 0030 00E100E0 	 .word -536813312
  67              	 .cfi_endproc
  68              	.LFE23:
  70              	 .section .text.__NVIC_DisableIRQ,"ax",%progbits
  71              	 .align 2
  72              	 .code 16
  73              	 .thumb_func
  75              	__NVIC_DisableIRQ:
  76              	.LFB25:
 622:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 623:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 624:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** /**
 625:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   \brief   Get Interrupt Enable status
 626:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   \details Returns a device specific interrupt enable status from the NVIC interrupt controller.
 627:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   \param [in]      IRQn  Device specific interrupt number.
 628:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   \return             0  Interrupt is not enabled.
 629:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   \return             1  Interrupt is enabled.
 630:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   \note    IRQn must not be negative.
 631:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****  */
 632:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** __STATIC_INLINE uint32_t __NVIC_GetEnableIRQ(IRQn_Type IRQn)
 633:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** {
 634:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   if ((int32_t)(IRQn) >= 0)
 635:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   {
 636:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****     return((uint32_t)(((NVIC->ISER[0U] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1
 637:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   }
 638:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   else
 639:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   {
 640:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****     return(0U);
 641:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   }
 642:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** }
 643:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 644:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 645:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** /**
 646:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   \brief   Disable Interrupt
 647:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   \details Disables a device specific interrupt in the NVIC interrupt controller.
 648:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   \param [in]      IRQn  Device specific interrupt number.
 649:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   \note    IRQn must not be negative.
 650:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****  */
 651:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** __STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
 652:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** {
  77              	 .loc 1 652 0
  78              	 .cfi_startproc
  79 0000 80B5     	 push {r7,lr}
  80              	.LCFI3:
  81              	 .cfi_def_cfa_offset 8
  82              	 .cfi_offset 7,-8
  83              	 .cfi_offset 14,-4
  84 0002 82B0     	 sub sp,sp,#8
  85              	.LCFI4:
  86              	 .cfi_def_cfa_offset 16
  87 0004 00AF     	 add r7,sp,#0
  88              	.LCFI5:
  89              	 .cfi_def_cfa_register 7
  90 0006 021C     	 mov r2,r0
  91 0008 FB1D     	 add r3,r7,#7
  92 000a 1A70     	 strb r2,[r3]
 653:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   if ((int32_t)(IRQn) >= 0)
  93              	 .loc 1 653 0
  94 000c FB1D     	 add r3,r7,#7
  95 000e 1B78     	 ldrb r3,[r3]
  96 0010 7F2B     	 cmp r3,#127
  97 0012 0ED8     	 bhi .L5
 654:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   {
 655:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****     NVIC->ICER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
  98              	 .loc 1 655 0
  99 0014 0849     	 ldr r1,.L7
 100 0016 FB1D     	 add r3,r7,#7
 101 0018 1B78     	 ldrb r3,[r3]
 102 001a 1A1C     	 mov r2,r3
 103 001c 1F23     	 mov r3,#31
 104 001e 1340     	 and r3,r2
 105 0020 0122     	 mov r2,#1
 106 0022 9A40     	 lsl r2,r2,r3
 107 0024 131C     	 mov r3,r2
 108 0026 8022     	 mov r2,#128
 109 0028 8B50     	 str r3,[r1,r2]
 110              	.LBB6:
 111              	.LBB7:
 112              	 .file 2 "C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include/cmsis_gcc.h"
   1:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** /**************************************************************************//**
   2:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****  * @file     cmsis_gcc.h
   3:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****  * @brief    CMSIS compiler GCC header file
   4:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****  * @version  V5.0.2
   5:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****  * @date     13. February 2017
   6:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****  ******************************************************************************/
   7:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** /*
   8:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****  * Copyright (c) 2009-2017 ARM Limited. All rights reserved.
   9:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****  *
  10:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****  * SPDX-License-Identifier: Apache-2.0
  11:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****  *
  12:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****  * Licensed under the Apache License, Version 2.0 (the License); you may
  13:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****  * not use this file except in compliance with the License.
  14:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****  * You may obtain a copy of the License at
  15:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****  *
  16:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****  * www.apache.org/licenses/LICENSE-2.0
  17:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****  *
  18:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****  * Unless required by applicable law or agreed to in writing, software
  19:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****  * distributed under the License is distributed on an AS IS BASIS, WITHOUT
  20:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  21:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****  * See the License for the specific language governing permissions and
  22:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****  * limitations under the License.
  23:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
  24:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
  25:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #ifndef __CMSIS_GCC_H
  26:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #define __CMSIS_GCC_H
  27:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
  28:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** /* ignore some GCC warnings */
  29:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #pragma GCC diagnostic push
  30:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wsign-conversion"
  31:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wconversion"
  32:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wunused-parameter"
  33:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
  34:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** /* Fallback for __has_builtin */
  35:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #ifndef __has_builtin
  36:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   #define __has_builtin(x) (0)
  37:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
  38:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
  39:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** /* CMSIS compiler specific defines */
  40:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #ifndef   __ASM
  41:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   #define __ASM                                  __asm
  42:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
  43:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #ifndef   __INLINE
  44:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   #define __INLINE                               inline
  45:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
  46:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #ifndef   __STATIC_INLINE
  47:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   #define __STATIC_INLINE                        static inline
  48:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
  49:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #ifndef   __STATIC_FORCEINLINE                 
  50:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   #define __STATIC_FORCEINLINE                   __attribute__((always_inline)) static inline
  51:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif                                           
  52:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #ifndef   __NO_RETURN
  53:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   #define __NO_RETURN                            __attribute__((__noreturn__))
  54:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
  55:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #ifndef   __USED
  56:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   #define __USED                                 __attribute__((used))
  57:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
  58:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #ifndef   __WEAK
  59:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   #define __WEAK                                 __attribute__((weak))
  60:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
  61:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #ifndef   __PACKED
  62:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   #define __PACKED                               __attribute__((packed, aligned(1)))
  63:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
  64:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #ifndef   __PACKED_STRUCT
  65:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   #define __PACKED_STRUCT                        struct __attribute__((packed, aligned(1)))
  66:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
  67:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #ifndef   __PACKED_UNION
  68:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   #define __PACKED_UNION                         union __attribute__((packed, aligned(1)))
  69:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
  70:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32        /* deprecated */
  71:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   #pragma GCC diagnostic push
  72:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  73:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  74:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   struct __attribute__((packed)) T_UINT32 { uint32_t v; };
  75:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   #pragma GCC diagnostic pop
  76:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
  77:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
  78:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT16_WRITE
  79:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   #pragma GCC diagnostic push
  80:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  81:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  82:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
  83:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   #pragma GCC diagnostic pop
  84:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void *)(addr))-
  85:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
  86:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT16_READ
  87:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   #pragma GCC diagnostic push
  88:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  89:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  90:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
  91:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   #pragma GCC diagnostic pop
  92:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(add
  93:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
  94:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32_WRITE
  95:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   #pragma GCC diagnostic push
  96:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  97:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  98:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
  99:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   #pragma GCC diagnostic pop
 100:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))-
 101:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
 102:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32_READ
 103:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   #pragma GCC diagnostic push
 104:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
 105:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
 106:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
 107:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   #pragma GCC diagnostic pop
 108:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(add
 109:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
 110:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #ifndef   __ALIGNED
 111:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   #define __ALIGNED(x)                           __attribute__((aligned(x)))
 112:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
 113:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #ifndef   __RESTRICT
 114:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   #define __RESTRICT                             __restrict
 115:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
 116:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 117:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 118:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** /* ###########################  Core Function Access  ########################### */
 119:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** /** \ingroup  CMSIS_Core_FunctionInterface
 120:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****     \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
 121:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   @{
 122:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 123:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 124:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 125:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Enable IRQ Interrupts
 126:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
 127:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****            Can only be executed in Privileged modes.
 128:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 129:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE void __enable_irq(void)
 130:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 131:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("cpsie i" : : : "memory");
 132:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 133:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 134:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 135:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 136:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Disable IRQ Interrupts
 137:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Disables IRQ interrupts by setting the I-bit in the CPSR.
 138:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****            Can only be executed in Privileged modes.
 139:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 140:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE void __disable_irq(void)
 141:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 142:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("cpsid i" : : : "memory");
 143:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 144:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 145:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 146:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 147:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Get Control Register
 148:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Returns the content of the Control Register.
 149:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \return               Control Register value
 150:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 151:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_CONTROL(void)
 152:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 153:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   uint32_t result;
 154:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 155:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MRS %0, control" : "=r" (result) );
 156:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   return(result);
 157:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 158:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 159:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 160:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 161:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 162:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Get Control Register (non-secure)
 163:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Returns the content of the non-secure Control Register when in secure mode.
 164:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \return               non-secure Control Register value
 165:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 166:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_CONTROL_NS(void)
 167:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 168:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   uint32_t result;
 169:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 170:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MRS %0, control_ns" : "=r" (result) );
 171:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   return(result);
 172:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 173:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
 174:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 175:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 176:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 177:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Set Control Register
 178:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Writes the given value to the Control Register.
 179:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \param [in]    control  Control Register value to set
 180:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 181:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_CONTROL(uint32_t control)
 182:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 183:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
 184:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 185:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 186:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 187:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 188:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 189:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Set Control Register (non-secure)
 190:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Writes the given value to the non-secure Control Register when in secure state.
 191:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \param [in]    control  Control Register value to set
 192:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 193:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_CONTROL_NS(uint32_t control)
 194:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 195:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MSR control_ns, %0" : : "r" (control) : "memory");
 196:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 197:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
 198:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 199:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 200:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 201:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Get IPSR Register
 202:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Returns the content of the IPSR Register.
 203:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \return               IPSR Register value
 204:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 205:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_IPSR(void)
 206:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 207:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   uint32_t result;
 208:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 209:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 210:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   return(result);
 211:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 212:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 213:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 214:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 215:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Get APSR Register
 216:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Returns the content of the APSR Register.
 217:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \return               APSR Register value
 218:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 219:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_APSR(void)
 220:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 221:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   uint32_t result;
 222:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 223:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MRS %0, apsr" : "=r" (result) );
 224:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   return(result);
 225:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 226:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 227:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 228:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 229:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Get xPSR Register
 230:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Returns the content of the xPSR Register.
 231:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \return               xPSR Register value
 232:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 233:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_xPSR(void)
 234:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 235:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   uint32_t result;
 236:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 237:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MRS %0, xpsr" : "=r" (result) );
 238:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   return(result);
 239:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 240:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 241:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 242:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 243:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Get Process Stack Pointer
 244:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Returns the current value of the Process Stack Pointer (PSP).
 245:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \return               PSP Register value
 246:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 247:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_PSP(void)
 248:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 249:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   register uint32_t result;
 250:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 251:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 252:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   return(result);
 253:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 254:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 255:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 256:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 257:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 258:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Get Process Stack Pointer (non-secure)
 259:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Returns the current value of the non-secure Process Stack Pointer (PSP) when in secure s
 260:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \return               PSP Register value
 261:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 262:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_PSP_NS(void)
 263:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 264:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   register uint32_t result;
 265:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 266:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MRS %0, psp_ns"  : "=r" (result) );
 267:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   return(result);
 268:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 269:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
 270:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 271:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 272:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 273:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Set Process Stack Pointer
 274:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Assigns the given value to the Process Stack Pointer (PSP).
 275:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \param [in]    topOfProcStack  Process Stack Pointer value to set
 276:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 277:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_PSP(uint32_t topOfProcStack)
 278:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 279:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 280:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 281:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 282:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 283:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 284:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 285:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Set Process Stack Pointer (non-secure)
 286:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Assigns the given value to the non-secure Process Stack Pointer (PSP) when in secure sta
 287:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \param [in]    topOfProcStack  Process Stack Pointer value to set
 288:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 289:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_PSP_NS(uint32_t topOfProcStack)
 290:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 291:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MSR psp_ns, %0" : : "r" (topOfProcStack) : );
 292:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 293:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
 294:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 295:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 296:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 297:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Get Main Stack Pointer
 298:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Returns the current value of the Main Stack Pointer (MSP).
 299:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \return               MSP Register value
 300:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 301:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_MSP(void)
 302:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 303:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   register uint32_t result;
 304:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 305:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MRS %0, msp" : "=r" (result) );
 306:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   return(result);
 307:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 308:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 309:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 310:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 311:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 312:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Get Main Stack Pointer (non-secure)
 313:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Returns the current value of the non-secure Main Stack Pointer (MSP) when in secure stat
 314:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \return               MSP Register value
 315:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 316:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_MSP_NS(void)
 317:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 318:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   register uint32_t result;
 319:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 320:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MRS %0, msp_ns" : "=r" (result) );
 321:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   return(result);
 322:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 323:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
 324:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 325:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 326:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 327:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Set Main Stack Pointer
 328:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Assigns the given value to the Main Stack Pointer (MSP).
 329:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \param [in]    topOfMainStack  Main Stack Pointer value to set
 330:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 331:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_MSP(uint32_t topOfMainStack)
 332:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 333:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
 334:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 335:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 336:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 337:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 338:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 339:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Set Main Stack Pointer (non-secure)
 340:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Assigns the given value to the non-secure Main Stack Pointer (MSP) when in secure state.
 341:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \param [in]    topOfMainStack  Main Stack Pointer value to set
 342:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 343:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_MSP_NS(uint32_t topOfMainStack)
 344:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 345:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MSR msp_ns, %0" : : "r" (topOfMainStack) : );
 346:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 347:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
 348:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 349:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 350:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 351:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 352:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Get Stack Pointer (non-secure)
 353:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Returns the current value of the non-secure Stack Pointer (SP) when in secure state.
 354:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \return               SP Register value
 355:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 356:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_SP_NS(void)
 357:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 358:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   register uint32_t result;
 359:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 360:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MRS %0, sp_ns" : "=r" (result) );
 361:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   return(result);
 362:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 363:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 364:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 365:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 366:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Set Stack Pointer (non-secure)
 367:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Assigns the given value to the non-secure Stack Pointer (SP) when in secure state.
 368:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \param [in]    topOfStack  Stack Pointer value to set
 369:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 370:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_SP_NS(uint32_t topOfStack)
 371:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 372:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MSR sp_ns, %0" : : "r" (topOfStack) : );
 373:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 374:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
 375:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 376:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 377:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 378:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Get Priority Mask
 379:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Returns the current state of the priority mask bit from the Priority Mask Register.
 380:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \return               Priority Mask value
 381:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 382:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
 383:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 384:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   uint32_t result;
 385:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 386:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 387:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   return(result);
 388:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 389:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 390:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 391:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 392:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 393:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Get Priority Mask (non-secure)
 394:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Returns the current state of the non-secure priority mask bit from the Priority Mask Reg
 395:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \return               Priority Mask value
 396:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 397:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_PRIMASK_NS(void)
 398:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 399:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   uint32_t result;
 400:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 401:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MRS %0, primask_ns" : "=r" (result) :: "memory");
 402:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   return(result);
 403:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 404:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
 405:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 406:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 407:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 408:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Set Priority Mask
 409:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Assigns the given value to the Priority Mask Register.
 410:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \param [in]    priMask  Priority Mask
 411:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 412:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_PRIMASK(uint32_t priMask)
 413:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 414:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 415:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 416:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 417:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 418:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 419:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 420:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Set Priority Mask (non-secure)
 421:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Assigns the given value to the non-secure Priority Mask Register when in secure state.
 422:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \param [in]    priMask  Priority Mask
 423:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 424:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_PRIMASK_NS(uint32_t priMask)
 425:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 426:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MSR primask_ns, %0" : : "r" (priMask) : "memory");
 427:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 428:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
 429:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 430:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 431:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
 432:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****      (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 433:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
 434:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 435:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Enable FIQ
 436:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Enables FIQ interrupts by clearing the F-bit in the CPSR.
 437:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****            Can only be executed in Privileged modes.
 438:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 439:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE void __enable_fault_irq(void)
 440:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 441:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("cpsie f" : : : "memory");
 442:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 443:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 444:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 445:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 446:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Disable FIQ
 447:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Disables FIQ interrupts by setting the F-bit in the CPSR.
 448:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****            Can only be executed in Privileged modes.
 449:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 450:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE void __disable_fault_irq(void)
 451:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 452:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("cpsid f" : : : "memory");
 453:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 454:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 455:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 456:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 457:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Get Base Priority
 458:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Returns the current value of the Base Priority register.
 459:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \return               Base Priority register value
 460:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 461:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_BASEPRI(void)
 462:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 463:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   uint32_t result;
 464:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 465:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 466:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   return(result);
 467:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 468:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 469:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 470:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 471:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 472:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Get Base Priority (non-secure)
 473:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Returns the current value of the non-secure Base Priority register when in secure state.
 474:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \return               Base Priority register value
 475:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 476:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_BASEPRI_NS(void)
 477:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 478:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   uint32_t result;
 479:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 480:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MRS %0, basepri_ns" : "=r" (result) );
 481:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   return(result);
 482:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 483:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
 484:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 485:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 486:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 487:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Set Base Priority
 488:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Assigns the given value to the Base Priority register.
 489:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 490:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 491:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_BASEPRI(uint32_t basePri)
 492:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 493:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 494:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 495:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 496:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 497:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 498:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 499:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Set Base Priority (non-secure)
 500:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Assigns the given value to the non-secure Base Priority register when in secure state.
 501:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 502:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 503:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_BASEPRI_NS(uint32_t basePri)
 504:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 505:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MSR basepri_ns, %0" : : "r" (basePri) : "memory");
 506:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 507:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
 508:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 509:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 510:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 511:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Set Base Priority with condition
 512:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Assigns the given value to the Base Priority register only if BASEPRI masking is disable
 513:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****            or the new value increases the BASEPRI priority level.
 514:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 515:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 516:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_BASEPRI_MAX(uint32_t basePri)
 517:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 518:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 519:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 520:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 521:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 522:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 523:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Get Fault Mask
 524:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Returns the current value of the Fault Mask register.
 525:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \return               Fault Mask register value
 526:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 527:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_FAULTMASK(void)
 528:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 529:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   uint32_t result;
 530:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 531:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MRS %0, faultmask" : "=r" (result) );
 532:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   return(result);
 533:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 534:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 535:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 536:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 537:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 538:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Get Fault Mask (non-secure)
 539:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Returns the current value of the non-secure Fault Mask register when in secure state.
 540:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \return               Fault Mask register value
 541:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 542:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_FAULTMASK_NS(void)
 543:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 544:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   uint32_t result;
 545:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 546:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MRS %0, faultmask_ns" : "=r" (result) );
 547:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   return(result);
 548:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 549:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
 550:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 551:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 552:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 553:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Set Fault Mask
 554:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Assigns the given value to the Fault Mask register.
 555:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \param [in]    faultMask  Fault Mask value to set
 556:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 557:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_FAULTMASK(uint32_t faultMask)
 558:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 559:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) : "memory");
 560:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 561:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 562:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 563:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 564:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 565:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Set Fault Mask (non-secure)
 566:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Assigns the given value to the non-secure Fault Mask register when in secure state.
 567:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \param [in]    faultMask  Fault Mask value to set
 568:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 569:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_FAULTMASK_NS(uint32_t faultMask)
 570:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 571:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MSR faultmask_ns, %0" : : "r" (faultMask) : "memory");
 572:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 573:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
 574:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 575:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif /* ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
 576:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****            (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 577:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****            (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    ) */
 578:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 579:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 580:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #if ((defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \
 581:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_BASE__ ) && (__ARM_ARCH_8M_BASE__ == 1))    )
 582:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 583:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 584:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Get Process Stack Pointer Limit
 585:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Returns the current value of the Process Stack Pointer Limit (PSPLIM).
 586:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \return               PSPLIM Register value
 587:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 588:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_PSPLIM(void)
 589:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 590:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   register uint32_t result;
 591:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 592:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MRS %0, psplim"  : "=r" (result) );
 593:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   return(result);
 594:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 595:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 596:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 597:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #if ((defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3)) && \
 598:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__) && (__ARM_ARCH_8M_MAIN__ == 1))    )
 599:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 600:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Get Process Stack Pointer Limit (non-secure)
 601:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Returns the current value of the non-secure Process Stack Pointer Limit (PSPLIM) when in
 602:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \return               PSPLIM Register value
 603:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 604:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_PSPLIM_NS(void)
 605:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 606:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   register uint32_t result;
 607:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 608:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MRS %0, psplim_ns"  : "=r" (result) );
 609:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   return(result);
 610:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 611:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
 612:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 613:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 614:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 615:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Set Process Stack Pointer Limit
 616:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Assigns the given value to the Process Stack Pointer Limit (PSPLIM).
 617:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \param [in]    ProcStackPtrLimit  Process Stack Pointer Limit value to set
 618:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 619:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_PSPLIM(uint32_t ProcStackPtrLimit)
 620:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 621:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MSR psplim, %0" : : "r" (ProcStackPtrLimit));
 622:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 623:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 624:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 625:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #if ((defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3)) && \
 626:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__) && (__ARM_ARCH_8M_MAIN__ == 1))    )
 627:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 628:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Set Process Stack Pointer (non-secure)
 629:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Assigns the given value to the non-secure Process Stack Pointer Limit (PSPLIM) when in s
 630:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \param [in]    ProcStackPtrLimit  Process Stack Pointer Limit value to set
 631:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 632:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_PSPLIM_NS(uint32_t ProcStackPtrLimit)
 633:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 634:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MSR psplim_ns, %0\n" : : "r" (ProcStackPtrLimit));
 635:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 636:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
 637:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 638:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 639:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 640:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Get Main Stack Pointer Limit
 641:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Returns the current value of the Main Stack Pointer Limit (MSPLIM).
 642:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \return               MSPLIM Register value
 643:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 644:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_MSPLIM(void)
 645:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 646:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   register uint32_t result;
 647:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 648:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MRS %0, msplim" : "=r" (result) );
 649:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 650:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   return(result);
 651:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 652:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 653:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 654:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #if ((defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3)) && \
 655:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__) && (__ARM_ARCH_8M_MAIN__ == 1))    )
 656:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 657:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Get Main Stack Pointer Limit (non-secure)
 658:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Returns the current value of the non-secure Main Stack Pointer Limit(MSPLIM) when in sec
 659:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \return               MSPLIM Register value
 660:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 661:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_MSPLIM_NS(void)
 662:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 663:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   register uint32_t result;
 664:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 665:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MRS %0, msplim_ns" : "=r" (result) );
 666:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   return(result);
 667:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 668:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
 669:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 670:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 671:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 672:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Set Main Stack Pointer Limit
 673:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Assigns the given value to the Main Stack Pointer Limit (MSPLIM).
 674:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \param [in]    MainStackPtrLimit  Main Stack Pointer Limit value to set
 675:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 676:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_MSPLIM(uint32_t MainStackPtrLimit)
 677:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 678:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MSR msplim, %0" : : "r" (MainStackPtrLimit));
 679:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 680:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 681:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 682:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #if ((defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3)) && \
 683:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__) && (__ARM_ARCH_8M_MAIN__ == 1))    )
 684:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 685:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Set Main Stack Pointer Limit (non-secure)
 686:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Assigns the given value to the non-secure Main Stack Pointer Limit (MSPLIM) when in secu
 687:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \param [in]    MainStackPtrLimit  Main Stack Pointer value to set
 688:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 689:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_MSPLIM_NS(uint32_t MainStackPtrLimit)
 690:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 691:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MSR msplim_ns, %0" : : "r" (MainStackPtrLimit));
 692:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 693:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
 694:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 695:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif /* ((defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \
 696:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****            (defined (__ARM_ARCH_8M_BASE__ ) && (__ARM_ARCH_8M_BASE__ == 1))    ) */
 697:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 698:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 699:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #if ((defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 700:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
 701:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 702:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 703:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Get FPSCR
 704:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Returns the current value of the Floating Point Status/Control register.
 705:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \return               Floating Point Status/Control register value
 706:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 707:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_FPSCR(void)
 708:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 709:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
 710:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****      (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
 711:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #if __has_builtin(__builtin_arm_get_fpscr) || (__GNUC__ > 7) || (__GNUC__ == 7 && __GNUC_MINOR__ >=
 712:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   /* see https://gcc.gnu.org/ml/gcc-patches/2017-04/msg00443.html */
 713:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   return __builtin_arm_get_fpscr();
 714:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #else
 715:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   uint32_t result;
 716:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 717:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
 718:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   return(result);
 719:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
 720:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #else
 721:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   return(0U);
 722:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
 723:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 724:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 725:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 726:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 727:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Set FPSCR
 728:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Assigns the given value to the Floating Point Status/Control register.
 729:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \param [in]    fpscr  Floating Point Status/Control value to set
 730:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 731:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_FPSCR(uint32_t fpscr)
 732:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 733:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
 734:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****      (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
 735:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #if __has_builtin(__builtin_arm_set_fpscr) || (__GNUC__ > 7) || (__GNUC__ == 7 && __GNUC_MINOR__ >=
 736:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   /* see https://gcc.gnu.org/ml/gcc-patches/2017-04/msg00443.html */
 737:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   __builtin_arm_set_fpscr(fpscr);
 738:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #else
 739:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) : "vfpcc", "memory");
 740:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
 741:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #else
 742:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   (void)fpscr;
 743:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
 744:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 745:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 746:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif /* ((defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 747:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****            (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    ) */
 748:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 749:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 750:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 751:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** /*@} end of CMSIS_Core_RegAccFunctions */
 752:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 753:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 754:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** /* ##########################  Core Instruction Access  ######################### */
 755:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** /** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
 756:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   Access to dedicated instructions
 757:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   @{
 758:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** */
 759:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 760:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** /* Define macros for porting to both thumb1 and thumb2.
 761:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****  * For thumb1, use low register (r0-r7), specified by constraint "l"
 762:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****  * Otherwise, use general registers, specified by constraint "r" */
 763:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #if defined (__thumb__) && !defined (__thumb2__)
 764:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #define __CMSIS_GCC_OUT_REG(r) "=l" (r)
 765:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #define __CMSIS_GCC_RW_REG(r) "+l" (r)
 766:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #define __CMSIS_GCC_USE_REG(r) "l" (r)
 767:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #else
 768:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #define __CMSIS_GCC_OUT_REG(r) "=r" (r)
 769:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #define __CMSIS_GCC_RW_REG(r) "+r" (r)
 770:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #define __CMSIS_GCC_USE_REG(r) "r" (r)
 771:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
 772:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 773:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 774:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   No Operation
 775:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details No Operation does nothing. This instruction can be used for code alignment purposes.
 776:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 777:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #define __NOP()                             __ASM volatile ("nop")
 778:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 779:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 780:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Wait For Interrupt
 781:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Wait For Interrupt is a hint instruction that suspends execution until one of a number o
 782:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 783:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #define __WFI()                             __ASM volatile ("wfi")
 784:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 785:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 786:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 787:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Wait For Event
 788:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Wait For Event is a hint instruction that permits the processor to enter
 789:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****            a low-power state until one of a number of events occurs.
 790:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 791:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #define __WFE()                             __ASM volatile ("wfe")
 792:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 793:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 794:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 795:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Send Event
 796:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Send Event is a hint instruction. It causes an event to be signaled to the CPU.
 797:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 798:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** #define __SEV()                             __ASM volatile ("sev")
 799:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 800:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 801:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 802:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Instruction Synchronization Barrier
 803:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Instruction Synchronization Barrier flushes the pipeline in the processor,
 804:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****            so that all instructions following the ISB are fetched from cache or memory,
 805:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****            after the instruction has been completed.
 806:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 807:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE void __ISB(void)
 808:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 809:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("isb 0xF":::"memory");
 810:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 811:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 812:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 813:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 814:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Data Synchronization Barrier
 815:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Acts as a special kind of Data Memory Barrier.
 816:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****            It completes when all explicit memory accesses before this instruction complete.
 817:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 818:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE void __DSB(void)
 819:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 820:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("dsb 0xF":::"memory");
 113              	 .loc 2 820 0
 114              	
 115 002a BFF34F8F 	 dsb 0xF
 116              	
 117              	 .code 16
 118              	.LBE7:
 119              	.LBE6:
 120              	.LBB8:
 121              	.LBB9:
 809:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 122              	 .loc 2 809 0
 123              	
 124 002e BFF36F8F 	 isb 0xF
 125              	
 126              	 .code 16
 127              	.L5:
 128              	.LBE9:
 129              	.LBE8:
 656:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****     __DSB();
 657:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****     __ISB();
 658:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   }
 659:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** }
 130              	 .loc 1 659 0
 131 0032 BD46     	 mov sp,r7
 132 0034 02B0     	 add sp,sp,#8
 133              	 
 134 0036 80BD     	 pop {r7,pc}
 135              	.L8:
 136              	 .align 2
 137              	.L7:
 138 0038 00E100E0 	 .word -536813312
 139              	 .cfi_endproc
 140              	.LFE25:
 142              	 .section .text.__NVIC_ClearPendingIRQ,"ax",%progbits
 143              	 .align 2
 144              	 .code 16
 145              	 .thumb_func
 147              	__NVIC_ClearPendingIRQ:
 148              	.LFB28:
 660:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 661:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 662:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** /**
 663:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   \brief   Get Pending Interrupt
 664:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   \details Reads the NVIC pending register and returns the pending bit for the specified device spe
 665:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   \param [in]      IRQn  Device specific interrupt number.
 666:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   \return             0  Interrupt status is not pending.
 667:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   \return             1  Interrupt status is pending.
 668:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   \note    IRQn must not be negative.
 669:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****  */
 670:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** __STATIC_INLINE uint32_t __NVIC_GetPendingIRQ(IRQn_Type IRQn)
 671:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** {
 672:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   if ((int32_t)(IRQn) >= 0)
 673:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   {
 674:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****     return((uint32_t)(((NVIC->ISPR[0U] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1
 675:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   }
 676:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   else
 677:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   {
 678:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****     return(0U);
 679:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   }
 680:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** }
 681:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 682:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 683:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** /**
 684:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   \brief   Set Pending Interrupt
 685:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   \details Sets the pending bit of a device specific interrupt in the NVIC pending register.
 686:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   \param [in]      IRQn  Device specific interrupt number.
 687:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   \note    IRQn must not be negative.
 688:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****  */
 689:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** __STATIC_INLINE void __NVIC_SetPendingIRQ(IRQn_Type IRQn)
 690:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** {
 691:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   if ((int32_t)(IRQn) >= 0)
 692:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   {
 693:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****     NVIC->ISPR[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 694:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   }
 695:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** }
 696:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 697:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 698:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** /**
 699:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   \brief   Clear Pending Interrupt
 700:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   \details Clears the pending bit of a device specific interrupt in the NVIC pending register.
 701:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   \param [in]      IRQn  Device specific interrupt number.
 702:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   \note    IRQn must not be negative.
 703:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****  */
 704:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** __STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
 705:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** {
 149              	 .loc 1 705 0
 150              	 .cfi_startproc
 151 0000 80B5     	 push {r7,lr}
 152              	.LCFI6:
 153              	 .cfi_def_cfa_offset 8
 154              	 .cfi_offset 7,-8
 155              	 .cfi_offset 14,-4
 156 0002 82B0     	 sub sp,sp,#8
 157              	.LCFI7:
 158              	 .cfi_def_cfa_offset 16
 159 0004 00AF     	 add r7,sp,#0
 160              	.LCFI8:
 161              	 .cfi_def_cfa_register 7
 162 0006 021C     	 mov r2,r0
 163 0008 FB1D     	 add r3,r7,#7
 164 000a 1A70     	 strb r2,[r3]
 706:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   if ((int32_t)(IRQn) >= 0)
 165              	 .loc 1 706 0
 166 000c FB1D     	 add r3,r7,#7
 167 000e 1B78     	 ldrb r3,[r3]
 168 0010 7F2B     	 cmp r3,#127
 169 0012 0AD8     	 bhi .L9
 707:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   {
 708:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****     NVIC->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 170              	 .loc 1 708 0
 171 0014 0649     	 ldr r1,.L11
 172 0016 FB1D     	 add r3,r7,#7
 173 0018 1B78     	 ldrb r3,[r3]
 174 001a 1A1C     	 mov r2,r3
 175 001c 1F23     	 mov r3,#31
 176 001e 1340     	 and r3,r2
 177 0020 0122     	 mov r2,#1
 178 0022 9A40     	 lsl r2,r2,r3
 179 0024 C023     	 mov r3,#192
 180 0026 5B00     	 lsl r3,r3,#1
 181 0028 CA50     	 str r2,[r1,r3]
 182              	.L9:
 709:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   }
 710:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** }
 183              	 .loc 1 710 0
 184 002a BD46     	 mov sp,r7
 185 002c 02B0     	 add sp,sp,#8
 186              	 
 187 002e 80BD     	 pop {r7,pc}
 188              	.L12:
 189              	 .align 2
 190              	.L11:
 191 0030 00E100E0 	 .word -536813312
 192              	 .cfi_endproc
 193              	.LFE28:
 195              	 .section .text.__NVIC_SetPriority,"ax",%progbits
 196              	 .align 2
 197              	 .code 16
 198              	 .thumb_func
 200              	__NVIC_SetPriority:
 201              	.LFB29:
 711:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 712:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** 
 713:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** /**
 714:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   \brief   Set Interrupt Priority
 715:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   \details Sets the priority of a device specific interrupt or a processor exception.
 716:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****            The interrupt number can be positive to specify a device specific interrupt,
 717:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****            or negative to specify a processor exception.
 718:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   \param [in]      IRQn  Interrupt number.
 719:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   \param [in]  priority  Priority to set.
 720:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   \note    The priority cannot be set for every processor exception.
 721:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****  */
 722:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** __STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
 723:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** {
 202              	 .loc 1 723 0
 203              	 .cfi_startproc
 204 0000 B0B5     	 push {r4,r5,r7,lr}
 205              	.LCFI9:
 206              	 .cfi_def_cfa_offset 16
 207              	 .cfi_offset 4,-16
 208              	 .cfi_offset 5,-12
 209              	 .cfi_offset 7,-8
 210              	 .cfi_offset 14,-4
 211 0002 82B0     	 sub sp,sp,#8
 212              	.LCFI10:
 213              	 .cfi_def_cfa_offset 24
 214 0004 00AF     	 add r7,sp,#0
 215              	.LCFI11:
 216              	 .cfi_def_cfa_register 7
 217 0006 021C     	 mov r2,r0
 218 0008 3960     	 str r1,[r7]
 219 000a FB1D     	 add r3,r7,#7
 220 000c 1A70     	 strb r2,[r3]
 724:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   if ((int32_t)(IRQn) >= 0)
 221              	 .loc 1 724 0
 222 000e FB1D     	 add r3,r7,#7
 223 0010 1B78     	 ldrb r3,[r3]
 224 0012 7F2B     	 cmp r3,#127
 225 0014 27D8     	 bhi .L14
 725:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   {
 726:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****     NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))
 226              	 .loc 1 726 0
 227 0016 2D4C     	 ldr r4,.L16
 228 0018 FB1D     	 add r3,r7,#7
 229 001a 1B78     	 ldrb r3,[r3]
 230 001c 5BB2     	 sxtb r3,r3
 231 001e 9B08     	 lsr r3,r3,#2
 232 0020 2A49     	 ldr r1,.L16
 233 0022 FA1D     	 add r2,r7,#7
 234 0024 1278     	 ldrb r2,[r2]
 235 0026 52B2     	 sxtb r2,r2
 236 0028 9208     	 lsr r2,r2,#2
 237 002a C032     	 add r2,r2,#192
 238 002c 9200     	 lsl r2,r2,#2
 239 002e 5258     	 ldr r2,[r2,r1]
 240 0030 F91D     	 add r1,r7,#7
 241 0032 0978     	 ldrb r1,[r1]
 242 0034 081C     	 mov r0,r1
 243 0036 0321     	 mov r1,#3
 244 0038 0140     	 and r1,r0
 245 003a C900     	 lsl r1,r1,#3
 246 003c 081C     	 mov r0,r1
 247 003e FF21     	 mov r1,#255
 248 0040 8140     	 lsl r1,r1,r0
 249 0042 C943     	 mvn r1,r1
 250 0044 1140     	 and r1,r2
 727:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****        (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 251              	 .loc 1 727 0
 252 0046 3A68     	 ldr r2,[r7]
 253 0048 9201     	 lsl r2,r2,#6
 254 004a FF20     	 mov r0,#255
 255 004c 0240     	 and r2,r0
 256 004e F81D     	 add r0,r7,#7
 257 0050 0078     	 ldrb r0,[r0]
 258 0052 051C     	 mov r5,r0
 259 0054 0320     	 mov r0,#3
 260 0056 2840     	 and r0,r5
 261 0058 C000     	 lsl r0,r0,#3
 262 005a 8240     	 lsl r2,r2,r0
 726:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****        (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 263              	 .loc 1 726 0
 264 005c 0A43     	 orr r2,r1
 265 005e C033     	 add r3,r3,#192
 266 0060 9B00     	 lsl r3,r3,#2
 267 0062 1A51     	 str r2,[r3,r4]
 268 0064 2EE0     	 b .L13
 269              	.L14:
 728:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   }
 729:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   else
 730:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   {
 731:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****     SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))
 270              	 .loc 1 731 0
 271 0066 1A4C     	 ldr r4,.L16+4
 272 0068 FB1D     	 add r3,r7,#7
 273 006a 1B78     	 ldrb r3,[r3]
 274 006c 1A1C     	 mov r2,r3
 275 006e 0F23     	 mov r3,#15
 276 0070 1340     	 and r3,r2
 277 0072 083B     	 sub r3,r3,#8
 278 0074 9908     	 lsr r1,r3,#2
 279 0076 164A     	 ldr r2,.L16+4
 280 0078 FB1D     	 add r3,r7,#7
 281 007a 1B78     	 ldrb r3,[r3]
 282 007c 181C     	 mov r0,r3
 283 007e 0F23     	 mov r3,#15
 284 0080 0340     	 and r3,r0
 285 0082 083B     	 sub r3,r3,#8
 286 0084 9B08     	 lsr r3,r3,#2
 287 0086 0633     	 add r3,r3,#6
 288 0088 9B00     	 lsl r3,r3,#2
 289 008a D318     	 add r3,r2,r3
 290 008c 5B68     	 ldr r3,[r3,#4]
 291 008e FA1D     	 add r2,r7,#7
 292 0090 1278     	 ldrb r2,[r2]
 293 0092 101C     	 mov r0,r2
 294 0094 0322     	 mov r2,#3
 295 0096 0240     	 and r2,r0
 296 0098 D200     	 lsl r2,r2,#3
 297 009a 101C     	 mov r0,r2
 298 009c FF22     	 mov r2,#255
 299 009e 8240     	 lsl r2,r2,r0
 300 00a0 D243     	 mvn r2,r2
 301 00a2 1A40     	 and r2,r3
 732:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****        (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 302              	 .loc 1 732 0
 303 00a4 3B68     	 ldr r3,[r7]
 304 00a6 9B01     	 lsl r3,r3,#6
 305 00a8 FF20     	 mov r0,#255
 306 00aa 0340     	 and r3,r0
 307 00ac F81D     	 add r0,r7,#7
 308 00ae 0078     	 ldrb r0,[r0]
 309 00b0 051C     	 mov r5,r0
 310 00b2 0320     	 mov r0,#3
 311 00b4 2840     	 and r0,r5
 312 00b6 C000     	 lsl r0,r0,#3
 313 00b8 8340     	 lsl r3,r3,r0
 731:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****        (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 314              	 .loc 1 731 0
 315 00ba 1A43     	 orr r2,r3
 316 00bc 8B1D     	 add r3,r1,#6
 317 00be 9B00     	 lsl r3,r3,#2
 318 00c0 E318     	 add r3,r4,r3
 319 00c2 5A60     	 str r2,[r3,#4]
 320              	.L13:
 733:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h ****   }
 734:C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Include\core_cm0.h **** }
 321              	 .loc 1 734 0
 322 00c4 BD46     	 mov sp,r7
 323 00c6 02B0     	 add sp,sp,#8
 324              	 
 325 00c8 B0BD     	 pop {r4,r5,r7,pc}
 326              	.L17:
 327 00ca C046     	 .align 2
 328              	.L16:
 329 00cc 00E100E0 	 .word -536813312
 330 00d0 00ED00E0 	 .word -536810240
 331              	 .cfi_endproc
 332              	.LFE29:
 334              	 .comm rs232Receivedata,256,4
 335              	 .global rs232ReceivedataPointer
 336              	 .section .bss.rs232ReceivedataPointer,"aw",%nobits
 339              	rs232ReceivedataPointer:
 340 0000 00       	 .space 1
 341              	 .global rs232EnterReceive
 342              	 .section .bss.rs232EnterReceive,"aw",%nobits
 345              	rs232EnterReceive:
 346 0000 00       	 .space 1
 347              	 .comm uartReceivedata,256,4
 348              	 .global uartReceivedataPointer
 349              	 .section .bss.uartReceivedataPointer,"aw",%nobits
 352              	uartReceivedataPointer:
 353 0000 00       	 .space 1
 354              	 .global uartEnterReceive
 355              	 .section .bss.uartEnterReceive,"aw",%nobits
 358              	uartEnterReceive:
 359 0000 00       	 .space 1
 360              	 .section .text.bit_init,"ax",%progbits
 361              	 .align 2
 362              	 .global bit_init
 363              	 .code 16
 364              	 .thumb_func
 366              	bit_init:
 367              	.LFB36:
 368              	 .file 3 "../XMC1100-LibHaas.c"
   1:../XMC1100-LibHaas.c **** ﻿// Bibliothek:       XMC1100-LibHaas.c Vers 0.82 vom 19.09.2021
   2:../XMC1100-LibHaas.c **** // Controller:       XMC1100 Board XMC1100 Boot Kit
   3:../XMC1100-LibHaas.c **** // Adapterboard:	 XMC-Learnboard Version0_9
   4:../XMC1100-LibHaas.c **** // Ausgangsversion:  Version 1.8 Birk, Bubbers
   5:../XMC1100-LibHaas.c **** // Autor			 Haas
   6:../XMC1100-LibHaas.c **** #include <xmc1100-LibHaas.h>
   7:../XMC1100-LibHaas.c **** 
   8:../XMC1100-LibHaas.c **** // Global Variablen
   9:../XMC1100-LibHaas.c **** // RS232
  10:../XMC1100-LibHaas.c **** char rs232Receivedata[256];
  11:../XMC1100-LibHaas.c **** uint8_t rs232ReceivedataPointer=0;
  12:../XMC1100-LibHaas.c **** uint8_t rs232EnterReceive=0;
  13:../XMC1100-LibHaas.c **** // UART
  14:../XMC1100-LibHaas.c **** char uartReceivedata[256];
  15:../XMC1100-LibHaas.c **** uint8_t uartReceivedataPointer=0;
  16:../XMC1100-LibHaas.c **** uint8_t uartEnterReceive=0;
  17:../XMC1100-LibHaas.c **** 
  18:../XMC1100-LibHaas.c **** // Definition der lokalen Funktionen:
  19:../XMC1100-LibHaas.c **** uint16_t bit_set_clr(uint16_t wert, uint16_t set ,uint16_t bitnr);
  20:../XMC1100-LibHaas.c **** void clock_init(void);
  21:../XMC1100-LibHaas.c **** 
  22:../XMC1100-LibHaas.c **** //***************************************************************
  23:../XMC1100-LibHaas.c **** // ab hier Funktionen für Port-Ein-/Ausgabe
  24:../XMC1100-LibHaas.c **** //***************************************************************
  25:../XMC1100-LibHaas.c **** 
  26:../XMC1100-LibHaas.c **** // --------------------------------------------------------------
  27:../XMC1100-LibHaas.c **** // Einzelnes Bit für Ein- oder Ausgabe initialisieren
  28:../XMC1100-LibHaas.c **** // port: P0,P1,P2 bitnr: 0..15 direction: INP 0, OUTP 1
  29:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
  30:../XMC1100-LibHaas.c **** void bit_init(uint8_t port, uint8_t bitnr, uint8_t direction)
  31:../XMC1100-LibHaas.c **** {
 369              	 .loc 3 31 0
 370              	 .cfi_startproc
 371 0000 90B5     	 push {r4,r7,lr}
 372              	.LCFI12:
 373              	 .cfi_def_cfa_offset 12
 374              	 .cfi_offset 4,-12
 375              	 .cfi_offset 7,-8
 376              	 .cfi_offset 14,-4
 377 0002 83B0     	 sub sp,sp,#12
 378              	.LCFI13:
 379              	 .cfi_def_cfa_offset 24
 380 0004 00AF     	 add r7,sp,#0
 381              	.LCFI14:
 382              	 .cfi_def_cfa_register 7
 383 0006 041C     	 mov r4,r0
 384 0008 081C     	 mov r0,r1
 385 000a 111C     	 mov r1,r2
 386 000c FB1D     	 add r3,r7,#7
 387 000e 221C     	 add r2,r4,#0
 388 0010 1A70     	 strb r2,[r3]
 389 0012 BB1D     	 add r3,r7,#6
 390 0014 021C     	 add r2,r0,#0
 391 0016 1A70     	 strb r2,[r3]
 392 0018 7B1D     	 add r3,r7,#5
 393 001a 0A1C     	 add r2,r1,#0
 394 001c 1A70     	 strb r2,[r3]
  32:../XMC1100-LibHaas.c **** 	switch (port)
 395              	 .loc 3 32 0
 396 001e FB1D     	 add r3,r7,#7
 397 0020 1B78     	 ldrb r3,[r3]
 398 0022 012B     	 cmp r3,#1
 399 0024 00D1     	 bne .LCB329
 400 0026 A1E0     	 b .L20
 401              	.LCB329:
 402 0028 022B     	 cmp r3,#2
 403 002a 00D1     	 bne .LCB331
 404 002c EAE0     	 b .L21
 405              	.LCB331:
 406 002e 002B     	 cmp r3,#0
 407 0030 00D0     	 beq .LCB333
 408 0032 9BE1     	 b .L18
 409              	.LCB333:
  33:../XMC1100-LibHaas.c **** 	{
  34:../XMC1100-LibHaas.c **** 		case 0 :
  35:../XMC1100-LibHaas.c **** 			{if (bitnr < 4 )
 410              	 .loc 3 35 0
 411 0034 BB1D     	 add r3,r7,#6
 412 0036 1B78     	 ldrb r3,[r3]
 413 0038 032B     	 cmp r3,#3
 414 003a 1DD8     	 bhi .L23
  36:../XMC1100-LibHaas.c **** 				{ if (direction == 1) PORT0->IOCR0 |=1UL << ((bitnr * 8)+7);
 415              	 .loc 3 36 0
 416 003c 7B1D     	 add r3,r7,#5
 417 003e 1B78     	 ldrb r3,[r3]
 418 0040 012B     	 cmp r3,#1
 419 0042 0CD1     	 bne .L24
 420              	 .loc 3 36 0 is_stmt 0 discriminator 1
 421 0044 CB4B     	 ldr r3,.L42
 422 0046 CB4A     	 ldr r2,.L42
 423 0048 1169     	 ldr r1,[r2,#16]
 424 004a BA1D     	 add r2,r7,#6
 425 004c 1278     	 ldrb r2,[r2]
 426 004e D200     	 lsl r2,r2,#3
 427 0050 0732     	 add r2,r2,#7
 428 0052 0120     	 mov r0,#1
 429 0054 9040     	 lsl r0,r0,r2
 430 0056 021C     	 mov r2,r0
 431 0058 0A43     	 orr r2,r1
 432 005a 1A61     	 str r2,[r3,#16]
 433 005c 0CE0     	 b .L23
 434              	.L24:
  37:../XMC1100-LibHaas.c **** 				  else PORT0->IOCR0 &= ~(1UL << ((bitnr * 8 ) + 7 ));
 435              	 .loc 3 37 0 is_stmt 1
 436 005e C54B     	 ldr r3,.L42
 437 0060 C44A     	 ldr r2,.L42
 438 0062 1269     	 ldr r2,[r2,#16]
 439 0064 B91D     	 add r1,r7,#6
 440 0066 0978     	 ldrb r1,[r1]
 441 0068 C900     	 lsl r1,r1,#3
 442 006a 0731     	 add r1,r1,#7
 443 006c 0120     	 mov r0,#1
 444 006e 8840     	 lsl r0,r0,r1
 445 0070 011C     	 mov r1,r0
 446 0072 C943     	 mvn r1,r1
 447 0074 0A40     	 and r2,r1
 448 0076 1A61     	 str r2,[r3,#16]
 449              	.L23:
  38:../XMC1100-LibHaas.c **** 				}
  39:../XMC1100-LibHaas.c **** 			 if ( (bitnr <8) && (bitnr > 3))
 450              	 .loc 3 39 0
 451 0078 BB1D     	 add r3,r7,#6
 452 007a 1B78     	 ldrb r3,[r3]
 453 007c 072B     	 cmp r3,#7
 454 007e 23D8     	 bhi .L25
 455              	 .loc 3 39 0 is_stmt 0 discriminator 1
 456 0080 BB1D     	 add r3,r7,#6
 457 0082 1B78     	 ldrb r3,[r3]
 458 0084 032B     	 cmp r3,#3
 459 0086 1FD9     	 bls .L25
  40:../XMC1100-LibHaas.c **** 					 { if (direction == 1) PORT0->IOCR4 |= 1UL<< (((bitnr-4) * 8)+7);
 460              	 .loc 3 40 0 is_stmt 1
 461 0088 7B1D     	 add r3,r7,#5
 462 008a 1B78     	 ldrb r3,[r3]
 463 008c 012B     	 cmp r3,#1
 464 008e 0DD1     	 bne .L26
 465              	 .loc 3 40 0 is_stmt 0 discriminator 1
 466 0090 B84B     	 ldr r3,.L42
 467 0092 B84A     	 ldr r2,.L42
 468 0094 5169     	 ldr r1,[r2,#20]
 469 0096 BA1D     	 add r2,r7,#6
 470 0098 1278     	 ldrb r2,[r2]
 471 009a 043A     	 sub r2,r2,#4
 472 009c D200     	 lsl r2,r2,#3
 473 009e 0732     	 add r2,r2,#7
 474 00a0 0120     	 mov r0,#1
 475 00a2 9040     	 lsl r0,r0,r2
 476 00a4 021C     	 mov r2,r0
 477 00a6 0A43     	 orr r2,r1
 478 00a8 5A61     	 str r2,[r3,#20]
 479 00aa 0DE0     	 b .L25
 480              	.L26:
  41:../XMC1100-LibHaas.c **** 					   else PORT0->IOCR4 &= ~(1UL << (((bitnr-4) * 8)+7) );
 481              	 .loc 3 41 0 is_stmt 1
 482 00ac B14B     	 ldr r3,.L42
 483 00ae B14A     	 ldr r2,.L42
 484 00b0 5269     	 ldr r2,[r2,#20]
 485 00b2 B91D     	 add r1,r7,#6
 486 00b4 0978     	 ldrb r1,[r1]
 487 00b6 0439     	 sub r1,r1,#4
 488 00b8 C900     	 lsl r1,r1,#3
 489 00ba 0731     	 add r1,r1,#7
 490 00bc 0120     	 mov r0,#1
 491 00be 8840     	 lsl r0,r0,r1
 492 00c0 011C     	 mov r1,r0
 493 00c2 C943     	 mvn r1,r1
 494 00c4 0A40     	 and r2,r1
 495 00c6 5A61     	 str r2,[r3,#20]
 496              	.L25:
  42:../XMC1100-LibHaas.c **** 					 }
  43:../XMC1100-LibHaas.c **** 			 if ( (bitnr <12) && (bitnr > 7))
 497              	 .loc 3 43 0
 498 00c8 BB1D     	 add r3,r7,#6
 499 00ca 1B78     	 ldrb r3,[r3]
 500 00cc 0B2B     	 cmp r3,#11
 501 00ce 23D8     	 bhi .L27
 502              	 .loc 3 43 0 is_stmt 0 discriminator 1
 503 00d0 BB1D     	 add r3,r7,#6
 504 00d2 1B78     	 ldrb r3,[r3]
 505 00d4 072B     	 cmp r3,#7
 506 00d6 1FD9     	 bls .L27
  44:../XMC1100-LibHaas.c **** 			 		 { if (direction == 1) PORT0->IOCR8 |= 1UL << (((bitnr-8) * 8)+7);
 507              	 .loc 3 44 0 is_stmt 1
 508 00d8 7B1D     	 add r3,r7,#5
 509 00da 1B78     	 ldrb r3,[r3]
 510 00dc 012B     	 cmp r3,#1
 511 00de 0DD1     	 bne .L28
 512              	 .loc 3 44 0 is_stmt 0 discriminator 1
 513 00e0 A44B     	 ldr r3,.L42
 514 00e2 A44A     	 ldr r2,.L42
 515 00e4 9169     	 ldr r1,[r2,#24]
 516 00e6 BA1D     	 add r2,r7,#6
 517 00e8 1278     	 ldrb r2,[r2]
 518 00ea 083A     	 sub r2,r2,#8
 519 00ec D200     	 lsl r2,r2,#3
 520 00ee 0732     	 add r2,r2,#7
 521 00f0 0120     	 mov r0,#1
 522 00f2 9040     	 lsl r0,r0,r2
 523 00f4 021C     	 mov r2,r0
 524 00f6 0A43     	 orr r2,r1
 525 00f8 9A61     	 str r2,[r3,#24]
 526 00fa 0DE0     	 b .L27
 527              	.L28:
  45:../XMC1100-LibHaas.c **** 			 		   else PORT0->IOCR8 &= ~(1UL << (((bitnr-8) * 8)+7) );
 528              	 .loc 3 45 0 is_stmt 1
 529 00fc 9D4B     	 ldr r3,.L42
 530 00fe 9D4A     	 ldr r2,.L42
 531 0100 9269     	 ldr r2,[r2,#24]
 532 0102 B91D     	 add r1,r7,#6
 533 0104 0978     	 ldrb r1,[r1]
 534 0106 0839     	 sub r1,r1,#8
 535 0108 C900     	 lsl r1,r1,#3
 536 010a 0731     	 add r1,r1,#7
 537 010c 0120     	 mov r0,#1
 538 010e 8840     	 lsl r0,r0,r1
 539 0110 011C     	 mov r1,r0
 540 0112 C943     	 mvn r1,r1
 541 0114 0A40     	 and r2,r1
 542 0116 9A61     	 str r2,[r3,#24]
 543              	.L27:
  46:../XMC1100-LibHaas.c **** 			 		 }
  47:../XMC1100-LibHaas.c **** 			 if ( (bitnr <16) && (bitnr > 11))
 544              	 .loc 3 47 0
 545 0118 BB1D     	 add r3,r7,#6
 546 011a 1B78     	 ldrb r3,[r3]
 547 011c 0F2B     	 cmp r3,#15
 548 011e 24D8     	 bhi .L29
 549              	 .loc 3 47 0 is_stmt 0 discriminator 1
 550 0120 BB1D     	 add r3,r7,#6
 551 0122 1B78     	 ldrb r3,[r3]
 552 0124 0B2B     	 cmp r3,#11
 553 0126 20D9     	 bls .L29
  48:../XMC1100-LibHaas.c **** 			 		{ if (direction == 1) PORT0->IOCR12 |= 1UL << (((bitnr-12) * 8)+7);
 554              	 .loc 3 48 0 is_stmt 1
 555 0128 7B1D     	 add r3,r7,#5
 556 012a 1B78     	 ldrb r3,[r3]
 557 012c 012B     	 cmp r3,#1
 558 012e 0DD1     	 bne .L30
 559              	 .loc 3 48 0 is_stmt 0 discriminator 1
 560 0130 904B     	 ldr r3,.L42
 561 0132 904A     	 ldr r2,.L42
 562 0134 D169     	 ldr r1,[r2,#28]
 563 0136 BA1D     	 add r2,r7,#6
 564 0138 1278     	 ldrb r2,[r2]
 565 013a 0C3A     	 sub r2,r2,#12
 566 013c D200     	 lsl r2,r2,#3
 567 013e 0732     	 add r2,r2,#7
 568 0140 0120     	 mov r0,#1
 569 0142 9040     	 lsl r0,r0,r2
 570 0144 021C     	 mov r2,r0
 571 0146 0A43     	 orr r2,r1
 572 0148 DA61     	 str r2,[r3,#28]
 573 014a 0EE0     	 b .L29
 574              	.L30:
  49:../XMC1100-LibHaas.c **** 			 		  else PORT0->IOCR12 &= ~(1UL << (((bitnr-12) * 8)+7) );
 575              	 .loc 3 49 0 is_stmt 1
 576 014c 894B     	 ldr r3,.L42
 577 014e 894A     	 ldr r2,.L42
 578 0150 D269     	 ldr r2,[r2,#28]
 579 0152 B91D     	 add r1,r7,#6
 580 0154 0978     	 ldrb r1,[r1]
 581 0156 0C39     	 sub r1,r1,#12
 582 0158 C900     	 lsl r1,r1,#3
 583 015a 0731     	 add r1,r1,#7
 584 015c 0120     	 mov r0,#1
 585 015e 8840     	 lsl r0,r0,r1
 586 0160 011C     	 mov r1,r0
 587 0162 C943     	 mvn r1,r1
 588 0164 0A40     	 and r2,r1
 589 0166 DA61     	 str r2,[r3,#28]
  50:../XMC1100-LibHaas.c **** 			 		}
  51:../XMC1100-LibHaas.c **** 			}
  52:../XMC1100-LibHaas.c **** 			break;
 590              	 .loc 3 52 0
 591 0168 00E1     	 b .L18
 592              	.L29:
 593 016a FFE0     	 b .L18
 594              	.L20:
  53:../XMC1100-LibHaas.c **** 	  case 1 :
  54:../XMC1100-LibHaas.c **** 			{
  55:../XMC1100-LibHaas.c **** 				{if (bitnr < 4 )
 595              	 .loc 3 55 0
 596 016c BB1D     	 add r3,r7,#6
 597 016e 1B78     	 ldrb r3,[r3]
 598 0170 032B     	 cmp r3,#3
 599 0172 1DD8     	 bhi .L31
  56:../XMC1100-LibHaas.c **** 					{ if (direction == 1) PORT1->IOCR0 |=1UL << ((bitnr * 8)+7);
 600              	 .loc 3 56 0
 601 0174 7B1D     	 add r3,r7,#5
 602 0176 1B78     	 ldrb r3,[r3]
 603 0178 012B     	 cmp r3,#1
 604 017a 0CD1     	 bne .L32
 605              	 .loc 3 56 0 is_stmt 0 discriminator 1
 606 017c 7E4B     	 ldr r3,.L42+4
 607 017e 7E4A     	 ldr r2,.L42+4
 608 0180 1169     	 ldr r1,[r2,#16]
 609 0182 BA1D     	 add r2,r7,#6
 610 0184 1278     	 ldrb r2,[r2]
 611 0186 D200     	 lsl r2,r2,#3
 612 0188 0732     	 add r2,r2,#7
 613 018a 0120     	 mov r0,#1
 614 018c 9040     	 lsl r0,r0,r2
 615 018e 021C     	 mov r2,r0
 616 0190 0A43     	 orr r2,r1
 617 0192 1A61     	 str r2,[r3,#16]
 618 0194 0CE0     	 b .L31
 619              	.L32:
  57:../XMC1100-LibHaas.c **** 						else PORT1->IOCR0 &= ~(1UL << ((bitnr * 8 ) + 7 ));
 620              	 .loc 3 57 0 is_stmt 1
 621 0196 784B     	 ldr r3,.L42+4
 622 0198 774A     	 ldr r2,.L42+4
 623 019a 1269     	 ldr r2,[r2,#16]
 624 019c B91D     	 add r1,r7,#6
 625 019e 0978     	 ldrb r1,[r1]
 626 01a0 C900     	 lsl r1,r1,#3
 627 01a2 0731     	 add r1,r1,#7
 628 01a4 0120     	 mov r0,#1
 629 01a6 8840     	 lsl r0,r0,r1
 630 01a8 011C     	 mov r1,r0
 631 01aa C943     	 mvn r1,r1
 632 01ac 0A40     	 and r2,r1
 633 01ae 1A61     	 str r2,[r3,#16]
 634              	.L31:
  58:../XMC1100-LibHaas.c **** 					}
  59:../XMC1100-LibHaas.c **** 			if ((bitnr < 8) && (bitnr > 3)) {
 635              	 .loc 3 59 0
 636 01b0 BB1D     	 add r3,r7,#6
 637 01b2 1B78     	 ldrb r3,[r3]
 638 01b4 072B     	 cmp r3,#7
 639 01b6 24D8     	 bhi .L33
 640              	 .loc 3 59 0 is_stmt 0 discriminator 1
 641 01b8 BB1D     	 add r3,r7,#6
 642 01ba 1B78     	 ldrb r3,[r3]
 643 01bc 032B     	 cmp r3,#3
 644 01be 20D9     	 bls .L33
  60:../XMC1100-LibHaas.c **** 				if (direction == 1) PORT1->IOCR4 |= 1UL << (((bitnr - 4) * 8) + 7);
 645              	 .loc 3 60 0 is_stmt 1
 646 01c0 7B1D     	 add r3,r7,#5
 647 01c2 1B78     	 ldrb r3,[r3]
 648 01c4 012B     	 cmp r3,#1
 649 01c6 0DD1     	 bne .L34
 650              	 .loc 3 60 0 is_stmt 0 discriminator 1
 651 01c8 6B4B     	 ldr r3,.L42+4
 652 01ca 6B4A     	 ldr r2,.L42+4
 653 01cc 5169     	 ldr r1,[r2,#20]
 654 01ce BA1D     	 add r2,r7,#6
 655 01d0 1278     	 ldrb r2,[r2]
 656 01d2 043A     	 sub r2,r2,#4
 657 01d4 D200     	 lsl r2,r2,#3
 658 01d6 0732     	 add r2,r2,#7
 659 01d8 0120     	 mov r0,#1
 660 01da 9040     	 lsl r0,r0,r2
 661 01dc 021C     	 mov r2,r0
 662 01de 0A43     	 orr r2,r1
 663 01e0 5A61     	 str r2,[r3,#20]
 664 01e2 0EE0     	 b .L33
 665              	.L34:
  61:../XMC1100-LibHaas.c **** 				else
  62:../XMC1100-LibHaas.c **** 					PORT1->IOCR4 &= ~(1UL << (((bitnr - 4) * 8) + 7));
 666              	 .loc 3 62 0 is_stmt 1
 667 01e4 644B     	 ldr r3,.L42+4
 668 01e6 644A     	 ldr r2,.L42+4
 669 01e8 5269     	 ldr r2,[r2,#20]
 670 01ea B91D     	 add r1,r7,#6
 671 01ec 0978     	 ldrb r1,[r1]
 672 01ee 0439     	 sub r1,r1,#4
 673 01f0 C900     	 lsl r1,r1,#3
 674 01f2 0731     	 add r1,r1,#7
 675 01f4 0120     	 mov r0,#1
 676 01f6 8840     	 lsl r0,r0,r1
 677 01f8 011C     	 mov r1,r0
 678 01fa C943     	 mvn r1,r1
 679 01fc 0A40     	 and r2,r1
 680 01fe 5A61     	 str r2,[r3,#20]
  63:../XMC1100-LibHaas.c **** 			}
  64:../XMC1100-LibHaas.c **** 
  65:../XMC1100-LibHaas.c **** 				}
  66:../XMC1100-LibHaas.c **** 			}
  67:../XMC1100-LibHaas.c **** 			break;
 681              	 .loc 3 67 0
 682 0200 B4E0     	 b .L18
 683              	.L33:
 684 0202 B3E0     	 b .L18
 685              	.L21:
  68:../XMC1100-LibHaas.c **** 
  69:../XMC1100-LibHaas.c **** 	  case 2 : //Achtung!! Nur Pins P2.0, P2.1, P2.10 und P2.11 sind als Out Pin einstellbar
  70:../XMC1100-LibHaas.c **** 	  	{
  71:../XMC1100-LibHaas.c **** 	  		if (bitnr < 2 ) {
 686              	 .loc 3 71 0
 687 0204 BB1D     	 add r3,r7,#6
 688 0206 1B78     	 ldrb r3,[r3]
 689 0208 012B     	 cmp r3,#1
 690 020a 28D8     	 bhi .L35
  72:../XMC1100-LibHaas.c **** 	  			CLR_BIT(PORT2->PDISC,bitnr); // digital Pad aktiv
 691              	 .loc 3 72 0
 692 020c 5B4B     	 ldr r3,.L42+8
 693 020e 5B4A     	 ldr r2,.L42+8
 694 0210 126E     	 ldr r2,[r2,#96]
 695 0212 B91D     	 add r1,r7,#6
 696 0214 0978     	 ldrb r1,[r1]
 697 0216 0120     	 mov r0,#1
 698 0218 8840     	 lsl r0,r0,r1
 699 021a 011C     	 mov r1,r0
 700 021c C943     	 mvn r1,r1
 701 021e 0A40     	 and r2,r1
 702 0220 1A66     	 str r2,[r3,#96]
  73:../XMC1100-LibHaas.c **** 	  			if (direction == 1) PORT2->IOCR0 |=1UL << ((bitnr * 8)+7);
 703              	 .loc 3 73 0
 704 0222 7B1D     	 add r3,r7,#5
 705 0224 1B78     	 ldrb r3,[r3]
 706 0226 012B     	 cmp r3,#1
 707 0228 0CD1     	 bne .L36
 708              	 .loc 3 73 0 is_stmt 0 discriminator 1
 709 022a 544B     	 ldr r3,.L42+8
 710 022c 534A     	 ldr r2,.L42+8
 711 022e 1169     	 ldr r1,[r2,#16]
 712 0230 BA1D     	 add r2,r7,#6
 713 0232 1278     	 ldrb r2,[r2]
 714 0234 D200     	 lsl r2,r2,#3
 715 0236 0732     	 add r2,r2,#7
 716 0238 0120     	 mov r0,#1
 717 023a 9040     	 lsl r0,r0,r2
 718 023c 021C     	 mov r2,r0
 719 023e 0A43     	 orr r2,r1
 720 0240 1A61     	 str r2,[r3,#16]
 721 0242 0CE0     	 b .L35
 722              	.L36:
  74:../XMC1100-LibHaas.c **** 					else PORT2->IOCR0 &= ~(1UL << ((bitnr * 8 ) + 7 ));
 723              	 .loc 3 74 0 is_stmt 1
 724 0244 4D4B     	 ldr r3,.L42+8
 725 0246 4D4A     	 ldr r2,.L42+8
 726 0248 1269     	 ldr r2,[r2,#16]
 727 024a B91D     	 add r1,r7,#6
 728 024c 0978     	 ldrb r1,[r1]
 729 024e C900     	 lsl r1,r1,#3
 730 0250 0731     	 add r1,r1,#7
 731 0252 0120     	 mov r0,#1
 732 0254 8840     	 lsl r0,r0,r1
 733 0256 011C     	 mov r1,r0
 734 0258 C943     	 mvn r1,r1
 735 025a 0A40     	 and r2,r1
 736 025c 1A61     	 str r2,[r3,#16]
 737              	.L35:
  75:../XMC1100-LibHaas.c **** 	  		}
  76:../XMC1100-LibHaas.c **** 				if ((bitnr > 1)&&(bitnr<4)) {
 738              	 .loc 3 76 0
 739 025e BB1D     	 add r3,r7,#6
 740 0260 1B78     	 ldrb r3,[r3]
 741 0262 012B     	 cmp r3,#1
 742 0264 1BD9     	 bls .L37
 743              	 .loc 3 76 0 is_stmt 0 discriminator 1
 744 0266 BB1D     	 add r3,r7,#6
 745 0268 1B78     	 ldrb r3,[r3]
 746 026a 032B     	 cmp r3,#3
 747 026c 17D8     	 bhi .L37
  77:../XMC1100-LibHaas.c **** 					CLR_BIT(PORT2->PDISC,bitnr); // digital Pad aktiv
 748              	 .loc 3 77 0 is_stmt 1
 749 026e 434B     	 ldr r3,.L42+8
 750 0270 424A     	 ldr r2,.L42+8
 751 0272 126E     	 ldr r2,[r2,#96]
 752 0274 B91D     	 add r1,r7,#6
 753 0276 0978     	 ldrb r1,[r1]
 754 0278 0120     	 mov r0,#1
 755 027a 8840     	 lsl r0,r0,r1
 756 027c 011C     	 mov r1,r0
 757 027e C943     	 mvn r1,r1
 758 0280 0A40     	 and r2,r1
 759 0282 1A66     	 str r2,[r3,#96]
  78:../XMC1100-LibHaas.c **** 					PORT2->IOCR0 &= ~(1UL << ((bitnr * 8) + 7));
 760              	 .loc 3 78 0
 761 0284 3D4B     	 ldr r3,.L42+8
 762 0286 3D4A     	 ldr r2,.L42+8
 763 0288 1269     	 ldr r2,[r2,#16]
 764 028a B91D     	 add r1,r7,#6
 765 028c 0978     	 ldrb r1,[r1]
 766 028e C900     	 lsl r1,r1,#3
 767 0290 0731     	 add r1,r1,#7
 768 0292 0120     	 mov r0,#1
 769 0294 8840     	 lsl r0,r0,r1
 770 0296 011C     	 mov r1,r0
 771 0298 C943     	 mvn r1,r1
 772 029a 0A40     	 and r2,r1
 773 029c 1A61     	 str r2,[r3,#16]
 774              	.L37:
  79:../XMC1100-LibHaas.c **** 				}
  80:../XMC1100-LibHaas.c **** 	  		if ((bitnr < 8) && (bitnr > 3)) {
 775              	 .loc 3 80 0
 776 029e BB1D     	 add r3,r7,#6
 777 02a0 1B78     	 ldrb r3,[r3]
 778 02a2 072B     	 cmp r3,#7
 779 02a4 1CD8     	 bhi .L38
 780              	 .loc 3 80 0 is_stmt 0 discriminator 1
 781 02a6 BB1D     	 add r3,r7,#6
 782 02a8 1B78     	 ldrb r3,[r3]
 783 02aa 032B     	 cmp r3,#3
 784 02ac 18D9     	 bls .L38
  81:../XMC1100-LibHaas.c **** 	  			    CLR_BIT(PORT2->PDISC,bitnr); // digital Pad aktiv
 785              	 .loc 3 81 0 is_stmt 1
 786 02ae 334B     	 ldr r3,.L42+8
 787 02b0 324A     	 ldr r2,.L42+8
 788 02b2 126E     	 ldr r2,[r2,#96]
 789 02b4 B91D     	 add r1,r7,#6
 790 02b6 0978     	 ldrb r1,[r1]
 791 02b8 0120     	 mov r0,#1
 792 02ba 8840     	 lsl r0,r0,r1
 793 02bc 011C     	 mov r1,r0
 794 02be C943     	 mvn r1,r1
 795 02c0 0A40     	 and r2,r1
 796 02c2 1A66     	 str r2,[r3,#96]
  82:../XMC1100-LibHaas.c **** 					PORT2->IOCR4 &= ~(1UL << (((bitnr-4) * 8 ) + 7 ));
 797              	 .loc 3 82 0
 798 02c4 2D4B     	 ldr r3,.L42+8
 799 02c6 2D4A     	 ldr r2,.L42+8
 800 02c8 5269     	 ldr r2,[r2,#20]
 801 02ca B91D     	 add r1,r7,#6
 802 02cc 0978     	 ldrb r1,[r1]
 803 02ce 0439     	 sub r1,r1,#4
 804 02d0 C900     	 lsl r1,r1,#3
 805 02d2 0731     	 add r1,r1,#7
 806 02d4 0120     	 mov r0,#1
 807 02d6 8840     	 lsl r0,r0,r1
 808 02d8 011C     	 mov r1,r0
 809 02da C943     	 mvn r1,r1
 810 02dc 0A40     	 and r2,r1
 811 02de 5A61     	 str r2,[r3,#20]
 812              	.L38:
  83:../XMC1100-LibHaas.c **** 				}
  84:../XMC1100-LibHaas.c **** 	  		if ((bitnr < 10) && (bitnr > 7)) {
 813              	 .loc 3 84 0
 814 02e0 BB1D     	 add r3,r7,#6
 815 02e2 1B78     	 ldrb r3,[r3]
 816 02e4 092B     	 cmp r3,#9
 817 02e6 11D8     	 bhi .L39
 818              	 .loc 3 84 0 is_stmt 0 discriminator 1
 819 02e8 BB1D     	 add r3,r7,#6
 820 02ea 1B78     	 ldrb r3,[r3]
 821 02ec 072B     	 cmp r3,#7
 822 02ee 0DD9     	 bls .L39
  85:../XMC1100-LibHaas.c **** 	  			PORT2->IOCR8 &= ~(1UL << (((bitnr-8) * 8 ) + 7 ));
 823              	 .loc 3 85 0 is_stmt 1
 824 02f0 224B     	 ldr r3,.L42+8
 825 02f2 224A     	 ldr r2,.L42+8
 826 02f4 9269     	 ldr r2,[r2,#24]
 827 02f6 B91D     	 add r1,r7,#6
 828 02f8 0978     	 ldrb r1,[r1]
 829 02fa 0839     	 sub r1,r1,#8
 830 02fc C900     	 lsl r1,r1,#3
 831 02fe 0731     	 add r1,r1,#7
 832 0300 0120     	 mov r0,#1
 833 0302 8840     	 lsl r0,r0,r1
 834 0304 011C     	 mov r1,r0
 835 0306 C943     	 mvn r1,r1
 836 0308 0A40     	 and r2,r1
 837 030a 9A61     	 str r2,[r3,#24]
 838              	.L39:
  86:../XMC1100-LibHaas.c **** 	  		}
  87:../XMC1100-LibHaas.c **** 	  		if (bitnr > 9 ) {
 839              	 .loc 3 87 0
 840 030c BB1D     	 add r3,r7,#6
 841 030e 1B78     	 ldrb r3,[r3]
 842 0310 092B     	 cmp r3,#9
 843 0312 2AD9     	 bls .L40
  88:../XMC1100-LibHaas.c **** 	  			CLR_BIT(PORT2->PDISC,bitnr); // digital Pad aktiv
 844              	 .loc 3 88 0
 845 0314 194B     	 ldr r3,.L42+8
 846 0316 194A     	 ldr r2,.L42+8
 847 0318 126E     	 ldr r2,[r2,#96]
 848 031a B91D     	 add r1,r7,#6
 849 031c 0978     	 ldrb r1,[r1]
 850 031e 0120     	 mov r0,#1
 851 0320 8840     	 lsl r0,r0,r1
 852 0322 011C     	 mov r1,r0
 853 0324 C943     	 mvn r1,r1
 854 0326 0A40     	 and r2,r1
 855 0328 1A66     	 str r2,[r3,#96]
  89:../XMC1100-LibHaas.c **** 	  			if (direction == 1) PORT2->IOCR8 |=1UL << (((bitnr-8) * 8)+7);
 856              	 .loc 3 89 0
 857 032a 7B1D     	 add r3,r7,#5
 858 032c 1B78     	 ldrb r3,[r3]
 859 032e 012B     	 cmp r3,#1
 860 0330 0DD1     	 bne .L41
 861              	 .loc 3 89 0 is_stmt 0 discriminator 1
 862 0332 124B     	 ldr r3,.L42+8
 863 0334 114A     	 ldr r2,.L42+8
 864 0336 9169     	 ldr r1,[r2,#24]
 865 0338 BA1D     	 add r2,r7,#6
 866 033a 1278     	 ldrb r2,[r2]
 867 033c 083A     	 sub r2,r2,#8
 868 033e D200     	 lsl r2,r2,#3
 869 0340 0732     	 add r2,r2,#7
 870 0342 0120     	 mov r0,#1
 871 0344 9040     	 lsl r0,r0,r2
 872 0346 021C     	 mov r2,r0
 873 0348 0A43     	 orr r2,r1
 874 034a 9A61     	 str r2,[r3,#24]
 875 034c 0DE0     	 b .L40
 876              	.L41:
  90:../XMC1100-LibHaas.c **** 	  			else PORT2->IOCR8 &= ~(1UL << (((bitnr-8) * 8 ) + 7 ));
 877              	 .loc 3 90 0 is_stmt 1
 878 034e 0B4B     	 ldr r3,.L42+8
 879 0350 0A4A     	 ldr r2,.L42+8
 880 0352 9269     	 ldr r2,[r2,#24]
 881 0354 B91D     	 add r1,r7,#6
 882 0356 0978     	 ldrb r1,[r1]
 883 0358 0839     	 sub r1,r1,#8
 884 035a C900     	 lsl r1,r1,#3
 885 035c 0731     	 add r1,r1,#7
 886 035e 0120     	 mov r0,#1
 887 0360 8840     	 lsl r0,r0,r1
 888 0362 011C     	 mov r1,r0
 889 0364 C943     	 mvn r1,r1
 890 0366 0A40     	 and r2,r1
 891 0368 9A61     	 str r2,[r3,#24]
 892              	.L40:
  91:../XMC1100-LibHaas.c **** 	  		}
  92:../XMC1100-LibHaas.c ****   			break;
 893              	 .loc 3 92 0
 894 036a C046     	 mov r8,r8
 895              	.L18:
  93:../XMC1100-LibHaas.c **** 	  	}
  94:../XMC1100-LibHaas.c **** 	  }
  95:../XMC1100-LibHaas.c **** }
 896              	 .loc 3 95 0
 897 036c BD46     	 mov sp,r7
 898 036e 03B0     	 add sp,sp,#12
 899              	 
 900 0370 90BD     	 pop {r4,r7,pc}
 901              	.L43:
 902 0372 C046     	 .align 2
 903              	.L42:
 904 0374 00000440 	 .word 1074003968
 905 0378 00010440 	 .word 1074004224
 906 037c 00020440 	 .word 1074004480
 907              	 .cfi_endproc
 908              	.LFE36:
 910              	 .section .text.bit_init_mode,"ax",%progbits
 911              	 .align 2
 912              	 .global bit_init_mode
 913              	 .code 16
 914              	 .thumb_func
 916              	bit_init_mode:
 917              	.LFB37:
  96:../XMC1100-LibHaas.c **** 
  97:../XMC1100-LibHaas.c **** /* --------------------------------------------------------------
  98:../XMC1100-LibHaas.c **** * Einzelnes Bit für Ein- oder Ausgabe initialisieren
  99:../XMC1100-LibHaas.c **** * port: P0,P1,P2 bitnr: 0..15 direction: INP 0, OUTP 1
 100:../XMC1100-LibHaas.c **** * mode: NO_PULL PULLUP PULLDOWN
 101:../XMC1100-LibHaas.c **** */
 102:../XMC1100-LibHaas.c **** void bit_init_mode (uint8_t port, uint8_t bitnr, uint8_t direction, uint8_t mode)
 103:../XMC1100-LibHaas.c **** {
 918              	 .loc 3 103 0
 919              	 .cfi_startproc
 920 0000 B0B5     	 push {r4,r5,r7,lr}
 921              	.LCFI15:
 922              	 .cfi_def_cfa_offset 16
 923              	 .cfi_offset 4,-16
 924              	 .cfi_offset 5,-12
 925              	 .cfi_offset 7,-8
 926              	 .cfi_offset 14,-4
 927 0002 82B0     	 sub sp,sp,#8
 928              	.LCFI16:
 929              	 .cfi_def_cfa_offset 24
 930 0004 00AF     	 add r7,sp,#0
 931              	.LCFI17:
 932              	 .cfi_def_cfa_register 7
 933 0006 051C     	 mov r5,r0
 934 0008 0C1C     	 mov r4,r1
 935 000a 101C     	 mov r0,r2
 936 000c 191C     	 mov r1,r3
 937 000e FB1D     	 add r3,r7,#7
 938 0010 2A1C     	 add r2,r5,#0
 939 0012 1A70     	 strb r2,[r3]
 940 0014 BB1D     	 add r3,r7,#6
 941 0016 221C     	 add r2,r4,#0
 942 0018 1A70     	 strb r2,[r3]
 943 001a 7B1D     	 add r3,r7,#5
 944 001c 021C     	 add r2,r0,#0
 945 001e 1A70     	 strb r2,[r3]
 946 0020 3B1D     	 add r3,r7,#4
 947 0022 0A1C     	 add r2,r1,#0
 948 0024 1A70     	 strb r2,[r3]
 104:../XMC1100-LibHaas.c **** 	switch (port)
 949              	 .loc 3 104 0
 950 0026 FB1D     	 add r3,r7,#7
 951 0028 1B78     	 ldrb r3,[r3]
 952 002a 012B     	 cmp r3,#1
 953 002c 00D1     	 bne .LCB857
 954 002e CFE1     	 b .L46
 955              	.LCB857:
 956 0030 022B     	 cmp r3,#2
 957 0032 00D1     	 bne .LCB859
 958 0034 ABE2     	 b .L47
 959              	.LCB859:
 960 0036 002B     	 cmp r3,#0
 961 0038 01D0     	 beq .LCB861
 962 003a 00F098FD 	 bl .L44
 963              	.LCB861:
 105:../XMC1100-LibHaas.c **** 	{
 106:../XMC1100-LibHaas.c **** 		case 0 :
 107:../XMC1100-LibHaas.c **** 		{
 108:../XMC1100-LibHaas.c **** 			if (bitnr < 4 ) {
 964              	 .loc 3 108 0
 965 003e BB1D     	 add r3,r7,#6
 966 0040 1B78     	 ldrb r3,[r3]
 967 0042 032B     	 cmp r3,#3
 968 0044 65D8     	 bhi .L49
 109:../XMC1100-LibHaas.c **** 				if (direction == 1) {
 969              	 .loc 3 109 0
 970 0046 7B1D     	 add r3,r7,#5
 971 0048 1B78     	 ldrb r3,[r3]
 972 004a 012B     	 cmp r3,#1
 973 004c 19D1     	 bne .L50
 110:../XMC1100-LibHaas.c **** 					PORT0->IOCR0 |=1UL << ((bitnr * 8)+7);
 974              	 .loc 3 110 0
 975 004e DF4B     	 ldr r3,.L100
 976 0050 DE4A     	 ldr r2,.L100
 977 0052 1169     	 ldr r1,[r2,#16]
 978 0054 BA1D     	 add r2,r7,#6
 979 0056 1278     	 ldrb r2,[r2]
 980 0058 D200     	 lsl r2,r2,#3
 981 005a 0732     	 add r2,r2,#7
 982 005c 0120     	 mov r0,#1
 983 005e 9040     	 lsl r0,r0,r2
 984 0060 021C     	 mov r2,r0
 985 0062 0A43     	 orr r2,r1
 986 0064 1A61     	 str r2,[r3,#16]
 111:../XMC1100-LibHaas.c **** 					PORT0->IOCR0 &= ~(0x0000000F << ((bitnr * 8)+3));
 987              	 .loc 3 111 0
 988 0066 D94B     	 ldr r3,.L100
 989 0068 D84A     	 ldr r2,.L100
 990 006a 1269     	 ldr r2,[r2,#16]
 991 006c B91D     	 add r1,r7,#6
 992 006e 0978     	 ldrb r1,[r1]
 993 0070 C900     	 lsl r1,r1,#3
 994 0072 0331     	 add r1,r1,#3
 995 0074 0F20     	 mov r0,#15
 996 0076 8840     	 lsl r0,r0,r1
 997 0078 011C     	 mov r1,r0
 998 007a C943     	 mvn r1,r1
 999 007c 0A40     	 and r2,r1
 1000 007e 1A61     	 str r2,[r3,#16]
 1001 0080 47E0     	 b .L49
 1002              	.L50:
 112:../XMC1100-LibHaas.c **** 				}
 113:../XMC1100-LibHaas.c **** 				else {
 114:../XMC1100-LibHaas.c **** 					PORT0->IOCR0 &= ~(1UL << ((bitnr * 8 ) + 7 ));
 1003              	 .loc 3 114 0
 1004 0082 D24B     	 ldr r3,.L100
 1005 0084 D14A     	 ldr r2,.L100
 1006 0086 1269     	 ldr r2,[r2,#16]
 1007 0088 B91D     	 add r1,r7,#6
 1008 008a 0978     	 ldrb r1,[r1]
 1009 008c C900     	 lsl r1,r1,#3
 1010 008e 0731     	 add r1,r1,#7
 1011 0090 0120     	 mov r0,#1
 1012 0092 8840     	 lsl r0,r0,r1
 1013 0094 011C     	 mov r1,r0
 1014 0096 C943     	 mvn r1,r1
 1015 0098 0A40     	 and r2,r1
 1016 009a 1A61     	 str r2,[r3,#16]
 115:../XMC1100-LibHaas.c **** 					if (mode == PULLUP) {
 1017              	 .loc 3 115 0
 1018 009c 3B1D     	 add r3,r7,#4
 1019 009e 1B78     	 ldrb r3,[r3]
 1020 00a0 012B     	 cmp r3,#1
 1021 00a2 19D1     	 bne .L51
 116:../XMC1100-LibHaas.c **** 						PORT0->IOCR0 &= ~(0x0000001F << ((bitnr * 8)+3) );
 1022              	 .loc 3 116 0
 1023 00a4 C94B     	 ldr r3,.L100
 1024 00a6 C94A     	 ldr r2,.L100
 1025 00a8 1269     	 ldr r2,[r2,#16]
 1026 00aa B91D     	 add r1,r7,#6
 1027 00ac 0978     	 ldrb r1,[r1]
 1028 00ae C900     	 lsl r1,r1,#3
 1029 00b0 0331     	 add r1,r1,#3
 1030 00b2 1F20     	 mov r0,#31
 1031 00b4 8840     	 lsl r0,r0,r1
 1032 00b6 011C     	 mov r1,r0
 1033 00b8 C943     	 mvn r1,r1
 1034 00ba 0A40     	 and r2,r1
 1035 00bc 1A61     	 str r2,[r3,#16]
 117:../XMC1100-LibHaas.c **** 						PORT0->IOCR0 |= (1UL << ((bitnr * 8)+4) );
 1036              	 .loc 3 117 0
 1037 00be C34B     	 ldr r3,.L100
 1038 00c0 C24A     	 ldr r2,.L100
 1039 00c2 1169     	 ldr r1,[r2,#16]
 1040 00c4 BA1D     	 add r2,r7,#6
 1041 00c6 1278     	 ldrb r2,[r2]
 1042 00c8 D200     	 lsl r2,r2,#3
 1043 00ca 0432     	 add r2,r2,#4
 1044 00cc 0120     	 mov r0,#1
 1045 00ce 9040     	 lsl r0,r0,r2
 1046 00d0 021C     	 mov r2,r0
 1047 00d2 0A43     	 orr r2,r1
 1048 00d4 1A61     	 str r2,[r3,#16]
 1049 00d6 1CE0     	 b .L49
 1050              	.L51:
 118:../XMC1100-LibHaas.c **** 					} else if (mode == PULLDOWN) {
 1051              	 .loc 3 118 0
 1052 00d8 3B1D     	 add r3,r7,#4
 1053 00da 1B78     	 ldrb r3,[r3]
 1054 00dc 022B     	 cmp r3,#2
 1055 00de 18D1     	 bne .L49
 119:../XMC1100-LibHaas.c **** 						PORT0->IOCR0 &= ~(0x0000001F << ((bitnr * 8)+3) );
 1056              	 .loc 3 119 0
 1057 00e0 BA4B     	 ldr r3,.L100
 1058 00e2 BA4A     	 ldr r2,.L100
 1059 00e4 1269     	 ldr r2,[r2,#16]
 1060 00e6 B91D     	 add r1,r7,#6
 1061 00e8 0978     	 ldrb r1,[r1]
 1062 00ea C900     	 lsl r1,r1,#3
 1063 00ec 0331     	 add r1,r1,#3
 1064 00ee 1F20     	 mov r0,#31
 1065 00f0 8840     	 lsl r0,r0,r1
 1066 00f2 011C     	 mov r1,r0
 1067 00f4 C943     	 mvn r1,r1
 1068 00f6 0A40     	 and r2,r1
 1069 00f8 1A61     	 str r2,[r3,#16]
 120:../XMC1100-LibHaas.c **** 						PORT0->IOCR0 |= (1UL << ((bitnr * 8)+3) );
 1070              	 .loc 3 120 0
 1071 00fa B44B     	 ldr r3,.L100
 1072 00fc B34A     	 ldr r2,.L100
 1073 00fe 1169     	 ldr r1,[r2,#16]
 1074 0100 BA1D     	 add r2,r7,#6
 1075 0102 1278     	 ldrb r2,[r2]
 1076 0104 D200     	 lsl r2,r2,#3
 1077 0106 0332     	 add r2,r2,#3
 1078 0108 0120     	 mov r0,#1
 1079 010a 9040     	 lsl r0,r0,r2
 1080 010c 021C     	 mov r2,r0
 1081 010e 0A43     	 orr r2,r1
 1082 0110 1A61     	 str r2,[r3,#16]
 1083              	.L49:
 121:../XMC1100-LibHaas.c **** 					}
 122:../XMC1100-LibHaas.c **** 				}
 123:../XMC1100-LibHaas.c **** 			}
 124:../XMC1100-LibHaas.c **** 			if ( (bitnr <8) && (bitnr > 3)) {
 1084              	 .loc 3 124 0
 1085 0112 BB1D     	 add r3,r7,#6
 1086 0114 1B78     	 ldrb r3,[r3]
 1087 0116 072B     	 cmp r3,#7
 1088 0118 6ED8     	 bhi .L52
 1089              	 .loc 3 124 0 is_stmt 0 discriminator 1
 1090 011a BB1D     	 add r3,r7,#6
 1091 011c 1B78     	 ldrb r3,[r3]
 1092 011e 032B     	 cmp r3,#3
 1093 0120 6AD9     	 bls .L52
 125:../XMC1100-LibHaas.c **** 				if (direction == 1) {
 1094              	 .loc 3 125 0 is_stmt 1
 1095 0122 7B1D     	 add r3,r7,#5
 1096 0124 1B78     	 ldrb r3,[r3]
 1097 0126 012B     	 cmp r3,#1
 1098 0128 1BD1     	 bne .L53
 126:../XMC1100-LibHaas.c **** 					PORT0->IOCR4 |= 1UL<< (((bitnr-4) * 8)+7);
 1099              	 .loc 3 126 0
 1100 012a A84B     	 ldr r3,.L100
 1101 012c A74A     	 ldr r2,.L100
 1102 012e 5169     	 ldr r1,[r2,#20]
 1103 0130 BA1D     	 add r2,r7,#6
 1104 0132 1278     	 ldrb r2,[r2]
 1105 0134 043A     	 sub r2,r2,#4
 1106 0136 D200     	 lsl r2,r2,#3
 1107 0138 0732     	 add r2,r2,#7
 1108 013a 0120     	 mov r0,#1
 1109 013c 9040     	 lsl r0,r0,r2
 1110 013e 021C     	 mov r2,r0
 1111 0140 0A43     	 orr r2,r1
 1112 0142 5A61     	 str r2,[r3,#20]
 127:../XMC1100-LibHaas.c **** 					PORT0->IOCR4 &= ~(0x0000000F << (((bitnr-4) * 8)+3));
 1113              	 .loc 3 127 0
 1114 0144 A14B     	 ldr r3,.L100
 1115 0146 A14A     	 ldr r2,.L100
 1116 0148 5269     	 ldr r2,[r2,#20]
 1117 014a B91D     	 add r1,r7,#6
 1118 014c 0978     	 ldrb r1,[r1]
 1119 014e 0439     	 sub r1,r1,#4
 1120 0150 C900     	 lsl r1,r1,#3
 1121 0152 0331     	 add r1,r1,#3
 1122 0154 0F20     	 mov r0,#15
 1123 0156 8840     	 lsl r0,r0,r1
 1124 0158 011C     	 mov r1,r0
 1125 015a C943     	 mvn r1,r1
 1126 015c 0A40     	 and r2,r1
 1127 015e 5A61     	 str r2,[r3,#20]
 1128 0160 4AE0     	 b .L52
 1129              	.L53:
 128:../XMC1100-LibHaas.c **** 				}
 129:../XMC1100-LibHaas.c **** 				else {
 130:../XMC1100-LibHaas.c **** 					PORT0->IOCR4 &= ~(1UL << (((bitnr-4) * 8)+7) );
 1130              	 .loc 3 130 0
 1131 0162 9A4B     	 ldr r3,.L100
 1132 0164 994A     	 ldr r2,.L100
 1133 0166 5269     	 ldr r2,[r2,#20]
 1134 0168 B91D     	 add r1,r7,#6
 1135 016a 0978     	 ldrb r1,[r1]
 1136 016c 0439     	 sub r1,r1,#4
 1137 016e C900     	 lsl r1,r1,#3
 1138 0170 0731     	 add r1,r1,#7
 1139 0172 0120     	 mov r0,#1
 1140 0174 8840     	 lsl r0,r0,r1
 1141 0176 011C     	 mov r1,r0
 1142 0178 C943     	 mvn r1,r1
 1143 017a 0A40     	 and r2,r1
 1144 017c 5A61     	 str r2,[r3,#20]
 131:../XMC1100-LibHaas.c **** 					if (mode == PULLUP) {
 1145              	 .loc 3 131 0
 1146 017e 3B1D     	 add r3,r7,#4
 1147 0180 1B78     	 ldrb r3,[r3]
 1148 0182 012B     	 cmp r3,#1
 1149 0184 1BD1     	 bne .L54
 132:../XMC1100-LibHaas.c **** 						PORT0->IOCR4 &= ~(0x0000001F << (((bitnr-4) * 8)+3) );
 1150              	 .loc 3 132 0
 1151 0186 914B     	 ldr r3,.L100
 1152 0188 904A     	 ldr r2,.L100
 1153 018a 5269     	 ldr r2,[r2,#20]
 1154 018c B91D     	 add r1,r7,#6
 1155 018e 0978     	 ldrb r1,[r1]
 1156 0190 0439     	 sub r1,r1,#4
 1157 0192 C900     	 lsl r1,r1,#3
 1158 0194 0331     	 add r1,r1,#3
 1159 0196 1F20     	 mov r0,#31
 1160 0198 8840     	 lsl r0,r0,r1
 1161 019a 011C     	 mov r1,r0
 1162 019c C943     	 mvn r1,r1
 1163 019e 0A40     	 and r2,r1
 1164 01a0 5A61     	 str r2,[r3,#20]
 133:../XMC1100-LibHaas.c **** 						PORT0->IOCR4 |= (1UL << (((bitnr-4) * 8)+4) );
 1165              	 .loc 3 133 0
 1166 01a2 8A4B     	 ldr r3,.L100
 1167 01a4 894A     	 ldr r2,.L100
 1168 01a6 5169     	 ldr r1,[r2,#20]
 1169 01a8 BA1D     	 add r2,r7,#6
 1170 01aa 1278     	 ldrb r2,[r2]
 1171 01ac 043A     	 sub r2,r2,#4
 1172 01ae D200     	 lsl r2,r2,#3
 1173 01b0 0432     	 add r2,r2,#4
 1174 01b2 0120     	 mov r0,#1
 1175 01b4 9040     	 lsl r0,r0,r2
 1176 01b6 021C     	 mov r2,r0
 1177 01b8 0A43     	 orr r2,r1
 1178 01ba 5A61     	 str r2,[r3,#20]
 1179 01bc 1CE0     	 b .L52
 1180              	.L54:
 134:../XMC1100-LibHaas.c **** 					}else if (mode == PULLDOWN) {
 1181              	 .loc 3 134 0
 1182 01be 3B1D     	 add r3,r7,#4
 1183 01c0 1B78     	 ldrb r3,[r3]
 1184 01c2 022B     	 cmp r3,#2
 1185 01c4 18D1     	 bne .L52
 135:../XMC1100-LibHaas.c **** 						PORT0->IOCR4 &= ~(0x0000001F << ((bitnr * 8)+3) );
 1186              	 .loc 3 135 0
 1187 01c6 814B     	 ldr r3,.L100
 1188 01c8 804A     	 ldr r2,.L100
 1189 01ca 5269     	 ldr r2,[r2,#20]
 1190 01cc B91D     	 add r1,r7,#6
 1191 01ce 0978     	 ldrb r1,[r1]
 1192 01d0 C900     	 lsl r1,r1,#3
 1193 01d2 0331     	 add r1,r1,#3
 1194 01d4 1F20     	 mov r0,#31
 1195 01d6 8840     	 lsl r0,r0,r1
 1196 01d8 011C     	 mov r1,r0
 1197 01da C943     	 mvn r1,r1
 1198 01dc 0A40     	 and r2,r1
 1199 01de 5A61     	 str r2,[r3,#20]
 136:../XMC1100-LibHaas.c **** 						PORT0->IOCR4 |= (1UL << ((bitnr * 8)+3) );
 1200              	 .loc 3 136 0
 1201 01e0 7A4B     	 ldr r3,.L100
 1202 01e2 7A4A     	 ldr r2,.L100
 1203 01e4 5169     	 ldr r1,[r2,#20]
 1204 01e6 BA1D     	 add r2,r7,#6
 1205 01e8 1278     	 ldrb r2,[r2]
 1206 01ea D200     	 lsl r2,r2,#3
 1207 01ec 0332     	 add r2,r2,#3
 1208 01ee 0120     	 mov r0,#1
 1209 01f0 9040     	 lsl r0,r0,r2
 1210 01f2 021C     	 mov r2,r0
 1211 01f4 0A43     	 orr r2,r1
 1212 01f6 5A61     	 str r2,[r3,#20]
 1213              	.L52:
 137:../XMC1100-LibHaas.c **** 					}
 138:../XMC1100-LibHaas.c **** 				}
 139:../XMC1100-LibHaas.c **** 			}
 140:../XMC1100-LibHaas.c **** 			if ( (bitnr <12) && (bitnr > 7)) {
 1214              	 .loc 3 140 0
 1215 01f8 BB1D     	 add r3,r7,#6
 1216 01fa 1B78     	 ldrb r3,[r3]
 1217 01fc 0B2B     	 cmp r3,#11
 1218 01fe 6ED8     	 bhi .L55
 1219              	 .loc 3 140 0 is_stmt 0 discriminator 1
 1220 0200 BB1D     	 add r3,r7,#6
 1221 0202 1B78     	 ldrb r3,[r3]
 1222 0204 072B     	 cmp r3,#7
 1223 0206 6AD9     	 bls .L55
 141:../XMC1100-LibHaas.c **** 				if (direction == 1) {
 1224              	 .loc 3 141 0 is_stmt 1
 1225 0208 7B1D     	 add r3,r7,#5
 1226 020a 1B78     	 ldrb r3,[r3]
 1227 020c 012B     	 cmp r3,#1
 1228 020e 1BD1     	 bne .L56
 142:../XMC1100-LibHaas.c **** 					PORT0->IOCR8 |= 1UL << (((bitnr-8) * 8)+7);
 1229              	 .loc 3 142 0
 1230 0210 6E4B     	 ldr r3,.L100
 1231 0212 6E4A     	 ldr r2,.L100
 1232 0214 9169     	 ldr r1,[r2,#24]
 1233 0216 BA1D     	 add r2,r7,#6
 1234 0218 1278     	 ldrb r2,[r2]
 1235 021a 083A     	 sub r2,r2,#8
 1236 021c D200     	 lsl r2,r2,#3
 1237 021e 0732     	 add r2,r2,#7
 1238 0220 0120     	 mov r0,#1
 1239 0222 9040     	 lsl r0,r0,r2
 1240 0224 021C     	 mov r2,r0
 1241 0226 0A43     	 orr r2,r1
 1242 0228 9A61     	 str r2,[r3,#24]
 143:../XMC1100-LibHaas.c **** 					PORT0->IOCR8 &= ~(0x0000000F << (((bitnr-8) * 8)+3));
 1243              	 .loc 3 143 0
 1244 022a 684B     	 ldr r3,.L100
 1245 022c 674A     	 ldr r2,.L100
 1246 022e 9269     	 ldr r2,[r2,#24]
 1247 0230 B91D     	 add r1,r7,#6
 1248 0232 0978     	 ldrb r1,[r1]
 1249 0234 0839     	 sub r1,r1,#8
 1250 0236 C900     	 lsl r1,r1,#3
 1251 0238 0331     	 add r1,r1,#3
 1252 023a 0F20     	 mov r0,#15
 1253 023c 8840     	 lsl r0,r0,r1
 1254 023e 011C     	 mov r1,r0
 1255 0240 C943     	 mvn r1,r1
 1256 0242 0A40     	 and r2,r1
 1257 0244 9A61     	 str r2,[r3,#24]
 1258 0246 4AE0     	 b .L55
 1259              	.L56:
 144:../XMC1100-LibHaas.c **** 				}
 145:../XMC1100-LibHaas.c **** 				else {
 146:../XMC1100-LibHaas.c **** 					PORT0->IOCR8 &= ~(1UL << (((bitnr-8) * 8)+7) );
 1260              	 .loc 3 146 0
 1261 0248 604B     	 ldr r3,.L100
 1262 024a 604A     	 ldr r2,.L100
 1263 024c 9269     	 ldr r2,[r2,#24]
 1264 024e B91D     	 add r1,r7,#6
 1265 0250 0978     	 ldrb r1,[r1]
 1266 0252 0839     	 sub r1,r1,#8
 1267 0254 C900     	 lsl r1,r1,#3
 1268 0256 0731     	 add r1,r1,#7
 1269 0258 0120     	 mov r0,#1
 1270 025a 8840     	 lsl r0,r0,r1
 1271 025c 011C     	 mov r1,r0
 1272 025e C943     	 mvn r1,r1
 1273 0260 0A40     	 and r2,r1
 1274 0262 9A61     	 str r2,[r3,#24]
 147:../XMC1100-LibHaas.c **** 					if (mode == PULLUP) {
 1275              	 .loc 3 147 0
 1276 0264 3B1D     	 add r3,r7,#4
 1277 0266 1B78     	 ldrb r3,[r3]
 1278 0268 012B     	 cmp r3,#1
 1279 026a 1BD1     	 bne .L57
 148:../XMC1100-LibHaas.c **** 						PORT0->IOCR8 &= ~(0x0000001F << (((bitnr-8) * 8)+3) );
 1280              	 .loc 3 148 0
 1281 026c 574B     	 ldr r3,.L100
 1282 026e 574A     	 ldr r2,.L100
 1283 0270 9269     	 ldr r2,[r2,#24]
 1284 0272 B91D     	 add r1,r7,#6
 1285 0274 0978     	 ldrb r1,[r1]
 1286 0276 0839     	 sub r1,r1,#8
 1287 0278 C900     	 lsl r1,r1,#3
 1288 027a 0331     	 add r1,r1,#3
 1289 027c 1F20     	 mov r0,#31
 1290 027e 8840     	 lsl r0,r0,r1
 1291 0280 011C     	 mov r1,r0
 1292 0282 C943     	 mvn r1,r1
 1293 0284 0A40     	 and r2,r1
 1294 0286 9A61     	 str r2,[r3,#24]
 149:../XMC1100-LibHaas.c **** 						PORT0->IOCR8 |= (1UL << (((bitnr-8) * 8)+4) );
 1295              	 .loc 3 149 0
 1296 0288 504B     	 ldr r3,.L100
 1297 028a 504A     	 ldr r2,.L100
 1298 028c 9169     	 ldr r1,[r2,#24]
 1299 028e BA1D     	 add r2,r7,#6
 1300 0290 1278     	 ldrb r2,[r2]
 1301 0292 083A     	 sub r2,r2,#8
 1302 0294 D200     	 lsl r2,r2,#3
 1303 0296 0432     	 add r2,r2,#4
 1304 0298 0120     	 mov r0,#1
 1305 029a 9040     	 lsl r0,r0,r2
 1306 029c 021C     	 mov r2,r0
 1307 029e 0A43     	 orr r2,r1
 1308 02a0 9A61     	 str r2,[r3,#24]
 1309 02a2 1CE0     	 b .L55
 1310              	.L57:
 150:../XMC1100-LibHaas.c **** 					} else if (mode == PULLDOWN) {
 1311              	 .loc 3 150 0
 1312 02a4 3B1D     	 add r3,r7,#4
 1313 02a6 1B78     	 ldrb r3,[r3]
 1314 02a8 022B     	 cmp r3,#2
 1315 02aa 18D1     	 bne .L55
 151:../XMC1100-LibHaas.c **** 						PORT0->IOCR8 &= ~(0x0000001F << ((bitnr * 8)+3) );
 1316              	 .loc 3 151 0
 1317 02ac 474B     	 ldr r3,.L100
 1318 02ae 474A     	 ldr r2,.L100
 1319 02b0 9269     	 ldr r2,[r2,#24]
 1320 02b2 B91D     	 add r1,r7,#6
 1321 02b4 0978     	 ldrb r1,[r1]
 1322 02b6 C900     	 lsl r1,r1,#3
 1323 02b8 0331     	 add r1,r1,#3
 1324 02ba 1F20     	 mov r0,#31
 1325 02bc 8840     	 lsl r0,r0,r1
 1326 02be 011C     	 mov r1,r0
 1327 02c0 C943     	 mvn r1,r1
 1328 02c2 0A40     	 and r2,r1
 1329 02c4 9A61     	 str r2,[r3,#24]
 152:../XMC1100-LibHaas.c **** 						PORT0->IOCR8 |= (1UL << ((bitnr * 8)+3) );
 1330              	 .loc 3 152 0
 1331 02c6 414B     	 ldr r3,.L100
 1332 02c8 404A     	 ldr r2,.L100
 1333 02ca 9169     	 ldr r1,[r2,#24]
 1334 02cc BA1D     	 add r2,r7,#6
 1335 02ce 1278     	 ldrb r2,[r2]
 1336 02d0 D200     	 lsl r2,r2,#3
 1337 02d2 0332     	 add r2,r2,#3
 1338 02d4 0120     	 mov r0,#1
 1339 02d6 9040     	 lsl r0,r0,r2
 1340 02d8 021C     	 mov r2,r0
 1341 02da 0A43     	 orr r2,r1
 1342 02dc 9A61     	 str r2,[r3,#24]
 1343              	.L55:
 153:../XMC1100-LibHaas.c **** 					}
 154:../XMC1100-LibHaas.c **** 				}
 155:../XMC1100-LibHaas.c **** 			}
 156:../XMC1100-LibHaas.c **** 			if ( (bitnr <16) && (bitnr > 11)) {
 1344              	 .loc 3 156 0
 1345 02de BB1D     	 add r3,r7,#6
 1346 02e0 1B78     	 ldrb r3,[r3]
 1347 02e2 0F2B     	 cmp r3,#15
 1348 02e4 70D8     	 bhi .L58
 1349              	 .loc 3 156 0 is_stmt 0 discriminator 1
 1350 02e6 BB1D     	 add r3,r7,#6
 1351 02e8 1B78     	 ldrb r3,[r3]
 1352 02ea 0B2B     	 cmp r3,#11
 1353 02ec 6CD9     	 bls .L58
 157:../XMC1100-LibHaas.c **** 				if (direction == OUTP){
 1354              	 .loc 3 157 0 is_stmt 1
 1355 02ee 7B1D     	 add r3,r7,#5
 1356 02f0 1B78     	 ldrb r3,[r3]
 1357 02f2 012B     	 cmp r3,#1
 1358 02f4 1BD1     	 bne .L59
 158:../XMC1100-LibHaas.c **** 					PORT0->IOCR12 |= 1UL << (((bitnr-12) * 8)+7);
 1359              	 .loc 3 158 0
 1360 02f6 354B     	 ldr r3,.L100
 1361 02f8 344A     	 ldr r2,.L100
 1362 02fa D169     	 ldr r1,[r2,#28]
 1363 02fc BA1D     	 add r2,r7,#6
 1364 02fe 1278     	 ldrb r2,[r2]
 1365 0300 0C3A     	 sub r2,r2,#12
 1366 0302 D200     	 lsl r2,r2,#3
 1367 0304 0732     	 add r2,r2,#7
 1368 0306 0120     	 mov r0,#1
 1369 0308 9040     	 lsl r0,r0,r2
 1370 030a 021C     	 mov r2,r0
 1371 030c 0A43     	 orr r2,r1
 1372 030e DA61     	 str r2,[r3,#28]
 159:../XMC1100-LibHaas.c **** 					PORT0->IOCR12 &= ~(0x0000000F << (((bitnr-12) * 8)+3));
 1373              	 .loc 3 159 0
 1374 0310 2E4B     	 ldr r3,.L100
 1375 0312 2E4A     	 ldr r2,.L100
 1376 0314 D269     	 ldr r2,[r2,#28]
 1377 0316 B91D     	 add r1,r7,#6
 1378 0318 0978     	 ldrb r1,[r1]
 1379 031a 0C39     	 sub r1,r1,#12
 1380 031c C900     	 lsl r1,r1,#3
 1381 031e 0331     	 add r1,r1,#3
 1382 0320 0F20     	 mov r0,#15
 1383 0322 8840     	 lsl r0,r0,r1
 1384 0324 011C     	 mov r1,r0
 1385 0326 C943     	 mvn r1,r1
 1386 0328 0A40     	 and r2,r1
 1387 032a DA61     	 str r2,[r3,#28]
 1388 032c 4CE0     	 b .L58
 1389              	.L59:
 160:../XMC1100-LibHaas.c **** 				}
 161:../XMC1100-LibHaas.c **** 				else {
 162:../XMC1100-LibHaas.c **** 					PORT0->IOCR12 &= ~(1UL << (((bitnr-12) * 8)+7) );
 1390              	 .loc 3 162 0
 1391 032e 274B     	 ldr r3,.L100
 1392 0330 264A     	 ldr r2,.L100
 1393 0332 D269     	 ldr r2,[r2,#28]
 1394 0334 B91D     	 add r1,r7,#6
 1395 0336 0978     	 ldrb r1,[r1]
 1396 0338 0C39     	 sub r1,r1,#12
 1397 033a C900     	 lsl r1,r1,#3
 1398 033c 0731     	 add r1,r1,#7
 1399 033e 0120     	 mov r0,#1
 1400 0340 8840     	 lsl r0,r0,r1
 1401 0342 011C     	 mov r1,r0
 1402 0344 C943     	 mvn r1,r1
 1403 0346 0A40     	 and r2,r1
 1404 0348 DA61     	 str r2,[r3,#28]
 163:../XMC1100-LibHaas.c **** 					if (mode == PULLUP) {
 1405              	 .loc 3 163 0
 1406 034a 3B1D     	 add r3,r7,#4
 1407 034c 1B78     	 ldrb r3,[r3]
 1408 034e 012B     	 cmp r3,#1
 1409 0350 1BD1     	 bne .L60
 164:../XMC1100-LibHaas.c **** 						PORT0->IOCR12 &= ~(0x0000001F << (((bitnr-12) * 8)+3) );
 1410              	 .loc 3 164 0
 1411 0352 1E4B     	 ldr r3,.L100
 1412 0354 1D4A     	 ldr r2,.L100
 1413 0356 D269     	 ldr r2,[r2,#28]
 1414 0358 B91D     	 add r1,r7,#6
 1415 035a 0978     	 ldrb r1,[r1]
 1416 035c 0C39     	 sub r1,r1,#12
 1417 035e C900     	 lsl r1,r1,#3
 1418 0360 0331     	 add r1,r1,#3
 1419 0362 1F20     	 mov r0,#31
 1420 0364 8840     	 lsl r0,r0,r1
 1421 0366 011C     	 mov r1,r0
 1422 0368 C943     	 mvn r1,r1
 1423 036a 0A40     	 and r2,r1
 1424 036c DA61     	 str r2,[r3,#28]
 165:../XMC1100-LibHaas.c **** 						PORT0->IOCR12 |= (1UL << (((bitnr-12) * 8)+4) );
 1425              	 .loc 3 165 0
 1426 036e 174B     	 ldr r3,.L100
 1427 0370 164A     	 ldr r2,.L100
 1428 0372 D169     	 ldr r1,[r2,#28]
 1429 0374 BA1D     	 add r2,r7,#6
 1430 0376 1278     	 ldrb r2,[r2]
 1431 0378 0C3A     	 sub r2,r2,#12
 1432 037a D200     	 lsl r2,r2,#3
 1433 037c 0432     	 add r2,r2,#4
 1434 037e 0120     	 mov r0,#1
 1435 0380 9040     	 lsl r0,r0,r2
 1436 0382 021C     	 mov r2,r0
 1437 0384 0A43     	 orr r2,r1
 1438 0386 DA61     	 str r2,[r3,#28]
 1439 0388 1EE0     	 b .L58
 1440              	.L60:
 166:../XMC1100-LibHaas.c **** 					}else if (mode == PULLDOWN) {
 1441              	 .loc 3 166 0
 1442 038a 3B1D     	 add r3,r7,#4
 1443 038c 1B78     	 ldrb r3,[r3]
 1444 038e 022B     	 cmp r3,#2
 1445 0390 1AD1     	 bne .L58
 167:../XMC1100-LibHaas.c **** 						PORT0->IOCR12 &= ~(0x0000001F << ((bitnr * 8)+3) );
 1446              	 .loc 3 167 0
 1447 0392 0E4B     	 ldr r3,.L100
 1448 0394 0D4A     	 ldr r2,.L100
 1449 0396 D269     	 ldr r2,[r2,#28]
 1450 0398 B91D     	 add r1,r7,#6
 1451 039a 0978     	 ldrb r1,[r1]
 1452 039c C900     	 lsl r1,r1,#3
 1453 039e 0331     	 add r1,r1,#3
 1454 03a0 1F20     	 mov r0,#31
 1455 03a2 8840     	 lsl r0,r0,r1
 1456 03a4 011C     	 mov r1,r0
 1457 03a6 C943     	 mvn r1,r1
 1458 03a8 0A40     	 and r2,r1
 1459 03aa DA61     	 str r2,[r3,#28]
 168:../XMC1100-LibHaas.c **** 						PORT0->IOCR12 |= (1UL << ((bitnr * 8)+3) );
 1460              	 .loc 3 168 0
 1461 03ac 074B     	 ldr r3,.L100
 1462 03ae 074A     	 ldr r2,.L100
 1463 03b0 D169     	 ldr r1,[r2,#28]
 1464 03b2 BA1D     	 add r2,r7,#6
 1465 03b4 1278     	 ldrb r2,[r2]
 1466 03b6 D200     	 lsl r2,r2,#3
 1467 03b8 0332     	 add r2,r2,#3
 1468 03ba 0120     	 mov r0,#1
 1469 03bc 9040     	 lsl r0,r0,r2
 1470 03be 021C     	 mov r2,r0
 1471 03c0 0A43     	 orr r2,r1
 1472 03c2 DA61     	 str r2,[r3,#28]
 169:../XMC1100-LibHaas.c **** 					}
 170:../XMC1100-LibHaas.c **** 				}
 171:../XMC1100-LibHaas.c **** 			}
 172:../XMC1100-LibHaas.c **** 		}
 173:../XMC1100-LibHaas.c **** 		break;
 1473              	 .loc 3 173 0
 1474 03c4 00F0D3FB 	 bl .L44
 1475              	.L58:
 1476 03c8 00F0D1FB 	 bl .L44
 1477              	.L101:
 1478              	 .align 2
 1479              	.L100:
 1480 03cc 00000440 	 .word 1074003968
 1481              	.L46:
 174:../XMC1100-LibHaas.c **** 		case 1 :
 175:../XMC1100-LibHaas.c **** 		{
 176:../XMC1100-LibHaas.c **** 			if (bitnr < 4 ) {
 1482              	 .loc 3 176 0
 1483 03d0 BB1D     	 add r3,r7,#6
 1484 03d2 1B78     	 ldrb r3,[r3]
 1485 03d4 032B     	 cmp r3,#3
 1486 03d6 65D8     	 bhi .L61
 177:../XMC1100-LibHaas.c **** 				if (direction == 1) {
 1487              	 .loc 3 177 0
 1488 03d8 7B1D     	 add r3,r7,#5
 1489 03da 1B78     	 ldrb r3,[r3]
 1490 03dc 012B     	 cmp r3,#1
 1491 03de 19D1     	 bne .L62
 178:../XMC1100-LibHaas.c **** 					PORT1->IOCR0 |=1UL << ((bitnr * 8)+7);
 1492              	 .loc 3 178 0
 1493 03e0 D84B     	 ldr r3,.L102
 1494 03e2 D84A     	 ldr r2,.L102
 1495 03e4 1169     	 ldr r1,[r2,#16]
 1496 03e6 BA1D     	 add r2,r7,#6
 1497 03e8 1278     	 ldrb r2,[r2]
 1498 03ea D200     	 lsl r2,r2,#3
 1499 03ec 0732     	 add r2,r2,#7
 1500 03ee 0120     	 mov r0,#1
 1501 03f0 9040     	 lsl r0,r0,r2
 1502 03f2 021C     	 mov r2,r0
 1503 03f4 0A43     	 orr r2,r1
 1504 03f6 1A61     	 str r2,[r3,#16]
 179:../XMC1100-LibHaas.c **** 					PORT1->IOCR0 &= ~(0x0000000F << ((bitnr * 8)+3));
 1505              	 .loc 3 179 0
 1506 03f8 D24B     	 ldr r3,.L102
 1507 03fa D24A     	 ldr r2,.L102
 1508 03fc 1269     	 ldr r2,[r2,#16]
 1509 03fe B91D     	 add r1,r7,#6
 1510 0400 0978     	 ldrb r1,[r1]
 1511 0402 C900     	 lsl r1,r1,#3
 1512 0404 0331     	 add r1,r1,#3
 1513 0406 0F20     	 mov r0,#15
 1514 0408 8840     	 lsl r0,r0,r1
 1515 040a 011C     	 mov r1,r0
 1516 040c C943     	 mvn r1,r1
 1517 040e 0A40     	 and r2,r1
 1518 0410 1A61     	 str r2,[r3,#16]
 1519 0412 47E0     	 b .L61
 1520              	.L62:
 180:../XMC1100-LibHaas.c **** 				}
 181:../XMC1100-LibHaas.c **** 				else {
 182:../XMC1100-LibHaas.c **** 					PORT1->IOCR0 &= ~(1UL << ((bitnr * 8 ) + 7 ));
 1521              	 .loc 3 182 0
 1522 0414 CB4B     	 ldr r3,.L102
 1523 0416 CB4A     	 ldr r2,.L102
 1524 0418 1269     	 ldr r2,[r2,#16]
 1525 041a B91D     	 add r1,r7,#6
 1526 041c 0978     	 ldrb r1,[r1]
 1527 041e C900     	 lsl r1,r1,#3
 1528 0420 0731     	 add r1,r1,#7
 1529 0422 0120     	 mov r0,#1
 1530 0424 8840     	 lsl r0,r0,r1
 1531 0426 011C     	 mov r1,r0
 1532 0428 C943     	 mvn r1,r1
 1533 042a 0A40     	 and r2,r1
 1534 042c 1A61     	 str r2,[r3,#16]
 183:../XMC1100-LibHaas.c **** 					if (mode == PULLUP) {
 1535              	 .loc 3 183 0
 1536 042e 3B1D     	 add r3,r7,#4
 1537 0430 1B78     	 ldrb r3,[r3]
 1538 0432 012B     	 cmp r3,#1
 1539 0434 19D1     	 bne .L63
 184:../XMC1100-LibHaas.c **** 						PORT1->IOCR0 &= ~(0x0000001F << ((bitnr * 8)+3) );
 1540              	 .loc 3 184 0
 1541 0436 C34B     	 ldr r3,.L102
 1542 0438 C24A     	 ldr r2,.L102
 1543 043a 1269     	 ldr r2,[r2,#16]
 1544 043c B91D     	 add r1,r7,#6
 1545 043e 0978     	 ldrb r1,[r1]
 1546 0440 C900     	 lsl r1,r1,#3
 1547 0442 0331     	 add r1,r1,#3
 1548 0444 1F20     	 mov r0,#31
 1549 0446 8840     	 lsl r0,r0,r1
 1550 0448 011C     	 mov r1,r0
 1551 044a C943     	 mvn r1,r1
 1552 044c 0A40     	 and r2,r1
 1553 044e 1A61     	 str r2,[r3,#16]
 185:../XMC1100-LibHaas.c **** 						PORT1->IOCR0 |= (1UL << ((bitnr * 8)+4) );
 1554              	 .loc 3 185 0
 1555 0450 BC4B     	 ldr r3,.L102
 1556 0452 BC4A     	 ldr r2,.L102
 1557 0454 1169     	 ldr r1,[r2,#16]
 1558 0456 BA1D     	 add r2,r7,#6
 1559 0458 1278     	 ldrb r2,[r2]
 1560 045a D200     	 lsl r2,r2,#3
 1561 045c 0432     	 add r2,r2,#4
 1562 045e 0120     	 mov r0,#1
 1563 0460 9040     	 lsl r0,r0,r2
 1564 0462 021C     	 mov r2,r0
 1565 0464 0A43     	 orr r2,r1
 1566 0466 1A61     	 str r2,[r3,#16]
 1567 0468 1CE0     	 b .L61
 1568              	.L63:
 186:../XMC1100-LibHaas.c **** 					} else if (mode == PULLDOWN) {
 1569              	 .loc 3 186 0
 1570 046a 3B1D     	 add r3,r7,#4
 1571 046c 1B78     	 ldrb r3,[r3]
 1572 046e 022B     	 cmp r3,#2
 1573 0470 18D1     	 bne .L61
 187:../XMC1100-LibHaas.c **** 						PORT1->IOCR0 &= ~(0x0000001F << ((bitnr * 8)+3) );
 1574              	 .loc 3 187 0
 1575 0472 B44B     	 ldr r3,.L102
 1576 0474 B34A     	 ldr r2,.L102
 1577 0476 1269     	 ldr r2,[r2,#16]
 1578 0478 B91D     	 add r1,r7,#6
 1579 047a 0978     	 ldrb r1,[r1]
 1580 047c C900     	 lsl r1,r1,#3
 1581 047e 0331     	 add r1,r1,#3
 1582 0480 1F20     	 mov r0,#31
 1583 0482 8840     	 lsl r0,r0,r1
 1584 0484 011C     	 mov r1,r0
 1585 0486 C943     	 mvn r1,r1
 1586 0488 0A40     	 and r2,r1
 1587 048a 1A61     	 str r2,[r3,#16]
 188:../XMC1100-LibHaas.c **** 						PORT1->IOCR0 |= (1UL << ((bitnr * 8)+3) );
 1588              	 .loc 3 188 0
 1589 048c AD4B     	 ldr r3,.L102
 1590 048e AD4A     	 ldr r2,.L102
 1591 0490 1169     	 ldr r1,[r2,#16]
 1592 0492 BA1D     	 add r2,r7,#6
 1593 0494 1278     	 ldrb r2,[r2]
 1594 0496 D200     	 lsl r2,r2,#3
 1595 0498 0332     	 add r2,r2,#3
 1596 049a 0120     	 mov r0,#1
 1597 049c 9040     	 lsl r0,r0,r2
 1598 049e 021C     	 mov r2,r0
 1599 04a0 0A43     	 orr r2,r1
 1600 04a2 1A61     	 str r2,[r3,#16]
 1601              	.L61:
 189:../XMC1100-LibHaas.c **** 					}
 190:../XMC1100-LibHaas.c **** 				}
 191:../XMC1100-LibHaas.c **** 			}
 192:../XMC1100-LibHaas.c **** 			if ( (bitnr <8) && (bitnr > 3)) {
 1602              	 .loc 3 192 0
 1603 04a4 BB1D     	 add r3,r7,#6
 1604 04a6 1B78     	 ldrb r3,[r3]
 1605 04a8 072B     	 cmp r3,#7
 1606 04aa 6FD8     	 bhi .L64
 1607              	 .loc 3 192 0 is_stmt 0 discriminator 1
 1608 04ac BB1D     	 add r3,r7,#6
 1609 04ae 1B78     	 ldrb r3,[r3]
 1610 04b0 032B     	 cmp r3,#3
 1611 04b2 6BD9     	 bls .L64
 193:../XMC1100-LibHaas.c **** 				if (direction == 1) {
 1612              	 .loc 3 193 0 is_stmt 1
 1613 04b4 7B1D     	 add r3,r7,#5
 1614 04b6 1B78     	 ldrb r3,[r3]
 1615 04b8 012B     	 cmp r3,#1
 1616 04ba 1BD1     	 bne .L65
 194:../XMC1100-LibHaas.c **** 					PORT1->IOCR4 |= 1UL<< (((bitnr-4) * 8)+7);
 1617              	 .loc 3 194 0
 1618 04bc A14B     	 ldr r3,.L102
 1619 04be A14A     	 ldr r2,.L102
 1620 04c0 5169     	 ldr r1,[r2,#20]
 1621 04c2 BA1D     	 add r2,r7,#6
 1622 04c4 1278     	 ldrb r2,[r2]
 1623 04c6 043A     	 sub r2,r2,#4
 1624 04c8 D200     	 lsl r2,r2,#3
 1625 04ca 0732     	 add r2,r2,#7
 1626 04cc 0120     	 mov r0,#1
 1627 04ce 9040     	 lsl r0,r0,r2
 1628 04d0 021C     	 mov r2,r0
 1629 04d2 0A43     	 orr r2,r1
 1630 04d4 5A61     	 str r2,[r3,#20]
 195:../XMC1100-LibHaas.c **** 					PORT1->IOCR4 &= ~(0x0000000F << (((bitnr-4) * 8)+3));
 1631              	 .loc 3 195 0
 1632 04d6 9B4B     	 ldr r3,.L102
 1633 04d8 9A4A     	 ldr r2,.L102
 1634 04da 5269     	 ldr r2,[r2,#20]
 1635 04dc B91D     	 add r1,r7,#6
 1636 04de 0978     	 ldrb r1,[r1]
 1637 04e0 0439     	 sub r1,r1,#4
 1638 04e2 C900     	 lsl r1,r1,#3
 1639 04e4 0331     	 add r1,r1,#3
 1640 04e6 0F20     	 mov r0,#15
 1641 04e8 8840     	 lsl r0,r0,r1
 1642 04ea 011C     	 mov r1,r0
 1643 04ec C943     	 mvn r1,r1
 1644 04ee 0A40     	 and r2,r1
 1645 04f0 5A61     	 str r2,[r3,#20]
 1646 04f2 4BE0     	 b .L64
 1647              	.L65:
 196:../XMC1100-LibHaas.c **** 				}
 197:../XMC1100-LibHaas.c **** 				else {
 198:../XMC1100-LibHaas.c **** 					PORT1->IOCR4 &= ~(1UL << (((bitnr-4) * 8)+7) );
 1648              	 .loc 3 198 0
 1649 04f4 934B     	 ldr r3,.L102
 1650 04f6 934A     	 ldr r2,.L102
 1651 04f8 5269     	 ldr r2,[r2,#20]
 1652 04fa B91D     	 add r1,r7,#6
 1653 04fc 0978     	 ldrb r1,[r1]
 1654 04fe 0439     	 sub r1,r1,#4
 1655 0500 C900     	 lsl r1,r1,#3
 1656 0502 0731     	 add r1,r1,#7
 1657 0504 0120     	 mov r0,#1
 1658 0506 8840     	 lsl r0,r0,r1
 1659 0508 011C     	 mov r1,r0
 1660 050a C943     	 mvn r1,r1
 1661 050c 0A40     	 and r2,r1
 1662 050e 5A61     	 str r2,[r3,#20]
 199:../XMC1100-LibHaas.c **** 					if (mode == PULLUP) {
 1663              	 .loc 3 199 0
 1664 0510 3B1D     	 add r3,r7,#4
 1665 0512 1B78     	 ldrb r3,[r3]
 1666 0514 012B     	 cmp r3,#1
 1667 0516 1BD1     	 bne .L66
 200:../XMC1100-LibHaas.c **** 						PORT1->IOCR4 &= ~(0x0000001F << (((bitnr-4) * 8)+3) );
 1668              	 .loc 3 200 0
 1669 0518 8A4B     	 ldr r3,.L102
 1670 051a 8A4A     	 ldr r2,.L102
 1671 051c 5269     	 ldr r2,[r2,#20]
 1672 051e B91D     	 add r1,r7,#6
 1673 0520 0978     	 ldrb r1,[r1]
 1674 0522 0439     	 sub r1,r1,#4
 1675 0524 C900     	 lsl r1,r1,#3
 1676 0526 0331     	 add r1,r1,#3
 1677 0528 1F20     	 mov r0,#31
 1678 052a 8840     	 lsl r0,r0,r1
 1679 052c 011C     	 mov r1,r0
 1680 052e C943     	 mvn r1,r1
 1681 0530 0A40     	 and r2,r1
 1682 0532 5A61     	 str r2,[r3,#20]
 201:../XMC1100-LibHaas.c **** 						PORT1->IOCR4 |= (1UL << (((bitnr-4) * 8)+4) );
 1683              	 .loc 3 201 0
 1684 0534 834B     	 ldr r3,.L102
 1685 0536 834A     	 ldr r2,.L102
 1686 0538 5169     	 ldr r1,[r2,#20]
 1687 053a BA1D     	 add r2,r7,#6
 1688 053c 1278     	 ldrb r2,[r2]
 1689 053e 043A     	 sub r2,r2,#4
 1690 0540 D200     	 lsl r2,r2,#3
 1691 0542 0432     	 add r2,r2,#4
 1692 0544 0120     	 mov r0,#1
 1693 0546 9040     	 lsl r0,r0,r2
 1694 0548 021C     	 mov r2,r0
 1695 054a 0A43     	 orr r2,r1
 1696 054c 5A61     	 str r2,[r3,#20]
 1697 054e 1DE0     	 b .L64
 1698              	.L66:
 202:../XMC1100-LibHaas.c **** 					}else if (mode == PULLDOWN) {
 1699              	 .loc 3 202 0
 1700 0550 3B1D     	 add r3,r7,#4
 1701 0552 1B78     	 ldrb r3,[r3]
 1702 0554 022B     	 cmp r3,#2
 1703 0556 19D1     	 bne .L64
 203:../XMC1100-LibHaas.c **** 						PORT1->IOCR4 &= ~(0x0000001F << ((bitnr * 8)+3) );
 1704              	 .loc 3 203 0
 1705 0558 7A4B     	 ldr r3,.L102
 1706 055a 7A4A     	 ldr r2,.L102
 1707 055c 5269     	 ldr r2,[r2,#20]
 1708 055e B91D     	 add r1,r7,#6
 1709 0560 0978     	 ldrb r1,[r1]
 1710 0562 C900     	 lsl r1,r1,#3
 1711 0564 0331     	 add r1,r1,#3
 1712 0566 1F20     	 mov r0,#31
 1713 0568 8840     	 lsl r0,r0,r1
 1714 056a 011C     	 mov r1,r0
 1715 056c C943     	 mvn r1,r1
 1716 056e 0A40     	 and r2,r1
 1717 0570 5A61     	 str r2,[r3,#20]
 204:../XMC1100-LibHaas.c **** 						PORT1->IOCR4 |= (1UL << ((bitnr * 8)+3) );
 1718              	 .loc 3 204 0
 1719 0572 744B     	 ldr r3,.L102
 1720 0574 734A     	 ldr r2,.L102
 1721 0576 5169     	 ldr r1,[r2,#20]
 1722 0578 BA1D     	 add r2,r7,#6
 1723 057a 1278     	 ldrb r2,[r2]
 1724 057c D200     	 lsl r2,r2,#3
 1725 057e 0332     	 add r2,r2,#3
 1726 0580 0120     	 mov r0,#1
 1727 0582 9040     	 lsl r0,r0,r2
 1728 0584 021C     	 mov r2,r0
 1729 0586 0A43     	 orr r2,r1
 1730 0588 5A61     	 str r2,[r3,#20]
 205:../XMC1100-LibHaas.c **** 					}
 206:../XMC1100-LibHaas.c **** 				}
 207:../XMC1100-LibHaas.c **** 			}
 208:../XMC1100-LibHaas.c **** 		}
 209:../XMC1100-LibHaas.c **** 		break;
 1731              	 .loc 3 209 0
 1732 058a F0E2     	 b .L44
 1733              	.L64:
 1734 058c EFE2     	 b .L44
 1735              	.L47:
 210:../XMC1100-LibHaas.c **** 
 211:../XMC1100-LibHaas.c **** 		case 2 :
 212:../XMC1100-LibHaas.c **** 			if (bitnr == 0) { //P2.0
 1736              	 .loc 3 212 0
 1737 058e BB1D     	 add r3,r7,#6
 1738 0590 1B78     	 ldrb r3,[r3]
 1739 0592 002B     	 cmp r3,#0
 1740 0594 4CD1     	 bne .L67
 213:../XMC1100-LibHaas.c **** 			 if (direction == OUTP) {
 1741              	 .loc 3 213 0
 1742 0596 7B1D     	 add r3,r7,#5
 1743 0598 1B78     	 ldrb r3,[r3]
 1744 059a 012B     	 cmp r3,#1
 1745 059c 12D1     	 bne .L68
 214:../XMC1100-LibHaas.c **** 				 CLR_BIT(PORT2->PDISC,0); // digital Pad aktiv
 1746              	 .loc 3 214 0
 1747 059e 6A4B     	 ldr r3,.L102+4
 1748 05a0 694A     	 ldr r2,.L102+4
 1749 05a2 126E     	 ldr r2,[r2,#96]
 1750 05a4 0121     	 mov r1,#1
 1751 05a6 8A43     	 bic r2,r1
 1752 05a8 1A66     	 str r2,[r3,#96]
 215:../XMC1100-LibHaas.c **** 				 PORT2->IOCR0 &= 0xffffff00;
 1753              	 .loc 3 215 0
 1754 05aa 674B     	 ldr r3,.L102+4
 1755 05ac 664A     	 ldr r2,.L102+4
 1756 05ae 1269     	 ldr r2,[r2,#16]
 1757 05b0 FF21     	 mov r1,#255
 1758 05b2 8A43     	 bic r2,r1
 1759 05b4 1A61     	 str r2,[r3,#16]
 216:../XMC1100-LibHaas.c **** 				 PORT2->IOCR0 |= 0x00000080;
 1760              	 .loc 3 216 0
 1761 05b6 644B     	 ldr r3,.L102+4
 1762 05b8 634A     	 ldr r2,.L102+4
 1763 05ba 1269     	 ldr r2,[r2,#16]
 1764 05bc 8021     	 mov r1,#128
 1765 05be 0A43     	 orr r2,r1
 1766 05c0 1A61     	 str r2,[r3,#16]
 1767 05c2 35E0     	 b .L67
 1768              	.L68:
 217:../XMC1100-LibHaas.c **** 			 } else if (direction == INP) {
 1769              	 .loc 3 217 0
 1770 05c4 7B1D     	 add r3,r7,#5
 1771 05c6 1B78     	 ldrb r3,[r3]
 1772 05c8 002B     	 cmp r3,#0
 1773 05ca 31D1     	 bne .L67
 218:../XMC1100-LibHaas.c **** 				 CLR_BIT(PORT2->PDISC,0); // digital Pad aktiv
 1774              	 .loc 3 218 0
 1775 05cc 5E4B     	 ldr r3,.L102+4
 1776 05ce 5E4A     	 ldr r2,.L102+4
 1777 05d0 126E     	 ldr r2,[r2,#96]
 1778 05d2 0121     	 mov r1,#1
 1779 05d4 8A43     	 bic r2,r1
 1780 05d6 1A66     	 str r2,[r3,#96]
 219:../XMC1100-LibHaas.c **** 				 if (mode==PULLUP) {
 1781              	 .loc 3 219 0
 1782 05d8 3B1D     	 add r3,r7,#4
 1783 05da 1B78     	 ldrb r3,[r3]
 1784 05dc 012B     	 cmp r3,#1
 1785 05de 0CD1     	 bne .L69
 220:../XMC1100-LibHaas.c **** 					 PORT2->IOCR0 &= 0xFFFFFF00;
 1786              	 .loc 3 220 0
 1787 05e0 594B     	 ldr r3,.L102+4
 1788 05e2 594A     	 ldr r2,.L102+4
 1789 05e4 1269     	 ldr r2,[r2,#16]
 1790 05e6 FF21     	 mov r1,#255
 1791 05e8 8A43     	 bic r2,r1
 1792 05ea 1A61     	 str r2,[r3,#16]
 221:../XMC1100-LibHaas.c **** 					 PORT2->IOCR0 |= 0x00000010;
 1793              	 .loc 3 221 0
 1794 05ec 564B     	 ldr r3,.L102+4
 1795 05ee 564A     	 ldr r2,.L102+4
 1796 05f0 1269     	 ldr r2,[r2,#16]
 1797 05f2 1021     	 mov r1,#16
 1798 05f4 0A43     	 orr r2,r1
 1799 05f6 1A61     	 str r2,[r3,#16]
 1800 05f8 1AE0     	 b .L67
 1801              	.L69:
 222:../XMC1100-LibHaas.c **** 				 } else if (mode==PULLDOWN) {
 1802              	 .loc 3 222 0
 1803 05fa 3B1D     	 add r3,r7,#4
 1804 05fc 1B78     	 ldrb r3,[r3]
 1805 05fe 022B     	 cmp r3,#2
 1806 0600 0CD1     	 bne .L70
 223:../XMC1100-LibHaas.c **** 					 PORT2->IOCR0 &= 0xFFFFFF00;
 1807              	 .loc 3 223 0
 1808 0602 514B     	 ldr r3,.L102+4
 1809 0604 504A     	 ldr r2,.L102+4
 1810 0606 1269     	 ldr r2,[r2,#16]
 1811 0608 FF21     	 mov r1,#255
 1812 060a 8A43     	 bic r2,r1
 1813 060c 1A61     	 str r2,[r3,#16]
 224:../XMC1100-LibHaas.c **** 					 PORT2->IOCR0 |= 0x00000008;
 1814              	 .loc 3 224 0
 1815 060e 4E4B     	 ldr r3,.L102+4
 1816 0610 4D4A     	 ldr r2,.L102+4
 1817 0612 1269     	 ldr r2,[r2,#16]
 1818 0614 0821     	 mov r1,#8
 1819 0616 0A43     	 orr r2,r1
 1820 0618 1A61     	 str r2,[r3,#16]
 1821 061a 09E0     	 b .L67
 1822              	.L70:
 225:../XMC1100-LibHaas.c **** 				 } else if (mode == ANALOG) {
 1823              	 .loc 3 225 0
 1824 061c 3B1D     	 add r3,r7,#4
 1825 061e 1B78     	 ldrb r3,[r3]
 1826 0620 032B     	 cmp r3,#3
 1827 0622 05D1     	 bne .L67
 226:../XMC1100-LibHaas.c **** 					SET_BIT(PORT2->PDISC,0); //Analog Modus aktiv
 1828              	 .loc 3 226 0
 1829 0624 484B     	 ldr r3,.L102+4
 1830 0626 484A     	 ldr r2,.L102+4
 1831 0628 126E     	 ldr r2,[r2,#96]
 1832 062a 0121     	 mov r1,#1
 1833 062c 0A43     	 orr r2,r1
 1834 062e 1A66     	 str r2,[r3,#96]
 1835              	.L67:
 227:../XMC1100-LibHaas.c **** 				 }
 228:../XMC1100-LibHaas.c **** 			 }
 229:../XMC1100-LibHaas.c **** 		 }
 230:../XMC1100-LibHaas.c **** 		 if (bitnr == 1) { //P2.1
 1836              	 .loc 3 230 0
 1837 0630 BB1D     	 add r3,r7,#6
 1838 0632 1B78     	 ldrb r3,[r3]
 1839 0634 012B     	 cmp r3,#1
 1840 0636 4FD1     	 bne .L71
 231:../XMC1100-LibHaas.c **** 			 if (direction == OUTP) {
 1841              	 .loc 3 231 0
 1842 0638 7B1D     	 add r3,r7,#5
 1843 063a 1B78     	 ldrb r3,[r3]
 1844 063c 012B     	 cmp r3,#1
 1845 063e 13D1     	 bne .L72
 232:../XMC1100-LibHaas.c **** 				 CLR_BIT(PORT2->PDISC,1); // digital Pad aktiv
 1846              	 .loc 3 232 0
 1847 0640 414B     	 ldr r3,.L102+4
 1848 0642 414A     	 ldr r2,.L102+4
 1849 0644 126E     	 ldr r2,[r2,#96]
 1850 0646 0221     	 mov r1,#2
 1851 0648 8A43     	 bic r2,r1
 1852 064a 1A66     	 str r2,[r3,#96]
 233:../XMC1100-LibHaas.c **** 				 PORT2->IOCR0 &= 0xffff00ff;
 1853              	 .loc 3 233 0
 1854 064c 3E4B     	 ldr r3,.L102+4
 1855 064e 3E4A     	 ldr r2,.L102+4
 1856 0650 1269     	 ldr r2,[r2,#16]
 1857 0652 3E49     	 ldr r1,.L102+8
 1858 0654 0A40     	 and r2,r1
 1859 0656 1A61     	 str r2,[r3,#16]
 234:../XMC1100-LibHaas.c **** 				 PORT2->IOCR0 |= 0x00008000;
 1860              	 .loc 3 234 0
 1861 0658 3B4B     	 ldr r3,.L102+4
 1862 065a 3B4A     	 ldr r2,.L102+4
 1863 065c 1269     	 ldr r2,[r2,#16]
 1864 065e 8021     	 mov r1,#128
 1865 0660 0902     	 lsl r1,r1,#8
 1866 0662 0A43     	 orr r2,r1
 1867 0664 1A61     	 str r2,[r3,#16]
 1868 0666 37E0     	 b .L71
 1869              	.L72:
 235:../XMC1100-LibHaas.c **** 			 } else if (direction == INP) {
 1870              	 .loc 3 235 0
 1871 0668 7B1D     	 add r3,r7,#5
 1872 066a 1B78     	 ldrb r3,[r3]
 1873 066c 002B     	 cmp r3,#0
 1874 066e 33D1     	 bne .L71
 236:../XMC1100-LibHaas.c **** 				 CLR_BIT(PORT2->PDISC,1); // digital Pad aktiv
 1875              	 .loc 3 236 0
 1876 0670 354B     	 ldr r3,.L102+4
 1877 0672 354A     	 ldr r2,.L102+4
 1878 0674 126E     	 ldr r2,[r2,#96]
 1879 0676 0221     	 mov r1,#2
 1880 0678 8A43     	 bic r2,r1
 1881 067a 1A66     	 str r2,[r3,#96]
 237:../XMC1100-LibHaas.c **** 				 if (mode==PULLUP) {
 1882              	 .loc 3 237 0
 1883 067c 3B1D     	 add r3,r7,#4
 1884 067e 1B78     	 ldrb r3,[r3]
 1885 0680 012B     	 cmp r3,#1
 1886 0682 0DD1     	 bne .L73
 238:../XMC1100-LibHaas.c **** 					 PORT2->IOCR0 &= 0xFFFF00ff;
 1887              	 .loc 3 238 0
 1888 0684 304B     	 ldr r3,.L102+4
 1889 0686 304A     	 ldr r2,.L102+4
 1890 0688 1269     	 ldr r2,[r2,#16]
 1891 068a 3049     	 ldr r1,.L102+8
 1892 068c 0A40     	 and r2,r1
 1893 068e 1A61     	 str r2,[r3,#16]
 239:../XMC1100-LibHaas.c **** 					 PORT2->IOCR0 |= 0x00001000;
 1894              	 .loc 3 239 0
 1895 0690 2D4B     	 ldr r3,.L102+4
 1896 0692 2D4A     	 ldr r2,.L102+4
 1897 0694 1269     	 ldr r2,[r2,#16]
 1898 0696 8021     	 mov r1,#128
 1899 0698 4901     	 lsl r1,r1,#5
 1900 069a 0A43     	 orr r2,r1
 1901 069c 1A61     	 str r2,[r3,#16]
 1902 069e 1BE0     	 b .L71
 1903              	.L73:
 240:../XMC1100-LibHaas.c **** 				 } else if (mode==PULLDOWN) {
 1904              	 .loc 3 240 0
 1905 06a0 3B1D     	 add r3,r7,#4
 1906 06a2 1B78     	 ldrb r3,[r3]
 1907 06a4 022B     	 cmp r3,#2
 1908 06a6 0DD1     	 bne .L74
 241:../XMC1100-LibHaas.c **** 					 PORT2->IOCR0 &= 0xFFFF00ff;
 1909              	 .loc 3 241 0
 1910 06a8 274B     	 ldr r3,.L102+4
 1911 06aa 274A     	 ldr r2,.L102+4
 1912 06ac 1269     	 ldr r2,[r2,#16]
 1913 06ae 2749     	 ldr r1,.L102+8
 1914 06b0 0A40     	 and r2,r1
 1915 06b2 1A61     	 str r2,[r3,#16]
 242:../XMC1100-LibHaas.c **** 					 PORT2->IOCR0 |= 0x00000800;
 1916              	 .loc 3 242 0
 1917 06b4 244B     	 ldr r3,.L102+4
 1918 06b6 244A     	 ldr r2,.L102+4
 1919 06b8 1269     	 ldr r2,[r2,#16]
 1920 06ba 8021     	 mov r1,#128
 1921 06bc 0901     	 lsl r1,r1,#4
 1922 06be 0A43     	 orr r2,r1
 1923 06c0 1A61     	 str r2,[r3,#16]
 1924 06c2 09E0     	 b .L71
 1925              	.L74:
 243:../XMC1100-LibHaas.c **** 				 } else if (mode == ANALOG) {
 1926              	 .loc 3 243 0
 1927 06c4 3B1D     	 add r3,r7,#4
 1928 06c6 1B78     	 ldrb r3,[r3]
 1929 06c8 032B     	 cmp r3,#3
 1930 06ca 05D1     	 bne .L71
 244:../XMC1100-LibHaas.c **** 					SET_BIT(PORT2->PDISC,1); //Analog Modus aktiv
 1931              	 .loc 3 244 0
 1932 06cc 1E4B     	 ldr r3,.L102+4
 1933 06ce 1E4A     	 ldr r2,.L102+4
 1934 06d0 126E     	 ldr r2,[r2,#96]
 1935 06d2 0221     	 mov r1,#2
 1936 06d4 0A43     	 orr r2,r1
 1937 06d6 1A66     	 str r2,[r3,#96]
 1938              	.L71:
 245:../XMC1100-LibHaas.c **** 				 }
 246:../XMC1100-LibHaas.c **** 			 }
 247:../XMC1100-LibHaas.c **** 		 }
 248:../XMC1100-LibHaas.c **** 		 if (bitnr == 2) { //P2.2
 1939              	 .loc 3 248 0
 1940 06d8 BB1D     	 add r3,r7,#6
 1941 06da 1B78     	 ldrb r3,[r3]
 1942 06dc 022B     	 cmp r3,#2
 1943 06de 43D1     	 bne .L75
 249:../XMC1100-LibHaas.c **** 			 if (direction == OUTP) {
 1944              	 .loc 3 249 0
 1945 06e0 7B1D     	 add r3,r7,#5
 1946 06e2 1B78     	 ldrb r3,[r3]
 1947 06e4 012B     	 cmp r3,#1
 1948 06e6 3FD0     	 beq .L75
 250:../XMC1100-LibHaas.c **** 				 // nicht moeglich
 251:../XMC1100-LibHaas.c **** 			 } else if (direction == INP) {
 1949              	 .loc 3 251 0
 1950 06e8 7B1D     	 add r3,r7,#5
 1951 06ea 1B78     	 ldrb r3,[r3]
 1952 06ec 002B     	 cmp r3,#0
 1953 06ee 3BD1     	 bne .L75
 252:../XMC1100-LibHaas.c **** 				 CLR_BIT(PORT2->PDISC,2); // digital Pad aktiv
 1954              	 .loc 3 252 0
 1955 06f0 154B     	 ldr r3,.L102+4
 1956 06f2 154A     	 ldr r2,.L102+4
 1957 06f4 126E     	 ldr r2,[r2,#96]
 1958 06f6 0421     	 mov r1,#4
 1959 06f8 8A43     	 bic r2,r1
 1960 06fa 1A66     	 str r2,[r3,#96]
 253:../XMC1100-LibHaas.c **** 				 if (mode==PULLUP) {
 1961              	 .loc 3 253 0
 1962 06fc 3B1D     	 add r3,r7,#4
 1963 06fe 1B78     	 ldrb r3,[r3]
 1964 0700 012B     	 cmp r3,#1
 1965 0702 0DD1     	 bne .L76
 254:../XMC1100-LibHaas.c **** 					 PORT2->IOCR0 &= 0xFF00ffff;
 1966              	 .loc 3 254 0
 1967 0704 104B     	 ldr r3,.L102+4
 1968 0706 104A     	 ldr r2,.L102+4
 1969 0708 1269     	 ldr r2,[r2,#16]
 1970 070a 1149     	 ldr r1,.L102+12
 1971 070c 0A40     	 and r2,r1
 1972 070e 1A61     	 str r2,[r3,#16]
 255:../XMC1100-LibHaas.c **** 					 PORT2->IOCR0 |= 0x00100000;
 1973              	 .loc 3 255 0
 1974 0710 0D4B     	 ldr r3,.L102+4
 1975 0712 0D4A     	 ldr r2,.L102+4
 1976 0714 1269     	 ldr r2,[r2,#16]
 1977 0716 8021     	 mov r1,#128
 1978 0718 4903     	 lsl r1,r1,#13
 1979 071a 0A43     	 orr r2,r1
 1980 071c 1A61     	 str r2,[r3,#16]
 1981 071e 23E0     	 b .L75
 1982              	.L76:
 256:../XMC1100-LibHaas.c **** 				 } else if (mode==PULLDOWN) {
 1983              	 .loc 3 256 0
 1984 0720 3B1D     	 add r3,r7,#4
 1985 0722 1B78     	 ldrb r3,[r3]
 1986 0724 022B     	 cmp r3,#2
 1987 0726 15D1     	 bne .L77
 257:../XMC1100-LibHaas.c **** 					 PORT2->IOCR0 &= 0xFF00ffff;
 1988              	 .loc 3 257 0
 1989 0728 074B     	 ldr r3,.L102+4
 1990 072a 074A     	 ldr r2,.L102+4
 1991 072c 1269     	 ldr r2,[r2,#16]
 1992 072e 0849     	 ldr r1,.L102+12
 1993 0730 0A40     	 and r2,r1
 1994 0732 1A61     	 str r2,[r3,#16]
 258:../XMC1100-LibHaas.c **** 					 PORT2->IOCR0 |= 0x00080000;
 1995              	 .loc 3 258 0
 1996 0734 044B     	 ldr r3,.L102+4
 1997 0736 044A     	 ldr r2,.L102+4
 1998 0738 1269     	 ldr r2,[r2,#16]
 1999 073a 8021     	 mov r1,#128
 2000 073c 0903     	 lsl r1,r1,#12
 2001 073e 0A43     	 orr r2,r1
 2002 0740 1A61     	 str r2,[r3,#16]
 2003 0742 11E0     	 b .L75
 2004              	.L103:
 2005              	 .align 2
 2006              	.L102:
 2007 0744 00010440 	 .word 1074004224
 2008 0748 00020440 	 .word 1074004480
 2009 074c FF00FFFF 	 .word -65281
 2010 0750 FFFF00FF 	 .word -16711681
 2011              	.L77:
 259:../XMC1100-LibHaas.c **** 				 } else if (mode == ANALOG) {
 2012              	 .loc 3 259 0
 2013 0754 3B1D     	 add r3,r7,#4
 2014 0756 1B78     	 ldrb r3,[r3]
 2015 0758 032B     	 cmp r3,#3
 2016 075a 05D1     	 bne .L75
 260:../XMC1100-LibHaas.c **** 					SET_BIT(PORT2->PDISC,2); //Analog Modus aktiv
 2017              	 .loc 3 260 0
 2018 075c CD4B     	 ldr r3,.L104
 2019 075e CD4A     	 ldr r2,.L104
 2020 0760 126E     	 ldr r2,[r2,#96]
 2021 0762 0421     	 mov r1,#4
 2022 0764 0A43     	 orr r2,r1
 2023 0766 1A66     	 str r2,[r3,#96]
 2024              	.L75:
 261:../XMC1100-LibHaas.c **** 				 }
 262:../XMC1100-LibHaas.c **** 			 }
 263:../XMC1100-LibHaas.c **** 		 }
 264:../XMC1100-LibHaas.c **** 		 if (bitnr == 3) { //P2.3
 2025              	 .loc 3 264 0
 2026 0768 BB1D     	 add r3,r7,#6
 2027 076a 1B78     	 ldrb r3,[r3]
 2028 076c 032B     	 cmp r3,#3
 2029 076e 3BD1     	 bne .L78
 265:../XMC1100-LibHaas.c **** 			 if (direction == OUTP) {
 2030              	 .loc 3 265 0
 2031 0770 7B1D     	 add r3,r7,#5
 2032 0772 1B78     	 ldrb r3,[r3]
 2033 0774 012B     	 cmp r3,#1
 2034 0776 37D0     	 beq .L78
 266:../XMC1100-LibHaas.c **** 				 // nicht moeglich
 267:../XMC1100-LibHaas.c **** 			 } else if (direction == INP) {
 2035              	 .loc 3 267 0
 2036 0778 7B1D     	 add r3,r7,#5
 2037 077a 1B78     	 ldrb r3,[r3]
 2038 077c 002B     	 cmp r3,#0
 2039 077e 33D1     	 bne .L78
 268:../XMC1100-LibHaas.c **** 				 CLR_BIT(PORT2->PDISC,3); // digital Pad aktiv
 2040              	 .loc 3 268 0
 2041 0780 C44B     	 ldr r3,.L104
 2042 0782 C44A     	 ldr r2,.L104
 2043 0784 126E     	 ldr r2,[r2,#96]
 2044 0786 0821     	 mov r1,#8
 2045 0788 8A43     	 bic r2,r1
 2046 078a 1A66     	 str r2,[r3,#96]
 269:../XMC1100-LibHaas.c **** 				 if (mode==PULLUP) {
 2047              	 .loc 3 269 0
 2048 078c 3B1D     	 add r3,r7,#4
 2049 078e 1B78     	 ldrb r3,[r3]
 2050 0790 012B     	 cmp r3,#1
 2051 0792 0DD1     	 bne .L79
 270:../XMC1100-LibHaas.c **** 					 PORT2->IOCR0 &= 0x00ffffff;
 2052              	 .loc 3 270 0
 2053 0794 BF4B     	 ldr r3,.L104
 2054 0796 BF4A     	 ldr r2,.L104
 2055 0798 1269     	 ldr r2,[r2,#16]
 2056 079a 1202     	 lsl r2,r2,#8
 2057 079c 120A     	 lsr r2,r2,#8
 2058 079e 1A61     	 str r2,[r3,#16]
 271:../XMC1100-LibHaas.c **** 					 PORT2->IOCR0 |= 0x10000000;
 2059              	 .loc 3 271 0
 2060 07a0 BC4B     	 ldr r3,.L104
 2061 07a2 BC4A     	 ldr r2,.L104
 2062 07a4 1269     	 ldr r2,[r2,#16]
 2063 07a6 8021     	 mov r1,#128
 2064 07a8 4905     	 lsl r1,r1,#21
 2065 07aa 0A43     	 orr r2,r1
 2066 07ac 1A61     	 str r2,[r3,#16]
 2067 07ae 1BE0     	 b .L78
 2068              	.L79:
 272:../XMC1100-LibHaas.c **** 				 } else if (mode==PULLDOWN) {
 2069              	 .loc 3 272 0
 2070 07b0 3B1D     	 add r3,r7,#4
 2071 07b2 1B78     	 ldrb r3,[r3]
 2072 07b4 022B     	 cmp r3,#2
 2073 07b6 0DD1     	 bne .L80
 273:../XMC1100-LibHaas.c **** 					 PORT2->IOCR0 &= 0x00ffffff;
 2074              	 .loc 3 273 0
 2075 07b8 B64B     	 ldr r3,.L104
 2076 07ba B64A     	 ldr r2,.L104
 2077 07bc 1269     	 ldr r2,[r2,#16]
 2078 07be 1202     	 lsl r2,r2,#8
 2079 07c0 120A     	 lsr r2,r2,#8
 2080 07c2 1A61     	 str r2,[r3,#16]
 274:../XMC1100-LibHaas.c **** 					 PORT2->IOCR0 |= 0x08000000;
 2081              	 .loc 3 274 0
 2082 07c4 B34B     	 ldr r3,.L104
 2083 07c6 B34A     	 ldr r2,.L104
 2084 07c8 1269     	 ldr r2,[r2,#16]
 2085 07ca 8021     	 mov r1,#128
 2086 07cc 0905     	 lsl r1,r1,#20
 2087 07ce 0A43     	 orr r2,r1
 2088 07d0 1A61     	 str r2,[r3,#16]
 2089 07d2 09E0     	 b .L78
 2090              	.L80:
 275:../XMC1100-LibHaas.c **** 				 } else if (mode == ANALOG) {
 2091              	 .loc 3 275 0
 2092 07d4 3B1D     	 add r3,r7,#4
 2093 07d6 1B78     	 ldrb r3,[r3]
 2094 07d8 032B     	 cmp r3,#3
 2095 07da 05D1     	 bne .L78
 276:../XMC1100-LibHaas.c **** 					SET_BIT(PORT2->PDISC,3); //Analog Modus aktiv
 2096              	 .loc 3 276 0
 2097 07dc AD4B     	 ldr r3,.L104
 2098 07de AD4A     	 ldr r2,.L104
 2099 07e0 126E     	 ldr r2,[r2,#96]
 2100 07e2 0821     	 mov r1,#8
 2101 07e4 0A43     	 orr r2,r1
 2102 07e6 1A66     	 str r2,[r3,#96]
 2103              	.L78:
 277:../XMC1100-LibHaas.c **** 				 }
 278:../XMC1100-LibHaas.c **** 			 }
 279:../XMC1100-LibHaas.c **** 		 }
 280:../XMC1100-LibHaas.c **** 		 if ((bitnr > 3) && (bitnr < 8)) { //P2.4 bis P2.7
 2104              	 .loc 3 280 0
 2105 07e8 BB1D     	 add r3,r7,#6
 2106 07ea 1B78     	 ldrb r3,[r3]
 2107 07ec 032B     	 cmp r3,#3
 2108 07ee 60D9     	 bls .L81
 2109              	 .loc 3 280 0 is_stmt 0 discriminator 1
 2110 07f0 BB1D     	 add r3,r7,#6
 2111 07f2 1B78     	 ldrb r3,[r3]
 2112 07f4 072B     	 cmp r3,#7
 2113 07f6 5CD8     	 bhi .L81
 281:../XMC1100-LibHaas.c **** 			 if (direction == OUTP) {
 2114              	 .loc 3 281 0 is_stmt 1
 2115 07f8 7B1D     	 add r3,r7,#5
 2116 07fa 1B78     	 ldrb r3,[r3]
 2117 07fc 012B     	 cmp r3,#1
 2118 07fe 58D0     	 beq .L81
 282:../XMC1100-LibHaas.c **** 				 // nicht moeglich
 283:../XMC1100-LibHaas.c **** 			 } else if (direction == INP) {
 2119              	 .loc 3 283 0
 2120 0800 7B1D     	 add r3,r7,#5
 2121 0802 1B78     	 ldrb r3,[r3]
 2122 0804 002B     	 cmp r3,#0
 2123 0806 54D1     	 bne .L81
 284:../XMC1100-LibHaas.c **** 				 CLR_BIT(PORT2->PDISC,bitnr); // digital Pad aktiv
 2124              	 .loc 3 284 0
 2125 0808 A24B     	 ldr r3,.L104
 2126 080a A24A     	 ldr r2,.L104
 2127 080c 126E     	 ldr r2,[r2,#96]
 2128 080e B91D     	 add r1,r7,#6
 2129 0810 0978     	 ldrb r1,[r1]
 2130 0812 0120     	 mov r0,#1
 2131 0814 8840     	 lsl r0,r0,r1
 2132 0816 011C     	 mov r1,r0
 2133 0818 C943     	 mvn r1,r1
 2134 081a 0A40     	 and r2,r1
 2135 081c 1A66     	 str r2,[r3,#96]
 285:../XMC1100-LibHaas.c **** 				 if (mode==PULLUP) {
 2136              	 .loc 3 285 0
 2137 081e 3B1D     	 add r3,r7,#4
 2138 0820 1B78     	 ldrb r3,[r3]
 2139 0822 012B     	 cmp r3,#1
 2140 0824 19D1     	 bne .L82
 286:../XMC1100-LibHaas.c **** 					 PORT2->IOCR4 &= ~(0xff<<((bitnr-4)*8)); //PORT2->IOCR1 &= 0xffffff00;
 2141              	 .loc 3 286 0
 2142 0826 9B4B     	 ldr r3,.L104
 2143 0828 9A4A     	 ldr r2,.L104
 2144 082a 5269     	 ldr r2,[r2,#20]
 2145 082c B91D     	 add r1,r7,#6
 2146 082e 0978     	 ldrb r1,[r1]
 2147 0830 0439     	 sub r1,r1,#4
 2148 0832 C900     	 lsl r1,r1,#3
 2149 0834 FF20     	 mov r0,#255
 2150 0836 8840     	 lsl r0,r0,r1
 2151 0838 011C     	 mov r1,r0
 2152 083a C943     	 mvn r1,r1
 2153 083c 0A40     	 and r2,r1
 2154 083e 5A61     	 str r2,[r3,#20]
 287:../XMC1100-LibHaas.c **** 					 PORT2->IOCR4 |= 0x10<<((bitnr-4)*8);    //PORT2->IOCR4 |= 0x00000010;
 2155              	 .loc 3 287 0
 2156 0840 944B     	 ldr r3,.L104
 2157 0842 944A     	 ldr r2,.L104
 2158 0844 5269     	 ldr r2,[r2,#20]
 2159 0846 B91D     	 add r1,r7,#6
 2160 0848 0978     	 ldrb r1,[r1]
 2161 084a 0439     	 sub r1,r1,#4
 2162 084c C900     	 lsl r1,r1,#3
 2163 084e 1020     	 mov r0,#16
 2164 0850 8840     	 lsl r0,r0,r1
 2165 0852 011C     	 mov r1,r0
 2166 0854 0A43     	 orr r2,r1
 2167 0856 5A61     	 str r2,[r3,#20]
 2168 0858 2BE0     	 b .L81
 2169              	.L82:
 288:../XMC1100-LibHaas.c **** 				 } else if (mode==PULLDOWN) {
 2170              	 .loc 3 288 0
 2171 085a 3B1D     	 add r3,r7,#4
 2172 085c 1B78     	 ldrb r3,[r3]
 2173 085e 022B     	 cmp r3,#2
 2174 0860 19D1     	 bne .L83
 289:../XMC1100-LibHaas.c **** 					 PORT2->IOCR4 &= ~(0xff<<((bitnr-4)*8)); //PORT2->IOCR1 &= 0xffffff00;
 2175              	 .loc 3 289 0
 2176 0862 8C4B     	 ldr r3,.L104
 2177 0864 8B4A     	 ldr r2,.L104
 2178 0866 5269     	 ldr r2,[r2,#20]
 2179 0868 B91D     	 add r1,r7,#6
 2180 086a 0978     	 ldrb r1,[r1]
 2181 086c 0439     	 sub r1,r1,#4
 2182 086e C900     	 lsl r1,r1,#3
 2183 0870 FF20     	 mov r0,#255
 2184 0872 8840     	 lsl r0,r0,r1
 2185 0874 011C     	 mov r1,r0
 2186 0876 C943     	 mvn r1,r1
 2187 0878 0A40     	 and r2,r1
 2188 087a 5A61     	 str r2,[r3,#20]
 290:../XMC1100-LibHaas.c **** 					 PORT2->IOCR4 |= 0x08<<((bitnr-4)*8);    //PORT2->IOCR4 |= 0x00000010;
 2189              	 .loc 3 290 0
 2190 087c 854B     	 ldr r3,.L104
 2191 087e 854A     	 ldr r2,.L104
 2192 0880 5269     	 ldr r2,[r2,#20]
 2193 0882 B91D     	 add r1,r7,#6
 2194 0884 0978     	 ldrb r1,[r1]
 2195 0886 0439     	 sub r1,r1,#4
 2196 0888 C900     	 lsl r1,r1,#3
 2197 088a 0820     	 mov r0,#8
 2198 088c 8840     	 lsl r0,r0,r1
 2199 088e 011C     	 mov r1,r0
 2200 0890 0A43     	 orr r2,r1
 2201 0892 5A61     	 str r2,[r3,#20]
 2202 0894 0DE0     	 b .L81
 2203              	.L83:
 291:../XMC1100-LibHaas.c **** 				 } else if (mode == ANALOG) {
 2204              	 .loc 3 291 0
 2205 0896 3B1D     	 add r3,r7,#4
 2206 0898 1B78     	 ldrb r3,[r3]
 2207 089a 032B     	 cmp r3,#3
 2208 089c 09D1     	 bne .L81
 292:../XMC1100-LibHaas.c **** 					 SET_BIT(PORT2->PDISC,bitnr); //Analog Modus aktiv
 2209              	 .loc 3 292 0
 2210 089e 7D4B     	 ldr r3,.L104
 2211 08a0 7C4A     	 ldr r2,.L104
 2212 08a2 116E     	 ldr r1,[r2,#96]
 2213 08a4 BA1D     	 add r2,r7,#6
 2214 08a6 1278     	 ldrb r2,[r2]
 2215 08a8 0120     	 mov r0,#1
 2216 08aa 9040     	 lsl r0,r0,r2
 2217 08ac 021C     	 mov r2,r0
 2218 08ae 0A43     	 orr r2,r1
 2219 08b0 1A66     	 str r2,[r3,#96]
 2220              	.L81:
 293:../XMC1100-LibHaas.c **** 				 }
 294:../XMC1100-LibHaas.c **** 			 }
 295:../XMC1100-LibHaas.c **** 		 }
 296:../XMC1100-LibHaas.c **** 		 if (bitnr == 8) { //P2.8
 2221              	 .loc 3 296 0
 2222 08b2 BB1D     	 add r3,r7,#6
 2223 08b4 1B78     	 ldrb r3,[r3]
 2224 08b6 082B     	 cmp r3,#8
 2225 08b8 4DD1     	 bne .L84
 297:../XMC1100-LibHaas.c **** 			if (direction == OUTP) {
 2226              	 .loc 3 297 0
 2227 08ba 7B1D     	 add r3,r7,#5
 2228 08bc 1B78     	 ldrb r3,[r3]
 2229 08be 012B     	 cmp r3,#1
 2230 08c0 12D1     	 bne .L85
 298:../XMC1100-LibHaas.c **** 				CLR_BIT(PORT2->PDISC,8); // digital Pad aktiv
 2231              	 .loc 3 298 0
 2232 08c2 744B     	 ldr r3,.L104
 2233 08c4 734A     	 ldr r2,.L104
 2234 08c6 126E     	 ldr r2,[r2,#96]
 2235 08c8 7349     	 ldr r1,.L104+4
 2236 08ca 0A40     	 and r2,r1
 2237 08cc 1A66     	 str r2,[r3,#96]
 299:../XMC1100-LibHaas.c **** 				PORT2->IOCR8 &= 0xffffff00;
 2238              	 .loc 3 299 0
 2239 08ce 714B     	 ldr r3,.L104
 2240 08d0 704A     	 ldr r2,.L104
 2241 08d2 9269     	 ldr r2,[r2,#24]
 2242 08d4 FF21     	 mov r1,#255
 2243 08d6 8A43     	 bic r2,r1
 2244 08d8 9A61     	 str r2,[r3,#24]
 300:../XMC1100-LibHaas.c **** 				PORT2->IOCR8 |= 0x00000080;
 2245              	 .loc 3 300 0
 2246 08da 6E4B     	 ldr r3,.L104
 2247 08dc 6D4A     	 ldr r2,.L104
 2248 08de 9269     	 ldr r2,[r2,#24]
 2249 08e0 8021     	 mov r1,#128
 2250 08e2 0A43     	 orr r2,r1
 2251 08e4 9A61     	 str r2,[r3,#24]
 2252 08e6 36E0     	 b .L84
 2253              	.L85:
 301:../XMC1100-LibHaas.c **** 			} else if (direction == INP) {
 2254              	 .loc 3 301 0
 2255 08e8 7B1D     	 add r3,r7,#5
 2256 08ea 1B78     	 ldrb r3,[r3]
 2257 08ec 002B     	 cmp r3,#0
 2258 08ee 32D1     	 bne .L84
 302:../XMC1100-LibHaas.c **** 				CLR_BIT(PORT2->PDISC,8); // digital Pad aktiv
 2259              	 .loc 3 302 0
 2260 08f0 684B     	 ldr r3,.L104
 2261 08f2 684A     	 ldr r2,.L104
 2262 08f4 126E     	 ldr r2,[r2,#96]
 2263 08f6 6849     	 ldr r1,.L104+4
 2264 08f8 0A40     	 and r2,r1
 2265 08fa 1A66     	 str r2,[r3,#96]
 303:../XMC1100-LibHaas.c **** 				if (mode==PULLUP) {
 2266              	 .loc 3 303 0
 2267 08fc 3B1D     	 add r3,r7,#4
 2268 08fe 1B78     	 ldrb r3,[r3]
 2269 0900 012B     	 cmp r3,#1
 2270 0902 0CD1     	 bne .L86
 304:../XMC1100-LibHaas.c **** 					PORT2->IOCR8 &= 0xFFFFFF00;
 2271              	 .loc 3 304 0
 2272 0904 634B     	 ldr r3,.L104
 2273 0906 634A     	 ldr r2,.L104
 2274 0908 9269     	 ldr r2,[r2,#24]
 2275 090a FF21     	 mov r1,#255
 2276 090c 8A43     	 bic r2,r1
 2277 090e 9A61     	 str r2,[r3,#24]
 305:../XMC1100-LibHaas.c **** 					PORT2->IOCR8 |= 0x00000010;
 2278              	 .loc 3 305 0
 2279 0910 604B     	 ldr r3,.L104
 2280 0912 604A     	 ldr r2,.L104
 2281 0914 9269     	 ldr r2,[r2,#24]
 2282 0916 1021     	 mov r1,#16
 2283 0918 0A43     	 orr r2,r1
 2284 091a 9A61     	 str r2,[r3,#24]
 2285 091c 1BE0     	 b .L84
 2286              	.L86:
 306:../XMC1100-LibHaas.c **** 				} else if (mode==PULLDOWN) {
 2287              	 .loc 3 306 0
 2288 091e 3B1D     	 add r3,r7,#4
 2289 0920 1B78     	 ldrb r3,[r3]
 2290 0922 022B     	 cmp r3,#2
 2291 0924 0CD1     	 bne .L87
 307:../XMC1100-LibHaas.c **** 					PORT2->IOCR8 &= 0xFFFFFF00;
 2292              	 .loc 3 307 0
 2293 0926 5B4B     	 ldr r3,.L104
 2294 0928 5A4A     	 ldr r2,.L104
 2295 092a 9269     	 ldr r2,[r2,#24]
 2296 092c FF21     	 mov r1,#255
 2297 092e 8A43     	 bic r2,r1
 2298 0930 9A61     	 str r2,[r3,#24]
 308:../XMC1100-LibHaas.c **** 					PORT2->IOCR8 |= 0x00000008;
 2299              	 .loc 3 308 0
 2300 0932 584B     	 ldr r3,.L104
 2301 0934 574A     	 ldr r2,.L104
 2302 0936 9269     	 ldr r2,[r2,#24]
 2303 0938 0821     	 mov r1,#8
 2304 093a 0A43     	 orr r2,r1
 2305 093c 9A61     	 str r2,[r3,#24]
 2306 093e 0AE0     	 b .L84
 2307              	.L87:
 309:../XMC1100-LibHaas.c **** 				} else if (mode == ANALOG) {
 2308              	 .loc 3 309 0
 2309 0940 3B1D     	 add r3,r7,#4
 2310 0942 1B78     	 ldrb r3,[r3]
 2311 0944 032B     	 cmp r3,#3
 2312 0946 06D1     	 bne .L84
 310:../XMC1100-LibHaas.c **** 					SET_BIT(PORT2->PDISC,8); //Analog Modus aktiv
 2313              	 .loc 3 310 0
 2314 0948 524B     	 ldr r3,.L104
 2315 094a 524A     	 ldr r2,.L104
 2316 094c 126E     	 ldr r2,[r2,#96]
 2317 094e 8021     	 mov r1,#128
 2318 0950 4900     	 lsl r1,r1,#1
 2319 0952 0A43     	 orr r2,r1
 2320 0954 1A66     	 str r2,[r3,#96]
 2321              	.L84:
 311:../XMC1100-LibHaas.c **** 				}
 312:../XMC1100-LibHaas.c **** 			}
 313:../XMC1100-LibHaas.c **** 		 }
 314:../XMC1100-LibHaas.c **** 		 if (bitnr == 9) { //P2.9
 2322              	 .loc 3 314 0
 2323 0956 BB1D     	 add r3,r7,#6
 2324 0958 1B78     	 ldrb r3,[r3]
 2325 095a 092B     	 cmp r3,#9
 2326 095c 50D1     	 bne .L88
 315:../XMC1100-LibHaas.c **** 			if (direction == OUTP) {
 2327              	 .loc 3 315 0
 2328 095e 7B1D     	 add r3,r7,#5
 2329 0960 1B78     	 ldrb r3,[r3]
 2330 0962 012B     	 cmp r3,#1
 2331 0964 13D1     	 bne .L89
 316:../XMC1100-LibHaas.c **** 				CLR_BIT(PORT2->PDISC,9); // digital Pad aktiv
 2332              	 .loc 3 316 0
 2333 0966 4B4B     	 ldr r3,.L104
 2334 0968 4A4A     	 ldr r2,.L104
 2335 096a 126E     	 ldr r2,[r2,#96]
 2336 096c 4B49     	 ldr r1,.L104+8
 2337 096e 0A40     	 and r2,r1
 2338 0970 1A66     	 str r2,[r3,#96]
 317:../XMC1100-LibHaas.c **** 				PORT2->IOCR8 &= 0xffff00ff;
 2339              	 .loc 3 317 0
 2340 0972 484B     	 ldr r3,.L104
 2341 0974 474A     	 ldr r2,.L104
 2342 0976 9269     	 ldr r2,[r2,#24]
 2343 0978 4949     	 ldr r1,.L104+12
 2344 097a 0A40     	 and r2,r1
 2345 097c 9A61     	 str r2,[r3,#24]
 318:../XMC1100-LibHaas.c **** 				PORT2->IOCR8 |= 0x00008000;
 2346              	 .loc 3 318 0
 2347 097e 454B     	 ldr r3,.L104
 2348 0980 444A     	 ldr r2,.L104
 2349 0982 9269     	 ldr r2,[r2,#24]
 2350 0984 8021     	 mov r1,#128
 2351 0986 0902     	 lsl r1,r1,#8
 2352 0988 0A43     	 orr r2,r1
 2353 098a 9A61     	 str r2,[r3,#24]
 2354 098c 38E0     	 b .L88
 2355              	.L89:
 319:../XMC1100-LibHaas.c **** 			} else if (direction == INP) {
 2356              	 .loc 3 319 0
 2357 098e 7B1D     	 add r3,r7,#5
 2358 0990 1B78     	 ldrb r3,[r3]
 2359 0992 002B     	 cmp r3,#0
 2360 0994 34D1     	 bne .L88
 320:../XMC1100-LibHaas.c **** 				CLR_BIT(PORT2->PDISC,9); // digital Pad aktiv
 2361              	 .loc 3 320 0
 2362 0996 3F4B     	 ldr r3,.L104
 2363 0998 3E4A     	 ldr r2,.L104
 2364 099a 126E     	 ldr r2,[r2,#96]
 2365 099c 3F49     	 ldr r1,.L104+8
 2366 099e 0A40     	 and r2,r1
 2367 09a0 1A66     	 str r2,[r3,#96]
 321:../XMC1100-LibHaas.c **** 				if (mode==PULLUP) {
 2368              	 .loc 3 321 0
 2369 09a2 3B1D     	 add r3,r7,#4
 2370 09a4 1B78     	 ldrb r3,[r3]
 2371 09a6 012B     	 cmp r3,#1
 2372 09a8 0DD1     	 bne .L90
 322:../XMC1100-LibHaas.c **** 					PORT2->IOCR8 &= 0xFFFF00FF;
 2373              	 .loc 3 322 0
 2374 09aa 3A4B     	 ldr r3,.L104
 2375 09ac 394A     	 ldr r2,.L104
 2376 09ae 9269     	 ldr r2,[r2,#24]
 2377 09b0 3B49     	 ldr r1,.L104+12
 2378 09b2 0A40     	 and r2,r1
 2379 09b4 9A61     	 str r2,[r3,#24]
 323:../XMC1100-LibHaas.c **** 					PORT2->IOCR8 |= 0x00001000;
 2380              	 .loc 3 323 0
 2381 09b6 374B     	 ldr r3,.L104
 2382 09b8 364A     	 ldr r2,.L104
 2383 09ba 9269     	 ldr r2,[r2,#24]
 2384 09bc 8021     	 mov r1,#128
 2385 09be 4901     	 lsl r1,r1,#5
 2386 09c0 0A43     	 orr r2,r1
 2387 09c2 9A61     	 str r2,[r3,#24]
 2388 09c4 1CE0     	 b .L88
 2389              	.L90:
 324:../XMC1100-LibHaas.c **** 				} else if (mode==PULLDOWN) {
 2390              	 .loc 3 324 0
 2391 09c6 3B1D     	 add r3,r7,#4
 2392 09c8 1B78     	 ldrb r3,[r3]
 2393 09ca 022B     	 cmp r3,#2
 2394 09cc 0DD1     	 bne .L91
 325:../XMC1100-LibHaas.c **** 					PORT2->IOCR8 &= 0xFFFF00FF;
 2395              	 .loc 3 325 0
 2396 09ce 314B     	 ldr r3,.L104
 2397 09d0 304A     	 ldr r2,.L104
 2398 09d2 9269     	 ldr r2,[r2,#24]
 2399 09d4 3249     	 ldr r1,.L104+12
 2400 09d6 0A40     	 and r2,r1
 2401 09d8 9A61     	 str r2,[r3,#24]
 326:../XMC1100-LibHaas.c **** 					PORT2->IOCR8 |= 0x00000800;
 2402              	 .loc 3 326 0
 2403 09da 2E4B     	 ldr r3,.L104
 2404 09dc 2D4A     	 ldr r2,.L104
 2405 09de 9269     	 ldr r2,[r2,#24]
 2406 09e0 8021     	 mov r1,#128
 2407 09e2 0901     	 lsl r1,r1,#4
 2408 09e4 0A43     	 orr r2,r1
 2409 09e6 9A61     	 str r2,[r3,#24]
 2410 09e8 0AE0     	 b .L88
 2411              	.L91:
 327:../XMC1100-LibHaas.c **** 				} else if (mode == ANALOG) {
 2412              	 .loc 3 327 0
 2413 09ea 3B1D     	 add r3,r7,#4
 2414 09ec 1B78     	 ldrb r3,[r3]
 2415 09ee 032B     	 cmp r3,#3
 2416 09f0 06D1     	 bne .L88
 328:../XMC1100-LibHaas.c **** 					SET_BIT(PORT2->PDISC,9); //Analog Modus aktiv
 2417              	 .loc 3 328 0
 2418 09f2 284B     	 ldr r3,.L104
 2419 09f4 274A     	 ldr r2,.L104
 2420 09f6 126E     	 ldr r2,[r2,#96]
 2421 09f8 8021     	 mov r1,#128
 2422 09fa 8900     	 lsl r1,r1,#2
 2423 09fc 0A43     	 orr r2,r1
 2424 09fe 1A66     	 str r2,[r3,#96]
 2425              	.L88:
 329:../XMC1100-LibHaas.c **** 				}
 330:../XMC1100-LibHaas.c **** 			}
 331:../XMC1100-LibHaas.c **** 		 }
 332:../XMC1100-LibHaas.c **** 		 if (bitnr == 10) { //P2.10
 2426              	 .loc 3 332 0
 2427 0a00 BB1D     	 add r3,r7,#6
 2428 0a02 1B78     	 ldrb r3,[r3]
 2429 0a04 0A2B     	 cmp r3,#10
 2430 0a06 5CD1     	 bne .L92
 333:../XMC1100-LibHaas.c **** 			 if (direction == OUTP) {
 2431              	 .loc 3 333 0
 2432 0a08 7B1D     	 add r3,r7,#5
 2433 0a0a 1B78     	 ldrb r3,[r3]
 2434 0a0c 012B     	 cmp r3,#1
 2435 0a0e 13D1     	 bne .L93
 334:../XMC1100-LibHaas.c **** 				 CLR_BIT(PORT2->PDISC,10); // digital Pad aktiv
 2436              	 .loc 3 334 0
 2437 0a10 204B     	 ldr r3,.L104
 2438 0a12 204A     	 ldr r2,.L104
 2439 0a14 126E     	 ldr r2,[r2,#96]
 2440 0a16 2349     	 ldr r1,.L104+16
 2441 0a18 0A40     	 and r2,r1
 2442 0a1a 1A66     	 str r2,[r3,#96]
 335:../XMC1100-LibHaas.c **** 				 PORT2->IOCR8 &= 0xff00ffff;
 2443              	 .loc 3 335 0
 2444 0a1c 1D4B     	 ldr r3,.L104
 2445 0a1e 1D4A     	 ldr r2,.L104
 2446 0a20 9269     	 ldr r2,[r2,#24]
 2447 0a22 2149     	 ldr r1,.L104+20
 2448 0a24 0A40     	 and r2,r1
 2449 0a26 9A61     	 str r2,[r3,#24]
 336:../XMC1100-LibHaas.c **** 				 PORT2->IOCR8 |= 0x00800000;
 2450              	 .loc 3 336 0
 2451 0a28 1A4B     	 ldr r3,.L104
 2452 0a2a 1A4A     	 ldr r2,.L104
 2453 0a2c 9269     	 ldr r2,[r2,#24]
 2454 0a2e 8021     	 mov r1,#128
 2455 0a30 0904     	 lsl r1,r1,#16
 2456 0a32 0A43     	 orr r2,r1
 2457 0a34 9A61     	 str r2,[r3,#24]
 2458 0a36 44E0     	 b .L92
 2459              	.L93:
 337:../XMC1100-LibHaas.c **** 			 } else if (direction == INP) {
 2460              	 .loc 3 337 0
 2461 0a38 7B1D     	 add r3,r7,#5
 2462 0a3a 1B78     	 ldrb r3,[r3]
 2463 0a3c 002B     	 cmp r3,#0
 2464 0a3e 40D1     	 bne .L92
 338:../XMC1100-LibHaas.c **** 				 CLR_BIT(PORT2->PDISC,10); // digital Pad aktiv
 2465              	 .loc 3 338 0
 2466 0a40 144B     	 ldr r3,.L104
 2467 0a42 144A     	 ldr r2,.L104
 2468 0a44 126E     	 ldr r2,[r2,#96]
 2469 0a46 1749     	 ldr r1,.L104+16
 2470 0a48 0A40     	 and r2,r1
 2471 0a4a 1A66     	 str r2,[r3,#96]
 339:../XMC1100-LibHaas.c **** 				 if (mode==PULLUP) {
 2472              	 .loc 3 339 0
 2473 0a4c 3B1D     	 add r3,r7,#4
 2474 0a4e 1B78     	 ldrb r3,[r3]
 2475 0a50 012B     	 cmp r3,#1
 2476 0a52 0DD1     	 bne .L94
 340:../XMC1100-LibHaas.c **** 					 PORT2->IOCR8 &= 0xFF00FFFF;
 2477              	 .loc 3 340 0
 2478 0a54 0F4B     	 ldr r3,.L104
 2479 0a56 0F4A     	 ldr r2,.L104
 2480 0a58 9269     	 ldr r2,[r2,#24]
 2481 0a5a 1349     	 ldr r1,.L104+20
 2482 0a5c 0A40     	 and r2,r1
 2483 0a5e 9A61     	 str r2,[r3,#24]
 341:../XMC1100-LibHaas.c **** 					 PORT2->IOCR8 |= 0x00100000;
 2484              	 .loc 3 341 0
 2485 0a60 0C4B     	 ldr r3,.L104
 2486 0a62 0C4A     	 ldr r2,.L104
 2487 0a64 9269     	 ldr r2,[r2,#24]
 2488 0a66 8021     	 mov r1,#128
 2489 0a68 4903     	 lsl r1,r1,#13
 2490 0a6a 0A43     	 orr r2,r1
 2491 0a6c 9A61     	 str r2,[r3,#24]
 2492 0a6e 28E0     	 b .L92
 2493              	.L94:
 342:../XMC1100-LibHaas.c **** 				 } else if (mode==PULLDOWN) {
 2494              	 .loc 3 342 0
 2495 0a70 3B1D     	 add r3,r7,#4
 2496 0a72 1B78     	 ldrb r3,[r3]
 2497 0a74 022B     	 cmp r3,#2
 2498 0a76 19D1     	 bne .L95
 343:../XMC1100-LibHaas.c **** 					 PORT2->IOCR8 &= 0xFF00FFFF;
 2499              	 .loc 3 343 0
 2500 0a78 064B     	 ldr r3,.L104
 2501 0a7a 064A     	 ldr r2,.L104
 2502 0a7c 9269     	 ldr r2,[r2,#24]
 2503 0a7e 0A49     	 ldr r1,.L104+20
 2504 0a80 0A40     	 and r2,r1
 2505 0a82 9A61     	 str r2,[r3,#24]
 344:../XMC1100-LibHaas.c **** 					 PORT2->IOCR8 |= 0x00080000;
 2506              	 .loc 3 344 0
 2507 0a84 034B     	 ldr r3,.L104
 2508 0a86 034A     	 ldr r2,.L104
 2509 0a88 9269     	 ldr r2,[r2,#24]
 2510 0a8a 8021     	 mov r1,#128
 2511 0a8c 0903     	 lsl r1,r1,#12
 2512 0a8e 0A43     	 orr r2,r1
 2513 0a90 9A61     	 str r2,[r3,#24]
 2514 0a92 16E0     	 b .L92
 2515              	.L105:
 2516              	 .align 2
 2517              	.L104:
 2518 0a94 00020440 	 .word 1074004480
 2519 0a98 FFFEFFFF 	 .word -257
 2520 0a9c FFFDFFFF 	 .word -513
 2521 0aa0 FF00FFFF 	 .word -65281
 2522 0aa4 FFFBFFFF 	 .word -1025
 2523 0aa8 FFFF00FF 	 .word -16711681
 2524              	.L95:
 345:../XMC1100-LibHaas.c **** 				 } else if (mode == ANALOG) {
 2525              	 .loc 3 345 0
 2526 0aac 3B1D     	 add r3,r7,#4
 2527 0aae 1B78     	 ldrb r3,[r3]
 2528 0ab0 032B     	 cmp r3,#3
 2529 0ab2 06D1     	 bne .L92
 346:../XMC1100-LibHaas.c **** 					 SET_BIT(PORT2->PDISC,10); //Analog Modus aktiv
 2530              	 .loc 3 346 0
 2531 0ab4 2F4B     	 ldr r3,.L106
 2532 0ab6 2F4A     	 ldr r2,.L106
 2533 0ab8 126E     	 ldr r2,[r2,#96]
 2534 0aba 8021     	 mov r1,#128
 2535 0abc C900     	 lsl r1,r1,#3
 2536 0abe 0A43     	 orr r2,r1
 2537 0ac0 1A66     	 str r2,[r3,#96]
 2538              	.L92:
 347:../XMC1100-LibHaas.c **** 				 }
 348:../XMC1100-LibHaas.c **** 			 }
 349:../XMC1100-LibHaas.c **** 		 }
 350:../XMC1100-LibHaas.c **** 		 if (bitnr == 11) { //P2.11
 2539              	 .loc 3 350 0
 2540 0ac2 BB1D     	 add r3,r7,#6
 2541 0ac4 1B78     	 ldrb r3,[r3]
 2542 0ac6 0B2B     	 cmp r3,#11
 2543 0ac8 50D1     	 bne .L96
 351:../XMC1100-LibHaas.c **** 			if (direction == OUTP) {
 2544              	 .loc 3 351 0
 2545 0aca 7B1D     	 add r3,r7,#5
 2546 0acc 1B78     	 ldrb r3,[r3]
 2547 0ace 012B     	 cmp r3,#1
 2548 0ad0 13D1     	 bne .L97
 352:../XMC1100-LibHaas.c **** 				CLR_BIT(PORT2->PDISC,11); // digital Pad aktiv
 2549              	 .loc 3 352 0
 2550 0ad2 284B     	 ldr r3,.L106
 2551 0ad4 274A     	 ldr r2,.L106
 2552 0ad6 126E     	 ldr r2,[r2,#96]
 2553 0ad8 2749     	 ldr r1,.L106+4
 2554 0ada 0A40     	 and r2,r1
 2555 0adc 1A66     	 str r2,[r3,#96]
 353:../XMC1100-LibHaas.c **** 				PORT2->IOCR8 &= 0x00ffffff;
 2556              	 .loc 3 353 0
 2557 0ade 254B     	 ldr r3,.L106
 2558 0ae0 244A     	 ldr r2,.L106
 2559 0ae2 9269     	 ldr r2,[r2,#24]
 2560 0ae4 1202     	 lsl r2,r2,#8
 2561 0ae6 120A     	 lsr r2,r2,#8
 2562 0ae8 9A61     	 str r2,[r3,#24]
 354:../XMC1100-LibHaas.c **** 				PORT2->IOCR8 |= 0x80000000;
 2563              	 .loc 3 354 0
 2564 0aea 224B     	 ldr r3,.L106
 2565 0aec 214A     	 ldr r2,.L106
 2566 0aee 9269     	 ldr r2,[r2,#24]
 2567 0af0 8021     	 mov r1,#128
 2568 0af2 0906     	 lsl r1,r1,#24
 2569 0af4 0A43     	 orr r2,r1
 2570 0af6 9A61     	 str r2,[r3,#24]
 2571 0af8 38E0     	 b .L96
 2572              	.L97:
 355:../XMC1100-LibHaas.c **** 			} else if (direction == INP) {
 2573              	 .loc 3 355 0
 2574 0afa 7B1D     	 add r3,r7,#5
 2575 0afc 1B78     	 ldrb r3,[r3]
 2576 0afe 002B     	 cmp r3,#0
 2577 0b00 34D1     	 bne .L96
 356:../XMC1100-LibHaas.c **** 				CLR_BIT(PORT2->PDISC,11); // digital Pad aktiv
 2578              	 .loc 3 356 0
 2579 0b02 1C4B     	 ldr r3,.L106
 2580 0b04 1B4A     	 ldr r2,.L106
 2581 0b06 126E     	 ldr r2,[r2,#96]
 2582 0b08 1B49     	 ldr r1,.L106+4
 2583 0b0a 0A40     	 and r2,r1
 2584 0b0c 1A66     	 str r2,[r3,#96]
 357:../XMC1100-LibHaas.c **** 				if (mode==PULLUP) {
 2585              	 .loc 3 357 0
 2586 0b0e 3B1D     	 add r3,r7,#4
 2587 0b10 1B78     	 ldrb r3,[r3]
 2588 0b12 012B     	 cmp r3,#1
 2589 0b14 0DD1     	 bne .L98
 358:../XMC1100-LibHaas.c **** 					PORT2->IOCR8 &= 0x00FFFFFF;
 2590              	 .loc 3 358 0
 2591 0b16 174B     	 ldr r3,.L106
 2592 0b18 164A     	 ldr r2,.L106
 2593 0b1a 9269     	 ldr r2,[r2,#24]
 2594 0b1c 1202     	 lsl r2,r2,#8
 2595 0b1e 120A     	 lsr r2,r2,#8
 2596 0b20 9A61     	 str r2,[r3,#24]
 359:../XMC1100-LibHaas.c **** 					PORT2->IOCR8 |= 0x10000000;
 2597              	 .loc 3 359 0
 2598 0b22 144B     	 ldr r3,.L106
 2599 0b24 134A     	 ldr r2,.L106
 2600 0b26 9269     	 ldr r2,[r2,#24]
 2601 0b28 8021     	 mov r1,#128
 2602 0b2a 4905     	 lsl r1,r1,#21
 2603 0b2c 0A43     	 orr r2,r1
 2604 0b2e 9A61     	 str r2,[r3,#24]
 2605 0b30 1CE0     	 b .L96
 2606              	.L98:
 360:../XMC1100-LibHaas.c **** 				} else if (mode==PULLDOWN) {
 2607              	 .loc 3 360 0
 2608 0b32 3B1D     	 add r3,r7,#4
 2609 0b34 1B78     	 ldrb r3,[r3]
 2610 0b36 022B     	 cmp r3,#2
 2611 0b38 0DD1     	 bne .L99
 361:../XMC1100-LibHaas.c **** 					PORT2->IOCR8 &= 0x00FFFFFF;
 2612              	 .loc 3 361 0
 2613 0b3a 0E4B     	 ldr r3,.L106
 2614 0b3c 0D4A     	 ldr r2,.L106
 2615 0b3e 9269     	 ldr r2,[r2,#24]
 2616 0b40 1202     	 lsl r2,r2,#8
 2617 0b42 120A     	 lsr r2,r2,#8
 2618 0b44 9A61     	 str r2,[r3,#24]
 362:../XMC1100-LibHaas.c **** 					PORT2->IOCR8 |= 0x08000000;
 2619              	 .loc 3 362 0
 2620 0b46 0B4B     	 ldr r3,.L106
 2621 0b48 0A4A     	 ldr r2,.L106
 2622 0b4a 9269     	 ldr r2,[r2,#24]
 2623 0b4c 8021     	 mov r1,#128
 2624 0b4e 0905     	 lsl r1,r1,#20
 2625 0b50 0A43     	 orr r2,r1
 2626 0b52 9A61     	 str r2,[r3,#24]
 2627 0b54 0AE0     	 b .L96
 2628              	.L99:
 363:../XMC1100-LibHaas.c **** 				} else if (mode == ANALOG) {
 2629              	 .loc 3 363 0
 2630 0b56 3B1D     	 add r3,r7,#4
 2631 0b58 1B78     	 ldrb r3,[r3]
 2632 0b5a 032B     	 cmp r3,#3
 2633 0b5c 06D1     	 bne .L96
 364:../XMC1100-LibHaas.c **** 					SET_BIT(PORT2->PDISC,11); //Analog Modus aktiv
 2634              	 .loc 3 364 0
 2635 0b5e 054B     	 ldr r3,.L106
 2636 0b60 044A     	 ldr r2,.L106
 2637 0b62 126E     	 ldr r2,[r2,#96]
 2638 0b64 8021     	 mov r1,#128
 2639 0b66 0901     	 lsl r1,r1,#4
 2640 0b68 0A43     	 orr r2,r1
 2641 0b6a 1A66     	 str r2,[r3,#96]
 2642              	.L96:
 365:../XMC1100-LibHaas.c **** 				}
 366:../XMC1100-LibHaas.c **** 			}
 367:../XMC1100-LibHaas.c **** 		 }
 368:../XMC1100-LibHaas.c **** 		 break;
 2643              	 .loc 3 368 0
 2644 0b6c C046     	 mov r8,r8
 2645              	.L44:
 369:../XMC1100-LibHaas.c **** 	}
 370:../XMC1100-LibHaas.c **** }
 2646              	 .loc 3 370 0
 2647 0b6e BD46     	 mov sp,r7
 2648 0b70 02B0     	 add sp,sp,#8
 2649              	 
 2650 0b72 B0BD     	 pop {r4,r5,r7,pc}
 2651              	.L107:
 2652              	 .align 2
 2653              	.L106:
 2654 0b74 00020440 	 .word 1074004480
 2655 0b78 FFF7FFFF 	 .word -2049
 2656              	 .cfi_endproc
 2657              	.LFE37:
 2659              	 .section .text.bit_set_clr,"ax",%progbits
 2660              	 .align 2
 2661              	 .global bit_set_clr
 2662              	 .code 16
 2663              	 .thumb_func
 2665              	bit_set_clr:
 2666              	.LFB38:
 371:../XMC1100-LibHaas.c **** 
 372:../XMC1100-LibHaas.c **** uint16_t bit_set_clr(uint16_t wert, uint16_t set ,uint16_t bitnr)
 373:../XMC1100-LibHaas.c **** {
 2667              	 .loc 3 373 0
 2668              	 .cfi_startproc
 2669 0000 90B5     	 push {r4,r7,lr}
 2670              	.LCFI18:
 2671              	 .cfi_def_cfa_offset 12
 2672              	 .cfi_offset 4,-12
 2673              	 .cfi_offset 7,-8
 2674              	 .cfi_offset 14,-4
 2675 0002 83B0     	 sub sp,sp,#12
 2676              	.LCFI19:
 2677              	 .cfi_def_cfa_offset 24
 2678 0004 00AF     	 add r7,sp,#0
 2679              	.LCFI20:
 2680              	 .cfi_def_cfa_register 7
 2681 0006 041C     	 mov r4,r0
 2682 0008 081C     	 mov r0,r1
 2683 000a 111C     	 mov r1,r2
 2684 000c BB1D     	 add r3,r7,#6
 2685 000e 221C     	 add r2,r4,#0
 2686 0010 1A80     	 strh r2,[r3]
 2687 0012 3B1D     	 add r3,r7,#4
 2688 0014 021C     	 add r2,r0,#0
 2689 0016 1A80     	 strh r2,[r3]
 2690 0018 BB1C     	 add r3,r7,#2
 2691 001a 0A1C     	 add r2,r1,#0
 2692 001c 1A80     	 strh r2,[r3]
 374:../XMC1100-LibHaas.c **** 	if ( set == 1 ) return  wert |= (0x01 << bitnr);
 2693              	 .loc 3 374 0
 2694 001e 3B1D     	 add r3,r7,#4
 2695 0020 1B88     	 ldrh r3,[r3]
 2696 0022 012B     	 cmp r3,#1
 2697 0024 0ED1     	 bne .L109
 2698              	 .loc 3 374 0 is_stmt 0 discriminator 1
 2699 0026 BB1C     	 add r3,r7,#2
 2700 0028 1B88     	 ldrh r3,[r3]
 2701 002a 0122     	 mov r2,#1
 2702 002c 9A40     	 lsl r2,r2,r3
 2703 002e 131C     	 mov r3,r2
 2704 0030 9AB2     	 uxth r2,r3
 2705 0032 BB1D     	 add r3,r7,#6
 2706 0034 1B88     	 ldrh r3,[r3]
 2707 0036 1343     	 orr r3,r2
 2708 0038 9AB2     	 uxth r2,r3
 2709 003a BB1D     	 add r3,r7,#6
 2710 003c 1A80     	 strh r2,[r3]
 2711 003e BB1D     	 add r3,r7,#6
 2712 0040 1B88     	 ldrh r3,[r3]
 2713 0042 10E0     	 b .L110
 2714              	.L109:
 375:../XMC1100-LibHaas.c **** 	else return wert &= ~(0x01 << bitnr);
 2715              	 .loc 3 375 0 is_stmt 1
 2716 0044 BB1C     	 add r3,r7,#2
 2717 0046 1B88     	 ldrh r3,[r3]
 2718 0048 0122     	 mov r2,#1
 2719 004a 9A40     	 lsl r2,r2,r3
 2720 004c 131C     	 mov r3,r2
 2721 004e 9BB2     	 uxth r3,r3
 2722 0050 DB43     	 mvn r3,r3
 2723 0052 99B2     	 uxth r1,r3
 2724 0054 BB1D     	 add r3,r7,#6
 2725 0056 1A88     	 ldrh r2,[r3]
 2726 0058 0B1C     	 add r3,r1,#0
 2727 005a 1340     	 and r3,r2
 2728 005c 9AB2     	 uxth r2,r3
 2729 005e BB1D     	 add r3,r7,#6
 2730 0060 1A80     	 strh r2,[r3]
 2731 0062 BB1D     	 add r3,r7,#6
 2732 0064 1B88     	 ldrh r3,[r3]
 2733              	.L110:
 376:../XMC1100-LibHaas.c **** }
 2734              	 .loc 3 376 0
 2735 0066 181C     	 mov r0,r3
 2736 0068 BD46     	 mov sp,r7
 2737 006a 03B0     	 add sp,sp,#12
 2738              	 
 2739 006c 90BD     	 pop {r4,r7,pc}
 2740              	 .cfi_endproc
 2741              	.LFE38:
 2743 006e C046     	 .section .text.port_init,"ax",%progbits
 2744              	 .align 2
 2745              	 .global port_init
 2746              	 .code 16
 2747              	 .thumb_func
 2749              	port_init:
 2750              	.LFB39:
 377:../XMC1100-LibHaas.c **** 
 378:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
 379:../XMC1100-LibHaas.c **** //Gesamtes Port für Ein- oder Ausgabe initialisieren
 380:../XMC1100-LibHaas.c **** // port: P0,P1 direction: INP 0, OUTP 1
 381:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
 382:../XMC1100-LibHaas.c ****  void port_init(uint8_t port, uint8_t direction)
 383:../XMC1100-LibHaas.c **** 
 384:../XMC1100-LibHaas.c **** {
 2751              	 .loc 3 384 0
 2752              	 .cfi_startproc
 2753 0000 80B5     	 push {r7,lr}
 2754              	.LCFI21:
 2755              	 .cfi_def_cfa_offset 8
 2756              	 .cfi_offset 7,-8
 2757              	 .cfi_offset 14,-4
 2758 0002 82B0     	 sub sp,sp,#8
 2759              	.LCFI22:
 2760              	 .cfi_def_cfa_offset 16
 2761 0004 00AF     	 add r7,sp,#0
 2762              	.LCFI23:
 2763              	 .cfi_def_cfa_register 7
 2764 0006 021C     	 mov r2,r0
 2765 0008 FB1D     	 add r3,r7,#7
 2766 000a 1A70     	 strb r2,[r3]
 2767 000c BB1D     	 add r3,r7,#6
 2768 000e 0A1C     	 add r2,r1,#0
 2769 0010 1A70     	 strb r2,[r3]
 385:../XMC1100-LibHaas.c **** 	switch(port)
 2770              	 .loc 3 385 0
 2771 0012 FB1D     	 add r3,r7,#7
 2772 0014 1B78     	 ldrb r3,[r3]
 2773 0016 012B     	 cmp r3,#1
 2774 0018 21D0     	 beq .L113
 2775 001a 022B     	 cmp r3,#2
 2776 001c 31D0     	 beq .L114
 2777 001e 002B     	 cmp r3,#0
 2778 0020 4DD1     	 bne .L111
 386:../XMC1100-LibHaas.c **** 	{
 387:../XMC1100-LibHaas.c **** 		case 0:	if (direction == OUTP) {
 2779              	 .loc 3 387 0
 2780 0022 BB1D     	 add r3,r7,#6
 2781 0024 1B78     	 ldrb r3,[r3]
 2782 0026 012B     	 cmp r3,#1
 2783 0028 0CD1     	 bne .L116
 388:../XMC1100-LibHaas.c **** 					PORT0->IOCR0 = 0x80808080;  // auf Ausgang setzen
 2784              	 .loc 3 388 0
 2785 002a 264B     	 ldr r3,.L122
 2786 002c 264A     	 ldr r2,.L122+4
 2787 002e 1A61     	 str r2,[r3,#16]
 389:../XMC1100-LibHaas.c **** 					PORT0->IOCR4 = 0x80808080;
 2788              	 .loc 3 389 0
 2789 0030 244B     	 ldr r3,.L122
 2790 0032 254A     	 ldr r2,.L122+4
 2791 0034 5A61     	 str r2,[r3,#20]
 390:../XMC1100-LibHaas.c **** 					PORT0->IOCR8 = 0x80808080;
 2792              	 .loc 3 390 0
 2793 0036 234B     	 ldr r3,.L122
 2794 0038 234A     	 ldr r2,.L122+4
 2795 003a 9A61     	 str r2,[r3,#24]
 391:../XMC1100-LibHaas.c **** 					PORT0->IOCR12 = 0x80808080;
 2796              	 .loc 3 391 0
 2797 003c 214B     	 ldr r3,.L122
 2798 003e 224A     	 ldr r2,.L122+4
 2799 0040 DA61     	 str r2,[r3,#28]
 392:../XMC1100-LibHaas.c **** 					}
 393:../XMC1100-LibHaas.c **** 				else {
 394:../XMC1100-LibHaas.c **** 					PORT0->IOCR0 = 0x00;
 395:../XMC1100-LibHaas.c **** 					PORT0->IOCR4 = 0x00;
 396:../XMC1100-LibHaas.c **** 					PORT0->IOCR8 = 0x00;
 397:../XMC1100-LibHaas.c **** 					PORT0->IOCR12 = 0x00;
 398:../XMC1100-LibHaas.c **** 					}
 399:../XMC1100-LibHaas.c **** 					break;
 2800              	 .loc 3 399 0
 2801 0042 3CE0     	 b .L111
 2802              	.L116:
 394:../XMC1100-LibHaas.c **** 					PORT0->IOCR4 = 0x00;
 2803              	 .loc 3 394 0
 2804 0044 1F4B     	 ldr r3,.L122
 2805 0046 0022     	 mov r2,#0
 2806 0048 1A61     	 str r2,[r3,#16]
 395:../XMC1100-LibHaas.c **** 					PORT0->IOCR8 = 0x00;
 2807              	 .loc 3 395 0
 2808 004a 1E4B     	 ldr r3,.L122
 2809 004c 0022     	 mov r2,#0
 2810 004e 5A61     	 str r2,[r3,#20]
 396:../XMC1100-LibHaas.c **** 					PORT0->IOCR12 = 0x00;
 2811              	 .loc 3 396 0
 2812 0050 1C4B     	 ldr r3,.L122
 2813 0052 0022     	 mov r2,#0
 2814 0054 9A61     	 str r2,[r3,#24]
 397:../XMC1100-LibHaas.c **** 					}
 2815              	 .loc 3 397 0
 2816 0056 1B4B     	 ldr r3,.L122
 2817 0058 0022     	 mov r2,#0
 2818 005a DA61     	 str r2,[r3,#28]
 2819              	 .loc 3 399 0
 2820 005c 2FE0     	 b .L111
 2821              	.L113:
 400:../XMC1100-LibHaas.c **** 		case 1:	 if (direction == OUTP) {
 2822              	 .loc 3 400 0
 2823 005e BB1D     	 add r3,r7,#6
 2824 0060 1B78     	 ldrb r3,[r3]
 2825 0062 012B     	 cmp r3,#1
 2826 0064 06D1     	 bne .L118
 401:../XMC1100-LibHaas.c **** 					PORT1->IOCR0 = 0x80808080;  // auf Ausgang setzen
 2827              	 .loc 3 401 0
 2828 0066 194B     	 ldr r3,.L122+8
 2829 0068 174A     	 ldr r2,.L122+4
 2830 006a 1A61     	 str r2,[r3,#16]
 402:../XMC1100-LibHaas.c **** 					PORT1->IOCR4 = 0x80808080;
 2831              	 .loc 3 402 0
 2832 006c 174B     	 ldr r3,.L122+8
 2833 006e 164A     	 ldr r2,.L122+4
 2834 0070 5A61     	 str r2,[r3,#20]
 403:../XMC1100-LibHaas.c **** 								}
 404:../XMC1100-LibHaas.c **** 				else {
 405:../XMC1100-LibHaas.c **** 					PORT1->IOCR0 = 0x00;
 406:../XMC1100-LibHaas.c **** 					PORT1->IOCR4 = 0x00;
 407:../XMC1100-LibHaas.c **** 			}
 408:../XMC1100-LibHaas.c **** 				break;
 2835              	 .loc 3 408 0
 2836 0072 24E0     	 b .L111
 2837              	.L118:
 405:../XMC1100-LibHaas.c **** 					PORT1->IOCR4 = 0x00;
 2838              	 .loc 3 405 0
 2839 0074 154B     	 ldr r3,.L122+8
 2840 0076 0022     	 mov r2,#0
 2841 0078 1A61     	 str r2,[r3,#16]
 406:../XMC1100-LibHaas.c **** 			}
 2842              	 .loc 3 406 0
 2843 007a 144B     	 ldr r3,.L122+8
 2844 007c 0022     	 mov r2,#0
 2845 007e 5A61     	 str r2,[r3,#20]
 2846              	 .loc 3 408 0
 2847 0080 1DE0     	 b .L111
 2848              	.L114:
 409:../XMC1100-LibHaas.c **** 
 410:../XMC1100-LibHaas.c **** 		case 2:	 if (direction == OUTP) {
 2849              	 .loc 3 410 0
 2850 0082 BB1D     	 add r3,r7,#6
 2851 0084 1B78     	 ldrb r3,[r3]
 2852 0086 012B     	 cmp r3,#1
 2853 0088 0CD1     	 bne .L120
 411:../XMC1100-LibHaas.c **** 					PORT2->IOCR0 = 0x80808080;  // auf Ausgang setzen geht aber nur für ein paar Pins an P2
 2854              	 .loc 3 411 0
 2855 008a 114B     	 ldr r3,.L122+12
 2856 008c 0E4A     	 ldr r2,.L122+4
 2857 008e 1A61     	 str r2,[r3,#16]
 412:../XMC1100-LibHaas.c **** 					PORT2->IOCR4 = 0x80808080;
 2858              	 .loc 3 412 0
 2859 0090 0F4B     	 ldr r3,.L122+12
 2860 0092 0D4A     	 ldr r2,.L122+4
 2861 0094 5A61     	 str r2,[r3,#20]
 413:../XMC1100-LibHaas.c **** 					PORT2->IOCR8 = 0x80808080;
 2862              	 .loc 3 413 0
 2863 0096 0E4B     	 ldr r3,.L122+12
 2864 0098 0B4A     	 ldr r2,.L122+4
 2865 009a 9A61     	 str r2,[r3,#24]
 414:../XMC1100-LibHaas.c **** 					PORT2->PDISC = 0; // digital Pad aktiv
 2866              	 .loc 3 414 0
 2867 009c 0C4B     	 ldr r3,.L122+12
 2868 009e 0022     	 mov r2,#0
 2869 00a0 1A66     	 str r2,[r3,#96]
 2870 00a2 0BE0     	 b .L121
 2871              	.L120:
 415:../XMC1100-LibHaas.c **** 				}
 416:../XMC1100-LibHaas.c **** 				else {
 417:../XMC1100-LibHaas.c **** 					PORT2->IOCR0 = 0x00;
 2872              	 .loc 3 417 0
 2873 00a4 0A4B     	 ldr r3,.L122+12
 2874 00a6 0022     	 mov r2,#0
 2875 00a8 1A61     	 str r2,[r3,#16]
 418:../XMC1100-LibHaas.c **** 					PORT2->IOCR4 = 0x00;
 2876              	 .loc 3 418 0
 2877 00aa 094B     	 ldr r3,.L122+12
 2878 00ac 0022     	 mov r2,#0
 2879 00ae 5A61     	 str r2,[r3,#20]
 419:../XMC1100-LibHaas.c **** 					PORT2->IOCR8 = 0x00;
 2880              	 .loc 3 419 0
 2881 00b0 074B     	 ldr r3,.L122+12
 2882 00b2 0022     	 mov r2,#0
 2883 00b4 9A61     	 str r2,[r3,#24]
 420:../XMC1100-LibHaas.c **** 					PORT2->PDISC = 0; // digital Pad aktiv
 2884              	 .loc 3 420 0
 2885 00b6 064B     	 ldr r3,.L122+12
 2886 00b8 0022     	 mov r2,#0
 2887 00ba 1A66     	 str r2,[r3,#96]
 2888              	.L121:
 421:../XMC1100-LibHaas.c **** 				}
 422:../XMC1100-LibHaas.c **** 				break;
 2889              	 .loc 3 422 0
 2890 00bc C046     	 mov r8,r8
 2891              	.L111:
 423:../XMC1100-LibHaas.c **** 
 424:../XMC1100-LibHaas.c **** 	}
 425:../XMC1100-LibHaas.c **** }
 2892              	 .loc 3 425 0
 2893 00be BD46     	 mov sp,r7
 2894 00c0 02B0     	 add sp,sp,#8
 2895              	 
 2896 00c2 80BD     	 pop {r7,pc}
 2897              	.L123:
 2898              	 .align 2
 2899              	.L122:
 2900 00c4 00000440 	 .word 1074003968
 2901 00c8 80808080 	 .word -2139062144
 2902 00cc 00010440 	 .word 1074004224
 2903 00d0 00020440 	 .word 1074004480
 2904              	 .cfi_endproc
 2905              	.LFE39:
 2907              	 .section .text.bit_read,"ax",%progbits
 2908              	 .align 2
 2909              	 .global bit_read
 2910              	 .code 16
 2911              	 .thumb_func
 2913              	bit_read:
 2914              	.LFB40:
 426:../XMC1100-LibHaas.c **** 
 427:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
 428:../XMC1100-LibHaas.c **** // Einzelnes Portbit einlesen
 429:../XMC1100-LibHaas.c **** // port: P0,P1,P2 bitnr: 0..15
 430:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
 431:../XMC1100-LibHaas.c **** uint8_t bit_read(uint8_t port, uint8_t bitnr)
 432:../XMC1100-LibHaas.c **** {
 2915              	 .loc 3 432 0
 2916              	 .cfi_startproc
 2917 0000 90B5     	 push {r4,r7,lr}
 2918              	.LCFI24:
 2919              	 .cfi_def_cfa_offset 12
 2920              	 .cfi_offset 4,-12
 2921              	 .cfi_offset 7,-8
 2922              	 .cfi_offset 14,-4
 2923 0002 85B0     	 sub sp,sp,#20
 2924              	.LCFI25:
 2925              	 .cfi_def_cfa_offset 32
 2926 0004 00AF     	 add r7,sp,#0
 2927              	.LCFI26:
 2928              	 .cfi_def_cfa_register 7
 2929 0006 021C     	 mov r2,r0
 2930 0008 FB1D     	 add r3,r7,#7
 2931 000a 1A70     	 strb r2,[r3]
 2932 000c BB1D     	 add r3,r7,#6
 2933 000e 0A1C     	 add r2,r1,#0
 2934 0010 1A70     	 strb r2,[r3]
 433:../XMC1100-LibHaas.c ****   uint16_t temp;
 434:../XMC1100-LibHaas.c **** 
 435:../XMC1100-LibHaas.c ****   temp = port_read(port);
 2935              	 .loc 3 435 0
 2936 0012 0E23     	 mov r3,#14
 2937 0014 FC18     	 add r4,r7,r3
 2938 0016 FB1D     	 add r3,r7,#7
 2939 0018 1B78     	 ldrb r3,[r3]
 2940 001a 181C     	 mov r0,r3
 2941 001c FFF7FEFF 	 bl port_read
 2942 0020 031C     	 mov r3,r0
 2943 0022 2380     	 strh r3,[r4]
 436:../XMC1100-LibHaas.c ****   return ((temp>>bitnr) & 0x01);
 2944              	 .loc 3 436 0
 2945 0024 0E23     	 mov r3,#14
 2946 0026 FB18     	 add r3,r7,r3
 2947 0028 1A88     	 ldrh r2,[r3]
 2948 002a BB1D     	 add r3,r7,#6
 2949 002c 1B78     	 ldrb r3,[r3]
 2950 002e 1A41     	 asr r2,r2,r3
 2951 0030 131C     	 mov r3,r2
 2952 0032 DBB2     	 uxtb r3,r3
 2953 0034 0122     	 mov r2,#1
 2954 0036 1340     	 and r3,r2
 2955 0038 DBB2     	 uxtb r3,r3
 437:../XMC1100-LibHaas.c **** }
 2956              	 .loc 3 437 0
 2957 003a 181C     	 mov r0,r3
 2958 003c BD46     	 mov sp,r7
 2959 003e 05B0     	 add sp,sp,#20
 2960              	 
 2961 0040 90BD     	 pop {r4,r7,pc}
 2962              	 .cfi_endproc
 2963              	.LFE40:
 2965 0042 C046     	 .section .text.bit_write,"ax",%progbits
 2966              	 .align 2
 2967              	 .global bit_write
 2968              	 .code 16
 2969              	 .thumb_func
 2971              	bit_write:
 2972              	.LFB41:
 438:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
 439:../XMC1100-LibHaas.c **** // Einzelnes Portbit ausgeben
 440:../XMC1100-LibHaas.c **** // port: P0,P1 bitnr: 0..15 P2=>bitnr 9..11
 441:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
 442:../XMC1100-LibHaas.c **** void bit_write(uint8_t port, uint8_t bitnr, uint8_t value)
 443:../XMC1100-LibHaas.c **** {
 2973              	 .loc 3 443 0
 2974              	 .cfi_startproc
 2975 0000 90B5     	 push {r4,r7,lr}
 2976              	.LCFI27:
 2977              	 .cfi_def_cfa_offset 12
 2978              	 .cfi_offset 4,-12
 2979              	 .cfi_offset 7,-8
 2980              	 .cfi_offset 14,-4
 2981 0002 83B0     	 sub sp,sp,#12
 2982              	.LCFI28:
 2983              	 .cfi_def_cfa_offset 24
 2984 0004 00AF     	 add r7,sp,#0
 2985              	.LCFI29:
 2986              	 .cfi_def_cfa_register 7
 2987 0006 041C     	 mov r4,r0
 2988 0008 081C     	 mov r0,r1
 2989 000a 111C     	 mov r1,r2
 2990 000c FB1D     	 add r3,r7,#7
 2991 000e 221C     	 add r2,r4,#0
 2992 0010 1A70     	 strb r2,[r3]
 2993 0012 BB1D     	 add r3,r7,#6
 2994 0014 021C     	 add r2,r0,#0
 2995 0016 1A70     	 strb r2,[r3]
 2996 0018 7B1D     	 add r3,r7,#5
 2997 001a 0A1C     	 add r2,r1,#0
 2998 001c 1A70     	 strb r2,[r3]
 444:../XMC1100-LibHaas.c **** 	//uint32_t temp;
 445:../XMC1100-LibHaas.c **** 	value &= 0x01;       // value darf nur 0 oder 1 sein!
 2999              	 .loc 3 445 0
 3000 001e 7B1D     	 add r3,r7,#5
 3001 0020 7A1D     	 add r2,r7,#5
 3002 0022 1278     	 ldrb r2,[r2]
 3003 0024 0121     	 mov r1,#1
 3004 0026 0A40     	 and r2,r1
 3005 0028 1A70     	 strb r2,[r3]
 446:../XMC1100-LibHaas.c **** 	switch (port)
 3006              	 .loc 3 446 0
 3007 002a FB1D     	 add r3,r7,#7
 3008 002c 1B78     	 ldrb r3,[r3]
 3009 002e 012B     	 cmp r3,#1
 3010 0030 35D0     	 beq .L128
 3011 0032 022B     	 cmp r3,#2
 3012 0034 4ED0     	 beq .L129
 3013 0036 002B     	 cmp r3,#0
 3014 0038 67D1     	 bne .L126
 447:../XMC1100-LibHaas.c **** 	{
 448:../XMC1100-LibHaas.c **** 		case 0 :
 449:../XMC1100-LibHaas.c **** 			if (value == 1) {
 3015              	 .loc 3 449 0
 3016 003a 7B1D     	 add r3,r7,#5
 3017 003c 1B78     	 ldrb r3,[r3]
 3018 003e 012B     	 cmp r3,#1
 3019 0040 16D1     	 bne .L131
 450:../XMC1100-LibHaas.c **** 				//PORT0->OUT |= 1UL << bitnr ;
 451:../XMC1100-LibHaas.c **** 				PORT0->OMR &= ~(1UL << (bitnr + 16)); // loeschen des Bits
 3020              	 .loc 3 451 0
 3021 0042 334B     	 ldr r3,.L137
 3022 0044 324A     	 ldr r2,.L137
 3023 0046 5268     	 ldr r2,[r2,#4]
 3024 0048 B91D     	 add r1,r7,#6
 3025 004a 0978     	 ldrb r1,[r1]
 3026 004c 1031     	 add r1,r1,#16
 3027 004e 0120     	 mov r0,#1
 3028 0050 8840     	 lsl r0,r0,r1
 3029 0052 011C     	 mov r1,r0
 3030 0054 C943     	 mvn r1,r1
 3031 0056 0A40     	 and r2,r1
 3032 0058 5A60     	 str r2,[r3,#4]
 452:../XMC1100-LibHaas.c **** 				PORT0->OMR |= 1UL << bitnr;      // setzen
 3033              	 .loc 3 452 0
 3034 005a 2D4B     	 ldr r3,.L137
 3035 005c 2C4A     	 ldr r2,.L137
 3036 005e 5168     	 ldr r1,[r2,#4]
 3037 0060 BA1D     	 add r2,r7,#6
 3038 0062 1278     	 ldrb r2,[r2]
 3039 0064 0120     	 mov r0,#1
 3040 0066 9040     	 lsl r0,r0,r2
 3041 0068 021C     	 mov r2,r0
 3042 006a 0A43     	 orr r2,r1
 3043 006c 5A60     	 str r2,[r3,#4]
 453:../XMC1100-LibHaas.c **** 				//temp=PORT0->OMR;
 454:../XMC1100-LibHaas.c **** 				//temp &= ~(1UL << (bitnr + 16)); // loeschen des Bits
 455:../XMC1100-LibHaas.c **** 				//temp |= 1UL << bitnr;      // setzen
 456:../XMC1100-LibHaas.c **** 				//PORT0->OMR = temp;
 457:../XMC1100-LibHaas.c **** 			}
 458:../XMC1100-LibHaas.c **** 			else {
 459:../XMC1100-LibHaas.c **** 				//PORT0->OUT &= ~( 1UL << bitnr);
 460:../XMC1100-LibHaas.c **** 				PORT0->OMR &= ~(1UL << bitnr);      // Set = 0
 461:../XMC1100-LibHaas.c **** 				PORT0->OMR |= 1UL << (bitnr + 16); // Reset = 0
 462:../XMC1100-LibHaas.c **** 				//temp = PORT0->OMR;
 463:../XMC1100-LibHaas.c **** 				//temp &= ~(1UL << bitnr);      // Set = 0
 464:../XMC1100-LibHaas.c **** 				//temp |= 1UL << (bitnr + 16); // Reset = 0
 465:../XMC1100-LibHaas.c **** 				//PORT0->OMR = temp;
 466:../XMC1100-LibHaas.c **** 			}
 467:../XMC1100-LibHaas.c **** 			break;
 3044              	 .loc 3 467 0
 3045 006e 4CE0     	 b .L126
 3046              	.L131:
 460:../XMC1100-LibHaas.c **** 				PORT0->OMR |= 1UL << (bitnr + 16); // Reset = 0
 3047              	 .loc 3 460 0
 3048 0070 274B     	 ldr r3,.L137
 3049 0072 274A     	 ldr r2,.L137
 3050 0074 5268     	 ldr r2,[r2,#4]
 3051 0076 B91D     	 add r1,r7,#6
 3052 0078 0978     	 ldrb r1,[r1]
 3053 007a 0120     	 mov r0,#1
 3054 007c 8840     	 lsl r0,r0,r1
 3055 007e 011C     	 mov r1,r0
 3056 0080 C943     	 mvn r1,r1
 3057 0082 0A40     	 and r2,r1
 3058 0084 5A60     	 str r2,[r3,#4]
 461:../XMC1100-LibHaas.c **** 				//temp = PORT0->OMR;
 3059              	 .loc 3 461 0
 3060 0086 224B     	 ldr r3,.L137
 3061 0088 214A     	 ldr r2,.L137
 3062 008a 5168     	 ldr r1,[r2,#4]
 3063 008c BA1D     	 add r2,r7,#6
 3064 008e 1278     	 ldrb r2,[r2]
 3065 0090 1032     	 add r2,r2,#16
 3066 0092 0120     	 mov r0,#1
 3067 0094 9040     	 lsl r0,r0,r2
 3068 0096 021C     	 mov r2,r0
 3069 0098 0A43     	 orr r2,r1
 3070 009a 5A60     	 str r2,[r3,#4]
 3071              	 .loc 3 467 0
 3072 009c 35E0     	 b .L126
 3073              	.L128:
 468:../XMC1100-LibHaas.c **** 	    case 1 :
 469:../XMC1100-LibHaas.c **** 	  	  	  {if (value == 1) PORT1->OUT |= 1UL << bitnr ;
 3074              	 .loc 3 469 0
 3075 009e 7B1D     	 add r3,r7,#5
 3076 00a0 1B78     	 ldrb r3,[r3]
 3077 00a2 012B     	 cmp r3,#1
 3078 00a4 0AD1     	 bne .L133
 3079              	 .loc 3 469 0 is_stmt 0 discriminator 1
 3080 00a6 1B4B     	 ldr r3,.L137+4
 3081 00a8 1A4A     	 ldr r2,.L137+4
 3082 00aa 1168     	 ldr r1,[r2]
 3083 00ac BA1D     	 add r2,r7,#6
 3084 00ae 1278     	 ldrb r2,[r2]
 3085 00b0 0120     	 mov r0,#1
 3086 00b2 9040     	 lsl r0,r0,r2
 3087 00b4 021C     	 mov r2,r0
 3088 00b6 0A43     	 orr r2,r1
 3089 00b8 1A60     	 str r2,[r3]
 470:../XMC1100-LibHaas.c **** 	  		   else PORT1->OUT &= ~( 1UL << bitnr);
 471:../XMC1100-LibHaas.c **** 	  		  }
 472:../XMC1100-LibHaas.c **** 			break;
 3090              	 .loc 3 472 0 is_stmt 1 discriminator 1
 3091 00ba 26E0     	 b .L126
 3092              	.L133:
 470:../XMC1100-LibHaas.c **** 	  		   else PORT1->OUT &= ~( 1UL << bitnr);
 3093              	 .loc 3 470 0
 3094 00bc 154B     	 ldr r3,.L137+4
 3095 00be 154A     	 ldr r2,.L137+4
 3096 00c0 1268     	 ldr r2,[r2]
 3097 00c2 B91D     	 add r1,r7,#6
 3098 00c4 0978     	 ldrb r1,[r1]
 3099 00c6 0120     	 mov r0,#1
 3100 00c8 8840     	 lsl r0,r0,r1
 3101 00ca 011C     	 mov r1,r0
 3102 00cc C943     	 mvn r1,r1
 3103 00ce 0A40     	 and r2,r1
 3104 00d0 1A60     	 str r2,[r3]
 3105              	 .loc 3 472 0
 3106 00d2 1AE0     	 b .L126
 3107              	.L129:
 473:../XMC1100-LibHaas.c **** 
 474:../XMC1100-LibHaas.c **** 	    case 2 :
 475:../XMC1100-LibHaas.c **** 			  {if (value == 1) PORT2->OUT |= 1UL << bitnr ;
 3108              	 .loc 3 475 0
 3109 00d4 7B1D     	 add r3,r7,#5
 3110 00d6 1B78     	 ldrb r3,[r3]
 3111 00d8 012B     	 cmp r3,#1
 3112 00da 0AD1     	 bne .L135
 3113              	 .loc 3 475 0 is_stmt 0 discriminator 1
 3114 00dc 0E4B     	 ldr r3,.L137+8
 3115 00de 0E4A     	 ldr r2,.L137+8
 3116 00e0 1168     	 ldr r1,[r2]
 3117 00e2 BA1D     	 add r2,r7,#6
 3118 00e4 1278     	 ldrb r2,[r2]
 3119 00e6 0120     	 mov r0,#1
 3120 00e8 9040     	 lsl r0,r0,r2
 3121 00ea 021C     	 mov r2,r0
 3122 00ec 0A43     	 orr r2,r1
 3123 00ee 1A60     	 str r2,[r3]
 3124 00f0 0AE0     	 b .L136
 3125              	.L135:
 476:../XMC1100-LibHaas.c **** 			   else PORT2->OUT &= ~( 1UL << bitnr);
 3126              	 .loc 3 476 0 is_stmt 1
 3127 00f2 094B     	 ldr r3,.L137+8
 3128 00f4 084A     	 ldr r2,.L137+8
 3129 00f6 1268     	 ldr r2,[r2]
 3130 00f8 B91D     	 add r1,r7,#6
 3131 00fa 0978     	 ldrb r1,[r1]
 3132 00fc 0120     	 mov r0,#1
 3133 00fe 8840     	 lsl r0,r0,r1
 3134 0100 011C     	 mov r1,r0
 3135 0102 C943     	 mvn r1,r1
 3136 0104 0A40     	 and r2,r1
 3137 0106 1A60     	 str r2,[r3]
 3138              	.L136:
 477:../XMC1100-LibHaas.c **** 			  }
 478:../XMC1100-LibHaas.c **** 			break;
 3139              	 .loc 3 478 0
 3140 0108 C046     	 mov r8,r8
 3141              	.L126:
 479:../XMC1100-LibHaas.c **** 		}
 480:../XMC1100-LibHaas.c ****  }
 3142              	 .loc 3 480 0
 3143 010a BD46     	 mov sp,r7
 3144 010c 03B0     	 add sp,sp,#12
 3145              	 
 3146 010e 90BD     	 pop {r4,r7,pc}
 3147              	.L138:
 3148              	 .align 2
 3149              	.L137:
 3150 0110 00000440 	 .word 1074003968
 3151 0114 00010440 	 .word 1074004224
 3152 0118 00020440 	 .word 1074004480
 3153              	 .cfi_endproc
 3154              	.LFE41:
 3156              	 .section .text.port_read,"ax",%progbits
 3157              	 .align 2
 3158              	 .global port_read
 3159              	 .code 16
 3160              	 .thumb_func
 3162              	port_read:
 3163              	.LFB42:
 481:../XMC1100-LibHaas.c **** 
 482:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
 483:../XMC1100-LibHaas.c **** // Gesamtes Port einlesen
 484:../XMC1100-LibHaas.c **** // port: P0,P1,P2
 485:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
 486:../XMC1100-LibHaas.c **** uint16_t port_read (uint8_t port)
 487:../XMC1100-LibHaas.c **** {
 3164              	 .loc 3 487 0
 3165              	 .cfi_startproc
 3166 0000 80B5     	 push {r7,lr}
 3167              	.LCFI30:
 3168              	 .cfi_def_cfa_offset 8
 3169              	 .cfi_offset 7,-8
 3170              	 .cfi_offset 14,-4
 3171 0002 84B0     	 sub sp,sp,#16
 3172              	.LCFI31:
 3173              	 .cfi_def_cfa_offset 24
 3174 0004 00AF     	 add r7,sp,#0
 3175              	.LCFI32:
 3176              	 .cfi_def_cfa_register 7
 3177 0006 021C     	 mov r2,r0
 3178 0008 FB1D     	 add r3,r7,#7
 3179 000a 1A70     	 strb r2,[r3]
 488:../XMC1100-LibHaas.c **** 	uint16_t temp;
 489:../XMC1100-LibHaas.c ****   switch (port)
 3180              	 .loc 3 489 0
 3181 000c FB1D     	 add r3,r7,#7
 3182 000e 1B78     	 ldrb r3,[r3]
 3183 0010 012B     	 cmp r3,#1
 3184 0012 0CD0     	 beq .L141
 3185 0014 022B     	 cmp r3,#2
 3186 0016 13D0     	 beq .L142
 3187 0018 002B     	 cmp r3,#0
 3188 001a 1AD1     	 bne .L145
 490:../XMC1100-LibHaas.c ****   {
 491:../XMC1100-LibHaas.c ****     case 0: temp = PORT0->IN; return temp; break;
 3189              	 .loc 3 491 0
 3190 001c 0F4B     	 ldr r3,.L146
 3191 001e 5A6A     	 ldr r2,[r3,#36]
 3192 0020 0E23     	 mov r3,#14
 3193 0022 FB18     	 add r3,r7,r3
 3194 0024 1A80     	 strh r2,[r3]
 3195 0026 0E23     	 mov r3,#14
 3196 0028 FB18     	 add r3,r7,r3
 3197 002a 1B88     	 ldrh r3,[r3]
 3198 002c 12E0     	 b .L144
 3199              	.L141:
 492:../XMC1100-LibHaas.c ****     case 1: temp = PORT1->IN; return temp; break;
 3200              	 .loc 3 492 0
 3201 002e 0C4B     	 ldr r3,.L146+4
 3202 0030 5A6A     	 ldr r2,[r3,#36]
 3203 0032 0E23     	 mov r3,#14
 3204 0034 FB18     	 add r3,r7,r3
 3205 0036 1A80     	 strh r2,[r3]
 3206 0038 0E23     	 mov r3,#14
 3207 003a FB18     	 add r3,r7,r3
 3208 003c 1B88     	 ldrh r3,[r3]
 3209 003e 09E0     	 b .L144
 3210              	.L142:
 493:../XMC1100-LibHaas.c ****     case 2: temp = PORT2->IN; return temp; break;
 3211              	 .loc 3 493 0
 3212 0040 084B     	 ldr r3,.L146+8
 3213 0042 5A6A     	 ldr r2,[r3,#36]
 3214 0044 0E23     	 mov r3,#14
 3215 0046 FB18     	 add r3,r7,r3
 3216 0048 1A80     	 strh r2,[r3]
 3217 004a 0E23     	 mov r3,#14
 3218 004c FB18     	 add r3,r7,r3
 3219 004e 1B88     	 ldrh r3,[r3]
 3220 0050 00E0     	 b .L144
 3221              	.L145:
 494:../XMC1100-LibHaas.c ****     default: return 0; break;
 3222              	 .loc 3 494 0
 3223 0052 0023     	 mov r3,#0
 3224              	.L144:
 495:../XMC1100-LibHaas.c ****   }
 496:../XMC1100-LibHaas.c ****   //return 0;
 497:../XMC1100-LibHaas.c **** }
 3225              	 .loc 3 497 0
 3226 0054 181C     	 mov r0,r3
 3227 0056 BD46     	 mov sp,r7
 3228 0058 04B0     	 add sp,sp,#16
 3229              	 
 3230 005a 80BD     	 pop {r7,pc}
 3231              	.L147:
 3232              	 .align 2
 3233              	.L146:
 3234 005c 00000440 	 .word 1074003968
 3235 0060 00010440 	 .word 1074004224
 3236 0064 00020440 	 .word 1074004480
 3237              	 .cfi_endproc
 3238              	.LFE42:
 3240              	 .section .text.port0_init_maske,"ax",%progbits
 3241              	 .align 2
 3242              	 .global port0_init_maske
 3243              	 .code 16
 3244              	 .thumb_func
 3246              	port0_init_maske:
 3247              	.LFB43:
 498:../XMC1100-LibHaas.c **** 
 499:../XMC1100-LibHaas.c **** //----------------------------------------------------------------
 500:../XMC1100-LibHaas.c **** //Gesamtes Port P0 initialisieren mit IO-Bitmaske
 501:../XMC1100-LibHaas.c **** // Bit der Maske 0 -> Input, 1 -> Output
 502:../XMC1100-LibHaas.c **** // z.B.0x00ff rechte 8 Bit Ausgabe, linke 8 Bit Eingabe (nur 6 sichtbar)
 503:../XMC1100-LibHaas.c **** // 0b0000000011111111 = 0x00ff
 504:../XMC1100-LibHaas.c **** //----------------------------------------------------------------
 505:../XMC1100-LibHaas.c **** void port0_init_maske(uint16_t io_maske)
 506:../XMC1100-LibHaas.c **** {
 3248              	 .loc 3 506 0
 3249              	 .cfi_startproc
 3250 0000 80B5     	 push {r7,lr}
 3251              	.LCFI33:
 3252              	 .cfi_def_cfa_offset 8
 3253              	 .cfi_offset 7,-8
 3254              	 .cfi_offset 14,-4
 3255 0002 84B0     	 sub sp,sp,#16
 3256              	.LCFI34:
 3257              	 .cfi_def_cfa_offset 24
 3258 0004 00AF     	 add r7,sp,#0
 3259              	.LCFI35:
 3260              	 .cfi_def_cfa_register 7
 3261 0006 021C     	 mov r2,r0
 3262 0008 BB1D     	 add r3,r7,#6
 3263 000a 1A80     	 strh r2,[r3]
 507:../XMC1100-LibHaas.c **** 	uint8_t z;
 508:../XMC1100-LibHaas.c **** 	for (z = 0; z<16;z++)				// 16 Bits (0..15)
 3264              	 .loc 3 508 0
 3265 000c 0F23     	 mov r3,#15
 3266 000e FB18     	 add r3,r7,r3
 3267 0010 0022     	 mov r2,#0
 3268 0012 1A70     	 strb r2,[r3]
 3269 0014 18E0     	 b .L149
 3270              	.L150:
 509:../XMC1100-LibHaas.c **** 	{
 510:../XMC1100-LibHaas.c **** 		bit_init(P0,z,io_maske&0b1);	// einzeln initialisieren
 3271              	 .loc 3 510 0 discriminator 3
 3272 0016 BB1D     	 add r3,r7,#6
 3273 0018 1B88     	 ldrh r3,[r3]
 3274 001a DBB2     	 uxtb r3,r3
 3275 001c 0122     	 mov r2,#1
 3276 001e 1340     	 and r3,r2
 3277 0020 DAB2     	 uxtb r2,r3
 3278 0022 0F23     	 mov r3,#15
 3279 0024 FB18     	 add r3,r7,r3
 3280 0026 1B78     	 ldrb r3,[r3]
 3281 0028 0020     	 mov r0,#0
 3282 002a 191C     	 mov r1,r3
 3283 002c FFF7FEFF 	 bl bit_init
 511:../XMC1100-LibHaas.c **** 		io_maske >>= 1;					// nächste Bit der Maske
 3284              	 .loc 3 511 0 discriminator 3
 3285 0030 BB1D     	 add r3,r7,#6
 3286 0032 BA1D     	 add r2,r7,#6
 3287 0034 1288     	 ldrh r2,[r2]
 3288 0036 5208     	 lsr r2,r2,#1
 3289 0038 1A80     	 strh r2,[r3]
 508:../XMC1100-LibHaas.c **** 	{
 3290              	 .loc 3 508 0 discriminator 3
 3291 003a 0F23     	 mov r3,#15
 3292 003c FB18     	 add r3,r7,r3
 3293 003e 1A78     	 ldrb r2,[r3]
 3294 0040 0F23     	 mov r3,#15
 3295 0042 FB18     	 add r3,r7,r3
 3296 0044 0132     	 add r2,r2,#1
 3297 0046 1A70     	 strb r2,[r3]
 3298              	.L149:
 508:../XMC1100-LibHaas.c **** 	{
 3299              	 .loc 3 508 0 is_stmt 0 discriminator 1
 3300 0048 0F23     	 mov r3,#15
 3301 004a FB18     	 add r3,r7,r3
 3302 004c 1B78     	 ldrb r3,[r3]
 3303 004e 0F2B     	 cmp r3,#15
 3304 0050 E1D9     	 bls .L150
 512:../XMC1100-LibHaas.c **** 	}
 513:../XMC1100-LibHaas.c **** }
 3305              	 .loc 3 513 0 is_stmt 1
 3306 0052 BD46     	 mov sp,r7
 3307 0054 04B0     	 add sp,sp,#16
 3308              	 
 3309 0056 80BD     	 pop {r7,pc}
 3310              	 .cfi_endproc
 3311              	.LFE43:
 3313              	 .section .text.port_write,"ax",%progbits
 3314              	 .align 2
 3315              	 .global port_write
 3316              	 .code 16
 3317              	 .thumb_func
 3319              	port_write:
 3320              	.LFB44:
 514:../XMC1100-LibHaas.c **** 
 515:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
 516:../XMC1100-LibHaas.c **** // Gesamtes Port ausgeben
 517:../XMC1100-LibHaas.c **** // port: P0,P1
 518:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
 519:../XMC1100-LibHaas.c **** void port_write(uint8_t port, uint16_t value)
 520:../XMC1100-LibHaas.c **** {
 3321              	 .loc 3 520 0
 3322              	 .cfi_startproc
 3323 0000 80B5     	 push {r7,lr}
 3324              	.LCFI36:
 3325              	 .cfi_def_cfa_offset 8
 3326              	 .cfi_offset 7,-8
 3327              	 .cfi_offset 14,-4
 3328 0002 82B0     	 sub sp,sp,#8
 3329              	.LCFI37:
 3330              	 .cfi_def_cfa_offset 16
 3331 0004 00AF     	 add r7,sp,#0
 3332              	.LCFI38:
 3333              	 .cfi_def_cfa_register 7
 3334 0006 021C     	 mov r2,r0
 3335 0008 FB1D     	 add r3,r7,#7
 3336 000a 1A70     	 strb r2,[r3]
 3337 000c 3B1D     	 add r3,r7,#4
 3338 000e 0A1C     	 add r2,r1,#0
 3339 0010 1A80     	 strh r2,[r3]
 521:../XMC1100-LibHaas.c ****   switch (port)
 3340              	 .loc 3 521 0
 3341 0012 FB1D     	 add r3,r7,#7
 3342 0014 1B78     	 ldrb r3,[r3]
 3343 0016 012B     	 cmp r3,#1
 3344 0018 08D0     	 beq .L153
 3345 001a 022B     	 cmp r3,#2
 3346 001c 0BD0     	 beq .L154
 3347 001e 002B     	 cmp r3,#0
 3348 0020 0ED1     	 bne .L151
 522:../XMC1100-LibHaas.c ****   {
 523:../XMC1100-LibHaas.c ****     case 0: PORT0->OUT  = value; break;
 3349              	 .loc 3 523 0
 3350 0022 094B     	 ldr r3,.L156
 3351 0024 3A1D     	 add r2,r7,#4
 3352 0026 1288     	 ldrh r2,[r2]
 3353 0028 1A60     	 str r2,[r3]
 3354 002a 09E0     	 b .L151
 3355              	.L153:
 524:../XMC1100-LibHaas.c ****     case 1: PORT1->OUT = value; break;
 3356              	 .loc 3 524 0
 3357 002c 074B     	 ldr r3,.L156+4
 3358 002e 3A1D     	 add r2,r7,#4
 3359 0030 1288     	 ldrh r2,[r2]
 3360 0032 1A60     	 str r2,[r3]
 3361 0034 04E0     	 b .L151
 3362              	.L154:
 525:../XMC1100-LibHaas.c ****     case 2: PORT1->OUT = value; break;
 3363              	 .loc 3 525 0
 3364 0036 054B     	 ldr r3,.L156+4
 3365 0038 3A1D     	 add r2,r7,#4
 3366 003a 1288     	 ldrh r2,[r2]
 3367 003c 1A60     	 str r2,[r3]
 3368 003e C046     	 mov r8,r8
 3369              	.L151:
 526:../XMC1100-LibHaas.c ****   }
 527:../XMC1100-LibHaas.c **** }
 3370              	 .loc 3 527 0
 3371 0040 BD46     	 mov sp,r7
 3372 0042 02B0     	 add sp,sp,#8
 3373              	 
 3374 0044 80BD     	 pop {r7,pc}
 3375              	.L157:
 3376 0046 C046     	 .align 2
 3377              	.L156:
 3378 0048 00000440 	 .word 1074003968
 3379 004c 00010440 	 .word 1074004224
 3380              	 .cfi_endproc
 3381              	.LFE44:
 3383              	 .section .text.clock_init,"ax",%progbits
 3384              	 .align 2
 3385              	 .global clock_init
 3386              	 .code 16
 3387              	 .thumb_func
 3389              	clock_init:
 3390              	.LFB45:
 528:../XMC1100-LibHaas.c **** // ***************************************************************
 529:../XMC1100-LibHaas.c **** // ab hier PWM-Funktionen
 530:../XMC1100-LibHaas.c **** // ***************************************************************
 531:../XMC1100-LibHaas.c **** 
 532:../XMC1100-LibHaas.c **** #define periode_pwm_8 2550 // 8-Bit-Periode fuer ca. 1.5 kHz
 533:../XMC1100-LibHaas.c **** #define periode_pwm 50000 // 16-Bit-Periode 50000 für leichtere Berechnung, ca. 640 Hz
 534:../XMC1100-LibHaas.c **** //#define periode_pwm 0xffff // max 16-Bit-Periode
 535:../XMC1100-LibHaas.c **** 
 536:../XMC1100-LibHaas.c **** 
 537:../XMC1100-LibHaas.c **** //------- Takt für 8-Bit- und 16-Bit-Funktionen PWM --------------------------------
 538:../XMC1100-LibHaas.c **** void clock_init(void)
 539:../XMC1100-LibHaas.c **** {
 3391              	 .loc 3 539 0
 3392              	 .cfi_startproc
 3393 0000 80B5     	 push {r7,lr}
 3394              	.LCFI39:
 3395              	 .cfi_def_cfa_offset 8
 3396              	 .cfi_offset 7,-8
 3397              	 .cfi_offset 14,-4
 3398 0002 00AF     	 add r7,sp,#0
 3399              	.LCFI40:
 3400              	 .cfi_def_cfa_register 7
 540:../XMC1100-LibHaas.c **** 	SCU_GENERAL->PASSWD = 0x000000C0UL;
 3401              	 .loc 3 540 0
 3402 0004 154B     	 ldr r3,.L161
 3403 0006 C022     	 mov r2,#192
 3404 0008 5A62     	 str r2,[r3,#36]
 541:../XMC1100-LibHaas.c **** 	SCU_CLK->CLKCR = 0x3FF10100;			// Config SCU Clock = 32MHz , PCLK = 64 MHz
 3405              	 .loc 3 541 0
 3406 000a 154B     	 ldr r3,.L161+4
 3407 000c 154A     	 ldr r2,.L161+8
 3408 000e 1A60     	 str r2,[r3]
 542:../XMC1100-LibHaas.c **** 	while((SCU_CLK->CLKCR)&0x40000000UL);	// wait for VDDC to stabilize
 3409              	 .loc 3 542 0
 3410 0010 C046     	 mov r8,r8
 3411              	.L159:
 3412              	 .loc 3 542 0 is_stmt 0 discriminator 1
 3413 0012 134B     	 ldr r3,.L161+4
 3414 0014 1A68     	 ldr r2,[r3]
 3415 0016 8023     	 mov r3,#128
 3416 0018 DB05     	 lsl r3,r3,#23
 3417 001a 1340     	 and r3,r2
 3418 001c F9D1     	 bne .L159
 543:../XMC1100-LibHaas.c **** 	SCU_GENERAL->PASSWD = 0x000000C3UL;
 3419              	 .loc 3 543 0 is_stmt 1
 3420 001e 0F4B     	 ldr r3,.L161
 3421 0020 C322     	 mov r2,#195
 3422 0022 5A62     	 str r2,[r3,#36]
 544:../XMC1100-LibHaas.c **** 	SCU_GENERAL->PASSWD = 0x000000C0UL;
 3423              	 .loc 3 544 0
 3424 0024 0D4B     	 ldr r3,.L161
 3425 0026 C022     	 mov r2,#192
 3426 0028 5A62     	 str r2,[r3,#36]
 545:../XMC1100-LibHaas.c **** 	SCU_CLK->CGATCLR0 |= 0x04;				// Disable CCU4 Gating
 3427              	 .loc 3 545 0
 3428 002a 0D4B     	 ldr r3,.L161+4
 3429 002c 0C4A     	 ldr r2,.L161+4
 3430 002e 1269     	 ldr r2,[r2,#16]
 3431 0030 0421     	 mov r1,#4
 3432 0032 0A43     	 orr r2,r1
 3433 0034 1A61     	 str r2,[r3,#16]
 546:../XMC1100-LibHaas.c **** 	while((SCU_CLK->CLKCR)&0x40000000UL);	// wait for VDDC to stabilize
 3434              	 .loc 3 546 0
 3435 0036 C046     	 mov r8,r8
 3436              	.L160:
 3437              	 .loc 3 546 0 is_stmt 0 discriminator 1
 3438 0038 094B     	 ldr r3,.L161+4
 3439 003a 1A68     	 ldr r2,[r3]
 3440 003c 8023     	 mov r3,#128
 3441 003e DB05     	 lsl r3,r3,#23
 3442 0040 1340     	 and r3,r2
 3443 0042 F9D1     	 bne .L160
 547:../XMC1100-LibHaas.c **** 	SCU_GENERAL->PASSWD = 0x000000C3UL;
 3444              	 .loc 3 547 0 is_stmt 1
 3445 0044 054B     	 ldr r3,.L161
 3446 0046 C322     	 mov r2,#195
 3447 0048 5A62     	 str r2,[r3,#36]
 548:../XMC1100-LibHaas.c **** 	SCU_CLK->CGATSET0 |= 0xfff;				// Modul  Clock enable , all Modul's
 3448              	 .loc 3 548 0
 3449 004a 054B     	 ldr r3,.L161+4
 3450 004c 044A     	 ldr r2,.L161+4
 3451 004e D268     	 ldr r2,[r2,#12]
 3452 0050 0549     	 ldr r1,.L161+12
 3453 0052 0A43     	 orr r2,r1
 3454 0054 DA60     	 str r2,[r3,#12]
 549:../XMC1100-LibHaas.c **** }
 3455              	 .loc 3 549 0
 3456 0056 BD46     	 mov sp,r7
 3457              	 
 3458 0058 80BD     	 pop {r7,pc}
 3459              	.L162:
 3460 005a C046     	 .align 2
 3461              	.L161:
 3462 005c 00000140 	 .word 1073807360
 3463 0060 00030140 	 .word 1073808128
 3464 0064 0001F13F 	 .word 1072759040
 3465 0068 FF0F0000 	 .word 4095
 3466              	 .cfi_endproc
 3467              	.LFE45:
 3469              	 .section .text.pwm1_init_8,"ax",%progbits
 3470              	 .align 2
 3471              	 .global pwm1_init_8
 3472              	 .code 16
 3473              	 .thumb_func
 3475              	pwm1_init_8:
 3476              	.LFB46:
 550:../XMC1100-LibHaas.c **** //-----------------------------------------------------------------------
 551:../XMC1100-LibHaas.c **** // 8-Bit-PWM1-Ausgang P0.6 initialisieren,
 552:../XMC1100-LibHaas.c **** // Hinweis: anschließend starten mit pwm1_start oder pwm1_start_interrupt
 553:../XMC1100-LibHaas.c **** //-----------------------------------------------------------------------
 554:../XMC1100-LibHaas.c **** void pwm1_init_8(void)
 555:../XMC1100-LibHaas.c **** {
 3477              	 .loc 3 555 0
 3478              	 .cfi_startproc
 3479 0000 80B5     	 push {r7,lr}
 3480              	.LCFI41:
 3481              	 .cfi_def_cfa_offset 8
 3482              	 .cfi_offset 7,-8
 3483              	 .cfi_offset 14,-4
 3484 0002 00AF     	 add r7,sp,#0
 3485              	.LCFI42:
 3486              	 .cfi_def_cfa_register 7
 556:../XMC1100-LibHaas.c **** 	clock_init();
 3487              	 .loc 3 556 0
 3488 0004 FFF7FEFF 	 bl clock_init
 557:../XMC1100-LibHaas.c **** 	SCU_GENERAL->CCUCON = 1;				// Enable CCU40
 3489              	 .loc 3 557 0
 3490 0008 0F4B     	 ldr r3,.L164
 3491 000a 0122     	 mov r2,#1
 3492 000c 1A63     	 str r2,[r3,#48]
 558:../XMC1100-LibHaas.c **** 	// CCU40 Init:
 559:../XMC1100-LibHaas.c **** 	 CCU40->GIDLC = 0x10F; 					// Vorteiler enable,CCU4x enable
 3493              	 .loc 3 559 0
 3494 000e 0F4B     	 ldr r3,.L164+4
 3495 0010 1022     	 mov r2,#16
 3496 0012 FF32     	 add r2,r2,#255
 3497 0014 DA60     	 str r2,[r3,#12]
 560:../XMC1100-LibHaas.c **** 	 CCU40_CC40->TC= 4;  					// Shadow transfer enable on clear
 3498              	 .loc 3 560 0
 3499 0016 0E4B     	 ldr r3,.L164+8
 3500 0018 0422     	 mov r2,#4
 3501 001a 5A61     	 str r2,[r3,#20]
 561:../XMC1100-LibHaas.c **** 	 CCU40_CC40->PSC = 0x4;					// Vorteiler , hier 64Mhz/16
 3502              	 .loc 3 561 0
 3503 001c 0C4B     	 ldr r3,.L164+8
 3504 001e 0422     	 mov r2,#4
 3505 0020 5A62     	 str r2,[r3,#36]
 562:../XMC1100-LibHaas.c **** 	 CCU40_CC40->PRS = periode_pwm_8; 		// Period Register set , hier ca. 1.5 kHz
 3506              	 .loc 3 562 0
 3507 0022 0B4B     	 ldr r3,.L164+8
 3508 0024 0B4A     	 ldr r2,.L164+12
 3509 0026 5A63     	 str r2,[r3,#52]
 563:../XMC1100-LibHaas.c **** 
 564:../XMC1100-LibHaas.c **** 		// CCU40 Compare:  ( Ausganspin P0.6 )
 565:../XMC1100-LibHaas.c **** 	 CCU40_CC40->CRS = 1270;				// Compare Wert,hier 1:1 Imp
 3510              	 .loc 3 565 0
 3511 0028 094B     	 ldr r3,.L164+8
 3512 002a 0B4A     	 ldr r2,.L164+16
 3513 002c DA63     	 str r2,[r3,#60]
 566:../XMC1100-LibHaas.c **** 	 CCU40->GCSS = 1; 						// Shadow transfer request slice 0
 3514              	 .loc 3 566 0
 3515 002e 074B     	 ldr r3,.L164+4
 3516 0030 0122     	 mov r2,#1
 3517 0032 1A61     	 str r2,[r3,#16]
 567:../XMC1100-LibHaas.c **** 	 //PORT0->IOCR0 = 0xA0;					// Alt4=>OUT bei P0.0
 568:../XMC1100-LibHaas.c **** 	 PORT0->IOCR4 |= 0xA0<<16;				// Alt4=>OUT bei P0.6
 3518              	 .loc 3 568 0
 3519 0034 094B     	 ldr r3,.L164+20
 3520 0036 094A     	 ldr r2,.L164+20
 3521 0038 5269     	 ldr r2,[r2,#20]
 3522 003a A021     	 mov r1,#160
 3523 003c 0904     	 lsl r1,r1,#16
 3524 003e 0A43     	 orr r2,r1
 3525 0040 5A61     	 str r2,[r3,#20]
 569:../XMC1100-LibHaas.c **** 	 //CCU40_CC40->TCSET = 0x1; //starts counting
 570:../XMC1100-LibHaas.c **** }
 3526              	 .loc 3 570 0
 3527 0042 BD46     	 mov sp,r7
 3528              	 
 3529 0044 80BD     	 pop {r7,pc}
 3530              	.L165:
 3531 0046 C046     	 .align 2
 3532              	.L164:
 3533 0048 00000140 	 .word 1073807360
 3534 004c 00000448 	 .word 1208221696
 3535 0050 00010448 	 .word 1208221952
 3536 0054 F6090000 	 .word 2550
 3537 0058 F6040000 	 .word 1270
 3538 005c 00000440 	 .word 1074003968
 3539              	 .cfi_endproc
 3540              	.LFE46:
 3542              	 .section .text.pwm1_init,"ax",%progbits
 3543              	 .align 2
 3544              	 .global pwm1_init
 3545              	 .code 16
 3546              	 .thumb_func
 3548              	pwm1_init:
 3549              	.LFB47:
 571:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
 572:../XMC1100-LibHaas.c **** // PWM1-Ausgang P0.6 initialisieren (16-Bit),
 573:../XMC1100-LibHaas.c **** // Hinweis: anschließend starten mit pwm1_start oder pwm1_start_interrupt
 574:../XMC1100-LibHaas.c **** // eingestellte Periodendauer bei #define periode_pwm 50000
 575:../XMC1100-LibHaas.c **** //----------------------------------------------------------------
 576:../XMC1100-LibHaas.c **** void pwm1_init(void)
 577:../XMC1100-LibHaas.c **** {
 3550              	 .loc 3 577 0
 3551              	 .cfi_startproc
 3552 0000 80B5     	 push {r7,lr}
 3553              	.LCFI43:
 3554              	 .cfi_def_cfa_offset 8
 3555              	 .cfi_offset 7,-8
 3556              	 .cfi_offset 14,-4
 3557 0002 00AF     	 add r7,sp,#0
 3558              	.LCFI44:
 3559              	 .cfi_def_cfa_register 7
 578:../XMC1100-LibHaas.c **** 	clock_init();
 3560              	 .loc 3 578 0
 3561 0004 FFF7FEFF 	 bl clock_init
 579:../XMC1100-LibHaas.c **** 	SCU_GENERAL->CCUCON = 1;				// Enable CCU40
 3562              	 .loc 3 579 0
 3563 0008 0F4B     	 ldr r3,.L167
 3564 000a 0122     	 mov r2,#1
 3565 000c 1A63     	 str r2,[r3,#48]
 580:../XMC1100-LibHaas.c **** 	// CCU40 Init:
 581:../XMC1100-LibHaas.c **** 	CCU40->GIDLC = 0x10F; 					// Vorteiler enable,CCU4x enable
 3566              	 .loc 3 581 0
 3567 000e 0F4B     	 ldr r3,.L167+4
 3568 0010 1022     	 mov r2,#16
 3569 0012 FF32     	 add r2,r2,#255
 3570 0014 DA60     	 str r2,[r3,#12]
 582:../XMC1100-LibHaas.c **** 	CCU40_CC40->TC = 4;  					// Shadow transfer enable on clear
 3571              	 .loc 3 582 0
 3572 0016 0E4B     	 ldr r3,.L167+8
 3573 0018 0422     	 mov r2,#4
 3574 001a 5A61     	 str r2,[r3,#20]
 583:../XMC1100-LibHaas.c **** 	CCU40_CC40->PSC = 0x1;					// Vorteiler , hier 64Mhz/2
 3575              	 .loc 3 583 0
 3576 001c 0C4B     	 ldr r3,.L167+8
 3577 001e 0122     	 mov r2,#1
 3578 0020 5A62     	 str r2,[r3,#36]
 584:../XMC1100-LibHaas.c **** 	CCU40_CC40->PRS = periode_pwm; 			// Period Register set, hier ca. 640 Hz
 3579              	 .loc 3 584 0
 3580 0022 0B4B     	 ldr r3,.L167+8
 3581 0024 0B4A     	 ldr r2,.L167+12
 3582 0026 5A63     	 str r2,[r3,#52]
 585:../XMC1100-LibHaas.c **** 
 586:../XMC1100-LibHaas.c **** 	// CCU40 Compare:  (Ausganspin P0.6)
 587:../XMC1100-LibHaas.c **** 	CCU40_CC40->CRS = 25000;				// Compare Wert,hier 1:1 Imp
 3583              	 .loc 3 587 0
 3584 0028 094B     	 ldr r3,.L167+8
 3585 002a 0B4A     	 ldr r2,.L167+16
 3586 002c DA63     	 str r2,[r3,#60]
 588:../XMC1100-LibHaas.c **** 	CCU40->GCSS = 1; 						// Shadow transfer request slice 0
 3587              	 .loc 3 588 0
 3588 002e 074B     	 ldr r3,.L167+4
 3589 0030 0122     	 mov r2,#1
 3590 0032 1A61     	 str r2,[r3,#16]
 589:../XMC1100-LibHaas.c **** 	//PORT0->IOCR0 = 0xA0;					// Alt4=>OUT bei P0.0
 590:../XMC1100-LibHaas.c **** 	PORT0->IOCR4 |= 0xA0<<16;				// Alt4=>OUT bei P0.6
 3591              	 .loc 3 590 0
 3592 0034 094B     	 ldr r3,.L167+20
 3593 0036 094A     	 ldr r2,.L167+20
 3594 0038 5269     	 ldr r2,[r2,#20]
 3595 003a A021     	 mov r1,#160
 3596 003c 0904     	 lsl r1,r1,#16
 3597 003e 0A43     	 orr r2,r1
 3598 0040 5A61     	 str r2,[r3,#20]
 591:../XMC1100-LibHaas.c **** 	//CCU40_CC40->TCSET = 0x1; //starts counting
 592:../XMC1100-LibHaas.c **** }
 3599              	 .loc 3 592 0
 3600 0042 BD46     	 mov sp,r7
 3601              	 
 3602 0044 80BD     	 pop {r7,pc}
 3603              	.L168:
 3604 0046 C046     	 .align 2
 3605              	.L167:
 3606 0048 00000140 	 .word 1073807360
 3607 004c 00000448 	 .word 1208221696
 3608 0050 00010448 	 .word 1208221952
 3609 0054 50C30000 	 .word 50000
 3610 0058 A8610000 	 .word 25000
 3611 005c 00000440 	 .word 1074003968
 3612              	 .cfi_endproc
 3613              	.LFE47:
 3615              	 .section .text.pwm2_init_8,"ax",%progbits
 3616              	 .align 2
 3617              	 .global pwm2_init_8
 3618              	 .code 16
 3619              	 .thumb_func
 3621              	pwm2_init_8:
 3622              	.LFB48:
 593:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
 594:../XMC1100-LibHaas.c **** // 8-Bit-PWM2-Ausgang P0.7 initialisieren
 595:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
 596:../XMC1100-LibHaas.c **** void pwm2_init_8(void)
 597:../XMC1100-LibHaas.c **** {
 3623              	 .loc 3 597 0
 3624              	 .cfi_startproc
 3625 0000 80B5     	 push {r7,lr}
 3626              	.LCFI45:
 3627              	 .cfi_def_cfa_offset 8
 3628              	 .cfi_offset 7,-8
 3629              	 .cfi_offset 14,-4
 3630 0002 00AF     	 add r7,sp,#0
 3631              	.LCFI46:
 3632              	 .cfi_def_cfa_register 7
 598:../XMC1100-LibHaas.c **** 	clock_init();
 3633              	 .loc 3 598 0
 3634 0004 FFF7FEFF 	 bl clock_init
 599:../XMC1100-LibHaas.c **** 	SCU_GENERAL->CCUCON = 1;				// Enable CCU40
 3635              	 .loc 3 599 0
 3636 0008 0F4B     	 ldr r3,.L170
 3637 000a 0122     	 mov r2,#1
 3638 000c 1A63     	 str r2,[r3,#48]
 600:../XMC1100-LibHaas.c **** 		// CCU41 Init:
 601:../XMC1100-LibHaas.c **** 	CCU40->GIDLC = 0x10F; 					// Vorteiler enable,CCU4x enable
 3639              	 .loc 3 601 0
 3640 000e 0F4B     	 ldr r3,.L170+4
 3641 0010 1022     	 mov r2,#16
 3642 0012 FF32     	 add r2,r2,#255
 3643 0014 DA60     	 str r2,[r3,#12]
 602:../XMC1100-LibHaas.c **** 	CCU40_CC41->TC= 4;  					// Shadow transfer enable on clear
 3644              	 .loc 3 602 0
 3645 0016 0E4B     	 ldr r3,.L170+8
 3646 0018 0422     	 mov r2,#4
 3647 001a 5A61     	 str r2,[r3,#20]
 603:../XMC1100-LibHaas.c **** 	CCU40_CC41->PSC = 0x4;					// Vorteiler , hier 64Mhz/16
 3648              	 .loc 3 603 0
 3649 001c 0C4B     	 ldr r3,.L170+8
 3650 001e 0422     	 mov r2,#4
 3651 0020 5A62     	 str r2,[r3,#36]
 604:../XMC1100-LibHaas.c **** 	CCU40_CC41->PRS = periode_pwm_8; 			// Period Register set , hier ca. 1.5 kHz
 3652              	 .loc 3 604 0
 3653 0022 0B4B     	 ldr r3,.L170+8
 3654 0024 0B4A     	 ldr r2,.L170+12
 3655 0026 5A63     	 str r2,[r3,#52]
 605:../XMC1100-LibHaas.c **** 
 606:../XMC1100-LibHaas.c **** 		// CCU40 Compare:  ( Ausganspin P0.0 )
 607:../XMC1100-LibHaas.c **** 	CCU40_CC41->CRS = 1270;				// Compare Wert,hier 1:1 Imp
 3656              	 .loc 3 607 0
 3657 0028 094B     	 ldr r3,.L170+8
 3658 002a 0B4A     	 ldr r2,.L170+16
 3659 002c DA63     	 str r2,[r3,#60]
 608:../XMC1100-LibHaas.c **** 	CCU40->GCSS = 1<<4; 				// Shadow transfer request slice 1
 3660              	 .loc 3 608 0
 3661 002e 074B     	 ldr r3,.L170+4
 3662 0030 1022     	 mov r2,#16
 3663 0032 1A61     	 str r2,[r3,#16]
 609:../XMC1100-LibHaas.c **** 	//PORT0->IOCR0 |= 0xA0 <<8;			// Alt4=>OUT bei P0.1
 610:../XMC1100-LibHaas.c **** 	PORT0->IOCR4 |= 0xA0<<24;			// Alt4=>OUT bei P0.7
 3664              	 .loc 3 610 0
 3665 0034 094B     	 ldr r3,.L170+20
 3666 0036 094A     	 ldr r2,.L170+20
 3667 0038 5269     	 ldr r2,[r2,#20]
 3668 003a A021     	 mov r1,#160
 3669 003c 0906     	 lsl r1,r1,#24
 3670 003e 0A43     	 orr r2,r1
 3671 0040 5A61     	 str r2,[r3,#20]
 611:../XMC1100-LibHaas.c **** }
 3672              	 .loc 3 611 0
 3673 0042 BD46     	 mov sp,r7
 3674              	 
 3675 0044 80BD     	 pop {r7,pc}
 3676              	.L171:
 3677 0046 C046     	 .align 2
 3678              	.L170:
 3679 0048 00000140 	 .word 1073807360
 3680 004c 00000448 	 .word 1208221696
 3681 0050 00020448 	 .word 1208222208
 3682 0054 F6090000 	 .word 2550
 3683 0058 F6040000 	 .word 1270
 3684 005c 00000440 	 .word 1074003968
 3685              	 .cfi_endproc
 3686              	.LFE48:
 3688              	 .section .text.pwm2_init,"ax",%progbits
 3689              	 .align 2
 3690              	 .global pwm2_init
 3691              	 .code 16
 3692              	 .thumb_func
 3694              	pwm2_init:
 3695              	.LFB49:
 612:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
 613:../XMC1100-LibHaas.c **** // PWM2-Ausgang P0.7 initialisieren (16-Bit)
 614:../XMC1100-LibHaas.c **** // Hinweis: anschließend starten mit pwm2_start oder pwm2_start_interrupt
 615:../XMC1100-LibHaas.c **** // eingestellte Periodendauer bei #define periode_pwm 50000
 616:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
 617:../XMC1100-LibHaas.c **** void pwm2_init(void)
 618:../XMC1100-LibHaas.c **** {
 3696              	 .loc 3 618 0
 3697              	 .cfi_startproc
 3698 0000 80B5     	 push {r7,lr}
 3699              	.LCFI47:
 3700              	 .cfi_def_cfa_offset 8
 3701              	 .cfi_offset 7,-8
 3702              	 .cfi_offset 14,-4
 3703 0002 00AF     	 add r7,sp,#0
 3704              	.LCFI48:
 3705              	 .cfi_def_cfa_register 7
 619:../XMC1100-LibHaas.c **** 	clock_init();
 3706              	 .loc 3 619 0
 3707 0004 FFF7FEFF 	 bl clock_init
 620:../XMC1100-LibHaas.c **** 	SCU_GENERAL->CCUCON = 1;				// Enable CCU40
 3708              	 .loc 3 620 0
 3709 0008 0F4B     	 ldr r3,.L173
 3710 000a 0122     	 mov r2,#1
 3711 000c 1A63     	 str r2,[r3,#48]
 621:../XMC1100-LibHaas.c **** 	// CCU41 Init:
 622:../XMC1100-LibHaas.c **** 	CCU40->GIDLC = 0x10F; 					// Vorteiler enable,CCU4x enable
 3712              	 .loc 3 622 0
 3713 000e 0F4B     	 ldr r3,.L173+4
 3714 0010 1022     	 mov r2,#16
 3715 0012 FF32     	 add r2,r2,#255
 3716 0014 DA60     	 str r2,[r3,#12]
 623:../XMC1100-LibHaas.c **** 	CCU40_CC41->TC = 4;  					// Shadow transfer enable on clear
 3717              	 .loc 3 623 0
 3718 0016 0E4B     	 ldr r3,.L173+8
 3719 0018 0422     	 mov r2,#4
 3720 001a 5A61     	 str r2,[r3,#20]
 624:../XMC1100-LibHaas.c **** 	CCU40_CC41->PSC = 0x1;					// Vorteiler , hier 64Mhz/2
 3721              	 .loc 3 624 0
 3722 001c 0C4B     	 ldr r3,.L173+8
 3723 001e 0122     	 mov r2,#1
 3724 0020 5A62     	 str r2,[r3,#36]
 625:../XMC1100-LibHaas.c **** 	CCU40_CC41->PRS = periode_pwm; 			// Period Register set, hier ca. 640 Hz
 3725              	 .loc 3 625 0
 3726 0022 0B4B     	 ldr r3,.L173+8
 3727 0024 0B4A     	 ldr r2,.L173+12
 3728 0026 5A63     	 str r2,[r3,#52]
 626:../XMC1100-LibHaas.c **** 
 627:../XMC1100-LibHaas.c **** 	// CCU40 Compare:  (Ausganspin P0.0)
 628:../XMC1100-LibHaas.c **** 	CCU40_CC41->CRS = 25000;			// Compare Wert,hier 1:1 Imp
 3729              	 .loc 3 628 0
 3730 0028 094B     	 ldr r3,.L173+8
 3731 002a 0B4A     	 ldr r2,.L173+16
 3732 002c DA63     	 str r2,[r3,#60]
 629:../XMC1100-LibHaas.c **** 	CCU40->GCSS = 1<<4; 				// Shadow transfer request slice 1
 3733              	 .loc 3 629 0
 3734 002e 074B     	 ldr r3,.L173+4
 3735 0030 1022     	 mov r2,#16
 3736 0032 1A61     	 str r2,[r3,#16]
 630:../XMC1100-LibHaas.c **** 	//PORT0->IOCR0 |= 0xA0 <<8;			// Alt4=>OUT bei P0.1
 631:../XMC1100-LibHaas.c **** 	PORT0->IOCR4 |= 0xA0<<24;			// Alt4=>OUT bei P0.7
 3737              	 .loc 3 631 0
 3738 0034 094B     	 ldr r3,.L173+20
 3739 0036 094A     	 ldr r2,.L173+20
 3740 0038 5269     	 ldr r2,[r2,#20]
 3741 003a A021     	 mov r1,#160
 3742 003c 0906     	 lsl r1,r1,#24
 3743 003e 0A43     	 orr r2,r1
 3744 0040 5A61     	 str r2,[r3,#20]
 632:../XMC1100-LibHaas.c **** }
 3745              	 .loc 3 632 0
 3746 0042 BD46     	 mov sp,r7
 3747              	 
 3748 0044 80BD     	 pop {r7,pc}
 3749              	.L174:
 3750 0046 C046     	 .align 2
 3751              	.L173:
 3752 0048 00000140 	 .word 1073807360
 3753 004c 00000448 	 .word 1208221696
 3754 0050 00020448 	 .word 1208222208
 3755 0054 50C30000 	 .word 50000
 3756 0058 A8610000 	 .word 25000
 3757 005c 00000440 	 .word 1074003968
 3758              	 .cfi_endproc
 3759              	.LFE49:
 3761              	 .section .text.pwm3_init_8,"ax",%progbits
 3762              	 .align 2
 3763              	 .global pwm3_init_8
 3764              	 .code 16
 3765              	 .thumb_func
 3767              	pwm3_init_8:
 3768              	.LFB50:
 633:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
 634:../XMC1100-LibHaas.c **** // 8-Bit-PWM3-Ausgang P0.8 initialisieren
 635:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
 636:../XMC1100-LibHaas.c **** void pwm3_init_8(void)
 637:../XMC1100-LibHaas.c **** {
 3769              	 .loc 3 637 0
 3770              	 .cfi_startproc
 3771 0000 80B5     	 push {r7,lr}
 3772              	.LCFI49:
 3773              	 .cfi_def_cfa_offset 8
 3774              	 .cfi_offset 7,-8
 3775              	 .cfi_offset 14,-4
 3776 0002 00AF     	 add r7,sp,#0
 3777              	.LCFI50:
 3778              	 .cfi_def_cfa_register 7
 638:../XMC1100-LibHaas.c **** 	clock_init();
 3779              	 .loc 3 638 0
 3780 0004 FFF7FEFF 	 bl clock_init
 639:../XMC1100-LibHaas.c **** 	SCU_GENERAL->CCUCON = 1;			// Enable CCU40
 3781              	 .loc 3 639 0
 3782 0008 0F4B     	 ldr r3,.L176
 3783 000a 0122     	 mov r2,#1
 3784 000c 1A63     	 str r2,[r3,#48]
 640:../XMC1100-LibHaas.c **** 		// CCU42 Init:
 641:../XMC1100-LibHaas.c **** 	CCU40->GIDLC = 0x10F; 				// Vorteiler enable,CCU4x enable
 3785              	 .loc 3 641 0
 3786 000e 0F4B     	 ldr r3,.L176+4
 3787 0010 1022     	 mov r2,#16
 3788 0012 FF32     	 add r2,r2,#255
 3789 0014 DA60     	 str r2,[r3,#12]
 642:../XMC1100-LibHaas.c **** 	CCU40_CC42->TC= 4;  				// Shadow transfer enable on clear
 3790              	 .loc 3 642 0
 3791 0016 0E4B     	 ldr r3,.L176+8
 3792 0018 0422     	 mov r2,#4
 3793 001a 5A61     	 str r2,[r3,#20]
 643:../XMC1100-LibHaas.c **** 	CCU40_CC42->PSC = 0x4;				// Vorteiler , hier 64Mhz/16
 3794              	 .loc 3 643 0
 3795 001c 0C4B     	 ldr r3,.L176+8
 3796 001e 0422     	 mov r2,#4
 3797 0020 5A62     	 str r2,[r3,#36]
 644:../XMC1100-LibHaas.c **** 	CCU40_CC42->PRS = periode_pwm_8; 		// Period Register set , hier ca. 1.5 kHz
 3798              	 .loc 3 644 0
 3799 0022 0B4B     	 ldr r3,.L176+8
 3800 0024 0B4A     	 ldr r2,.L176+12
 3801 0026 5A63     	 str r2,[r3,#52]
 645:../XMC1100-LibHaas.c **** 
 646:../XMC1100-LibHaas.c **** 		// CCU40 Compare:  ( Ausganspin P0.8 )
 647:../XMC1100-LibHaas.c **** 	CCU40_CC42->CRS = 1270;				// Compare Wert,hier 1:1 Imp
 3802              	 .loc 3 647 0
 3803 0028 094B     	 ldr r3,.L176+8
 3804 002a 0B4A     	 ldr r2,.L176+16
 3805 002c DA63     	 str r2,[r3,#60]
 648:../XMC1100-LibHaas.c **** 	CCU40->GCSS = 1<<8; 				// Shadow transfer request slice 2
 3806              	 .loc 3 648 0
 3807 002e 074B     	 ldr r3,.L176+4
 3808 0030 8022     	 mov r2,#128
 3809 0032 5200     	 lsl r2,r2,#1
 3810 0034 1A61     	 str r2,[r3,#16]
 649:../XMC1100-LibHaas.c **** 	//PORT0->IOCR0 |= 0xA0 << 16;		// Alt4=>OUT bei P0.2
 650:../XMC1100-LibHaas.c **** 	PORT0->IOCR8 |= 0xA0;				// Alt4=>OUT bei P0.8
 3811              	 .loc 3 650 0
 3812 0036 094B     	 ldr r3,.L176+20
 3813 0038 084A     	 ldr r2,.L176+20
 3814 003a 9269     	 ldr r2,[r2,#24]
 3815 003c A021     	 mov r1,#160
 3816 003e 0A43     	 orr r2,r1
 3817 0040 9A61     	 str r2,[r3,#24]
 651:../XMC1100-LibHaas.c **** }
 3818              	 .loc 3 651 0
 3819 0042 BD46     	 mov sp,r7
 3820              	 
 3821 0044 80BD     	 pop {r7,pc}
 3822              	.L177:
 3823 0046 C046     	 .align 2
 3824              	.L176:
 3825 0048 00000140 	 .word 1073807360
 3826 004c 00000448 	 .word 1208221696
 3827 0050 00030448 	 .word 1208222464
 3828 0054 F6090000 	 .word 2550
 3829 0058 F6040000 	 .word 1270
 3830 005c 00000440 	 .word 1074003968
 3831              	 .cfi_endproc
 3832              	.LFE50:
 3834              	 .section .text.pwm3_init,"ax",%progbits
 3835              	 .align 2
 3836              	 .global pwm3_init
 3837              	 .code 16
 3838              	 .thumb_func
 3840              	pwm3_init:
 3841              	.LFB51:
 652:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
 653:../XMC1100-LibHaas.c **** // PWM3-Ausgang P0.8 initialisieren (16-Bit)
 654:../XMC1100-LibHaas.c **** // Hinweis: anschließend starten mit pwm3_start oder pwm3_start_interrupt
 655:../XMC1100-LibHaas.c **** // eingestellte Periodendauer bei #define periode_pwm 50000
 656:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
 657:../XMC1100-LibHaas.c **** void pwm3_init(void)
 658:../XMC1100-LibHaas.c **** {
 3842              	 .loc 3 658 0
 3843              	 .cfi_startproc
 3844 0000 80B5     	 push {r7,lr}
 3845              	.LCFI51:
 3846              	 .cfi_def_cfa_offset 8
 3847              	 .cfi_offset 7,-8
 3848              	 .cfi_offset 14,-4
 3849 0002 00AF     	 add r7,sp,#0
 3850              	.LCFI52:
 3851              	 .cfi_def_cfa_register 7
 659:../XMC1100-LibHaas.c **** 	clock_init();
 3852              	 .loc 3 659 0
 3853 0004 FFF7FEFF 	 bl clock_init
 660:../XMC1100-LibHaas.c **** 	SCU_GENERAL->CCUCON = 1;			// Enable CCU40
 3854              	 .loc 3 660 0
 3855 0008 0F4B     	 ldr r3,.L179
 3856 000a 0122     	 mov r2,#1
 3857 000c 1A63     	 str r2,[r3,#48]
 661:../XMC1100-LibHaas.c **** 		// CCU42 Init:
 662:../XMC1100-LibHaas.c **** 	CCU40->GIDLC = 0x10F; 				// Vorteiler enable,CCU4x enable
 3858              	 .loc 3 662 0
 3859 000e 0F4B     	 ldr r3,.L179+4
 3860 0010 1022     	 mov r2,#16
 3861 0012 FF32     	 add r2,r2,#255
 3862 0014 DA60     	 str r2,[r3,#12]
 663:../XMC1100-LibHaas.c **** 	CCU40_CC42->TC = 4;  				// Shadow transfer enable on clear
 3863              	 .loc 3 663 0
 3864 0016 0E4B     	 ldr r3,.L179+8
 3865 0018 0422     	 mov r2,#4
 3866 001a 5A61     	 str r2,[r3,#20]
 664:../XMC1100-LibHaas.c **** 	CCU40_CC42->PSC = 0x1;				// Vorteiler , hier 64Mhz/2
 3867              	 .loc 3 664 0
 3868 001c 0C4B     	 ldr r3,.L179+8
 3869 001e 0122     	 mov r2,#1
 3870 0020 5A62     	 str r2,[r3,#36]
 665:../XMC1100-LibHaas.c **** 	CCU40_CC42->PRS = periode_pwm; 		// Period Register set , hier ca. 640 Hz
 3871              	 .loc 3 665 0
 3872 0022 0B4B     	 ldr r3,.L179+8
 3873 0024 0B4A     	 ldr r2,.L179+12
 3874 0026 5A63     	 str r2,[r3,#52]
 666:../XMC1100-LibHaas.c **** 
 667:../XMC1100-LibHaas.c **** 	// CCU40 Compare:  (Ausganspin P0.8)
 668:../XMC1100-LibHaas.c **** 	CCU40_CC42->CRS = 25000;			// Compare Wert,hier 1:1 Imp
 3875              	 .loc 3 668 0
 3876 0028 094B     	 ldr r3,.L179+8
 3877 002a 0B4A     	 ldr r2,.L179+16
 3878 002c DA63     	 str r2,[r3,#60]
 669:../XMC1100-LibHaas.c **** 	CCU40->GCSS = 1<<8; 				// Shadow transfer request slice 2
 3879              	 .loc 3 669 0
 3880 002e 074B     	 ldr r3,.L179+4
 3881 0030 8022     	 mov r2,#128
 3882 0032 5200     	 lsl r2,r2,#1
 3883 0034 1A61     	 str r2,[r3,#16]
 670:../XMC1100-LibHaas.c **** 	//PORT0->IOCR0 |= 0xA0 << 16;		// Alt4=>OUT bei P0.2
 671:../XMC1100-LibHaas.c **** 	PORT0->IOCR8 |= 0xA0;				// Alt4=>OUT bei P0.8
 3884              	 .loc 3 671 0
 3885 0036 094B     	 ldr r3,.L179+20
 3886 0038 084A     	 ldr r2,.L179+20
 3887 003a 9269     	 ldr r2,[r2,#24]
 3888 003c A021     	 mov r1,#160
 3889 003e 0A43     	 orr r2,r1
 3890 0040 9A61     	 str r2,[r3,#24]
 672:../XMC1100-LibHaas.c **** }
 3891              	 .loc 3 672 0
 3892 0042 BD46     	 mov sp,r7
 3893              	 
 3894 0044 80BD     	 pop {r7,pc}
 3895              	.L180:
 3896 0046 C046     	 .align 2
 3897              	.L179:
 3898 0048 00000140 	 .word 1073807360
 3899 004c 00000448 	 .word 1208221696
 3900 0050 00030448 	 .word 1208222464
 3901 0054 50C30000 	 .word 50000
 3902 0058 A8610000 	 .word 25000
 3903 005c 00000440 	 .word 1074003968
 3904              	 .cfi_endproc
 3905              	.LFE51:
 3907              	 .section .text.pwm4_init,"ax",%progbits
 3908              	 .align 2
 3909              	 .global pwm4_init
 3910              	 .code 16
 3911              	 .thumb_func
 3913              	pwm4_init:
 3914              	.LFB52:
 673:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
 674:../XMC1100-LibHaas.c **** // PWM4-Ausgang P0.9 initialisieren (16-Bit)
 675:../XMC1100-LibHaas.c **** // Hinweis: anschließend starten mit pwm4_start oder pwm4_start_interrupt
 676:../XMC1100-LibHaas.c **** // eingestellte Periodendauer bei #define periode_pwm 50000
 677:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
 678:../XMC1100-LibHaas.c **** void pwm4_init(void)
 679:../XMC1100-LibHaas.c **** {
 3915              	 .loc 3 679 0
 3916              	 .cfi_startproc
 3917 0000 80B5     	 push {r7,lr}
 3918              	.LCFI53:
 3919              	 .cfi_def_cfa_offset 8
 3920              	 .cfi_offset 7,-8
 3921              	 .cfi_offset 14,-4
 3922 0002 00AF     	 add r7,sp,#0
 3923              	.LCFI54:
 3924              	 .cfi_def_cfa_register 7
 680:../XMC1100-LibHaas.c **** 	clock_init();
 3925              	 .loc 3 680 0
 3926 0004 FFF7FEFF 	 bl clock_init
 681:../XMC1100-LibHaas.c **** 	SCU_GENERAL->CCUCON = 1;			// Enable CCU40
 3927              	 .loc 3 681 0
 3928 0008 0F4B     	 ldr r3,.L182
 3929 000a 0122     	 mov r2,#1
 3930 000c 1A63     	 str r2,[r3,#48]
 682:../XMC1100-LibHaas.c **** 		// CCU42 Init:
 683:../XMC1100-LibHaas.c **** 	CCU40->GIDLC = 0x10F; 				// Vorteiler enable,CCU4x enable
 3931              	 .loc 3 683 0
 3932 000e 0F4B     	 ldr r3,.L182+4
 3933 0010 1022     	 mov r2,#16
 3934 0012 FF32     	 add r2,r2,#255
 3935 0014 DA60     	 str r2,[r3,#12]
 684:../XMC1100-LibHaas.c **** 	CCU40_CC43->TC = 4;  				// Shadow transfer enable on clear
 3936              	 .loc 3 684 0
 3937 0016 0E4B     	 ldr r3,.L182+8
 3938 0018 0422     	 mov r2,#4
 3939 001a 5A61     	 str r2,[r3,#20]
 685:../XMC1100-LibHaas.c **** 	CCU40_CC43->PSC = 0x1;				// Vorteiler , hier 64Mhz/2
 3940              	 .loc 3 685 0
 3941 001c 0C4B     	 ldr r3,.L182+8
 3942 001e 0122     	 mov r2,#1
 3943 0020 5A62     	 str r2,[r3,#36]
 686:../XMC1100-LibHaas.c **** 	CCU40_CC43->PRS = periode_pwm; 		// Period Register set , hier ca. 640 Hz
 3944              	 .loc 3 686 0
 3945 0022 0B4B     	 ldr r3,.L182+8
 3946 0024 0B4A     	 ldr r2,.L182+12
 3947 0026 5A63     	 str r2,[r3,#52]
 687:../XMC1100-LibHaas.c **** 
 688:../XMC1100-LibHaas.c **** 	// CCU40 Compare:  (Ausganspin P0.8)
 689:../XMC1100-LibHaas.c **** 	CCU40_CC43->CRS = 25000;			// Compare Wert,hier 1:1 Imp
 3948              	 .loc 3 689 0
 3949 0028 094B     	 ldr r3,.L182+8
 3950 002a 0B4A     	 ldr r2,.L182+16
 3951 002c DA63     	 str r2,[r3,#60]
 690:../XMC1100-LibHaas.c **** 	CCU40->GCSS = 1<<12; 				// Shadow transfer request slice 3
 3952              	 .loc 3 690 0
 3953 002e 074B     	 ldr r3,.L182+4
 3954 0030 8022     	 mov r2,#128
 3955 0032 5201     	 lsl r2,r2,#5
 3956 0034 1A61     	 str r2,[r3,#16]
 691:../XMC1100-LibHaas.c **** 	//PORT0->IOCR0 |= 0xA0 << 16;		// Alt4=>OUT bei P0.2
 692:../XMC1100-LibHaas.c **** 	//PORT0->IOCR8 &= !(0xF8 << 8);
 693:../XMC1100-LibHaas.c **** 	PORT0->IOCR8 |= 0xA0 << 8;				// Alt4=>OUT bei P0.9
 3957              	 .loc 3 693 0
 3958 0036 094B     	 ldr r3,.L182+20
 3959 0038 084A     	 ldr r2,.L182+20
 3960 003a 9269     	 ldr r2,[r2,#24]
 3961 003c A021     	 mov r1,#160
 3962 003e 0902     	 lsl r1,r1,#8
 3963 0040 0A43     	 orr r2,r1
 3964 0042 9A61     	 str r2,[r3,#24]
 694:../XMC1100-LibHaas.c **** }
 3965              	 .loc 3 694 0
 3966 0044 BD46     	 mov sp,r7
 3967              	 
 3968 0046 80BD     	 pop {r7,pc}
 3969              	.L183:
 3970              	 .align 2
 3971              	.L182:
 3972 0048 00000140 	 .word 1073807360
 3973 004c 00000448 	 .word 1208221696
 3974 0050 00040448 	 .word 1208222720
 3975 0054 50C30000 	 .word 50000
 3976 0058 A8610000 	 .word 25000
 3977 005c 00000440 	 .word 1074003968
 3978              	 .cfi_endproc
 3979              	.LFE52:
 3981              	 .section .text.pwm1_duty_cycle_8,"ax",%progbits
 3982              	 .align 2
 3983              	 .global pwm1_duty_cycle_8
 3984              	 .code 16
 3985              	 .thumb_func
 3987              	pwm1_duty_cycle_8:
 3988              	.LFB53:
 695:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
 696:../XMC1100-LibHaas.c **** // 8-Bit-Comparewert einstellen, der den Tastgrad des 8-Bit-PWM-Singals verändert
 697:../XMC1100-LibHaas.c **** // compare = 0...255, Tastgrad 50% bei compare = 127
 698:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
 699:../XMC1100-LibHaas.c **** void pwm1_duty_cycle_8 (uint8_t compare)
 700:../XMC1100-LibHaas.c **** {
 3989              	 .loc 3 700 0
 3990              	 .cfi_startproc
 3991 0000 80B5     	 push {r7,lr}
 3992              	.LCFI55:
 3993              	 .cfi_def_cfa_offset 8
 3994              	 .cfi_offset 7,-8
 3995              	 .cfi_offset 14,-4
 3996 0002 82B0     	 sub sp,sp,#8
 3997              	.LCFI56:
 3998              	 .cfi_def_cfa_offset 16
 3999 0004 00AF     	 add r7,sp,#0
 4000              	.LCFI57:
 4001              	 .cfi_def_cfa_register 7
 4002 0006 021C     	 mov r2,r0
 4003 0008 FB1D     	 add r3,r7,#7
 4004 000a 1A70     	 strb r2,[r3]
 701:../XMC1100-LibHaas.c **** 	CCU40_CC40->CRS = periode_pwm_8 - (compare * 10);// Compare Wert,hier 1:1 Imp
 4005              	 .loc 3 701 0
 4006 000c 094B     	 ldr r3,.L185
 4007 000e FA1D     	 add r2,r7,#7
 4008 0010 1278     	 ldrb r2,[r2]
 4009 0012 0A21     	 mov r1,#10
 4010 0014 4942     	 neg r1,r1
 4011 0016 4A43     	 mul r2,r1
 4012 0018 0749     	 ldr r1,.L185+4
 4013 001a 8C46     	 mov ip,r1
 4014 001c 6244     	 add r2,r2,ip
 4015 001e DA63     	 str r2,[r3,#60]
 702:../XMC1100-LibHaas.c **** 	CCU40->GCSS |= 1; 					//Shadow transfer request slice 0
 4016              	 .loc 3 702 0
 4017 0020 064B     	 ldr r3,.L185+8
 4018 0022 064A     	 ldr r2,.L185+8
 4019 0024 1269     	 ldr r2,[r2,#16]
 4020 0026 0121     	 mov r1,#1
 4021 0028 0A43     	 orr r2,r1
 4022 002a 1A61     	 str r2,[r3,#16]
 703:../XMC1100-LibHaas.c **** }
 4023              	 .loc 3 703 0
 4024 002c BD46     	 mov sp,r7
 4025 002e 02B0     	 add sp,sp,#8
 4026              	 
 4027 0030 80BD     	 pop {r7,pc}
 4028              	.L186:
 4029 0032 C046     	 .align 2
 4030              	.L185:
 4031 0034 00010448 	 .word 1208221952
 4032 0038 F6090000 	 .word 2550
 4033 003c 00000448 	 .word 1208221696
 4034              	 .cfi_endproc
 4035              	.LFE53:
 4037              	 .section .text.pwm1_duty_cycle,"ax",%progbits
 4038              	 .align 2
 4039              	 .global pwm1_duty_cycle
 4040              	 .code 16
 4041              	 .thumb_func
 4043              	pwm1_duty_cycle:
 4044              	.LFB54:
 704:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
 705:../XMC1100-LibHaas.c **** // 16-Bit-Comparewert einstellen, der den Tastgrad des PWM-Singals verändert
 706:../XMC1100-LibHaas.c **** // eingestellte Periodendauer bei #define periode_pwm 50000
 707:../XMC1100-LibHaas.c **** // compare = 0...50000, Tastgrad 50% bei compare = 25000
 708:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
 709:../XMC1100-LibHaas.c **** void pwm1_duty_cycle (uint16_t compare)
 710:../XMC1100-LibHaas.c **** {
 4045              	 .loc 3 710 0
 4046              	 .cfi_startproc
 4047 0000 80B5     	 push {r7,lr}
 4048              	.LCFI58:
 4049              	 .cfi_def_cfa_offset 8
 4050              	 .cfi_offset 7,-8
 4051              	 .cfi_offset 14,-4
 4052 0002 82B0     	 sub sp,sp,#8
 4053              	.LCFI59:
 4054              	 .cfi_def_cfa_offset 16
 4055 0004 00AF     	 add r7,sp,#0
 4056              	.LCFI60:
 4057              	 .cfi_def_cfa_register 7
 4058 0006 021C     	 mov r2,r0
 4059 0008 BB1D     	 add r3,r7,#6
 4060 000a 1A80     	 strh r2,[r3]
 711:../XMC1100-LibHaas.c **** 	CCU40_CC40->CRS = compare; 	// Compare Wert, hier 1:1 Imp
 4061              	 .loc 3 711 0
 4062 000c 064B     	 ldr r3,.L188
 4063 000e BA1D     	 add r2,r7,#6
 4064 0010 1288     	 ldrh r2,[r2]
 4065 0012 DA63     	 str r2,[r3,#60]
 712:../XMC1100-LibHaas.c **** 	CCU40->GCSS |= 1; 					// Shadow transfer request slice 0
 4066              	 .loc 3 712 0
 4067 0014 054B     	 ldr r3,.L188+4
 4068 0016 054A     	 ldr r2,.L188+4
 4069 0018 1269     	 ldr r2,[r2,#16]
 4070 001a 0121     	 mov r1,#1
 4071 001c 0A43     	 orr r2,r1
 4072 001e 1A61     	 str r2,[r3,#16]
 713:../XMC1100-LibHaas.c **** }
 4073              	 .loc 3 713 0
 4074 0020 BD46     	 mov sp,r7
 4075 0022 02B0     	 add sp,sp,#8
 4076              	 
 4077 0024 80BD     	 pop {r7,pc}
 4078              	.L189:
 4079 0026 C046     	 .align 2
 4080              	.L188:
 4081 0028 00010448 	 .word 1208221952
 4082 002c 00000448 	 .word 1208221696
 4083              	 .cfi_endproc
 4084              	.LFE54:
 4086              	 .section .text.pwm1_duty_cycle_period_8,"ax",%progbits
 4087              	 .align 2
 4088              	 .global pwm1_duty_cycle_period_8
 4089              	 .code 16
 4090              	 .thumb_func
 4092              	pwm1_duty_cycle_period_8:
 4093              	.LFB55:
 714:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
 715:../XMC1100-LibHaas.c **** // 8-Bit-Comparewert (für Tastgrad) und Periodendauer der 8-Bit-PWM1 P0.6 einstellen
 716:../XMC1100-LibHaas.c **** // compare = 0...period, period = 0...255
 717:../XMC1100-LibHaas.c **** // Tastgrad 50% bei compare = period/2
 718:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
 719:../XMC1100-LibHaas.c **** void pwm1_duty_cycle_period_8 (uint8_t compare, uint8_t periode)
 720:../XMC1100-LibHaas.c **** {
 4094              	 .loc 3 720 0
 4095              	 .cfi_startproc
 4096 0000 80B5     	 push {r7,lr}
 4097              	.LCFI61:
 4098              	 .cfi_def_cfa_offset 8
 4099              	 .cfi_offset 7,-8
 4100              	 .cfi_offset 14,-4
 4101 0002 82B0     	 sub sp,sp,#8
 4102              	.LCFI62:
 4103              	 .cfi_def_cfa_offset 16
 4104 0004 00AF     	 add r7,sp,#0
 4105              	.LCFI63:
 4106              	 .cfi_def_cfa_register 7
 4107 0006 021C     	 mov r2,r0
 4108 0008 FB1D     	 add r3,r7,#7
 4109 000a 1A70     	 strb r2,[r3]
 4110 000c BB1D     	 add r3,r7,#6
 4111 000e 0A1C     	 add r2,r1,#0
 4112 0010 1A70     	 strb r2,[r3]
 721:../XMC1100-LibHaas.c **** 	CCU40_CC40->PRS = periode*10; 			// Period Register set , ca. 1.5 kHz bei periode = 255
 4113              	 .loc 3 721 0
 4114 0012 0E4A     	 ldr r2,.L191
 4115 0014 BB1D     	 add r3,r7,#6
 4116 0016 1978     	 ldrb r1,[r3]
 4117 0018 0B1C     	 mov r3,r1
 4118 001a 9B00     	 lsl r3,r3,#2
 4119 001c 5B18     	 add r3,r3,r1
 4120 001e 5B00     	 lsl r3,r3,#1
 4121 0020 5363     	 str r3,[r2,#52]
 722:../XMC1100-LibHaas.c **** 	CCU40_CC40->CRS = (periode - compare)*10;// Compare Wert
 4122              	 .loc 3 722 0
 4123 0022 0A4A     	 ldr r2,.L191
 4124 0024 BB1D     	 add r3,r7,#6
 4125 0026 1978     	 ldrb r1,[r3]
 4126 0028 FB1D     	 add r3,r7,#7
 4127 002a 1B78     	 ldrb r3,[r3]
 4128 002c C91A     	 sub r1,r1,r3
 4129 002e 0B1C     	 mov r3,r1
 4130 0030 9B00     	 lsl r3,r3,#2
 4131 0032 5B18     	 add r3,r3,r1
 4132 0034 5B00     	 lsl r3,r3,#1
 4133 0036 D363     	 str r3,[r2,#60]
 723:../XMC1100-LibHaas.c **** 	CCU40->GCSS |= 1; 						//Shadow transfer request slice 0
 4134              	 .loc 3 723 0
 4135 0038 054B     	 ldr r3,.L191+4
 4136 003a 054A     	 ldr r2,.L191+4
 4137 003c 1269     	 ldr r2,[r2,#16]
 4138 003e 0121     	 mov r1,#1
 4139 0040 0A43     	 orr r2,r1
 4140 0042 1A61     	 str r2,[r3,#16]
 724:../XMC1100-LibHaas.c **** }
 4141              	 .loc 3 724 0
 4142 0044 BD46     	 mov sp,r7
 4143 0046 02B0     	 add sp,sp,#8
 4144              	 
 4145 0048 80BD     	 pop {r7,pc}
 4146              	.L192:
 4147 004a C046     	 .align 2
 4148              	.L191:
 4149 004c 00010448 	 .word 1208221952
 4150 0050 00000448 	 .word 1208221696
 4151              	 .cfi_endproc
 4152              	.LFE55:
 4154              	 .section .text.pwm1_duty_cycle_period,"ax",%progbits
 4155              	 .align 2
 4156              	 .global pwm1_duty_cycle_period
 4157              	 .code 16
 4158              	 .thumb_func
 4160              	pwm1_duty_cycle_period:
 4161              	.LFB56:
 725:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
 726:../XMC1100-LibHaas.c **** // 16-Bit-Comparewert (für Tastgrad) und Periodendauer der PWM1 P0.6 einstellen
 727:../XMC1100-LibHaas.c **** // Vorteiler max 15
 728:../XMC1100-LibHaas.c **** // eingestellte Periodendauer bei #define periode_pwm 50000
 729:../XMC1100-LibHaas.c **** // compare = 0...period, period = 0...50000
 730:../XMC1100-LibHaas.c **** // Tastgrad 50% bei compare = period/2
 731:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
 732:../XMC1100-LibHaas.c **** void pwm1_duty_cycle_period (uint8_t vorteiler, uint16_t compare, uint16_t periode)
 733:../XMC1100-LibHaas.c **** {
 4162              	 .loc 3 733 0
 4163              	 .cfi_startproc
 4164 0000 90B5     	 push {r4,r7,lr}
 4165              	.LCFI64:
 4166              	 .cfi_def_cfa_offset 12
 4167              	 .cfi_offset 4,-12
 4168              	 .cfi_offset 7,-8
 4169              	 .cfi_offset 14,-4
 4170 0002 83B0     	 sub sp,sp,#12
 4171              	.LCFI65:
 4172              	 .cfi_def_cfa_offset 24
 4173 0004 00AF     	 add r7,sp,#0
 4174              	.LCFI66:
 4175              	 .cfi_def_cfa_register 7
 4176 0006 041C     	 mov r4,r0
 4177 0008 081C     	 mov r0,r1
 4178 000a 111C     	 mov r1,r2
 4179 000c FB1D     	 add r3,r7,#7
 4180 000e 221C     	 add r2,r4,#0
 4181 0010 1A70     	 strb r2,[r3]
 4182 0012 3B1D     	 add r3,r7,#4
 4183 0014 021C     	 add r2,r0,#0
 4184 0016 1A80     	 strh r2,[r3]
 4185 0018 BB1C     	 add r3,r7,#2
 4186 001a 0A1C     	 add r2,r1,#0
 4187 001c 1A80     	 strh r2,[r3]
 734:../XMC1100-LibHaas.c **** 	vorteiler %= 0x10;				// max. 15
 4188              	 .loc 3 734 0
 4189 001e FB1D     	 add r3,r7,#7
 4190 0020 FA1D     	 add r2,r7,#7
 4191 0022 1278     	 ldrb r2,[r2]
 4192 0024 0F21     	 mov r1,#15
 4193 0026 0A40     	 and r2,r1
 4194 0028 1A70     	 strb r2,[r3]
 735:../XMC1100-LibHaas.c **** 	CCU40_CC40->PSC = vorteiler;
 4195              	 .loc 3 735 0
 4196 002a 0A4B     	 ldr r3,.L194
 4197 002c FA1D     	 add r2,r7,#7
 4198 002e 1278     	 ldrb r2,[r2]
 4199 0030 5A62     	 str r2,[r3,#36]
 736:../XMC1100-LibHaas.c **** 	CCU40_CC40->PRS = periode; 		// Period Register set, ca. 640 Hz bei periode = 50000
 4200              	 .loc 3 736 0
 4201 0032 084B     	 ldr r3,.L194
 4202 0034 BA1C     	 add r2,r7,#2
 4203 0036 1288     	 ldrh r2,[r2]
 4204 0038 5A63     	 str r2,[r3,#52]
 737:../XMC1100-LibHaas.c **** 	CCU40_CC40->CRS = compare;		// Compare Wert
 4205              	 .loc 3 737 0
 4206 003a 064B     	 ldr r3,.L194
 4207 003c 3A1D     	 add r2,r7,#4
 4208 003e 1288     	 ldrh r2,[r2]
 4209 0040 DA63     	 str r2,[r3,#60]
 738:../XMC1100-LibHaas.c **** 	CCU40->GCSS |= 1; 				// Shadow transfer request slice 0
 4210              	 .loc 3 738 0
 4211 0042 054B     	 ldr r3,.L194+4
 4212 0044 044A     	 ldr r2,.L194+4
 4213 0046 1269     	 ldr r2,[r2,#16]
 4214 0048 0121     	 mov r1,#1
 4215 004a 0A43     	 orr r2,r1
 4216 004c 1A61     	 str r2,[r3,#16]
 739:../XMC1100-LibHaas.c **** }
 4217              	 .loc 3 739 0
 4218 004e BD46     	 mov sp,r7
 4219 0050 03B0     	 add sp,sp,#12
 4220              	 
 4221 0052 90BD     	 pop {r4,r7,pc}
 4222              	.L195:
 4223              	 .align 2
 4224              	.L194:
 4225 0054 00010448 	 .word 1208221952
 4226 0058 00000448 	 .word 1208221696
 4227              	 .cfi_endproc
 4228              	.LFE56:
 4230              	 .section .text.pwm2_duty_cycle_8,"ax",%progbits
 4231              	 .align 2
 4232              	 .global pwm2_duty_cycle_8
 4233              	 .code 16
 4234              	 .thumb_func
 4236              	pwm2_duty_cycle_8:
 4237              	.LFB57:
 740:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
 741:../XMC1100-LibHaas.c **** // 8-Bit-Comparewert einstellen, der den Tastgrad des 8-Bit-PWM-Singals verändert
 742:../XMC1100-LibHaas.c **** // compare = 0...255, Tastgrad 50% bei compare = 127
 743:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
 744:../XMC1100-LibHaas.c **** void pwm2_duty_cycle_8 (uint8_t compare)
 745:../XMC1100-LibHaas.c **** {
 4238              	 .loc 3 745 0
 4239              	 .cfi_startproc
 4240 0000 80B5     	 push {r7,lr}
 4241              	.LCFI67:
 4242              	 .cfi_def_cfa_offset 8
 4243              	 .cfi_offset 7,-8
 4244              	 .cfi_offset 14,-4
 4245 0002 82B0     	 sub sp,sp,#8
 4246              	.LCFI68:
 4247              	 .cfi_def_cfa_offset 16
 4248 0004 00AF     	 add r7,sp,#0
 4249              	.LCFI69:
 4250              	 .cfi_def_cfa_register 7
 4251 0006 021C     	 mov r2,r0
 4252 0008 FB1D     	 add r3,r7,#7
 4253 000a 1A70     	 strb r2,[r3]
 746:../XMC1100-LibHaas.c **** 	CCU40_CC41->CRS = periode_pwm_8 - (compare * 10);// Compare Wert,hier 1:1 Imp
 4254              	 .loc 3 746 0
 4255 000c 094B     	 ldr r3,.L197
 4256 000e FA1D     	 add r2,r7,#7
 4257 0010 1278     	 ldrb r2,[r2]
 4258 0012 0A21     	 mov r1,#10
 4259 0014 4942     	 neg r1,r1
 4260 0016 4A43     	 mul r2,r1
 4261 0018 0749     	 ldr r1,.L197+4
 4262 001a 8C46     	 mov ip,r1
 4263 001c 6244     	 add r2,r2,ip
 4264 001e DA63     	 str r2,[r3,#60]
 747:../XMC1100-LibHaas.c **** 	CCU40->GCSS |= 1<<4; 				//Shadow transfer request slice 1
 4265              	 .loc 3 747 0
 4266 0020 064B     	 ldr r3,.L197+8
 4267 0022 064A     	 ldr r2,.L197+8
 4268 0024 1269     	 ldr r2,[r2,#16]
 4269 0026 1021     	 mov r1,#16
 4270 0028 0A43     	 orr r2,r1
 4271 002a 1A61     	 str r2,[r3,#16]
 748:../XMC1100-LibHaas.c **** }
 4272              	 .loc 3 748 0
 4273 002c BD46     	 mov sp,r7
 4274 002e 02B0     	 add sp,sp,#8
 4275              	 
 4276 0030 80BD     	 pop {r7,pc}
 4277              	.L198:
 4278 0032 C046     	 .align 2
 4279              	.L197:
 4280 0034 00020448 	 .word 1208222208
 4281 0038 F6090000 	 .word 2550
 4282 003c 00000448 	 .word 1208221696
 4283              	 .cfi_endproc
 4284              	.LFE57:
 4286              	 .section .text.pwm2_duty_cycle,"ax",%progbits
 4287              	 .align 2
 4288              	 .global pwm2_duty_cycle
 4289              	 .code 16
 4290              	 .thumb_func
 4292              	pwm2_duty_cycle:
 4293              	.LFB58:
 749:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
 750:../XMC1100-LibHaas.c **** // 16-Bit-Comparewert einstellen, der den Tastgrad des PWM-Singals verändert
 751:../XMC1100-LibHaas.c **** // eingestellte Periodendauer bei #define periode_pwm 50000
 752:../XMC1100-LibHaas.c **** // compare = 0...50000, Tastgrad 50% bei compare = 25000
 753:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
 754:../XMC1100-LibHaas.c **** void pwm2_duty_cycle (uint16_t compare)
 755:../XMC1100-LibHaas.c **** {
 4294              	 .loc 3 755 0
 4295              	 .cfi_startproc
 4296 0000 80B5     	 push {r7,lr}
 4297              	.LCFI70:
 4298              	 .cfi_def_cfa_offset 8
 4299              	 .cfi_offset 7,-8
 4300              	 .cfi_offset 14,-4
 4301 0002 82B0     	 sub sp,sp,#8
 4302              	.LCFI71:
 4303              	 .cfi_def_cfa_offset 16
 4304 0004 00AF     	 add r7,sp,#0
 4305              	.LCFI72:
 4306              	 .cfi_def_cfa_register 7
 4307 0006 021C     	 mov r2,r0
 4308 0008 BB1D     	 add r3,r7,#6
 4309 000a 1A80     	 strh r2,[r3]
 756:../XMC1100-LibHaas.c **** 	CCU40_CC41->CRS = compare;	// Compare Wert,hier 1:1 Imp
 4310              	 .loc 3 756 0
 4311 000c 064B     	 ldr r3,.L200
 4312 000e BA1D     	 add r2,r7,#6
 4313 0010 1288     	 ldrh r2,[r2]
 4314 0012 DA63     	 str r2,[r3,#60]
 757:../XMC1100-LibHaas.c **** 	CCU40->GCSS |= 1<<4; 				// Shadow transfer request slice 1
 4315              	 .loc 3 757 0
 4316 0014 054B     	 ldr r3,.L200+4
 4317 0016 054A     	 ldr r2,.L200+4
 4318 0018 1269     	 ldr r2,[r2,#16]
 4319 001a 1021     	 mov r1,#16
 4320 001c 0A43     	 orr r2,r1
 4321 001e 1A61     	 str r2,[r3,#16]
 758:../XMC1100-LibHaas.c **** }
 4322              	 .loc 3 758 0
 4323 0020 BD46     	 mov sp,r7
 4324 0022 02B0     	 add sp,sp,#8
 4325              	 
 4326 0024 80BD     	 pop {r7,pc}
 4327              	.L201:
 4328 0026 C046     	 .align 2
 4329              	.L200:
 4330 0028 00020448 	 .word 1208222208
 4331 002c 00000448 	 .word 1208221696
 4332              	 .cfi_endproc
 4333              	.LFE58:
 4335              	 .section .text.pwm2_duty_cycle_period_8,"ax",%progbits
 4336              	 .align 2
 4337              	 .global pwm2_duty_cycle_period_8
 4338              	 .code 16
 4339              	 .thumb_func
 4341              	pwm2_duty_cycle_period_8:
 4342              	.LFB59:
 759:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
 760:../XMC1100-LibHaas.c **** // 8-Bit-Comparewert (für Tastgrad) und Periodendauer der 8-Bit-PWM2 P0.7 einstellen
 761:../XMC1100-LibHaas.c **** // compare = 0...periode, periode = 0...255
 762:../XMC1100-LibHaas.c **** // Tastgrad 50% bei compare = periode/2
 763:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
 764:../XMC1100-LibHaas.c **** void pwm2_duty_cycle_period_8 (uint8_t compare, uint8_t periode)
 765:../XMC1100-LibHaas.c **** {
 4343              	 .loc 3 765 0
 4344              	 .cfi_startproc
 4345 0000 80B5     	 push {r7,lr}
 4346              	.LCFI73:
 4347              	 .cfi_def_cfa_offset 8
 4348              	 .cfi_offset 7,-8
 4349              	 .cfi_offset 14,-4
 4350 0002 82B0     	 sub sp,sp,#8
 4351              	.LCFI74:
 4352              	 .cfi_def_cfa_offset 16
 4353 0004 00AF     	 add r7,sp,#0
 4354              	.LCFI75:
 4355              	 .cfi_def_cfa_register 7
 4356 0006 021C     	 mov r2,r0
 4357 0008 FB1D     	 add r3,r7,#7
 4358 000a 1A70     	 strb r2,[r3]
 4359 000c BB1D     	 add r3,r7,#6
 4360 000e 0A1C     	 add r2,r1,#0
 4361 0010 1A70     	 strb r2,[r3]
 766:../XMC1100-LibHaas.c **** 	CCU40_CC41->PRS = periode*10; 			// Period Register set , ca. 1.5 kHz bei periode = 255
 4362              	 .loc 3 766 0
 4363 0012 0E4A     	 ldr r2,.L203
 4364 0014 BB1D     	 add r3,r7,#6
 4365 0016 1978     	 ldrb r1,[r3]
 4366 0018 0B1C     	 mov r3,r1
 4367 001a 9B00     	 lsl r3,r3,#2
 4368 001c 5B18     	 add r3,r3,r1
 4369 001e 5B00     	 lsl r3,r3,#1
 4370 0020 5363     	 str r3,[r2,#52]
 767:../XMC1100-LibHaas.c **** 	CCU40_CC41->CRS = (periode - compare)*10;// Compare Wert
 4371              	 .loc 3 767 0
 4372 0022 0A4A     	 ldr r2,.L203
 4373 0024 BB1D     	 add r3,r7,#6
 4374 0026 1978     	 ldrb r1,[r3]
 4375 0028 FB1D     	 add r3,r7,#7
 4376 002a 1B78     	 ldrb r3,[r3]
 4377 002c C91A     	 sub r1,r1,r3
 4378 002e 0B1C     	 mov r3,r1
 4379 0030 9B00     	 lsl r3,r3,#2
 4380 0032 5B18     	 add r3,r3,r1
 4381 0034 5B00     	 lsl r3,r3,#1
 4382 0036 D363     	 str r3,[r2,#60]
 768:../XMC1100-LibHaas.c **** 	CCU40->GCSS |= 1<<4; 				//Shadow transfer request slice 1
 4383              	 .loc 3 768 0
 4384 0038 054B     	 ldr r3,.L203+4
 4385 003a 054A     	 ldr r2,.L203+4
 4386 003c 1269     	 ldr r2,[r2,#16]
 4387 003e 1021     	 mov r1,#16
 4388 0040 0A43     	 orr r2,r1
 4389 0042 1A61     	 str r2,[r3,#16]
 769:../XMC1100-LibHaas.c **** }
 4390              	 .loc 3 769 0
 4391 0044 BD46     	 mov sp,r7
 4392 0046 02B0     	 add sp,sp,#8
 4393              	 
 4394 0048 80BD     	 pop {r7,pc}
 4395              	.L204:
 4396 004a C046     	 .align 2
 4397              	.L203:
 4398 004c 00020448 	 .word 1208222208
 4399 0050 00000448 	 .word 1208221696
 4400              	 .cfi_endproc
 4401              	.LFE59:
 4403              	 .section .text.pwm2_duty_cycle_period,"ax",%progbits
 4404              	 .align 2
 4405              	 .global pwm2_duty_cycle_period
 4406              	 .code 16
 4407              	 .thumb_func
 4409              	pwm2_duty_cycle_period:
 4410              	.LFB60:
 770:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
 771:../XMC1100-LibHaas.c **** // 16-Bit-Comparewert (für Tastgrad) und Periodendauer der PWM2 P0.7 einstellen
 772:../XMC1100-LibHaas.c **** // Vorteiler max 15
 773:../XMC1100-LibHaas.c **** // eingestellte Periodendauer bei #define periode_pwm 50000
 774:../XMC1100-LibHaas.c **** // compare = 0...period, period = 0...50000
 775:../XMC1100-LibHaas.c **** // Tastgrad 50% bei compare = periode/2
 776:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
 777:../XMC1100-LibHaas.c **** void pwm2_duty_cycle_period (uint8_t vorteiler, uint16_t compare, uint16_t periode)
 778:../XMC1100-LibHaas.c **** {
 4411              	 .loc 3 778 0
 4412              	 .cfi_startproc
 4413 0000 90B5     	 push {r4,r7,lr}
 4414              	.LCFI76:
 4415              	 .cfi_def_cfa_offset 12
 4416              	 .cfi_offset 4,-12
 4417              	 .cfi_offset 7,-8
 4418              	 .cfi_offset 14,-4
 4419 0002 83B0     	 sub sp,sp,#12
 4420              	.LCFI77:
 4421              	 .cfi_def_cfa_offset 24
 4422 0004 00AF     	 add r7,sp,#0
 4423              	.LCFI78:
 4424              	 .cfi_def_cfa_register 7
 4425 0006 041C     	 mov r4,r0
 4426 0008 081C     	 mov r0,r1
 4427 000a 111C     	 mov r1,r2
 4428 000c FB1D     	 add r3,r7,#7
 4429 000e 221C     	 add r2,r4,#0
 4430 0010 1A70     	 strb r2,[r3]
 4431 0012 3B1D     	 add r3,r7,#4
 4432 0014 021C     	 add r2,r0,#0
 4433 0016 1A80     	 strh r2,[r3]
 4434 0018 BB1C     	 add r3,r7,#2
 4435 001a 0A1C     	 add r2,r1,#0
 4436 001c 1A80     	 strh r2,[r3]
 779:../XMC1100-LibHaas.c **** 	vorteiler %= 0x10;					// max. 15
 4437              	 .loc 3 779 0
 4438 001e FB1D     	 add r3,r7,#7
 4439 0020 FA1D     	 add r2,r7,#7
 4440 0022 1278     	 ldrb r2,[r2]
 4441 0024 0F21     	 mov r1,#15
 4442 0026 0A40     	 and r2,r1
 4443 0028 1A70     	 strb r2,[r3]
 780:../XMC1100-LibHaas.c **** 	CCU40_CC41->PSC = vorteiler;
 4444              	 .loc 3 780 0
 4445 002a 0A4B     	 ldr r3,.L206
 4446 002c FA1D     	 add r2,r7,#7
 4447 002e 1278     	 ldrb r2,[r2]
 4448 0030 5A62     	 str r2,[r3,#36]
 781:../XMC1100-LibHaas.c **** 	CCU40_CC41->PRS = periode; 			// Period Register set, ca. 640 Hz bei periode = 50000
 4449              	 .loc 3 781 0
 4450 0032 084B     	 ldr r3,.L206
 4451 0034 BA1C     	 add r2,r7,#2
 4452 0036 1288     	 ldrh r2,[r2]
 4453 0038 5A63     	 str r2,[r3,#52]
 782:../XMC1100-LibHaas.c **** 	CCU40_CC41->CRS = compare;			// Compare Wert
 4454              	 .loc 3 782 0
 4455 003a 064B     	 ldr r3,.L206
 4456 003c 3A1D     	 add r2,r7,#4
 4457 003e 1288     	 ldrh r2,[r2]
 4458 0040 DA63     	 str r2,[r3,#60]
 783:../XMC1100-LibHaas.c **** 	CCU40->GCSS |= 1<<4; 				// Shadow transfer request slice 1
 4459              	 .loc 3 783 0
 4460 0042 054B     	 ldr r3,.L206+4
 4461 0044 044A     	 ldr r2,.L206+4
 4462 0046 1269     	 ldr r2,[r2,#16]
 4463 0048 1021     	 mov r1,#16
 4464 004a 0A43     	 orr r2,r1
 4465 004c 1A61     	 str r2,[r3,#16]
 784:../XMC1100-LibHaas.c **** }
 4466              	 .loc 3 784 0
 4467 004e BD46     	 mov sp,r7
 4468 0050 03B0     	 add sp,sp,#12
 4469              	 
 4470 0052 90BD     	 pop {r4,r7,pc}
 4471              	.L207:
 4472              	 .align 2
 4473              	.L206:
 4474 0054 00020448 	 .word 1208222208
 4475 0058 00000448 	 .word 1208221696
 4476              	 .cfi_endproc
 4477              	.LFE60:
 4479              	 .section .text.pwm3_duty_cycle_8,"ax",%progbits
 4480              	 .align 2
 4481              	 .global pwm3_duty_cycle_8
 4482              	 .code 16
 4483              	 .thumb_func
 4485              	pwm3_duty_cycle_8:
 4486              	.LFB61:
 785:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
 786:../XMC1100-LibHaas.c **** // 8-Bit-Comparewert einstellen, der den Tastgrad des 8-Bit-PWM-Singals verändert
 787:../XMC1100-LibHaas.c **** // compare = 0...255, Tastgrad 50% bei compare = 127
 788:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
 789:../XMC1100-LibHaas.c **** void pwm3_duty_cycle_8 (uint8_t compare)
 790:../XMC1100-LibHaas.c **** {
 4487              	 .loc 3 790 0
 4488              	 .cfi_startproc
 4489 0000 80B5     	 push {r7,lr}
 4490              	.LCFI79:
 4491              	 .cfi_def_cfa_offset 8
 4492              	 .cfi_offset 7,-8
 4493              	 .cfi_offset 14,-4
 4494 0002 82B0     	 sub sp,sp,#8
 4495              	.LCFI80:
 4496              	 .cfi_def_cfa_offset 16
 4497 0004 00AF     	 add r7,sp,#0
 4498              	.LCFI81:
 4499              	 .cfi_def_cfa_register 7
 4500 0006 021C     	 mov r2,r0
 4501 0008 FB1D     	 add r3,r7,#7
 4502 000a 1A70     	 strb r2,[r3]
 791:../XMC1100-LibHaas.c **** 	CCU40_CC42->CRS = periode_pwm_8 - (compare * 10);// Compare Wert,hier 1:1 Imp
 4503              	 .loc 3 791 0
 4504 000c 094B     	 ldr r3,.L209
 4505 000e FA1D     	 add r2,r7,#7
 4506 0010 1278     	 ldrb r2,[r2]
 4507 0012 0A21     	 mov r1,#10
 4508 0014 4942     	 neg r1,r1
 4509 0016 4A43     	 mul r2,r1
 4510 0018 0749     	 ldr r1,.L209+4
 4511 001a 8C46     	 mov ip,r1
 4512 001c 6244     	 add r2,r2,ip
 4513 001e DA63     	 str r2,[r3,#60]
 792:../XMC1100-LibHaas.c **** 	CCU40->GCSS |= 1<<8; 				//Shadow transfer request slice 2
 4514              	 .loc 3 792 0
 4515 0020 064B     	 ldr r3,.L209+8
 4516 0022 064A     	 ldr r2,.L209+8
 4517 0024 1269     	 ldr r2,[r2,#16]
 4518 0026 8021     	 mov r1,#128
 4519 0028 4900     	 lsl r1,r1,#1
 4520 002a 0A43     	 orr r2,r1
 4521 002c 1A61     	 str r2,[r3,#16]
 793:../XMC1100-LibHaas.c **** }
 4522              	 .loc 3 793 0
 4523 002e BD46     	 mov sp,r7
 4524 0030 02B0     	 add sp,sp,#8
 4525              	 
 4526 0032 80BD     	 pop {r7,pc}
 4527              	.L210:
 4528              	 .align 2
 4529              	.L209:
 4530 0034 00030448 	 .word 1208222464
 4531 0038 F6090000 	 .word 2550
 4532 003c 00000448 	 .word 1208221696
 4533              	 .cfi_endproc
 4534              	.LFE61:
 4536              	 .section .text.pwm3_duty_cycle,"ax",%progbits
 4537              	 .align 2
 4538              	 .global pwm3_duty_cycle
 4539              	 .code 16
 4540              	 .thumb_func
 4542              	pwm3_duty_cycle:
 4543              	.LFB62:
 794:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
 795:../XMC1100-LibHaas.c **** // 16-Bit-Comparewert einstellen, der den Tastgrad des PWM-Singals verändert
 796:../XMC1100-LibHaas.c **** // eingestellte Periodendauer bei #define periode_pwm 50000
 797:../XMC1100-LibHaas.c **** // compare = 0...50000, Tastgrad 50% bei compare = 25000
 798:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
 799:../XMC1100-LibHaas.c **** void pwm3_duty_cycle (uint16_t compare)
 800:../XMC1100-LibHaas.c **** {
 4544              	 .loc 3 800 0
 4545              	 .cfi_startproc
 4546 0000 80B5     	 push {r7,lr}
 4547              	.LCFI82:
 4548              	 .cfi_def_cfa_offset 8
 4549              	 .cfi_offset 7,-8
 4550              	 .cfi_offset 14,-4
 4551 0002 82B0     	 sub sp,sp,#8
 4552              	.LCFI83:
 4553              	 .cfi_def_cfa_offset 16
 4554 0004 00AF     	 add r7,sp,#0
 4555              	.LCFI84:
 4556              	 .cfi_def_cfa_register 7
 4557 0006 021C     	 mov r2,r0
 4558 0008 BB1D     	 add r3,r7,#6
 4559 000a 1A80     	 strh r2,[r3]
 801:../XMC1100-LibHaas.c **** 	CCU40_CC42->CRS = compare;	// Compare Wert,hier 1:1 Imp
 4560              	 .loc 3 801 0
 4561 000c 064B     	 ldr r3,.L212
 4562 000e BA1D     	 add r2,r7,#6
 4563 0010 1288     	 ldrh r2,[r2]
 4564 0012 DA63     	 str r2,[r3,#60]
 802:../XMC1100-LibHaas.c **** 	CCU40->GCSS |= 1<<8; 				// Shadow transfer request slice 2
 4565              	 .loc 3 802 0
 4566 0014 054B     	 ldr r3,.L212+4
 4567 0016 054A     	 ldr r2,.L212+4
 4568 0018 1269     	 ldr r2,[r2,#16]
 4569 001a 8021     	 mov r1,#128
 4570 001c 4900     	 lsl r1,r1,#1
 4571 001e 0A43     	 orr r2,r1
 4572 0020 1A61     	 str r2,[r3,#16]
 803:../XMC1100-LibHaas.c **** }
 4573              	 .loc 3 803 0
 4574 0022 BD46     	 mov sp,r7
 4575 0024 02B0     	 add sp,sp,#8
 4576              	 
 4577 0026 80BD     	 pop {r7,pc}
 4578              	.L213:
 4579              	 .align 2
 4580              	.L212:
 4581 0028 00030448 	 .word 1208222464
 4582 002c 00000448 	 .word 1208221696
 4583              	 .cfi_endproc
 4584              	.LFE62:
 4586              	 .section .text.pwm3_duty_cycle_period_8,"ax",%progbits
 4587              	 .align 2
 4588              	 .global pwm3_duty_cycle_period_8
 4589              	 .code 16
 4590              	 .thumb_func
 4592              	pwm3_duty_cycle_period_8:
 4593              	.LFB63:
 804:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
 805:../XMC1100-LibHaas.c **** // 8-Bit-Comparewert (für Tastgrad) und Periodendauer der 8-Bit-PWM3 P0.8 einstellen
 806:../XMC1100-LibHaas.c **** // compare = 0...periode, periode = 0...255
 807:../XMC1100-LibHaas.c **** // Tastgrad 50% bei compare = periode/2
 808:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
 809:../XMC1100-LibHaas.c **** void pwm3_duty_cycle_period_8 (uint8_t compare, uint8_t periode)
 810:../XMC1100-LibHaas.c **** {
 4594              	 .loc 3 810 0
 4595              	 .cfi_startproc
 4596 0000 80B5     	 push {r7,lr}
 4597              	.LCFI85:
 4598              	 .cfi_def_cfa_offset 8
 4599              	 .cfi_offset 7,-8
 4600              	 .cfi_offset 14,-4
 4601 0002 82B0     	 sub sp,sp,#8
 4602              	.LCFI86:
 4603              	 .cfi_def_cfa_offset 16
 4604 0004 00AF     	 add r7,sp,#0
 4605              	.LCFI87:
 4606              	 .cfi_def_cfa_register 7
 4607 0006 021C     	 mov r2,r0
 4608 0008 FB1D     	 add r3,r7,#7
 4609 000a 1A70     	 strb r2,[r3]
 4610 000c BB1D     	 add r3,r7,#6
 4611 000e 0A1C     	 add r2,r1,#0
 4612 0010 1A70     	 strb r2,[r3]
 811:../XMC1100-LibHaas.c **** 	CCU40_CC42->PRS = periode*10; 			// Period Register set , ca. 1.5 kHz bei periode = 255
 4613              	 .loc 3 811 0
 4614 0012 0E4A     	 ldr r2,.L215
 4615 0014 BB1D     	 add r3,r7,#6
 4616 0016 1978     	 ldrb r1,[r3]
 4617 0018 0B1C     	 mov r3,r1
 4618 001a 9B00     	 lsl r3,r3,#2
 4619 001c 5B18     	 add r3,r3,r1
 4620 001e 5B00     	 lsl r3,r3,#1
 4621 0020 5363     	 str r3,[r2,#52]
 812:../XMC1100-LibHaas.c **** 	CCU40_CC42->CRS = (periode - compare)*10;// Compare Wert
 4622              	 .loc 3 812 0
 4623 0022 0A4A     	 ldr r2,.L215
 4624 0024 BB1D     	 add r3,r7,#6
 4625 0026 1978     	 ldrb r1,[r3]
 4626 0028 FB1D     	 add r3,r7,#7
 4627 002a 1B78     	 ldrb r3,[r3]
 4628 002c C91A     	 sub r1,r1,r3
 4629 002e 0B1C     	 mov r3,r1
 4630 0030 9B00     	 lsl r3,r3,#2
 4631 0032 5B18     	 add r3,r3,r1
 4632 0034 5B00     	 lsl r3,r3,#1
 4633 0036 D363     	 str r3,[r2,#60]
 813:../XMC1100-LibHaas.c **** 	CCU40->GCSS |= 1<<8; 				//Shadow transfer request slice 2
 4634              	 .loc 3 813 0
 4635 0038 054B     	 ldr r3,.L215+4
 4636 003a 054A     	 ldr r2,.L215+4
 4637 003c 1269     	 ldr r2,[r2,#16]
 4638 003e 8021     	 mov r1,#128
 4639 0040 4900     	 lsl r1,r1,#1
 4640 0042 0A43     	 orr r2,r1
 4641 0044 1A61     	 str r2,[r3,#16]
 814:../XMC1100-LibHaas.c **** }
 4642              	 .loc 3 814 0
 4643 0046 BD46     	 mov sp,r7
 4644 0048 02B0     	 add sp,sp,#8
 4645              	 
 4646 004a 80BD     	 pop {r7,pc}
 4647              	.L216:
 4648              	 .align 2
 4649              	.L215:
 4650 004c 00030448 	 .word 1208222464
 4651 0050 00000448 	 .word 1208221696
 4652              	 .cfi_endproc
 4653              	.LFE63:
 4655              	 .section .text.pwm3_duty_cycle_period,"ax",%progbits
 4656              	 .align 2
 4657              	 .global pwm3_duty_cycle_period
 4658              	 .code 16
 4659              	 .thumb_func
 4661              	pwm3_duty_cycle_period:
 4662              	.LFB64:
 815:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
 816:../XMC1100-LibHaas.c **** // 16-Bit-Comparewert (für Tastgrad) und Periodendauer der PWM3 P0.8 einstellen
 817:../XMC1100-LibHaas.c **** // Vorteiler max 15
 818:../XMC1100-LibHaas.c **** // eingestellte Periodendauer bei #define periode_pwm 50000
 819:../XMC1100-LibHaas.c **** // compare = 0...period, period = 0...50000
 820:../XMC1100-LibHaas.c **** // Tastgrad 50% bei compare = periode/2
 821:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
 822:../XMC1100-LibHaas.c **** void pwm3_duty_cycle_period (uint8_t vorteiler, uint16_t compare, uint16_t periode)
 823:../XMC1100-LibHaas.c **** {
 4663              	 .loc 3 823 0
 4664              	 .cfi_startproc
 4665 0000 90B5     	 push {r4,r7,lr}
 4666              	.LCFI88:
 4667              	 .cfi_def_cfa_offset 12
 4668              	 .cfi_offset 4,-12
 4669              	 .cfi_offset 7,-8
 4670              	 .cfi_offset 14,-4
 4671 0002 83B0     	 sub sp,sp,#12
 4672              	.LCFI89:
 4673              	 .cfi_def_cfa_offset 24
 4674 0004 00AF     	 add r7,sp,#0
 4675              	.LCFI90:
 4676              	 .cfi_def_cfa_register 7
 4677 0006 041C     	 mov r4,r0
 4678 0008 081C     	 mov r0,r1
 4679 000a 111C     	 mov r1,r2
 4680 000c FB1D     	 add r3,r7,#7
 4681 000e 221C     	 add r2,r4,#0
 4682 0010 1A70     	 strb r2,[r3]
 4683 0012 3B1D     	 add r3,r7,#4
 4684 0014 021C     	 add r2,r0,#0
 4685 0016 1A80     	 strh r2,[r3]
 4686 0018 BB1C     	 add r3,r7,#2
 4687 001a 0A1C     	 add r2,r1,#0
 4688 001c 1A80     	 strh r2,[r3]
 824:../XMC1100-LibHaas.c **** 	vorteiler %= 0x10;					// max. 15
 4689              	 .loc 3 824 0
 4690 001e FB1D     	 add r3,r7,#7
 4691 0020 FA1D     	 add r2,r7,#7
 4692 0022 1278     	 ldrb r2,[r2]
 4693 0024 0F21     	 mov r1,#15
 4694 0026 0A40     	 and r2,r1
 4695 0028 1A70     	 strb r2,[r3]
 825:../XMC1100-LibHaas.c **** 	CCU40_CC42->PSC = vorteiler;
 4696              	 .loc 3 825 0
 4697 002a 0B4B     	 ldr r3,.L218
 4698 002c FA1D     	 add r2,r7,#7
 4699 002e 1278     	 ldrb r2,[r2]
 4700 0030 5A62     	 str r2,[r3,#36]
 826:../XMC1100-LibHaas.c **** 	CCU40_CC42->PRS = periode; 			// Period Register set, ca. 640 Hz bei periode = 50000
 4701              	 .loc 3 826 0
 4702 0032 094B     	 ldr r3,.L218
 4703 0034 BA1C     	 add r2,r7,#2
 4704 0036 1288     	 ldrh r2,[r2]
 4705 0038 5A63     	 str r2,[r3,#52]
 827:../XMC1100-LibHaas.c **** 	CCU40_CC42->CRS = compare;			// Compare Wert
 4706              	 .loc 3 827 0
 4707 003a 074B     	 ldr r3,.L218
 4708 003c 3A1D     	 add r2,r7,#4
 4709 003e 1288     	 ldrh r2,[r2]
 4710 0040 DA63     	 str r2,[r3,#60]
 828:../XMC1100-LibHaas.c **** 	CCU40->GCSS |= 1<<8; 				// Shadow transfer request slice 2
 4711              	 .loc 3 828 0
 4712 0042 064B     	 ldr r3,.L218+4
 4713 0044 054A     	 ldr r2,.L218+4
 4714 0046 1269     	 ldr r2,[r2,#16]
 4715 0048 8021     	 mov r1,#128
 4716 004a 4900     	 lsl r1,r1,#1
 4717 004c 0A43     	 orr r2,r1
 4718 004e 1A61     	 str r2,[r3,#16]
 829:../XMC1100-LibHaas.c **** }
 4719              	 .loc 3 829 0
 4720 0050 BD46     	 mov sp,r7
 4721 0052 03B0     	 add sp,sp,#12
 4722              	 
 4723 0054 90BD     	 pop {r4,r7,pc}
 4724              	.L219:
 4725 0056 C046     	 .align 2
 4726              	.L218:
 4727 0058 00030448 	 .word 1208222464
 4728 005c 00000448 	 .word 1208221696
 4729              	 .cfi_endproc
 4730              	.LFE64:
 4732              	 .section .text.pwm4_duty_cycle,"ax",%progbits
 4733              	 .align 2
 4734              	 .global pwm4_duty_cycle
 4735              	 .code 16
 4736              	 .thumb_func
 4738              	pwm4_duty_cycle:
 4739              	.LFB65:
 830:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
 831:../XMC1100-LibHaas.c **** // 16-Bit-Comparewert einstellen, der den Tastgrad des PWM-Singals verändert
 832:../XMC1100-LibHaas.c **** // eingestellte Periodendauer bei #define periode_pwm 50000
 833:../XMC1100-LibHaas.c **** // compare = 0...50000, Tastgrad 50% bei compare = 25000
 834:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
 835:../XMC1100-LibHaas.c **** void pwm4_duty_cycle (uint16_t compare)
 836:../XMC1100-LibHaas.c **** {
 4740              	 .loc 3 836 0
 4741              	 .cfi_startproc
 4742 0000 80B5     	 push {r7,lr}
 4743              	.LCFI91:
 4744              	 .cfi_def_cfa_offset 8
 4745              	 .cfi_offset 7,-8
 4746              	 .cfi_offset 14,-4
 4747 0002 82B0     	 sub sp,sp,#8
 4748              	.LCFI92:
 4749              	 .cfi_def_cfa_offset 16
 4750 0004 00AF     	 add r7,sp,#0
 4751              	.LCFI93:
 4752              	 .cfi_def_cfa_register 7
 4753 0006 021C     	 mov r2,r0
 4754 0008 BB1D     	 add r3,r7,#6
 4755 000a 1A80     	 strh r2,[r3]
 837:../XMC1100-LibHaas.c **** 	CCU40_CC43->CRS = compare;	// Compare Wert,hier 1:1 Imp
 4756              	 .loc 3 837 0
 4757 000c 064B     	 ldr r3,.L221
 4758 000e BA1D     	 add r2,r7,#6
 4759 0010 1288     	 ldrh r2,[r2]
 4760 0012 DA63     	 str r2,[r3,#60]
 838:../XMC1100-LibHaas.c **** 	CCU40->GCSS |= 1<<12; 				// Shadow transfer request slice 2
 4761              	 .loc 3 838 0
 4762 0014 054B     	 ldr r3,.L221+4
 4763 0016 054A     	 ldr r2,.L221+4
 4764 0018 1269     	 ldr r2,[r2,#16]
 4765 001a 8021     	 mov r1,#128
 4766 001c 4901     	 lsl r1,r1,#5
 4767 001e 0A43     	 orr r2,r1
 4768 0020 1A61     	 str r2,[r3,#16]
 839:../XMC1100-LibHaas.c **** }
 4769              	 .loc 3 839 0
 4770 0022 BD46     	 mov sp,r7
 4771 0024 02B0     	 add sp,sp,#8
 4772              	 
 4773 0026 80BD     	 pop {r7,pc}
 4774              	.L222:
 4775              	 .align 2
 4776              	.L221:
 4777 0028 00040448 	 .word 1208222720
 4778 002c 00000448 	 .word 1208221696
 4779              	 .cfi_endproc
 4780              	.LFE65:
 4782              	 .section .text.pwm4_duty_cycle_period,"ax",%progbits
 4783              	 .align 2
 4784              	 .global pwm4_duty_cycle_period
 4785              	 .code 16
 4786              	 .thumb_func
 4788              	pwm4_duty_cycle_period:
 4789              	.LFB66:
 840:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
 841:../XMC1100-LibHaas.c **** // 16-Bit-Comparewert (für Tastgrad) und Periodendauer der PWM3 P0.9 einstellen
 842:../XMC1100-LibHaas.c **** // Vorteiler max 15
 843:../XMC1100-LibHaas.c **** // eingestellte Periodendauer bei #define periode_pwm 50000
 844:../XMC1100-LibHaas.c **** // compare = 0...period, period = 0...50000
 845:../XMC1100-LibHaas.c **** // Tastgrad 50% bei compare = periode/2
 846:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
 847:../XMC1100-LibHaas.c **** void pwm4_duty_cycle_period (uint8_t vorteiler, uint16_t compare, uint16_t periode)
 848:../XMC1100-LibHaas.c **** {
 4790              	 .loc 3 848 0
 4791              	 .cfi_startproc
 4792 0000 90B5     	 push {r4,r7,lr}
 4793              	.LCFI94:
 4794              	 .cfi_def_cfa_offset 12
 4795              	 .cfi_offset 4,-12
 4796              	 .cfi_offset 7,-8
 4797              	 .cfi_offset 14,-4
 4798 0002 83B0     	 sub sp,sp,#12
 4799              	.LCFI95:
 4800              	 .cfi_def_cfa_offset 24
 4801 0004 00AF     	 add r7,sp,#0
 4802              	.LCFI96:
 4803              	 .cfi_def_cfa_register 7
 4804 0006 041C     	 mov r4,r0
 4805 0008 081C     	 mov r0,r1
 4806 000a 111C     	 mov r1,r2
 4807 000c FB1D     	 add r3,r7,#7
 4808 000e 221C     	 add r2,r4,#0
 4809 0010 1A70     	 strb r2,[r3]
 4810 0012 3B1D     	 add r3,r7,#4
 4811 0014 021C     	 add r2,r0,#0
 4812 0016 1A80     	 strh r2,[r3]
 4813 0018 BB1C     	 add r3,r7,#2
 4814 001a 0A1C     	 add r2,r1,#0
 4815 001c 1A80     	 strh r2,[r3]
 849:../XMC1100-LibHaas.c **** 	vorteiler %= 0x10;					// max. 15
 4816              	 .loc 3 849 0
 4817 001e FB1D     	 add r3,r7,#7
 4818 0020 FA1D     	 add r2,r7,#7
 4819 0022 1278     	 ldrb r2,[r2]
 4820 0024 0F21     	 mov r1,#15
 4821 0026 0A40     	 and r2,r1
 4822 0028 1A70     	 strb r2,[r3]
 850:../XMC1100-LibHaas.c **** 	CCU40_CC43->PSC = vorteiler;
 4823              	 .loc 3 850 0
 4824 002a 0B4B     	 ldr r3,.L224
 4825 002c FA1D     	 add r2,r7,#7
 4826 002e 1278     	 ldrb r2,[r2]
 4827 0030 5A62     	 str r2,[r3,#36]
 851:../XMC1100-LibHaas.c **** 	CCU40_CC43->PRS = periode; 			// Period Register set, ca. 640 Hz bei periode = 50000
 4828              	 .loc 3 851 0
 4829 0032 094B     	 ldr r3,.L224
 4830 0034 BA1C     	 add r2,r7,#2
 4831 0036 1288     	 ldrh r2,[r2]
 4832 0038 5A63     	 str r2,[r3,#52]
 852:../XMC1100-LibHaas.c **** 	CCU40_CC43->CRS = compare;			// Compare Wert
 4833              	 .loc 3 852 0
 4834 003a 074B     	 ldr r3,.L224
 4835 003c 3A1D     	 add r2,r7,#4
 4836 003e 1288     	 ldrh r2,[r2]
 4837 0040 DA63     	 str r2,[r3,#60]
 853:../XMC1100-LibHaas.c **** 	CCU40->GCSS |= 1<<12; 				// Shadow transfer request slice 2
 4838              	 .loc 3 853 0
 4839 0042 064B     	 ldr r3,.L224+4
 4840 0044 054A     	 ldr r2,.L224+4
 4841 0046 1269     	 ldr r2,[r2,#16]
 4842 0048 8021     	 mov r1,#128
 4843 004a 4901     	 lsl r1,r1,#5
 4844 004c 0A43     	 orr r2,r1
 4845 004e 1A61     	 str r2,[r3,#16]
 854:../XMC1100-LibHaas.c **** }
 4846              	 .loc 3 854 0
 4847 0050 BD46     	 mov sp,r7
 4848 0052 03B0     	 add sp,sp,#12
 4849              	 
 4850 0054 90BD     	 pop {r4,r7,pc}
 4851              	.L225:
 4852 0056 C046     	 .align 2
 4853              	.L224:
 4854 0058 00040448 	 .word 1208222720
 4855 005c 00000448 	 .word 1208221696
 4856              	 .cfi_endproc
 4857              	.LFE66:
 4859              	 .section .text.pwm1_start,"ax",%progbits
 4860              	 .align 2
 4861              	 .global pwm1_start
 4862              	 .code 16
 4863              	 .thumb_func
 4865              	pwm1_start:
 4866              	.LFB67:
 855:../XMC1100-LibHaas.c **** //----------------------------------------------------------------
 856:../XMC1100-LibHaas.c **** // PWM1-Ausgang P0.6 Ausgabe starten ohne Interrupt starten, 8- oder 16-Bit
 857:../XMC1100-LibHaas.c **** //----------------------------------------------------------------
 858:../XMC1100-LibHaas.c **** void pwm1_start(void)
 859:../XMC1100-LibHaas.c **** {
 4867              	 .loc 3 859 0
 4868              	 .cfi_startproc
 4869 0000 80B5     	 push {r7,lr}
 4870              	.LCFI97:
 4871              	 .cfi_def_cfa_offset 8
 4872              	 .cfi_offset 7,-8
 4873              	 .cfi_offset 14,-4
 4874 0002 00AF     	 add r7,sp,#0
 4875              	.LCFI98:
 4876              	 .cfi_def_cfa_register 7
 860:../XMC1100-LibHaas.c **** 	 CCU40_CC40->TCSET = 0x1; //starts counting
 4877              	 .loc 3 860 0
 4878 0004 024B     	 ldr r3,.L227
 4879 0006 0122     	 mov r2,#1
 4880 0008 DA60     	 str r2,[r3,#12]
 861:../XMC1100-LibHaas.c **** }
 4881              	 .loc 3 861 0
 4882 000a BD46     	 mov sp,r7
 4883              	 
 4884 000c 80BD     	 pop {r7,pc}
 4885              	.L228:
 4886 000e C046     	 .align 2
 4887              	.L227:
 4888 0010 00010448 	 .word 1208221952
 4889              	 .cfi_endproc
 4890              	.LFE67:
 4892              	 .section .text.pwm1_start_interrupt,"ax",%progbits
 4893              	 .align 2
 4894              	 .global pwm1_start_interrupt
 4895              	 .code 16
 4896              	 .thumb_func
 4898              	pwm1_start_interrupt:
 4899              	.LFB68:
 862:../XMC1100-LibHaas.c **** /*------------------------------------------------------------------
 863:../XMC1100-LibHaas.c **** * PWM1-Ausgang P0.6 Ausgabe starten mit Interrupt nach jeder Periode
 864:../XMC1100-LibHaas.c **** * Diese Timer-ISR ins eigene Programm kopieren
 865:../XMC1100-LibHaas.c **** void CCU40_0_IRQHandler (void)
 866:../XMC1100-LibHaas.c **** {
 867:../XMC1100-LibHaas.c **** 	pwm1_duty_cycle (uint8_t compare); // neuen Comparewert laden
 868:../XMC1100-LibHaas.c **** }
 869:../XMC1100-LibHaas.c **** */
 870:../XMC1100-LibHaas.c **** void pwm1_start_interrupt(void)
 871:../XMC1100-LibHaas.c **** {
 4900              	 .loc 3 871 0
 4901              	 .cfi_startproc
 4902 0000 80B5     	 push {r7,lr}
 4903              	.LCFI99:
 4904              	 .cfi_def_cfa_offset 8
 4905              	 .cfi_offset 7,-8
 4906              	 .cfi_offset 14,-4
 4907 0002 00AF     	 add r7,sp,#0
 4908              	.LCFI100:
 4909              	 .cfi_def_cfa_register 7
 872:../XMC1100-LibHaas.c **** 	CCU40_CC40->TCSET = 0x1; 		//starts counting
 4910              	 .loc 3 872 0
 4911 0004 074B     	 ldr r3,.L230
 4912 0006 0122     	 mov r2,#1
 4913 0008 DA60     	 str r2,[r3,#12]
 873:../XMC1100-LibHaas.c **** 	// Int bei Periode CCU42_CC40 :
 874:../XMC1100-LibHaas.c **** 	CCU40_CC40->INTE |=1 ;			//Int bei Period Match_
 4914              	 .loc 3 874 0
 4915 000a 0649     	 ldr r1,.L230
 4916 000c 054A     	 ldr r2,.L230
 4917 000e A423     	 mov r3,#164
 4918 0010 D358     	 ldr r3,[r2,r3]
 4919 0012 0122     	 mov r2,#1
 4920 0014 1343     	 orr r3,r2
 4921 0016 A422     	 mov r2,#164
 4922 0018 8B50     	 str r3,[r1,r2]
 875:../XMC1100-LibHaas.c **** 	NVIC_EnableIRQ(CCU40_0_IRQn); 	// Int Freigabe für CCU40 => CC40
 4923              	 .loc 3 875 0
 4924 001a 1520     	 mov r0,#21
 4925 001c FFF7FEFF 	 bl __NVIC_EnableIRQ
 876:../XMC1100-LibHaas.c **** }
 4926              	 .loc 3 876 0
 4927 0020 BD46     	 mov sp,r7
 4928              	 
 4929 0022 80BD     	 pop {r7,pc}
 4930              	.L231:
 4931              	 .align 2
 4932              	.L230:
 4933 0024 00010448 	 .word 1208221952
 4934              	 .cfi_endproc
 4935              	.LFE68:
 4937              	 .section .text.pwm2_start,"ax",%progbits
 4938              	 .align 2
 4939              	 .global pwm2_start
 4940              	 .code 16
 4941              	 .thumb_func
 4943              	pwm2_start:
 4944              	.LFB69:
 877:../XMC1100-LibHaas.c **** //----------------------------------------------------------------
 878:../XMC1100-LibHaas.c **** // PWM2-Ausgang P0.7 Ausgabe starten ohne Interrupt starten
 879:../XMC1100-LibHaas.c **** //----------------------------------------------------------------
 880:../XMC1100-LibHaas.c **** void pwm2_start(void)
 881:../XMC1100-LibHaas.c **** {
 4945              	 .loc 3 881 0
 4946              	 .cfi_startproc
 4947 0000 80B5     	 push {r7,lr}
 4948              	.LCFI101:
 4949              	 .cfi_def_cfa_offset 8
 4950              	 .cfi_offset 7,-8
 4951              	 .cfi_offset 14,-4
 4952 0002 00AF     	 add r7,sp,#0
 4953              	.LCFI102:
 4954              	 .cfi_def_cfa_register 7
 882:../XMC1100-LibHaas.c **** 	 CCU40_CC41->TCSET = 0x1; //starts counting
 4955              	 .loc 3 882 0
 4956 0004 024B     	 ldr r3,.L233
 4957 0006 0122     	 mov r2,#1
 4958 0008 DA60     	 str r2,[r3,#12]
 883:../XMC1100-LibHaas.c **** }
 4959              	 .loc 3 883 0
 4960 000a BD46     	 mov sp,r7
 4961              	 
 4962 000c 80BD     	 pop {r7,pc}
 4963              	.L234:
 4964 000e C046     	 .align 2
 4965              	.L233:
 4966 0010 00020448 	 .word 1208222208
 4967              	 .cfi_endproc
 4968              	.LFE69:
 4970              	 .section .text.pwm2_start_interrupt,"ax",%progbits
 4971              	 .align 2
 4972              	 .global pwm2_start_interrupt
 4973              	 .code 16
 4974              	 .thumb_func
 4976              	pwm2_start_interrupt:
 4977              	.LFB70:
 884:../XMC1100-LibHaas.c **** /*------------------------------------------------------------------
 885:../XMC1100-LibHaas.c **** * PWM2-Ausgang P0.7 Ausgabe starten mit Interrupt nach jeder Periode
 886:../XMC1100-LibHaas.c **** * Diese Timer-ISR ins eigene Programm kopieren
 887:../XMC1100-LibHaas.c **** void CCU40_1_IRQHandler (void)
 888:../XMC1100-LibHaas.c **** {
 889:../XMC1100-LibHaas.c **** 	pwm2_duty_cycle (uint8_t compare); // neuen Comparewert laden
 890:../XMC1100-LibHaas.c **** }
 891:../XMC1100-LibHaas.c **** */
 892:../XMC1100-LibHaas.c **** void pwm2_start_interrupt(void)
 893:../XMC1100-LibHaas.c **** {
 4978              	 .loc 3 893 0
 4979              	 .cfi_startproc
 4980 0000 80B5     	 push {r7,lr}
 4981              	.LCFI103:
 4982              	 .cfi_def_cfa_offset 8
 4983              	 .cfi_offset 7,-8
 4984              	 .cfi_offset 14,-4
 4985 0002 00AF     	 add r7,sp,#0
 4986              	.LCFI104:
 4987              	 .cfi_def_cfa_register 7
 894:../XMC1100-LibHaas.c **** 	CCU40_CC41->TCSET = 0x1; 		//starts counting
 4988              	 .loc 3 894 0
 4989 0004 074B     	 ldr r3,.L236
 4990 0006 0122     	 mov r2,#1
 4991 0008 DA60     	 str r2,[r3,#12]
 895:../XMC1100-LibHaas.c **** 	// Int bei Periode CCU42_CC41 :
 896:../XMC1100-LibHaas.c **** 	CCU40_CC41->INTE |=1 ;			//Int bei Period Match_
 4992              	 .loc 3 896 0
 4993 000a 0649     	 ldr r1,.L236
 4994 000c 054A     	 ldr r2,.L236
 4995 000e A423     	 mov r3,#164
 4996 0010 D358     	 ldr r3,[r2,r3]
 4997 0012 0122     	 mov r2,#1
 4998 0014 1343     	 orr r3,r2
 4999 0016 A422     	 mov r2,#164
 5000 0018 8B50     	 str r3,[r1,r2]
 897:../XMC1100-LibHaas.c **** 	NVIC_EnableIRQ(CCU40_1_IRQn); 	// Int Freigabe für CCU40 => CC41
 5001              	 .loc 3 897 0
 5002 001a 1620     	 mov r0,#22
 5003 001c FFF7FEFF 	 bl __NVIC_EnableIRQ
 898:../XMC1100-LibHaas.c **** }
 5004              	 .loc 3 898 0
 5005 0020 BD46     	 mov sp,r7
 5006              	 
 5007 0022 80BD     	 pop {r7,pc}
 5008              	.L237:
 5009              	 .align 2
 5010              	.L236:
 5011 0024 00020448 	 .word 1208222208
 5012              	 .cfi_endproc
 5013              	.LFE70:
 5015              	 .section .text.pwm3_start,"ax",%progbits
 5016              	 .align 2
 5017              	 .global pwm3_start
 5018              	 .code 16
 5019              	 .thumb_func
 5021              	pwm3_start:
 5022              	.LFB71:
 899:../XMC1100-LibHaas.c **** //----------------------------------------------------------------
 900:../XMC1100-LibHaas.c **** // PWM3-Ausgang P0.8 Ausgabe starten ohne Interrupt starten
 901:../XMC1100-LibHaas.c **** //----------------------------------------------------------------
 902:../XMC1100-LibHaas.c **** void pwm3_start(void)
 903:../XMC1100-LibHaas.c **** {
 5023              	 .loc 3 903 0
 5024              	 .cfi_startproc
 5025 0000 80B5     	 push {r7,lr}
 5026              	.LCFI105:
 5027              	 .cfi_def_cfa_offset 8
 5028              	 .cfi_offset 7,-8
 5029              	 .cfi_offset 14,-4
 5030 0002 00AF     	 add r7,sp,#0
 5031              	.LCFI106:
 5032              	 .cfi_def_cfa_register 7
 904:../XMC1100-LibHaas.c **** 	 CCU40_CC42->TCSET = 0x1; //starts counting
 5033              	 .loc 3 904 0
 5034 0004 024B     	 ldr r3,.L239
 5035 0006 0122     	 mov r2,#1
 5036 0008 DA60     	 str r2,[r3,#12]
 905:../XMC1100-LibHaas.c **** }
 5037              	 .loc 3 905 0
 5038 000a BD46     	 mov sp,r7
 5039              	 
 5040 000c 80BD     	 pop {r7,pc}
 5041              	.L240:
 5042 000e C046     	 .align 2
 5043              	.L239:
 5044 0010 00030448 	 .word 1208222464
 5045              	 .cfi_endproc
 5046              	.LFE71:
 5048              	 .section .text.pwm3_start_interrupt,"ax",%progbits
 5049              	 .align 2
 5050              	 .global pwm3_start_interrupt
 5051              	 .code 16
 5052              	 .thumb_func
 5054              	pwm3_start_interrupt:
 5055              	.LFB72:
 906:../XMC1100-LibHaas.c **** /*------------------------------------------------------------------
 907:../XMC1100-LibHaas.c **** * PWM3-Ausgang P0.8 Ausgabe starten mit Interrupt nach jeder Periode
 908:../XMC1100-LibHaas.c **** * Diese Timer-ISR ins eigene Programm kopieren
 909:../XMC1100-LibHaas.c **** void CCU40_2_IRQHandler (void)
 910:../XMC1100-LibHaas.c **** {
 911:../XMC1100-LibHaas.c **** 	pwm3_duty_cycle (uint8_t compare); // neuen Comparewert laden
 912:../XMC1100-LibHaas.c **** }
 913:../XMC1100-LibHaas.c **** */
 914:../XMC1100-LibHaas.c **** void pwm3_start_interrupt(void)
 915:../XMC1100-LibHaas.c **** {
 5056              	 .loc 3 915 0
 5057              	 .cfi_startproc
 5058 0000 80B5     	 push {r7,lr}
 5059              	.LCFI107:
 5060              	 .cfi_def_cfa_offset 8
 5061              	 .cfi_offset 7,-8
 5062              	 .cfi_offset 14,-4
 5063 0002 00AF     	 add r7,sp,#0
 5064              	.LCFI108:
 5065              	 .cfi_def_cfa_register 7
 916:../XMC1100-LibHaas.c **** 	CCU40_CC42->TCSET = 0x1; 		//starts counting
 5066              	 .loc 3 916 0
 5067 0004 074B     	 ldr r3,.L242
 5068 0006 0122     	 mov r2,#1
 5069 0008 DA60     	 str r2,[r3,#12]
 917:../XMC1100-LibHaas.c **** 	// Int bei Periode CCU42_CC42 :
 918:../XMC1100-LibHaas.c **** 	CCU40_CC42->INTE |=1 ;			//Int bei Period Match_
 5070              	 .loc 3 918 0
 5071 000a 0649     	 ldr r1,.L242
 5072 000c 054A     	 ldr r2,.L242
 5073 000e A423     	 mov r3,#164
 5074 0010 D358     	 ldr r3,[r2,r3]
 5075 0012 0122     	 mov r2,#1
 5076 0014 1343     	 orr r3,r2
 5077 0016 A422     	 mov r2,#164
 5078 0018 8B50     	 str r3,[r1,r2]
 919:../XMC1100-LibHaas.c **** 	NVIC_EnableIRQ(CCU40_2_IRQn); 	// Int Freigabe für CCU40 => CC42
 5079              	 .loc 3 919 0
 5080 001a 1720     	 mov r0,#23
 5081 001c FFF7FEFF 	 bl __NVIC_EnableIRQ
 920:../XMC1100-LibHaas.c **** }
 5082              	 .loc 3 920 0
 5083 0020 BD46     	 mov sp,r7
 5084              	 
 5085 0022 80BD     	 pop {r7,pc}
 5086              	.L243:
 5087              	 .align 2
 5088              	.L242:
 5089 0024 00030448 	 .word 1208222464
 5090              	 .cfi_endproc
 5091              	.LFE72:
 5093              	 .section .text.pwm4_start,"ax",%progbits
 5094              	 .align 2
 5095              	 .global pwm4_start
 5096              	 .code 16
 5097              	 .thumb_func
 5099              	pwm4_start:
 5100              	.LFB73:
 921:../XMC1100-LibHaas.c **** //----------------------------------------------------------------
 922:../XMC1100-LibHaas.c **** // PWM4-Ausgang P0.9 Ausgabe starten ohne Interrupt starten
 923:../XMC1100-LibHaas.c **** //----------------------------------------------------------------
 924:../XMC1100-LibHaas.c **** void pwm4_start(void)
 925:../XMC1100-LibHaas.c **** {
 5101              	 .loc 3 925 0
 5102              	 .cfi_startproc
 5103 0000 80B5     	 push {r7,lr}
 5104              	.LCFI109:
 5105              	 .cfi_def_cfa_offset 8
 5106              	 .cfi_offset 7,-8
 5107              	 .cfi_offset 14,-4
 5108 0002 00AF     	 add r7,sp,#0
 5109              	.LCFI110:
 5110              	 .cfi_def_cfa_register 7
 926:../XMC1100-LibHaas.c **** 	 CCU40_CC43->TCSET = 0x1; //starts counting
 5111              	 .loc 3 926 0
 5112 0004 024B     	 ldr r3,.L245
 5113 0006 0122     	 mov r2,#1
 5114 0008 DA60     	 str r2,[r3,#12]
 927:../XMC1100-LibHaas.c **** }
 5115              	 .loc 3 927 0
 5116 000a BD46     	 mov sp,r7
 5117              	 
 5118 000c 80BD     	 pop {r7,pc}
 5119              	.L246:
 5120 000e C046     	 .align 2
 5121              	.L245:
 5122 0010 00040448 	 .word 1208222720
 5123              	 .cfi_endproc
 5124              	.LFE73:
 5126              	 .section .text.pwm4_start_interrupt,"ax",%progbits
 5127              	 .align 2
 5128              	 .global pwm4_start_interrupt
 5129              	 .code 16
 5130              	 .thumb_func
 5132              	pwm4_start_interrupt:
 5133              	.LFB74:
 928:../XMC1100-LibHaas.c **** /*------------------------------------------------------------------
 929:../XMC1100-LibHaas.c **** * PWM4-Ausgang P0.9 Ausgabe starten mit Interrupt nach jeder Periode
 930:../XMC1100-LibHaas.c **** * Diese Timer-ISR ins eigene Programm kopieren
 931:../XMC1100-LibHaas.c **** void CCU40_3_IRQHandler (void)
 932:../XMC1100-LibHaas.c **** {
 933:../XMC1100-LibHaas.c **** 	pwm4_duty_cycle (uint8_t compare); // neuen Comparewert laden
 934:../XMC1100-LibHaas.c **** }
 935:../XMC1100-LibHaas.c **** */
 936:../XMC1100-LibHaas.c **** void pwm4_start_interrupt(void)
 937:../XMC1100-LibHaas.c **** {
 5134              	 .loc 3 937 0
 5135              	 .cfi_startproc
 5136 0000 80B5     	 push {r7,lr}
 5137              	.LCFI111:
 5138              	 .cfi_def_cfa_offset 8
 5139              	 .cfi_offset 7,-8
 5140              	 .cfi_offset 14,-4
 5141 0002 00AF     	 add r7,sp,#0
 5142              	.LCFI112:
 5143              	 .cfi_def_cfa_register 7
 938:../XMC1100-LibHaas.c **** 	CCU40_CC43->TCSET = 0x1; 		//starts counting
 5144              	 .loc 3 938 0
 5145 0004 074B     	 ldr r3,.L248
 5146 0006 0122     	 mov r2,#1
 5147 0008 DA60     	 str r2,[r3,#12]
 939:../XMC1100-LibHaas.c **** 	// Int bei Periode CCU40_CC43 :
 940:../XMC1100-LibHaas.c **** 	CCU40_CC43->INTE |=1 ;			//Int bei Period Match_
 5148              	 .loc 3 940 0
 5149 000a 0649     	 ldr r1,.L248
 5150 000c 054A     	 ldr r2,.L248
 5151 000e A423     	 mov r3,#164
 5152 0010 D358     	 ldr r3,[r2,r3]
 5153 0012 0122     	 mov r2,#1
 5154 0014 1343     	 orr r3,r2
 5155 0016 A422     	 mov r2,#164
 5156 0018 8B50     	 str r3,[r1,r2]
 941:../XMC1100-LibHaas.c **** 	NVIC_EnableIRQ(CCU40_3_IRQn); 	// Int Freigabe für CCU40 => CC43
 5157              	 .loc 3 941 0
 5158 001a 1820     	 mov r0,#24
 5159 001c FFF7FEFF 	 bl __NVIC_EnableIRQ
 942:../XMC1100-LibHaas.c **** }
 5160              	 .loc 3 942 0
 5161 0020 BD46     	 mov sp,r7
 5162              	 
 5163 0022 80BD     	 pop {r7,pc}
 5164              	.L249:
 5165              	 .align 2
 5166              	.L248:
 5167 0024 00040448 	 .word 1208222720
 5168              	 .cfi_endproc
 5169              	.LFE74:
 5171              	 .section .text.pwm1_stop,"ax",%progbits
 5172              	 .align 2
 5173              	 .global pwm1_stop
 5174              	 .code 16
 5175              	 .thumb_func
 5177              	pwm1_stop:
 5178              	.LFB75:
 943:../XMC1100-LibHaas.c **** // PWM1 anhalten -----------------------------------------------------
 944:../XMC1100-LibHaas.c **** void pwm1_stop(void)
 945:../XMC1100-LibHaas.c **** {
 5179              	 .loc 3 945 0
 5180              	 .cfi_startproc
 5181 0000 80B5     	 push {r7,lr}
 5182              	.LCFI113:
 5183              	 .cfi_def_cfa_offset 8
 5184              	 .cfi_offset 7,-8
 5185              	 .cfi_offset 14,-4
 5186 0002 00AF     	 add r7,sp,#0
 5187              	.LCFI114:
 5188              	 .cfi_def_cfa_register 7
 946:../XMC1100-LibHaas.c **** 	CCU40_CC40->TCCLR = 0x01;
 5189              	 .loc 3 946 0
 5190 0004 034B     	 ldr r3,.L251
 5191 0006 0122     	 mov r2,#1
 5192 0008 1A61     	 str r2,[r3,#16]
 947:../XMC1100-LibHaas.c **** 	NVIC_DisableIRQ(CCU40_0_IRQn); 	// Int sperren für CCU40 => CC40
 5193              	 .loc 3 947 0
 5194 000a 1520     	 mov r0,#21
 5195 000c FFF7FEFF 	 bl __NVIC_DisableIRQ
 948:../XMC1100-LibHaas.c **** }
 5196              	 .loc 3 948 0
 5197 0010 BD46     	 mov sp,r7
 5198              	 
 5199 0012 80BD     	 pop {r7,pc}
 5200              	.L252:
 5201              	 .align 2
 5202              	.L251:
 5203 0014 00010448 	 .word 1208221952
 5204              	 .cfi_endproc
 5205              	.LFE75:
 5207              	 .section .text.pwm2_stop,"ax",%progbits
 5208              	 .align 2
 5209              	 .global pwm2_stop
 5210              	 .code 16
 5211              	 .thumb_func
 5213              	pwm2_stop:
 5214              	.LFB76:
 949:../XMC1100-LibHaas.c **** // PWM2 anhalten -----------------------------------------------------
 950:../XMC1100-LibHaas.c **** void pwm2_stop(void)
 951:../XMC1100-LibHaas.c **** {
 5215              	 .loc 3 951 0
 5216              	 .cfi_startproc
 5217 0000 80B5     	 push {r7,lr}
 5218              	.LCFI115:
 5219              	 .cfi_def_cfa_offset 8
 5220              	 .cfi_offset 7,-8
 5221              	 .cfi_offset 14,-4
 5222 0002 00AF     	 add r7,sp,#0
 5223              	.LCFI116:
 5224              	 .cfi_def_cfa_register 7
 952:../XMC1100-LibHaas.c **** 	CCU40_CC41->TCCLR = 0x01;
 5225              	 .loc 3 952 0
 5226 0004 034B     	 ldr r3,.L254
 5227 0006 0122     	 mov r2,#1
 5228 0008 1A61     	 str r2,[r3,#16]
 953:../XMC1100-LibHaas.c **** 	NVIC_DisableIRQ(CCU40_1_IRQn); 	// Int sperren für CCU40 => CC41
 5229              	 .loc 3 953 0
 5230 000a 1620     	 mov r0,#22
 5231 000c FFF7FEFF 	 bl __NVIC_DisableIRQ
 954:../XMC1100-LibHaas.c **** }
 5232              	 .loc 3 954 0
 5233 0010 BD46     	 mov sp,r7
 5234              	 
 5235 0012 80BD     	 pop {r7,pc}
 5236              	.L255:
 5237              	 .align 2
 5238              	.L254:
 5239 0014 00020448 	 .word 1208222208
 5240              	 .cfi_endproc
 5241              	.LFE76:
 5243              	 .section .text.pwm3_stop,"ax",%progbits
 5244              	 .align 2
 5245              	 .global pwm3_stop
 5246              	 .code 16
 5247              	 .thumb_func
 5249              	pwm3_stop:
 5250              	.LFB77:
 955:../XMC1100-LibHaas.c **** // PWM3 anhalten -----------------------------------------------------
 956:../XMC1100-LibHaas.c **** void pwm3_stop(void)
 957:../XMC1100-LibHaas.c **** {
 5251              	 .loc 3 957 0
 5252              	 .cfi_startproc
 5253 0000 80B5     	 push {r7,lr}
 5254              	.LCFI117:
 5255              	 .cfi_def_cfa_offset 8
 5256              	 .cfi_offset 7,-8
 5257              	 .cfi_offset 14,-4
 5258 0002 00AF     	 add r7,sp,#0
 5259              	.LCFI118:
 5260              	 .cfi_def_cfa_register 7
 958:../XMC1100-LibHaas.c **** 	CCU40_CC42->TCCLR = 0x01;
 5261              	 .loc 3 958 0
 5262 0004 034B     	 ldr r3,.L257
 5263 0006 0122     	 mov r2,#1
 5264 0008 1A61     	 str r2,[r3,#16]
 959:../XMC1100-LibHaas.c **** 	NVIC_DisableIRQ(CCU40_2_IRQn); 	// Int sperren für CCU40 => CC42
 5265              	 .loc 3 959 0
 5266 000a 1720     	 mov r0,#23
 5267 000c FFF7FEFF 	 bl __NVIC_DisableIRQ
 960:../XMC1100-LibHaas.c **** }
 5268              	 .loc 3 960 0
 5269 0010 BD46     	 mov sp,r7
 5270              	 
 5271 0012 80BD     	 pop {r7,pc}
 5272              	.L258:
 5273              	 .align 2
 5274              	.L257:
 5275 0014 00030448 	 .word 1208222464
 5276              	 .cfi_endproc
 5277              	.LFE77:
 5279              	 .section .text.pwm4_stop,"ax",%progbits
 5280              	 .align 2
 5281              	 .global pwm4_stop
 5282              	 .code 16
 5283              	 .thumb_func
 5285              	pwm4_stop:
 5286              	.LFB78:
 961:../XMC1100-LibHaas.c **** // PWM4 anhalten -----------------------------------------------------
 962:../XMC1100-LibHaas.c **** void pwm4_stop(void)
 963:../XMC1100-LibHaas.c **** {
 5287              	 .loc 3 963 0
 5288              	 .cfi_startproc
 5289 0000 80B5     	 push {r7,lr}
 5290              	.LCFI119:
 5291              	 .cfi_def_cfa_offset 8
 5292              	 .cfi_offset 7,-8
 5293              	 .cfi_offset 14,-4
 5294 0002 00AF     	 add r7,sp,#0
 5295              	.LCFI120:
 5296              	 .cfi_def_cfa_register 7
 964:../XMC1100-LibHaas.c **** 	CCU40_CC43->TCCLR = 0x01;
 5297              	 .loc 3 964 0
 5298 0004 034B     	 ldr r3,.L260
 5299 0006 0122     	 mov r2,#1
 5300 0008 1A61     	 str r2,[r3,#16]
 965:../XMC1100-LibHaas.c **** 	NVIC_DisableIRQ(CCU40_3_IRQn); 	// Int sperren für CCU40 => CC43
 5301              	 .loc 3 965 0
 5302 000a 1820     	 mov r0,#24
 5303 000c FFF7FEFF 	 bl __NVIC_DisableIRQ
 966:../XMC1100-LibHaas.c **** }
 5304              	 .loc 3 966 0
 5305 0010 BD46     	 mov sp,r7
 5306              	 
 5307 0012 80BD     	 pop {r7,pc}
 5308              	.L261:
 5309              	 .align 2
 5310              	.L260:
 5311 0014 00040448 	 .word 1208222720
 5312              	 .cfi_endproc
 5313              	.LFE78:
 5315              	 .section .text.adc_init,"ax",%progbits
 5316              	 .align 2
 5317              	 .global adc_init
 5318              	 .code 16
 5319              	 .thumb_func
 5321              	adc_init:
 5322              	.LFB79:
 967:../XMC1100-LibHaas.c **** 
 968:../XMC1100-LibHaas.c **** 
 969:../XMC1100-LibHaas.c **** // ab hier ADC-Funktionen ****************************************
 970:../XMC1100-LibHaas.c **** 
 971:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
 972:../XMC1100-LibHaas.c **** // Analog-Digital-Converter initialisieren
 973:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
 974:../XMC1100-LibHaas.c **** void adc_init(void)
 975:../XMC1100-LibHaas.c **** {
 5323              	 .loc 3 975 0
 5324              	 .cfi_startproc
 5325 0000 80B5     	 push {r7,lr}
 5326              	.LCFI121:
 5327              	 .cfi_def_cfa_offset 8
 5328              	 .cfi_offset 7,-8
 5329              	 .cfi_offset 14,-4
 5330 0002 00AF     	 add r7,sp,#0
 5331              	.LCFI122:
 5332              	 .cfi_def_cfa_register 7
 976:../XMC1100-LibHaas.c **** 	PORT2->IOCR4 = PORT2->IOCR4 & 0x00000000;	// P2 => INPUT
 5333              	 .loc 3 976 0
 5334 0004 4A4B     	 ldr r3,.L266
 5335 0006 5B69     	 ldr r3,[r3,#20]
 5336 0008 494B     	 ldr r3,.L266
 5337 000a 0022     	 mov r2,#0
 5338 000c 5A61     	 str r2,[r3,#20]
 977:../XMC1100-LibHaas.c **** 	SCU_GENERAL->PASSWD = 0x000000C0UL;			// Modul write enable
 5339              	 .loc 3 977 0
 5340 000e 494B     	 ldr r3,.L266+4
 5341 0010 C022     	 mov r2,#192
 5342 0012 5A62     	 str r2,[r3,#36]
 978:../XMC1100-LibHaas.c **** 	SCU_CLK->CGATCLR0 |= 0x00000001; 			// disable  VADC gating
 5343              	 .loc 3 978 0
 5344 0014 484B     	 ldr r3,.L266+8
 5345 0016 484A     	 ldr r2,.L266+8
 5346 0018 1269     	 ldr r2,[r2,#16]
 5347 001a 0121     	 mov r1,#1
 5348 001c 0A43     	 orr r2,r1
 5349 001e 1A61     	 str r2,[r3,#16]
 979:../XMC1100-LibHaas.c **** 	while (( SCU_CLK->CLKCR)& 0x40000000);		// wait for stabilize
 5350              	 .loc 3 979 0
 5351 0020 C046     	 mov r8,r8
 5352              	.L263:
 5353              	 .loc 3 979 0 is_stmt 0 discriminator 1
 5354 0022 454B     	 ldr r3,.L266+8
 5355 0024 1A68     	 ldr r2,[r3]
 5356 0026 8023     	 mov r3,#128
 5357 0028 DB05     	 lsl r3,r3,#23
 5358 002a 1340     	 and r3,r2
 5359 002c F9D1     	 bne .L263
 980:../XMC1100-LibHaas.c **** 	SCU_GENERAL->PASSWD = 0x000000C3UL;
 5360              	 .loc 3 980 0 is_stmt 1
 5361 002e 414B     	 ldr r3,.L266+4
 5362 0030 C322     	 mov r2,#195
 5363 0032 5A62     	 str r2,[r3,#36]
 981:../XMC1100-LibHaas.c **** 	CLR_BIT(VADC->CLC,0); 						// Clock Enable
 5364              	 .loc 3 981 0
 5365 0034 414B     	 ldr r3,.L266+12
 5366 0036 414A     	 ldr r2,.L266+12
 5367 0038 1268     	 ldr r2,[r2]
 5368 003a 0121     	 mov r1,#1
 5369 003c 8A43     	 bic r2,r1
 5370 003e 1A60     	 str r2,[r3]
 982:../XMC1100-LibHaas.c **** 
 983:../XMC1100-LibHaas.c **** 	SHS0->SHSCFG = 0x00008000 ; 				// SCWC Bit = 1
 5371              	 .loc 3 983 0
 5372 0040 3F4B     	 ldr r3,.L266+16
 5373 0042 8022     	 mov r2,#128
 5374 0044 1202     	 lsl r2,r2,#8
 5375 0046 1A64     	 str r2,[r3,#64]
 984:../XMC1100-LibHaas.c **** 	//SET_BIT (SHS0->SHSCFG,15); => geht nicht !!
 985:../XMC1100-LibHaas.c **** 	CLR_BIT (SHS0->SHSCFG,12);  				// ANOFF = 0
 5376              	 .loc 3 985 0
 5377 0048 3D4B     	 ldr r3,.L266+16
 5378 004a 3D4A     	 ldr r2,.L266+16
 5379 004c 126C     	 ldr r2,[r2,#64]
 5380 004e 3D49     	 ldr r1,.L266+20
 5381 0050 0A40     	 and r2,r1
 5382 0052 1A64     	 str r2,[r3,#64]
 986:../XMC1100-LibHaas.c **** 	SET_BIT (SHS0->SHSCFG,11); 					// int. Uref
 5383              	 .loc 3 986 0
 5384 0054 3A4B     	 ldr r3,.L266+16
 5385 0056 3A4A     	 ldr r2,.L266+16
 5386 0058 126C     	 ldr r2,[r2,#64]
 5387 005a 8021     	 mov r1,#128
 5388 005c 0901     	 lsl r1,r1,#4
 5389 005e 0A43     	 orr r2,r1
 5390 0060 1A64     	 str r2,[r3,#64]
 987:../XMC1100-LibHaas.c **** 	*((int*)0x40010500)= 0x01;					// Toggle on => workarond
 5391              	 .loc 3 987 0
 5392 0062 394B     	 ldr r3,.L266+24
 5393 0064 0122     	 mov r2,#1
 5394 0066 1A60     	 str r2,[r3]
 988:../XMC1100-LibHaas.c **** 	//VADC_Start = 0x00000001;					// Zusatz Bit für Start
 989:../XMC1100-LibHaas.c **** 	while ( (SHS0->SHSCFG & 0x00004000) == 0);	// Warte auf ready
 5395              	 .loc 3 989 0
 5396 0068 C046     	 mov r8,r8
 5397              	.L264:
 5398              	 .loc 3 989 0 is_stmt 0 discriminator 1
 5399 006a 354B     	 ldr r3,.L266+16
 5400 006c 1A6C     	 ldr r2,[r3,#64]
 5401 006e 8023     	 mov r3,#128
 5402 0070 DB01     	 lsl r3,r3,#7
 5403 0072 1340     	 and r3,r2
 5404 0074 F9D0     	 beq .L264
 990:../XMC1100-LibHaas.c ****     //--------------Kalibrierung
 991:../XMC1100-LibHaas.c **** 	 // VADC->GLOBCFG &= ~VADC_GLOBCFG_DPCAL0_Msk;    // Enable post-calibration.
 992:../XMC1100-LibHaas.c **** 	  // workaround for calibration
 993:../XMC1100-LibHaas.c **** 	  VADC->GLOBCFG |= VADC_GLOBCFG_DPCAL0_Msk;
 5405              	 .loc 3 993 0 is_stmt 1
 5406 0076 3149     	 ldr r1,.L266+12
 5407 0078 304A     	 ldr r2,.L266+12
 5408 007a 8023     	 mov r3,#128
 5409 007c D358     	 ldr r3,[r2,r3]
 5410 007e 8022     	 mov r2,#128
 5411 0080 5202     	 lsl r2,r2,#9
 5412 0082 1343     	 orr r3,r2
 5413 0084 8022     	 mov r2,#128
 5414 0086 8B50     	 str r3,[r1,r2]
 994:../XMC1100-LibHaas.c **** 	  VADC->GLOBCFG |= VADC_GLOBCFG_DPCAL1_Msk;
 5415              	 .loc 3 994 0
 5416 0088 2C49     	 ldr r1,.L266+12
 5417 008a 2C4A     	 ldr r2,.L266+12
 5418 008c 8023     	 mov r3,#128
 5419 008e D358     	 ldr r3,[r2,r3]
 5420 0090 8022     	 mov r2,#128
 5421 0092 9202     	 lsl r2,r2,#10
 5422 0094 1343     	 orr r3,r2
 5423 0096 8022     	 mov r2,#128
 5424 0098 8B50     	 str r3,[r1,r2]
 995:../XMC1100-LibHaas.c **** 	  VADC->GLOBCFG &= ~VADC_GLOBCFG_SUCAL_Msk;      // Raising edge on SUCAL to initiate the calibrat
 5425              	 .loc 3 995 0
 5426 009a 2849     	 ldr r1,.L266+12
 5427 009c 274A     	 ldr r2,.L266+12
 5428 009e 8023     	 mov r3,#128
 5429 00a0 D358     	 ldr r3,[r2,r3]
 5430 00a2 5B00     	 lsl r3,r3,#1
 5431 00a4 5B08     	 lsr r3,r3,#1
 5432 00a6 8022     	 mov r2,#128
 5433 00a8 8B50     	 str r3,[r1,r2]
 996:../XMC1100-LibHaas.c **** 	  VADC->GLOBCFG |= VADC_GLOBCFG_SUCAL_Msk;
 5434              	 .loc 3 996 0
 5435 00aa 2449     	 ldr r1,.L266+12
 5436 00ac 234A     	 ldr r2,.L266+12
 5437 00ae 8023     	 mov r3,#128
 5438 00b0 D358     	 ldr r3,[r2,r3]
 5439 00b2 8022     	 mov r2,#128
 5440 00b4 1206     	 lsl r2,r2,#24
 5441 00b6 1343     	 orr r3,r2
 5442 00b8 8022     	 mov r2,#128
 5443 00ba 8B50     	 str r3,[r1,r2]
 997:../XMC1100-LibHaas.c **** 	  // workaround for calibration
 998:../XMC1100-LibHaas.c **** 	  VADC->GLOBCFG |= VADC_GLOBCFG_DPCAL0_Msk;
 5444              	 .loc 3 998 0
 5445 00bc 1F49     	 ldr r1,.L266+12
 5446 00be 1F4A     	 ldr r2,.L266+12
 5447 00c0 8023     	 mov r3,#128
 5448 00c2 D358     	 ldr r3,[r2,r3]
 5449 00c4 8022     	 mov r2,#128
 5450 00c6 5202     	 lsl r2,r2,#9
 5451 00c8 1343     	 orr r3,r2
 5452 00ca 8022     	 mov r2,#128
 5453 00cc 8B50     	 str r3,[r1,r2]
 999:../XMC1100-LibHaas.c **** 	  VADC->GLOBCFG |= VADC_GLOBCFG_DPCAL1_Msk;
 5454              	 .loc 3 999 0
 5455 00ce 1B49     	 ldr r1,.L266+12
 5456 00d0 1A4A     	 ldr r2,.L266+12
 5457 00d2 8023     	 mov r3,#128
 5458 00d4 D358     	 ldr r3,[r2,r3]
 5459 00d6 8022     	 mov r2,#128
 5460 00d8 9202     	 lsl r2,r2,#10
 5461 00da 1343     	 orr r3,r2
 5462 00dc 8022     	 mov r2,#128
 5463 00de 8B50     	 str r3,[r1,r2]
1000:../XMC1100-LibHaas.c **** 	  while ((SHS0->SHSCFG & SHS_SHSCFG_STATE_Msk) != 0);  // Wait until calibration is finished.
 5464              	 .loc 3 1000 0
 5465 00e0 C046     	 mov r8,r8
 5466              	.L265:
 5467              	 .loc 3 1000 0 is_stmt 0 discriminator 1
 5468 00e2 174B     	 ldr r3,.L266+16
 5469 00e4 1B6C     	 ldr r3,[r3,#64]
 5470 00e6 1B0F     	 lsr r3,r3,#28
 5471 00e8 1B07     	 lsl r3,r3,#28
 5472 00ea FAD1     	 bne .L265
1001:../XMC1100-LibHaas.c **** 	  *((int*)0x480340E0) = 0x80008000;
 5473              	 .loc 3 1001 0 is_stmt 1
 5474 00ec 174B     	 ldr r3,.L266+28
 5475 00ee 184A     	 ldr r2,.L266+32
 5476 00f0 1A60     	 str r2,[r3]
1002:../XMC1100-LibHaas.c **** 	  *((int*)0x480340E4) = 0x80008000;
 5477              	 .loc 3 1002 0
 5478 00f2 184B     	 ldr r3,.L266+36
 5479 00f4 164A     	 ldr r2,.L266+32
 5480 00f6 1A60     	 str r2,[r3]
1003:../XMC1100-LibHaas.c **** 	//--------------Ende Kalibrierung
1004:../XMC1100-LibHaas.c **** 	SET_BIT (VADC->BRSMR,0);					// Conv Request => pending Bit
 5481              	 .loc 3 1004 0
 5482 00f8 1049     	 ldr r1,.L266+12
 5483 00fa 104A     	 ldr r2,.L266+12
 5484 00fc 8123     	 mov r3,#129
 5485 00fe 9B00     	 lsl r3,r3,#2
 5486 0100 D358     	 ldr r3,[r2,r3]
 5487 0102 0122     	 mov r2,#1
 5488 0104 1A43     	 orr r2,r3
 5489 0106 8123     	 mov r3,#129
 5490 0108 9B00     	 lsl r3,r3,#2
 5491 010a CA50     	 str r2,[r1,r3]
1005:../XMC1100-LibHaas.c **** 	VADC->BRSCTRL = 0x00000000;					// kein ext. Trigger
 5492              	 .loc 3 1005 0
 5493 010c 0B4A     	 ldr r2,.L266+12
 5494 010e 8023     	 mov r3,#128
 5495 0110 9B00     	 lsl r3,r3,#2
 5496 0112 0021     	 mov r1,#0
 5497 0114 D150     	 str r1,[r2,r3]
1006:../XMC1100-LibHaas.c **** 	SET_BIT(VADC->BRSSEL[0],0)  ;				// Kanal 0
 5498              	 .loc 3 1006 0
 5499 0116 0949     	 ldr r1,.L266+12
 5500 0118 084A     	 ldr r2,.L266+12
 5501 011a C023     	 mov r3,#192
 5502 011c 5B00     	 lsl r3,r3,#1
 5503 011e D358     	 ldr r3,[r2,r3]
 5504 0120 0122     	 mov r2,#1
 5505 0122 1A43     	 orr r2,r3
 5506 0124 C023     	 mov r3,#192
 5507 0126 5B00     	 lsl r3,r3,#1
 5508 0128 CA50     	 str r2,[r1,r3]
1007:../XMC1100-LibHaas.c **** }
 5509              	 .loc 3 1007 0
 5510 012a BD46     	 mov sp,r7
 5511              	 
 5512 012c 80BD     	 pop {r7,pc}
 5513              	.L267:
 5514 012e C046     	 .align 2
 5515              	.L266:
 5516 0130 00020440 	 .word 1074004480
 5517 0134 00000140 	 .word 1073807360
 5518 0138 00030140 	 .word 1073808128
 5519 013c 00000348 	 .word 1208156160
 5520 0140 00400348 	 .word 1208172544
 5521 0144 FFEFFFFF 	 .word -4097
 5522 0148 00050140 	 .word 1073808640
 5523 014c E0400348 	 .word 1208172768
 5524 0150 00800080 	 .word -2147450880
 5525 0154 E4400348 	 .word 1208172772
 5526              	 .cfi_endproc
 5527              	.LFE79:
 5529              	 .global __aeabi_uidivmod
 5530              	 .section .text.adc_in,"ax",%progbits
 5531              	 .align 2
 5532              	 .global adc_in
 5533              	 .code 16
 5534              	 .thumb_func
 5536              	adc_in:
 5537              	.LFB80:
1008:../XMC1100-LibHaas.c **** 
1009:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
1010:../XMC1100-LibHaas.c **** // 12-Bit-Wert vom Analogeingang einlesen
1011:../XMC1100-LibHaas.c **** // Kanal 0: Poti links, 1: Poti rechts, 2: P2.9, 3: P2.10, 4: P2.11, 7: P2.2
1012:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
1013:../XMC1100-LibHaas.c **** uint16_t adc_in(uint8_t kanal)
1014:../XMC1100-LibHaas.c **** 
1015:../XMC1100-LibHaas.c **** {
 5538              	 .loc 3 1015 0
 5539              	 .cfi_startproc
 5540 0000 90B5     	 push {r4,r7,lr}
 5541              	.LCFI123:
 5542              	 .cfi_def_cfa_offset 12
 5543              	 .cfi_offset 4,-12
 5544              	 .cfi_offset 7,-8
 5545              	 .cfi_offset 14,-4
 5546 0002 83B0     	 sub sp,sp,#12
 5547              	.LCFI124:
 5548              	 .cfi_def_cfa_offset 24
 5549 0004 00AF     	 add r7,sp,#0
 5550              	.LCFI125:
 5551              	 .cfi_def_cfa_register 7
 5552 0006 021C     	 mov r2,r0
 5553 0008 FB1D     	 add r3,r7,#7
 5554 000a 1A70     	 strb r2,[r3]
1016:../XMC1100-LibHaas.c **** 	kanal %=7;									// max Kanal 7
 5555              	 .loc 3 1016 0
 5556 000c FC1D     	 add r4,r7,#7
 5557 000e FB1D     	 add r3,r7,#7
 5558 0010 1B78     	 ldrb r3,[r3]
 5559 0012 181C     	 mov r0,r3
 5560 0014 0721     	 mov r1,#7
 5561 0016 FFF7FEFF 	 bl __aeabi_uidivmod
 5562 001a 0B1C     	 mov r3,r1
 5563 001c 2370     	 strb r3,[r4]
1017:../XMC1100-LibHaas.c **** 	VADC->BRSPND[0]  = 1 << kanal;				// Pending Kanal 0.. 8
 5564              	 .loc 3 1017 0
 5565 001e 134A     	 ldr r2,.L271
 5566 0020 FB1D     	 add r3,r7,#7
 5567 0022 1B78     	 ldrb r3,[r3]
 5568 0024 0121     	 mov r1,#1
 5569 0026 9940     	 lsl r1,r1,r3
 5570 0028 0B1C     	 mov r3,r1
 5571 002a 191C     	 mov r1,r3
 5572 002c E023     	 mov r3,#224
 5573 002e 5B00     	 lsl r3,r3,#1
 5574 0030 D150     	 str r1,[r2,r3]
1018:../XMC1100-LibHaas.c **** 	while ((VADC->GLOBRES & 0x80000000) == 0 );	// Abfrage VF Bit
 5575              	 .loc 3 1018 0
 5576 0032 C046     	 mov r8,r8
 5577              	.L269:
 5578              	 .loc 3 1018 0 is_stmt 0 discriminator 1
 5579 0034 0D4A     	 ldr r2,.L271
 5580 0036 C023     	 mov r3,#192
 5581 0038 9B00     	 lsl r3,r3,#2
 5582 003a D358     	 ldr r3,[r2,r3]
 5583 003c 002B     	 cmp r3,#0
 5584 003e F9DA     	 bge .L269
1019:../XMC1100-LibHaas.c **** 	CLR_BIT(VADC->GLOBRES,31);					// Clear VF Bit
 5585              	 .loc 3 1019 0 is_stmt 1
 5586 0040 0A49     	 ldr r1,.L271
 5587 0042 0A4A     	 ldr r2,.L271
 5588 0044 C023     	 mov r3,#192
 5589 0046 9B00     	 lsl r3,r3,#2
 5590 0048 D358     	 ldr r3,[r2,r3]
 5591 004a 5B00     	 lsl r3,r3,#1
 5592 004c 5A08     	 lsr r2,r3,#1
 5593 004e C023     	 mov r3,#192
 5594 0050 9B00     	 lsl r3,r3,#2
 5595 0052 CA50     	 str r2,[r1,r3]
1020:../XMC1100-LibHaas.c **** 	return (VADC->GLOBRES & 0x00000fff);		// 12 Bit Ergebnis
 5596              	 .loc 3 1020 0
 5597 0054 054A     	 ldr r2,.L271
 5598 0056 C023     	 mov r3,#192
 5599 0058 9B00     	 lsl r3,r3,#2
 5600 005a D358     	 ldr r3,[r2,r3]
 5601 005c 9BB2     	 uxth r3,r3
 5602 005e 1B05     	 lsl r3,r3,#20
 5603 0060 1B0D     	 lsr r3,r3,#20
 5604 0062 9BB2     	 uxth r3,r3
1021:../XMC1100-LibHaas.c **** }
 5605              	 .loc 3 1021 0
 5606 0064 181C     	 mov r0,r3
 5607 0066 BD46     	 mov sp,r7
 5608 0068 03B0     	 add sp,sp,#12
 5609              	 
 5610 006a 90BD     	 pop {r4,r7,pc}
 5611              	.L272:
 5612              	 .align 2
 5613              	.L271:
 5614 006c 00000348 	 .word 1208156160
 5615              	 .cfi_endproc
 5616              	.LFE80:
 5618              	 .section .text.delay_10us,"ax",%progbits
 5619              	 .align 2
 5620              	 .global delay_10us
 5621              	 .code 16
 5622              	 .thumb_func
 5624              	delay_10us:
 5625              	.LFB81:
1022:../XMC1100-LibHaas.c **** // Delays ********************************************************
1023:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
1024:../XMC1100-LibHaas.c **** void delay_10us (uint8_t n)
1025:../XMC1100-LibHaas.c **** {
 5626              	 .loc 3 1025 0
 5627              	 .cfi_startproc
 5628 0000 80B5     	 push {r7,lr}
 5629              	.LCFI126:
 5630              	 .cfi_def_cfa_offset 8
 5631              	 .cfi_offset 7,-8
 5632              	 .cfi_offset 14,-4
 5633 0002 84B0     	 sub sp,sp,#16
 5634              	.LCFI127:
 5635              	 .cfi_def_cfa_offset 24
 5636 0004 00AF     	 add r7,sp,#0
 5637              	.LCFI128:
 5638              	 .cfi_def_cfa_register 7
 5639 0006 021C     	 mov r2,r0
 5640 0008 FB1D     	 add r3,r7,#7
 5641 000a 1A70     	 strb r2,[r3]
1026:../XMC1100-LibHaas.c **** 	volatile uint16_t z;
1027:../XMC1100-LibHaas.c **** 	for (;n != 0;--n)
 5642              	 .loc 3 1027 0
 5643 000c 18E0     	 b .L274
 5644              	.L277:
1028:../XMC1100-LibHaas.c **** 			for (z = 10; 	z!= 0; 	--z); // 10 zu lang, 9 zu kurz
 5645              	 .loc 3 1028 0
 5646 000e 0E23     	 mov r3,#14
 5647 0010 FB18     	 add r3,r7,r3
 5648 0012 0A22     	 mov r2,#10
 5649 0014 1A80     	 strh r2,[r3]
 5650 0016 08E0     	 b .L275
 5651              	.L276:
 5652              	 .loc 3 1028 0 is_stmt 0 discriminator 3
 5653 0018 0E23     	 mov r3,#14
 5654 001a FB18     	 add r3,r7,r3
 5655 001c 1B88     	 ldrh r3,[r3]
 5656 001e 9BB2     	 uxth r3,r3
 5657 0020 013B     	 sub r3,r3,#1
 5658 0022 9AB2     	 uxth r2,r3
 5659 0024 0E23     	 mov r3,#14
 5660 0026 FB18     	 add r3,r7,r3
 5661 0028 1A80     	 strh r2,[r3]
 5662              	.L275:
 5663              	 .loc 3 1028 0 discriminator 1
 5664 002a 0E23     	 mov r3,#14
 5665 002c FB18     	 add r3,r7,r3
 5666 002e 1B88     	 ldrh r3,[r3]
 5667 0030 9BB2     	 uxth r3,r3
 5668 0032 002B     	 cmp r3,#0
 5669 0034 F0D1     	 bne .L276
1027:../XMC1100-LibHaas.c **** 			for (z = 10; 	z!= 0; 	--z); // 10 zu lang, 9 zu kurz
 5670              	 .loc 3 1027 0 is_stmt 1
 5671 0036 FB1D     	 add r3,r7,#7
 5672 0038 FA1D     	 add r2,r7,#7
 5673 003a 1278     	 ldrb r2,[r2]
 5674 003c 013A     	 sub r2,r2,#1
 5675 003e 1A70     	 strb r2,[r3]
 5676              	.L274:
1027:../XMC1100-LibHaas.c **** 			for (z = 10; 	z!= 0; 	--z); // 10 zu lang, 9 zu kurz
 5677              	 .loc 3 1027 0 is_stmt 0 discriminator 1
 5678 0040 FB1D     	 add r3,r7,#7
 5679 0042 1B78     	 ldrb r3,[r3]
 5680 0044 002B     	 cmp r3,#0
 5681 0046 E2D1     	 bne .L277
1029:../XMC1100-LibHaas.c **** }
 5682              	 .loc 3 1029 0 is_stmt 1
 5683 0048 BD46     	 mov sp,r7
 5684 004a 04B0     	 add sp,sp,#16
 5685              	 
 5686 004c 80BD     	 pop {r7,pc}
 5687              	 .cfi_endproc
 5688              	.LFE81:
 5690 004e C046     	 .section .text.delay_100us,"ax",%progbits
 5691              	 .align 2
 5692              	 .global delay_100us
 5693              	 .code 16
 5694              	 .thumb_func
 5696              	delay_100us:
 5697              	.LFB82:
1030:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
1031:../XMC1100-LibHaas.c **** // Zeitverzögerung n mal 100µs
1032:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
1033:../XMC1100-LibHaas.c **** void delay_100us (uint8_t n)
1034:../XMC1100-LibHaas.c **** {
 5698              	 .loc 3 1034 0
 5699              	 .cfi_startproc
 5700 0000 80B5     	 push {r7,lr}
 5701              	.LCFI129:
 5702              	 .cfi_def_cfa_offset 8
 5703              	 .cfi_offset 7,-8
 5704              	 .cfi_offset 14,-4
 5705 0002 84B0     	 sub sp,sp,#16
 5706              	.LCFI130:
 5707              	 .cfi_def_cfa_offset 24
 5708 0004 00AF     	 add r7,sp,#0
 5709              	.LCFI131:
 5710              	 .cfi_def_cfa_register 7
 5711 0006 021C     	 mov r2,r0
 5712 0008 FB1D     	 add r3,r7,#7
 5713 000a 1A70     	 strb r2,[r3]
1035:../XMC1100-LibHaas.c **** 	volatile uint16_t z;
1036:../XMC1100-LibHaas.c **** 	for (;n != 0;--n)
 5714              	 .loc 3 1036 0
 5715 000c 18E0     	 b .L279
 5716              	.L282:
1037:../XMC1100-LibHaas.c **** 		for (z = _T_CONST_; 	z!= 0; 	--z);
 5717              	 .loc 3 1037 0
 5718 000e 0E23     	 mov r3,#14
 5719 0010 FB18     	 add r3,r7,r3
 5720 0012 6D22     	 mov r2,#109
 5721 0014 1A80     	 strh r2,[r3]
 5722 0016 08E0     	 b .L280
 5723              	.L281:
 5724              	 .loc 3 1037 0 is_stmt 0 discriminator 3
 5725 0018 0E23     	 mov r3,#14
 5726 001a FB18     	 add r3,r7,r3
 5727 001c 1B88     	 ldrh r3,[r3]
 5728 001e 9BB2     	 uxth r3,r3
 5729 0020 013B     	 sub r3,r3,#1
 5730 0022 9AB2     	 uxth r2,r3
 5731 0024 0E23     	 mov r3,#14
 5732 0026 FB18     	 add r3,r7,r3
 5733 0028 1A80     	 strh r2,[r3]
 5734              	.L280:
 5735              	 .loc 3 1037 0 discriminator 1
 5736 002a 0E23     	 mov r3,#14
 5737 002c FB18     	 add r3,r7,r3
 5738 002e 1B88     	 ldrh r3,[r3]
 5739 0030 9BB2     	 uxth r3,r3
 5740 0032 002B     	 cmp r3,#0
 5741 0034 F0D1     	 bne .L281
1036:../XMC1100-LibHaas.c **** 		for (z = _T_CONST_; 	z!= 0; 	--z);
 5742              	 .loc 3 1036 0 is_stmt 1
 5743 0036 FB1D     	 add r3,r7,#7
 5744 0038 FA1D     	 add r2,r7,#7
 5745 003a 1278     	 ldrb r2,[r2]
 5746 003c 013A     	 sub r2,r2,#1
 5747 003e 1A70     	 strb r2,[r3]
 5748              	.L279:
1036:../XMC1100-LibHaas.c **** 		for (z = _T_CONST_; 	z!= 0; 	--z);
 5749              	 .loc 3 1036 0 is_stmt 0 discriminator 1
 5750 0040 FB1D     	 add r3,r7,#7
 5751 0042 1B78     	 ldrb r3,[r3]
 5752 0044 002B     	 cmp r3,#0
 5753 0046 E2D1     	 bne .L282
1038:../XMC1100-LibHaas.c **** }
 5754              	 .loc 3 1038 0 is_stmt 1
 5755 0048 BD46     	 mov sp,r7
 5756 004a 04B0     	 add sp,sp,#16
 5757              	 
 5758 004c 80BD     	 pop {r7,pc}
 5759              	 .cfi_endproc
 5760              	.LFE82:
 5762 004e C046     	 .section .text.delay_ms,"ax",%progbits
 5763              	 .align 2
 5764              	 .global delay_ms
 5765              	 .code 16
 5766              	 .thumb_func
 5768              	delay_ms:
 5769              	.LFB83:
1039:../XMC1100-LibHaas.c **** 
1040:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
1041:../XMC1100-LibHaas.c **** // Zeitverzögerung Millisekunden
1042:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
1043:../XMC1100-LibHaas.c **** void delay_ms( uint16_t millisekunden)
1044:../XMC1100-LibHaas.c **** {
 5770              	 .loc 3 1044 0
 5771              	 .cfi_startproc
 5772 0000 80B5     	 push {r7,lr}
 5773              	.LCFI132:
 5774              	 .cfi_def_cfa_offset 8
 5775              	 .cfi_offset 7,-8
 5776              	 .cfi_offset 14,-4
 5777 0002 84B0     	 sub sp,sp,#16
 5778              	.LCFI133:
 5779              	 .cfi_def_cfa_offset 24
 5780 0004 00AF     	 add r7,sp,#0
 5781              	.LCFI134:
 5782              	 .cfi_def_cfa_register 7
 5783 0006 021C     	 mov r2,r0
 5784 0008 BB1D     	 add r3,r7,#6
 5785 000a 1A80     	 strh r2,[r3]
1045:../XMC1100-LibHaas.c **** 	volatile uint16_t n = 0;
 5786              	 .loc 3 1045 0
 5787 000c 0E23     	 mov r3,#14
 5788 000e FB18     	 add r3,r7,r3
 5789 0010 0022     	 mov r2,#0
 5790 0012 1A80     	 strh r2,[r3]
1046:../XMC1100-LibHaas.c **** 
1047:../XMC1100-LibHaas.c **** 	while(n < millisekunden)
 5791              	 .loc 3 1047 0
 5792 0014 0BE0     	 b .L284
 5793              	.L285:
1048:../XMC1100-LibHaas.c **** 	{
1049:../XMC1100-LibHaas.c **** 		delay_100us(10);
 5794              	 .loc 3 1049 0
 5795 0016 0A20     	 mov r0,#10
 5796 0018 FFF7FEFF 	 bl delay_100us
1050:../XMC1100-LibHaas.c **** 		n++;
 5797              	 .loc 3 1050 0
 5798 001c 0E23     	 mov r3,#14
 5799 001e FB18     	 add r3,r7,r3
 5800 0020 1B88     	 ldrh r3,[r3]
 5801 0022 9BB2     	 uxth r3,r3
 5802 0024 0133     	 add r3,r3,#1
 5803 0026 9AB2     	 uxth r2,r3
 5804 0028 0E23     	 mov r3,#14
 5805 002a FB18     	 add r3,r7,r3
 5806 002c 1A80     	 strh r2,[r3]
 5807              	.L284:
1047:../XMC1100-LibHaas.c **** 	{
 5808              	 .loc 3 1047 0
 5809 002e 0E23     	 mov r3,#14
 5810 0030 FB18     	 add r3,r7,r3
 5811 0032 1B88     	 ldrh r3,[r3]
 5812 0034 9BB2     	 uxth r3,r3
 5813 0036 BA1D     	 add r2,r7,#6
 5814 0038 1288     	 ldrh r2,[r2]
 5815 003a 9A42     	 cmp r2,r3
 5816 003c EBD8     	 bhi .L285
1051:../XMC1100-LibHaas.c **** 	}
1052:../XMC1100-LibHaas.c **** }
 5817              	 .loc 3 1052 0
 5818 003e BD46     	 mov sp,r7
 5819 0040 04B0     	 add sp,sp,#16
 5820              	 
 5821 0042 80BD     	 pop {r7,pc}
 5822              	 .cfi_endproc
 5823              	.LFE83:
 5825              	 .section .text.i2c_delay,"ax",%progbits
 5826              	 .align 2
 5827              	 .global i2c_delay
 5828              	 .code 16
 5829              	 .thumb_func
 5831              	i2c_delay:
 5832              	.LFB84:
1053:../XMC1100-LibHaas.c **** 
1054:../XMC1100-LibHaas.c **** //void delay_s(uint16_t sekunden)
1055:../XMC1100-LibHaas.c **** //{
1056:../XMC1100-LibHaas.c **** //	volatile uint16_t n = 0;
1057:../XMC1100-LibHaas.c **** //
1058:../XMC1100-LibHaas.c **** //	while(n < sekunden)
1059:../XMC1100-LibHaas.c **** //	{
1060:../XMC1100-LibHaas.c **** //		delay_ms(1000);
1061:../XMC1100-LibHaas.c **** //		n++;
1062:../XMC1100-LibHaas.c **** //	}
1063:../XMC1100-LibHaas.c **** //}
1064:../XMC1100-LibHaas.c **** 
1065:../XMC1100-LibHaas.c **** // ****************************************************************************
1066:../XMC1100-LibHaas.c **** // I2C- Routinen zur Ansteuerung eins I2C-Slaves
1067:../XMC1100-LibHaas.c **** // I2C-Bus-Funktionen i2c_init, i2c_start, i2c_stop, i2c_write, i2c_read
1068:../XMC1100-LibHaas.c **** // ****************************************************************************
1069:../XMC1100-LibHaas.c **** 
1070:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
1071:../XMC1100-LibHaas.c **** // **** Zeitverzoegerung zur Verlangsamung der Datenuebertragungsrate ***********
1072:../XMC1100-LibHaas.c **** // **** i=2 bis i=100 waehlen je nach I2C-IC und Pull-Up-Widerstand
1073:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
1074:../XMC1100-LibHaas.c **** void i2c_delay(void)
1075:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
1076:../XMC1100-LibHaas.c **** {
 5833              	 .loc 3 1076 0
 5834              	 .cfi_startproc
 5835 0000 80B5     	 push {r7,lr}
 5836              	.LCFI135:
 5837              	 .cfi_def_cfa_offset 8
 5838              	 .cfi_offset 7,-8
 5839              	 .cfi_offset 14,-4
 5840 0002 82B0     	 sub sp,sp,#8
 5841              	.LCFI136:
 5842              	 .cfi_def_cfa_offset 16
 5843 0004 00AF     	 add r7,sp,#0
 5844              	.LCFI137:
 5845              	 .cfi_def_cfa_register 7
1077:../XMC1100-LibHaas.c ****   volatile uint8_t i;	         // i nicht rausoptimieren (volatile)!!
1078:../XMC1100-LibHaas.c ****   for (i=10;i!=0;i--);
 5846              	 .loc 3 1078 0
 5847 0006 FB1D     	 add r3,r7,#7
 5848 0008 0A22     	 mov r2,#10
 5849 000a 1A70     	 strb r2,[r3]
 5850 000c 06E0     	 b .L287
 5851              	.L288:
 5852              	 .loc 3 1078 0 is_stmt 0 discriminator 3
 5853 000e FB1D     	 add r3,r7,#7
 5854 0010 1B78     	 ldrb r3,[r3]
 5855 0012 DBB2     	 uxtb r3,r3
 5856 0014 013B     	 sub r3,r3,#1
 5857 0016 DAB2     	 uxtb r2,r3
 5858 0018 FB1D     	 add r3,r7,#7
 5859 001a 1A70     	 strb r2,[r3]
 5860              	.L287:
 5861              	 .loc 3 1078 0 discriminator 1
 5862 001c FB1D     	 add r3,r7,#7
 5863 001e 1B78     	 ldrb r3,[r3]
 5864 0020 DBB2     	 uxtb r3,r3
 5865 0022 002B     	 cmp r3,#0
 5866 0024 F3D1     	 bne .L288
1079:../XMC1100-LibHaas.c **** }
 5867              	 .loc 3 1079 0 is_stmt 1
 5868 0026 BD46     	 mov sp,r7
 5869 0028 02B0     	 add sp,sp,#8
 5870              	 
 5871 002a 80BD     	 pop {r7,pc}
 5872              	 .cfi_endproc
 5873              	.LFE84:
 5875              	 .section .text.i2c_init,"ax",%progbits
 5876              	 .align 2
 5877              	 .global i2c_init
 5878              	 .code 16
 5879              	 .thumb_func
 5881              	i2c_init:
 5882              	.LFB85:
1080:../XMC1100-LibHaas.c **** 
1081:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
1082:../XMC1100-LibHaas.c **** // Initialiserung I2C-Bus
1083:../XMC1100-LibHaas.c **** // SDA P1.0, SCL P1.1
1084:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
1085:../XMC1100-LibHaas.c **** void i2c_init (void)
1086:../XMC1100-LibHaas.c **** {
 5883              	 .loc 3 1086 0
 5884              	 .cfi_startproc
 5885 0000 80B5     	 push {r7,lr}
 5886              	.LCFI138:
 5887              	 .cfi_def_cfa_offset 8
 5888              	 .cfi_offset 7,-8
 5889              	 .cfi_offset 14,-4
 5890 0002 00AF     	 add r7,sp,#0
 5891              	.LCFI139:
 5892              	 .cfi_def_cfa_register 7
1087:../XMC1100-LibHaas.c ****   I2C_DIR |= SDA_OUT; 			// SDA => Pn.0
 5893              	 .loc 3 1087 0
 5894 0004 0F4B     	 ldr r3,.L290
 5895 0006 0F4A     	 ldr r2,.L290
 5896 0008 5269     	 ldr r2,[r2,#20]
 5897 000a C021     	 mov r1,#192
 5898 000c 0A43     	 orr r2,r1
 5899 000e 5A61     	 str r2,[r3,#20]
1088:../XMC1100-LibHaas.c ****   I2C_DIR |= SCL_OUT;			//SCL => OUT
 5900              	 .loc 3 1088 0
 5901 0010 0C4B     	 ldr r3,.L290
 5902 0012 0C4A     	 ldr r2,.L290
 5903 0014 5269     	 ldr r2,[r2,#20]
 5904 0016 8021     	 mov r1,#128
 5905 0018 0902     	 lsl r1,r1,#8
 5906 001a 0A43     	 orr r2,r1
 5907 001c 5A61     	 str r2,[r3,#20]
1089:../XMC1100-LibHaas.c ****   I2C_PORT_OUT |= (1<<SDA);   	// Leitungen in den Grundzustand High
 5908              	 .loc 3 1089 0
 5909 001e 094B     	 ldr r3,.L290
 5910 0020 084A     	 ldr r2,.L290
 5911 0022 1268     	 ldr r2,[r2]
 5912 0024 1021     	 mov r1,#16
 5913 0026 0A43     	 orr r2,r1
 5914 0028 1A60     	 str r2,[r3]
1090:../XMC1100-LibHaas.c ****   i2c_delay();
 5915              	 .loc 3 1090 0
 5916 002a FFF7FEFF 	 bl i2c_delay
1091:../XMC1100-LibHaas.c ****   I2C_PORT_OUT |= (1<<SCL);
 5917              	 .loc 3 1091 0
 5918 002e 054B     	 ldr r3,.L290
 5919 0030 044A     	 ldr r2,.L290
 5920 0032 1268     	 ldr r2,[r2]
 5921 0034 2021     	 mov r1,#32
 5922 0036 0A43     	 orr r2,r1
 5923 0038 1A60     	 str r2,[r3]
1092:../XMC1100-LibHaas.c ****   i2c_delay();
 5924              	 .loc 3 1092 0
 5925 003a FFF7FEFF 	 bl i2c_delay
1093:../XMC1100-LibHaas.c **** }
 5926              	 .loc 3 1093 0
 5927 003e BD46     	 mov sp,r7
 5928              	 
 5929 0040 80BD     	 pop {r7,pc}
 5930              	.L291:
 5931 0042 C046     	 .align 2
 5932              	.L290:
 5933 0044 00000440 	 .word 1074003968
 5934              	 .cfi_endproc
 5935              	.LFE85:
 5937              	 .section .text.i2c_start,"ax",%progbits
 5938              	 .align 2
 5939              	 .global i2c_start
 5940              	 .code 16
 5941              	 .thumb_func
 5943              	i2c_start:
 5944              	.LFB86:
1094:../XMC1100-LibHaas.c **** 
1095:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
1096:../XMC1100-LibHaas.c **** // Startbedingung I2C-Bus
1097:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
1098:../XMC1100-LibHaas.c **** void i2c_start (void)
1099:../XMC1100-LibHaas.c **** {
 5945              	 .loc 3 1099 0
 5946              	 .cfi_startproc
 5947 0000 80B5     	 push {r7,lr}
 5948              	.LCFI140:
 5949              	 .cfi_def_cfa_offset 8
 5950              	 .cfi_offset 7,-8
 5951              	 .cfi_offset 14,-4
 5952 0002 00AF     	 add r7,sp,#0
 5953              	.LCFI141:
 5954              	 .cfi_def_cfa_register 7
1100:../XMC1100-LibHaas.c ****   I2C_DIR |= SDA_OUT;			// Richtung => OUT
 5955              	 .loc 3 1100 0
 5956 0004 124B     	 ldr r3,.L293
 5957 0006 124A     	 ldr r2,.L293
 5958 0008 5269     	 ldr r2,[r2,#20]
 5959 000a C021     	 mov r1,#192
 5960 000c 0A43     	 orr r2,r1
 5961 000e 5A61     	 str r2,[r3,#20]
1101:../XMC1100-LibHaas.c ****   I2C_DIR |= SCL_OUT;			// Richtung => OUT
 5962              	 .loc 3 1101 0
 5963 0010 0F4B     	 ldr r3,.L293
 5964 0012 0F4A     	 ldr r2,.L293
 5965 0014 5269     	 ldr r2,[r2,#20]
 5966 0016 8021     	 mov r1,#128
 5967 0018 0902     	 lsl r1,r1,#8
 5968 001a 0A43     	 orr r2,r1
 5969 001c 5A61     	 str r2,[r3,#20]
1102:../XMC1100-LibHaas.c ****   I2C_PORT_OUT |= (1<<SDA);     // Grundzustand
 5970              	 .loc 3 1102 0
 5971 001e 0C4B     	 ldr r3,.L293
 5972 0020 0B4A     	 ldr r2,.L293
 5973 0022 1268     	 ldr r2,[r2]
 5974 0024 1021     	 mov r1,#16
 5975 0026 0A43     	 orr r2,r1
 5976 0028 1A60     	 str r2,[r3]
1103:../XMC1100-LibHaas.c ****   I2C_PORT_OUT |= (1<<SCL);
 5977              	 .loc 3 1103 0
 5978 002a 094B     	 ldr r3,.L293
 5979 002c 084A     	 ldr r2,.L293
 5980 002e 1268     	 ldr r2,[r2]
 5981 0030 2021     	 mov r1,#32
 5982 0032 0A43     	 orr r2,r1
 5983 0034 1A60     	 str r2,[r3]
1104:../XMC1100-LibHaas.c ****   i2c_delay();
 5984              	 .loc 3 1104 0
 5985 0036 FFF7FEFF 	 bl i2c_delay
1105:../XMC1100-LibHaas.c ****   I2C_PORT_OUT &= ~(1<<SDA);    // Wechsel SDA von 1 -> 0 w�hrend SCL = 1
 5986              	 .loc 3 1105 0
 5987 003a 054B     	 ldr r3,.L293
 5988 003c 044A     	 ldr r2,.L293
 5989 003e 1268     	 ldr r2,[r2]
 5990 0040 1021     	 mov r1,#16
 5991 0042 8A43     	 bic r2,r1
 5992 0044 1A60     	 str r2,[r3]
1106:../XMC1100-LibHaas.c ****   i2c_delay();
 5993              	 .loc 3 1106 0
 5994 0046 FFF7FEFF 	 bl i2c_delay
1107:../XMC1100-LibHaas.c ****   //I2C_PORT_OUT &= ~(1<<SCL);
1108:../XMC1100-LibHaas.c ****   //i2c_delay();
1109:../XMC1100-LibHaas.c **** }
 5995              	 .loc 3 1109 0
 5996 004a BD46     	 mov sp,r7
 5997              	 
 5998 004c 80BD     	 pop {r7,pc}
 5999              	.L294:
 6000 004e C046     	 .align 2
 6001              	.L293:
 6002 0050 00000440 	 .word 1074003968
 6003              	 .cfi_endproc
 6004              	.LFE86:
 6006              	 .section .text.i2c_stop,"ax",%progbits
 6007              	 .align 2
 6008              	 .global i2c_stop
 6009              	 .code 16
 6010              	 .thumb_func
 6012              	i2c_stop:
 6013              	.LFB87:
1110:../XMC1100-LibHaas.c **** 
1111:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
1112:../XMC1100-LibHaas.c **** // Stoppbedingung I2C-Bus
1113:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
1114:../XMC1100-LibHaas.c **** void i2c_stop (void)
1115:../XMC1100-LibHaas.c **** {
 6014              	 .loc 3 1115 0
 6015              	 .cfi_startproc
 6016 0000 80B5     	 push {r7,lr}
 6017              	.LCFI142:
 6018              	 .cfi_def_cfa_offset 8
 6019              	 .cfi_offset 7,-8
 6020              	 .cfi_offset 14,-4
 6021 0002 00AF     	 add r7,sp,#0
 6022              	.LCFI143:
 6023              	 .cfi_def_cfa_register 7
1116:../XMC1100-LibHaas.c **** 	I2C_DIR |= SDA_OUT;	// Richtung => OUT
 6024              	 .loc 3 1116 0
 6025 0004 124B     	 ldr r3,.L296
 6026 0006 124A     	 ldr r2,.L296
 6027 0008 5269     	 ldr r2,[r2,#20]
 6028 000a C021     	 mov r1,#192
 6029 000c 0A43     	 orr r2,r1
 6030 000e 5A61     	 str r2,[r3,#20]
1117:../XMC1100-LibHaas.c **** 	I2C_DIR |= SCL_OUT;	// Richtung => OUT
 6031              	 .loc 3 1117 0
 6032 0010 0F4B     	 ldr r3,.L296
 6033 0012 0F4A     	 ldr r2,.L296
 6034 0014 5269     	 ldr r2,[r2,#20]
 6035 0016 8021     	 mov r1,#128
 6036 0018 0902     	 lsl r1,r1,#8
 6037 001a 0A43     	 orr r2,r1
 6038 001c 5A61     	 str r2,[r3,#20]
1118:../XMC1100-LibHaas.c **** 	I2C_PORT_OUT &= ~(1<<SDA);                 // SDA = 4;
 6039              	 .loc 3 1118 0
 6040 001e 0C4B     	 ldr r3,.L296
 6041 0020 0B4A     	 ldr r2,.L296
 6042 0022 1268     	 ldr r2,[r2]
 6043 0024 1021     	 mov r1,#16
 6044 0026 8A43     	 bic r2,r1
 6045 0028 1A60     	 str r2,[r3]
1119:../XMC1100-LibHaas.c **** 	I2C_PORT_OUT |= (1<<SCL);                  // SCL = 5;
 6046              	 .loc 3 1119 0
 6047 002a 094B     	 ldr r3,.L296
 6048 002c 084A     	 ldr r2,.L296
 6049 002e 1268     	 ldr r2,[r2]
 6050 0030 2021     	 mov r1,#32
 6051 0032 0A43     	 orr r2,r1
 6052 0034 1A60     	 str r2,[r3]
1120:../XMC1100-LibHaas.c **** 	i2c_delay();
 6053              	 .loc 3 1120 0
 6054 0036 FFF7FEFF 	 bl i2c_delay
1121:../XMC1100-LibHaas.c ****   // Wechsel von SDA 0 -> 1 w�hrend SCL = 1
1122:../XMC1100-LibHaas.c **** 	I2C_PORT_OUT |= (1<<SDA);                  // SDA = 4;
 6055              	 .loc 3 1122 0
 6056 003a 054B     	 ldr r3,.L296
 6057 003c 044A     	 ldr r2,.L296
 6058 003e 1268     	 ldr r2,[r2]
 6059 0040 1021     	 mov r1,#16
 6060 0042 0A43     	 orr r2,r1
 6061 0044 1A60     	 str r2,[r3]
1123:../XMC1100-LibHaas.c **** 	i2c_delay();
 6062              	 .loc 3 1123 0
 6063 0046 FFF7FEFF 	 bl i2c_delay
1124:../XMC1100-LibHaas.c **** }
 6064              	 .loc 3 1124 0
 6065 004a BD46     	 mov sp,r7
 6066              	 
 6067 004c 80BD     	 pop {r7,pc}
 6068              	.L297:
 6069 004e C046     	 .align 2
 6070              	.L296:
 6071 0050 00000440 	 .word 1074003968
 6072              	 .cfi_endproc
 6073              	.LFE87:
 6075              	 .section .text.i2c_write,"ax",%progbits
 6076              	 .align 2
 6077              	 .global i2c_write
 6078              	 .code 16
 6079              	 .thumb_func
 6081              	i2c_write:
 6082              	.LFB88:
1125:../XMC1100-LibHaas.c **** 
1126:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
1127:../XMC1100-LibHaas.c **** // Byte ausgeben an I2C-Bus , Rueckgabewert = ack = ACK/NACK
1128:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
1129:../XMC1100-LibHaas.c **** uint8_t i2c_write (uint8_t value)
1130:../XMC1100-LibHaas.c **** {
 6083              	 .loc 3 1130 0
 6084              	 .cfi_startproc
 6085 0000 80B5     	 push {r7,lr}
 6086              	.LCFI144:
 6087              	 .cfi_def_cfa_offset 8
 6088              	 .cfi_offset 7,-8
 6089              	 .cfi_offset 14,-4
 6090 0002 84B0     	 sub sp,sp,#16
 6091              	.LCFI145:
 6092              	 .cfi_def_cfa_offset 24
 6093 0004 00AF     	 add r7,sp,#0
 6094              	.LCFI146:
 6095              	 .cfi_def_cfa_register 7
 6096 0006 021C     	 mov r2,r0
 6097 0008 FB1D     	 add r3,r7,#7
 6098 000a 1A70     	 strb r2,[r3]
1131:../XMC1100-LibHaas.c ****   uint8_t z;                             // Zaehler
1132:../XMC1100-LibHaas.c ****   uint8_t ack;                           // Acknowledge-Bit
1133:../XMC1100-LibHaas.c **** 
1134:../XMC1100-LibHaas.c ****     I2C_DIR |= SDA_OUT;					// Richtung => OUT
 6099              	 .loc 3 1134 0
 6100 000c 394B     	 ldr r3,.L304
 6101 000e 394A     	 ldr r2,.L304
 6102 0010 5269     	 ldr r2,[r2,#20]
 6103 0012 C021     	 mov r1,#192
 6104 0014 0A43     	 orr r2,r1
 6105 0016 5A61     	 str r2,[r3,#20]
1135:../XMC1100-LibHaas.c ****     I2C_DIR |= SCL_OUT;					// Richtung => OUT
 6106              	 .loc 3 1135 0
 6107 0018 364B     	 ldr r3,.L304
 6108 001a 364A     	 ldr r2,.L304
 6109 001c 5269     	 ldr r2,[r2,#20]
 6110 001e 8021     	 mov r1,#128
 6111 0020 0902     	 lsl r1,r1,#8
 6112 0022 0A43     	 orr r2,r1
 6113 0024 5A61     	 str r2,[r3,#20]
1136:../XMC1100-LibHaas.c **** 
1137:../XMC1100-LibHaas.c ****   for (z = 8; z != 0; z --)              // Zaehler: serielle Ausgabe von 8 Bit
 6114              	 .loc 3 1137 0
 6115 0026 0F23     	 mov r3,#15
 6116 0028 FB18     	 add r3,r7,r3
 6117 002a 0822     	 mov r2,#8
 6118 002c 1A70     	 strb r2,[r3]
 6119 002e 2DE0     	 b .L299
 6120              	.L302:
1138:../XMC1100-LibHaas.c ****   {
1139:../XMC1100-LibHaas.c **** 	  I2C_PORT_OUT &= ~(1<<SCL);         // SCL = 0  Clockausgabe
 6121              	 .loc 3 1139 0
 6122 0030 304B     	 ldr r3,.L304
 6123 0032 304A     	 ldr r2,.L304
 6124 0034 1268     	 ldr r2,[r2]
 6125 0036 2021     	 mov r1,#32
 6126 0038 8A43     	 bic r2,r1
 6127 003a 1A60     	 str r2,[r3]
1140:../XMC1100-LibHaas.c **** 	  // Daten:
1141:../XMC1100-LibHaas.c **** 	  if ((value & 0x80) == 0x80)        // Ausgabe: MSB first
 6128              	 .loc 3 1141 0
 6129 003c FB1D     	 add r3,r7,#7
 6130 003e 1B78     	 ldrb r3,[r3]
 6131 0040 5BB2     	 sxtb r3,r3
 6132 0042 002B     	 cmp r3,#0
 6133 0044 06DA     	 bge .L300
1142:../XMC1100-LibHaas.c **** 		  I2C_PORT_OUT |= (1<<SDA);      // SDA = 1;
 6134              	 .loc 3 1142 0
 6135 0046 2B4B     	 ldr r3,.L304
 6136 0048 2A4A     	 ldr r2,.L304
 6137 004a 1268     	 ldr r2,[r2]
 6138 004c 1021     	 mov r1,#16
 6139 004e 0A43     	 orr r2,r1
 6140 0050 1A60     	 str r2,[r3]
 6141 0052 05E0     	 b .L301
 6142              	.L300:
1143:../XMC1100-LibHaas.c **** 	  else
1144:../XMC1100-LibHaas.c **** 		  I2C_PORT_OUT &= ~(1<<SDA);     // SDA = 0;
 6143              	 .loc 3 1144 0
 6144 0054 274B     	 ldr r3,.L304
 6145 0056 274A     	 ldr r2,.L304
 6146 0058 1268     	 ldr r2,[r2]
 6147 005a 1021     	 mov r1,#16
 6148 005c 8A43     	 bic r2,r1
 6149 005e 1A60     	 str r2,[r3]
 6150              	.L301:
1145:../XMC1100-LibHaas.c **** 	  value <<=1;                  // naechstes Bit!
 6151              	 .loc 3 1145 0 discriminator 2
 6152 0060 FA1D     	 add r2,r7,#7
 6153 0062 FB1D     	 add r3,r7,#7
 6154 0064 1B78     	 ldrb r3,[r3]
 6155 0066 DB18     	 add r3,r3,r3
 6156 0068 1370     	 strb r3,[r2]
1146:../XMC1100-LibHaas.c **** 
1147:../XMC1100-LibHaas.c **** 	  i2c_delay();
 6157              	 .loc 3 1147 0 discriminator 2
 6158 006a FFF7FEFF 	 bl i2c_delay
1148:../XMC1100-LibHaas.c **** 	  I2C_PORT_OUT |= (1<<SCL);          // SCL = 1
 6159              	 .loc 3 1148 0 discriminator 2
 6160 006e 214B     	 ldr r3,.L304
 6161 0070 204A     	 ldr r2,.L304
 6162 0072 1268     	 ldr r2,[r2]
 6163 0074 2021     	 mov r1,#32
 6164 0076 0A43     	 orr r2,r1
 6165 0078 1A60     	 str r2,[r3]
1149:../XMC1100-LibHaas.c ****     i2c_delay();
 6166              	 .loc 3 1149 0 discriminator 2
 6167 007a FFF7FEFF 	 bl i2c_delay
1137:../XMC1100-LibHaas.c ****   {
 6168              	 .loc 3 1137 0 discriminator 2
 6169 007e 0F23     	 mov r3,#15
 6170 0080 FB18     	 add r3,r7,r3
 6171 0082 1A78     	 ldrb r2,[r3]
 6172 0084 0F23     	 mov r3,#15
 6173 0086 FB18     	 add r3,r7,r3
 6174 0088 013A     	 sub r2,r2,#1
 6175 008a 1A70     	 strb r2,[r3]
 6176              	.L299:
1137:../XMC1100-LibHaas.c ****   {
 6177              	 .loc 3 1137 0 is_stmt 0 discriminator 1
 6178 008c 0F23     	 mov r3,#15
 6179 008e FB18     	 add r3,r7,r3
 6180 0090 1B78     	 ldrb r3,[r3]
 6181 0092 002B     	 cmp r3,#0
 6182 0094 CCD1     	 bne .L302
1150:../XMC1100-LibHaas.c ****   }
1151:../XMC1100-LibHaas.c ****   //I2C_DIR &= SDA_IN;					// Data auf Input hier ist es zu früh, wenn LSB 0 war
1152:../XMC1100-LibHaas.c ****   I2C_PORT_OUT &= ~(1<<SCL);    // SCL = 0 Datenausabe
 6183              	 .loc 3 1152 0 is_stmt 1
 6184 0096 174B     	 ldr r3,.L304
 6185 0098 164A     	 ldr r2,.L304
 6186 009a 1268     	 ldr r2,[r2]
 6187 009c 2021     	 mov r1,#32
 6188 009e 8A43     	 bic r2,r1
 6189 00a0 1A60     	 str r2,[r3]
1153:../XMC1100-LibHaas.c ****   I2C_DIR &= SDA_IN;						// Data auf Input
 6190              	 .loc 3 1153 0
 6191 00a2 144B     	 ldr r3,.L304
 6192 00a4 134A     	 ldr r2,.L304
 6193 00a6 5269     	 ldr r2,[r2,#20]
 6194 00a8 FF21     	 mov r1,#255
 6195 00aa 8A43     	 bic r2,r1
 6196 00ac 5A61     	 str r2,[r3,#20]
1154:../XMC1100-LibHaas.c **** 
1155:../XMC1100-LibHaas.c ****   i2c_delay();
 6197              	 .loc 3 1155 0
 6198 00ae FFF7FEFF 	 bl i2c_delay
1156:../XMC1100-LibHaas.c ****   I2C_PORT_OUT |= (1<<SCL);              // SCL = 1 Slave kann best�tigen
 6199              	 .loc 3 1156 0
 6200 00b2 104B     	 ldr r3,.L304
 6201 00b4 0F4A     	 ldr r2,.L304
 6202 00b6 1268     	 ldr r2,[r2]
 6203 00b8 2021     	 mov r1,#32
 6204 00ba 0A43     	 orr r2,r1
 6205 00bc 1A60     	 str r2,[r3]
1157:../XMC1100-LibHaas.c ****   i2c_delay();                           // warten
 6206              	 .loc 3 1157 0
 6207 00be FFF7FEFF 	 bl i2c_delay
1158:../XMC1100-LibHaas.c **** 
1159:../XMC1100-LibHaas.c ****   ack = (I2C_PORT_IN & (1<<SDA))>>SDA;
 6208              	 .loc 3 1159 0
 6209 00c2 0C4B     	 ldr r3,.L304
 6210 00c4 5B6A     	 ldr r3,[r3,#36]
 6211 00c6 1022     	 mov r2,#16
 6212 00c8 1340     	 and r3,r2
 6213 00ca 1A09     	 lsr r2,r3,#4
 6214 00cc 0E23     	 mov r3,#14
 6215 00ce FB18     	 add r3,r7,r3
 6216 00d0 1A70     	 strb r2,[r3]
1160:../XMC1100-LibHaas.c **** 
1161:../XMC1100-LibHaas.c ****   i2c_delay();
 6217              	 .loc 3 1161 0
 6218 00d2 FFF7FEFF 	 bl i2c_delay
1162:../XMC1100-LibHaas.c ****   I2C_PORT_OUT &= ~(1<<SCL);             // SCL = 0 Slave soll Ackn-Ausgabe beenden
 6219              	 .loc 3 1162 0
 6220 00d6 074B     	 ldr r3,.L304
 6221 00d8 064A     	 ldr r2,.L304
 6222 00da 1268     	 ldr r2,[r2]
 6223 00dc 2021     	 mov r1,#32
 6224 00de 8A43     	 bic r2,r1
 6225 00e0 1A60     	 str r2,[r3]
1163:../XMC1100-LibHaas.c ****   i2c_delay();
 6226              	 .loc 3 1163 0
 6227 00e2 FFF7FEFF 	 bl i2c_delay
1164:../XMC1100-LibHaas.c **** 
1165:../XMC1100-LibHaas.c ****   return ack;                            // Acknoledge-Bit ist R�ckgabewert der Funktion
 6228              	 .loc 3 1165 0
 6229 00e6 0E23     	 mov r3,#14
 6230 00e8 FB18     	 add r3,r7,r3
 6231 00ea 1B78     	 ldrb r3,[r3]
1166:../XMC1100-LibHaas.c ****                                          // ack = 0 bedeutet Slave hat "verstanden" !!!!!!
1167:../XMC1100-LibHaas.c **** }
 6232              	 .loc 3 1167 0
 6233 00ec 181C     	 mov r0,r3
 6234 00ee BD46     	 mov sp,r7
 6235 00f0 04B0     	 add sp,sp,#16
 6236              	 
 6237 00f2 80BD     	 pop {r7,pc}
 6238              	.L305:
 6239              	 .align 2
 6240              	.L304:
 6241 00f4 00000440 	 .word 1074003968
 6242              	 .cfi_endproc
 6243              	.LFE88:
 6245              	 .section .text.i2c_read,"ax",%progbits
 6246              	 .align 2
 6247              	 .global i2c_read
 6248              	 .code 16
 6249              	 .thumb_func
 6251              	i2c_read:
 6252              	.LFB89:
1168:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
1169:../XMC1100-LibHaas.c **** // Byte einlesen vom I2C-Bus.
1170:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
1171:../XMC1100-LibHaas.c **** uint8_t i2c_read (uint8_t ack)
1172:../XMC1100-LibHaas.c **** {
 6253              	 .loc 3 1172 0
 6254              	 .cfi_startproc
 6255 0000 80B5     	 push {r7,lr}
 6256              	.LCFI147:
 6257              	 .cfi_def_cfa_offset 8
 6258              	 .cfi_offset 7,-8
 6259              	 .cfi_offset 14,-4
 6260 0002 84B0     	 sub sp,sp,#16
 6261              	.LCFI148:
 6262              	 .cfi_def_cfa_offset 24
 6263 0004 00AF     	 add r7,sp,#0
 6264              	.LCFI149:
 6265              	 .cfi_def_cfa_register 7
 6266 0006 021C     	 mov r2,r0
 6267 0008 FB1D     	 add r3,r7,#7
 6268 000a 1A70     	 strb r2,[r3]
1173:../XMC1100-LibHaas.c ****   uint8_t z, value = 0;
 6269              	 .loc 3 1173 0
 6270 000c 0E23     	 mov r3,#14
 6271 000e FB18     	 add r3,r7,r3
 6272 0010 0022     	 mov r2,#0
 6273 0012 1A70     	 strb r2,[r3]
1174:../XMC1100-LibHaas.c ****   I2C_DIR &= SDA_IN;			// Data auf Input
 6274              	 .loc 3 1174 0
 6275 0014 3A4B     	 ldr r3,.L312
 6276 0016 3A4A     	 ldr r2,.L312
 6277 0018 5269     	 ldr r2,[r2,#20]
 6278 001a FF21     	 mov r1,#255
 6279 001c 8A43     	 bic r2,r1
 6280 001e 5A61     	 str r2,[r3,#20]
1175:../XMC1100-LibHaas.c **** 
1176:../XMC1100-LibHaas.c **** 
1177:../XMC1100-LibHaas.c ****   for (z = 8; z != 0; z--)      // Z�hler: serielles Einlesen von 8 Bit
 6281              	 .loc 3 1177 0
 6282 0020 0F23     	 mov r3,#15
 6283 0022 FB18     	 add r3,r7,r3
 6284 0024 0822     	 mov r2,#8
 6285 0026 1A70     	 strb r2,[r3]
 6286 0028 2CE0     	 b .L307
 6287              	.L308:
1178:../XMC1100-LibHaas.c ****   {
1179:../XMC1100-LibHaas.c ****     I2C_PORT_OUT |= (1<<SCL);       // SCL = 1  Daten sind g�ltig
 6288              	 .loc 3 1179 0 discriminator 3
 6289 002a 354B     	 ldr r3,.L312
 6290 002c 344A     	 ldr r2,.L312
 6291 002e 1268     	 ldr r2,[r2]
 6292 0030 2021     	 mov r1,#32
 6293 0032 0A43     	 orr r2,r1
 6294 0034 1A60     	 str r2,[r3]
1180:../XMC1100-LibHaas.c ****     i2c_delay();
 6295              	 .loc 3 1180 0 discriminator 3
 6296 0036 FFF7FEFF 	 bl i2c_delay
1181:../XMC1100-LibHaas.c **** 
1182:../XMC1100-LibHaas.c ****     value <<= 1;
 6297              	 .loc 3 1182 0 discriminator 3
 6298 003a 0E23     	 mov r3,#14
 6299 003c FA18     	 add r2,r7,r3
 6300 003e 0E23     	 mov r3,#14
 6301 0040 FB18     	 add r3,r7,r3
 6302 0042 1B78     	 ldrb r3,[r3]
 6303 0044 DB18     	 add r3,r3,r3
 6304 0046 1370     	 strb r3,[r2]
1183:../XMC1100-LibHaas.c ****     value |= (uint8_t) ((I2C_PORT_IN & (1<<SDA))>>SDA);    //SDA   Datenbit in Puffer
 6305              	 .loc 3 1183 0 discriminator 3
 6306 0048 2D4B     	 ldr r3,.L312
 6307 004a 5B6A     	 ldr r3,[r3,#36]
 6308 004c 1022     	 mov r2,#16
 6309 004e 1340     	 and r3,r2
 6310 0050 1B09     	 lsr r3,r3,#4
 6311 0052 D9B2     	 uxtb r1,r3
 6312 0054 0E23     	 mov r3,#14
 6313 0056 FB18     	 add r3,r7,r3
 6314 0058 0E22     	 mov r2,#14
 6315 005a BA18     	 add r2,r7,r2
 6316 005c 1278     	 ldrb r2,[r2]
 6317 005e 0A43     	 orr r2,r1
 6318 0060 1A70     	 strb r2,[r3]
1184:../XMC1100-LibHaas.c **** 
1185:../XMC1100-LibHaas.c ****     i2c_delay();
 6319              	 .loc 3 1185 0 discriminator 3
 6320 0062 FFF7FEFF 	 bl i2c_delay
1186:../XMC1100-LibHaas.c ****     I2C_PORT_OUT &= ~(1<<SCL);                // SCL = 0  Daten lesen beendet
 6321              	 .loc 3 1186 0 discriminator 3
 6322 0066 264B     	 ldr r3,.L312
 6323 0068 254A     	 ldr r2,.L312
 6324 006a 1268     	 ldr r2,[r2]
 6325 006c 2021     	 mov r1,#32
 6326 006e 8A43     	 bic r2,r1
 6327 0070 1A60     	 str r2,[r3]
1187:../XMC1100-LibHaas.c ****     i2c_delay();
 6328              	 .loc 3 1187 0 discriminator 3
 6329 0072 FFF7FEFF 	 bl i2c_delay
1177:../XMC1100-LibHaas.c ****   {
 6330              	 .loc 3 1177 0 discriminator 3
 6331 0076 0F23     	 mov r3,#15
 6332 0078 FB18     	 add r3,r7,r3
 6333 007a 1A78     	 ldrb r2,[r3]
 6334 007c 0F23     	 mov r3,#15
 6335 007e FB18     	 add r3,r7,r3
 6336 0080 013A     	 sub r2,r2,#1
 6337 0082 1A70     	 strb r2,[r3]
 6338              	.L307:
1177:../XMC1100-LibHaas.c ****   {
 6339              	 .loc 3 1177 0 is_stmt 0 discriminator 1
 6340 0084 0F23     	 mov r3,#15
 6341 0086 FB18     	 add r3,r7,r3
 6342 0088 1B78     	 ldrb r3,[r3]
 6343 008a 002B     	 cmp r3,#0
 6344 008c CDD1     	 bne .L308
1188:../XMC1100-LibHaas.c ****   }
1189:../XMC1100-LibHaas.c ****   I2C_DIR |= SDA_OUT;	// Richtung => OUT
 6345              	 .loc 3 1189 0 is_stmt 1
 6346 008e 1C4B     	 ldr r3,.L312
 6347 0090 1B4A     	 ldr r2,.L312
 6348 0092 5269     	 ldr r2,[r2,#20]
 6349 0094 C021     	 mov r1,#192
 6350 0096 0A43     	 orr r2,r1
 6351 0098 5A61     	 str r2,[r3,#20]
1190:../XMC1100-LibHaas.c ****   if (ack == ACK)  I2C_PORT_OUT &= ~(1<<SDA); // SDA = 0  (= Acknowledge)
 6352              	 .loc 3 1190 0
 6353 009a FB1D     	 add r3,r7,#7
 6354 009c 1B78     	 ldrb r3,[r3]
 6355 009e 002B     	 cmp r3,#0
 6356 00a0 06D1     	 bne .L309
 6357              	 .loc 3 1190 0 is_stmt 0 discriminator 1
 6358 00a2 174B     	 ldr r3,.L312
 6359 00a4 164A     	 ldr r2,.L312
 6360 00a6 1268     	 ldr r2,[r2]
 6361 00a8 1021     	 mov r1,#16
 6362 00aa 8A43     	 bic r2,r1
 6363 00ac 1A60     	 str r2,[r3]
 6364 00ae 05E0     	 b .L310
 6365              	.L309:
1191:../XMC1100-LibHaas.c ****   else             I2C_PORT_OUT |= (1<<SDA);  // SDA = 1  (= Not Acknowledge)
 6366              	 .loc 3 1191 0 is_stmt 1
 6367 00b0 134B     	 ldr r3,.L312
 6368 00b2 134A     	 ldr r2,.L312
 6369 00b4 1268     	 ldr r2,[r2]
 6370 00b6 1021     	 mov r1,#16
 6371 00b8 0A43     	 orr r2,r1
 6372 00ba 1A60     	 str r2,[r3]
 6373              	.L310:
1192:../XMC1100-LibHaas.c **** 
1193:../XMC1100-LibHaas.c ****   i2c_delay();
 6374              	 .loc 3 1193 0
 6375 00bc FFF7FEFF 	 bl i2c_delay
1194:../XMC1100-LibHaas.c ****   I2C_PORT_OUT |= (1<<SCL);                   // SCL = 1  Ackn. g�ltig
 6376              	 .loc 3 1194 0
 6377 00c0 0F4B     	 ldr r3,.L312
 6378 00c2 0F4A     	 ldr r2,.L312
 6379 00c4 1268     	 ldr r2,[r2]
 6380 00c6 2021     	 mov r1,#32
 6381 00c8 0A43     	 orr r2,r1
 6382 00ca 1A60     	 str r2,[r3]
1195:../XMC1100-LibHaas.c ****   i2c_delay();
 6383              	 .loc 3 1195 0
 6384 00cc FFF7FEFF 	 bl i2c_delay
1196:../XMC1100-LibHaas.c ****   I2C_PORT_OUT &= ~(1<<SCL);                  // SCL = 0  Ackn. beendet
 6385              	 .loc 3 1196 0
 6386 00d0 0B4B     	 ldr r3,.L312
 6387 00d2 0B4A     	 ldr r2,.L312
 6388 00d4 1268     	 ldr r2,[r2]
 6389 00d6 2021     	 mov r1,#32
 6390 00d8 8A43     	 bic r2,r1
 6391 00da 1A60     	 str r2,[r3]
1197:../XMC1100-LibHaas.c ****   i2c_delay();
 6392              	 .loc 3 1197 0
 6393 00dc FFF7FEFF 	 bl i2c_delay
1198:../XMC1100-LibHaas.c ****   I2C_PORT_OUT &= ~(1<<SDA);                  // SDA = 0  Leitung SDA vorbereiten f�r Stoppbed.
 6394              	 .loc 3 1198 0
 6395 00e0 074B     	 ldr r3,.L312
 6396 00e2 074A     	 ldr r2,.L312
 6397 00e4 1268     	 ldr r2,[r2]
 6398 00e6 1021     	 mov r1,#16
 6399 00e8 8A43     	 bic r2,r1
 6400 00ea 1A60     	 str r2,[r3]
1199:../XMC1100-LibHaas.c ****   i2c_delay();
 6401              	 .loc 3 1199 0
 6402 00ec FFF7FEFF 	 bl i2c_delay
1200:../XMC1100-LibHaas.c **** 
1201:../XMC1100-LibHaas.c ****   return ( value );                       // eingelesenes Byte = R�ckgabewert
 6403              	 .loc 3 1201 0
 6404 00f0 0E23     	 mov r3,#14
 6405 00f2 FB18     	 add r3,r7,r3
 6406 00f4 1B78     	 ldrb r3,[r3]
1202:../XMC1100-LibHaas.c **** }
 6407              	 .loc 3 1202 0
 6408 00f6 181C     	 mov r0,r3
 6409 00f8 BD46     	 mov sp,r7
 6410 00fa 04B0     	 add sp,sp,#16
 6411              	 
 6412 00fc 80BD     	 pop {r7,pc}
 6413              	.L313:
 6414 00fe C046     	 .align 2
 6415              	.L312:
 6416 0100 00000440 	 .word 1074003968
 6417              	 .cfi_endproc
 6418              	.LFE89:
 6420              	 .section .text.rs232_init,"ax",%progbits
 6421              	 .align 2
 6422              	 .global rs232_init
 6423              	 .code 16
 6424              	 .thumb_func
 6426              	rs232_init:
 6427              	.LFB90:
1203:../XMC1100-LibHaas.c **** 
1204:../XMC1100-LibHaas.c **** // ****************************************************************************
1205:../XMC1100-LibHaas.c **** // RS232-Routinen zur Kommunikation mit PC-Terminal
1206:../XMC1100-LibHaas.c **** // ****************************************************************************
1207:../XMC1100-LibHaas.c **** // RxD auf P1.3 , XMC1100 TxD auf P1.2
1208:../XMC1100-LibHaas.c **** // values calculated for 9.6 kbaud @ 32 MHz
1209:../XMC1100-LibHaas.c **** // Baudrate = 32 MHz * Step/1024 * 1/(PDIV +1)  * 1/ (PCTQ +1) * 1/ (DCTQ +1)
1210:../XMC1100-LibHaas.c **** //#define FDR_STEP	25	// fuer 9.6 kBaud
1211:../XMC1100-LibHaas.c **** //#define BRG_PDIV	4
1212:../XMC1100-LibHaas.c **** //#define BRG_DCTQ	15
1213:../XMC1100-LibHaas.c **** //#define BRG_PCTQ	0
1214:../XMC1100-LibHaas.c **** #define FDR_STEP	118
1215:../XMC1100-LibHaas.c **** #define BRG_PDIV	23  //9600  11=>19,2k  5=>38,4k  3=>57,6k  1=>115,2k
1216:../XMC1100-LibHaas.c **** #define BRG_DCTQ	15
1217:../XMC1100-LibHaas.c **** #define BRG_PCTQ	0
1218:../XMC1100-LibHaas.c **** 
1219:../XMC1100-LibHaas.c **** /* USIC : FIFO DPTR & SIZE MASK and POS Values */
1220:../XMC1100-LibHaas.c **** #define   USIC_CH_TBCTR_DPTRSIZE_Pos  	(0U)
1221:../XMC1100-LibHaas.c **** #define   USIC_CH_TBCTR_DPTRSIZE_Msk  	(0x0700003FU << USIC_CH_TBCTR_DPTRSIZE_Pos)
1222:../XMC1100-LibHaas.c **** 
1223:../XMC1100-LibHaas.c **** #define   USIC_CH_RBCTR_DPTRSIZE_Pos  	(0U)
1224:../XMC1100-LibHaas.c **** #define   USIC_CH_RBCTR_DPTRSIZE_Msk  	(0x0700003FU << USIC_CH_RBCTR_DPTRSIZE_Pos)
1225:../XMC1100-LibHaas.c **** 
1226:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
1227:../XMC1100-LibHaas.c **** // Serielle Schnittstelle initialisieren
1228:../XMC1100-LibHaas.c **** // RxD auf P1.3 , XMC1100 TxD auf P1.2, 9600 Baud, 8N1
1229:../XMC1100-LibHaas.c **** // über USB als virtuelle Schnittstelle COM x am PC verwendbar
1230:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
1231:../XMC1100-LibHaas.c **** void rs232_init ( void )
1232:../XMC1100-LibHaas.c **** {	//USIC0 Cannel 1 wird verwendet:
 6428              	 .loc 3 1232 0
 6429              	 .cfi_startproc
 6430 0000 80B5     	 push {r7,lr}
 6431              	.LCFI150:
 6432              	 .cfi_def_cfa_offset 8
 6433              	 .cfi_offset 7,-8
 6434              	 .cfi_offset 14,-4
 6435 0002 00AF     	 add r7,sp,#0
 6436              	.LCFI151:
 6437              	 .cfi_def_cfa_register 7
1233:../XMC1100-LibHaas.c **** 	SCU_GENERAL->PASSWD = 0x000000C0UL;
 6438              	 .loc 3 1233 0
 6439 0004 594B     	 ldr r3,.L316
 6440 0006 C022     	 mov r2,#192
 6441 0008 5A62     	 str r2,[r3,#36]
1234:../XMC1100-LibHaas.c **** 	SCU_CLK->CGATCLR0 |= 0x00000008;		// stop gating USIC
 6442              	 .loc 3 1234 0
 6443 000a 594B     	 ldr r3,.L316+4
 6444 000c 584A     	 ldr r2,.L316+4
 6445 000e 1269     	 ldr r2,[r2,#16]
 6446 0010 0821     	 mov r1,#8
 6447 0012 0A43     	 orr r2,r1
 6448 0014 1A61     	 str r2,[r3,#16]
1235:../XMC1100-LibHaas.c **** 		while((SCU_CLK->CLKCR)&0x40000000UL);	// wait for VDDC to stabilize
 6449              	 .loc 3 1235 0
 6450 0016 C046     	 mov r8,r8
 6451              	.L315:
 6452              	 .loc 3 1235 0 is_stmt 0 discriminator 1
 6453 0018 554B     	 ldr r3,.L316+4
 6454 001a 1A68     	 ldr r2,[r3]
 6455 001c 8023     	 mov r3,#128
 6456 001e DB05     	 lsl r3,r3,#23
 6457 0020 1340     	 and r3,r2
 6458 0022 F9D1     	 bne .L315
1236:../XMC1100-LibHaas.c **** 	SCU_GENERAL->PASSWD = 0x000000C3UL;
 6459              	 .loc 3 1236 0 is_stmt 1
 6460 0024 514B     	 ldr r3,.L316
 6461 0026 C322     	 mov r2,#195
 6462 0028 5A62     	 str r2,[r3,#36]
1237:../XMC1100-LibHaas.c **** 
1238:../XMC1100-LibHaas.c **** 	USIC0_CH1->KSCFG |= 3UL ;	//  Mode enable + Freigabe write
 6463              	 .loc 3 1238 0
 6464 002a 524B     	 ldr r3,.L316+8
 6465 002c 514A     	 ldr r2,.L316+8
 6466 002e D268     	 ldr r2,[r2,#12]
 6467 0030 0321     	 mov r1,#3
 6468 0032 0A43     	 orr r2,r1
 6469 0034 DA60     	 str r2,[r3,#12]
1239:../XMC1100-LibHaas.c **** 	//WR_REG(USIC0_CH1->FDR, USIC_CH_FDR_DM_Msk, USIC_CH_FDR_DM_Pos, 2);
1240:../XMC1100-LibHaas.c **** 	USIC0_CH1->FDR |= 1UL << 15 ;	//Fractional divider mode selected
 6470              	 .loc 3 1240 0
 6471 0036 4F4B     	 ldr r3,.L316+8
 6472 0038 4E4A     	 ldr r2,.L316+8
 6473 003a 1269     	 ldr r2,[r2,#16]
 6474 003c 8021     	 mov r1,#128
 6475 003e 0902     	 lsl r1,r1,#8
 6476 0040 0A43     	 orr r2,r1
 6477 0042 1A61     	 str r2,[r3,#16]
1241:../XMC1100-LibHaas.c **** 		//Step value
1242:../XMC1100-LibHaas.c **** 	USIC0_CH1->FDR|= FDR_STEP ;
 6478              	 .loc 3 1242 0
 6479 0044 4B4B     	 ldr r3,.L316+8
 6480 0046 4B4A     	 ldr r2,.L316+8
 6481 0048 1269     	 ldr r2,[r2,#16]
 6482 004a 7621     	 mov r1,#118
 6483 004c 0A43     	 orr r2,r1
 6484 004e 1A61     	 str r2,[r3,#16]
1243:../XMC1100-LibHaas.c **** 		//Vorteiler:
1244:../XMC1100-LibHaas.c **** 		// Baudrate = 32 MHz * Step/1024 * 1/(PDIV +1)  * 1/ (PCTQ +1) * 1/ (DCTQ +1)
1245:../XMC1100-LibHaas.c **** 	USIC0_CH1->BRG |= (BRG_PDIV << 16) ;
 6485              	 .loc 3 1245 0
 6486 0050 484B     	 ldr r3,.L316+8
 6487 0052 484A     	 ldr r2,.L316+8
 6488 0054 5269     	 ldr r2,[r2,#20]
 6489 0056 B821     	 mov r1,#184
 6490 0058 4903     	 lsl r1,r1,#13
 6491 005a 0A43     	 orr r2,r1
 6492 005c 5A61     	 str r2,[r3,#20]
1246:../XMC1100-LibHaas.c **** 	USIC0_CH1->BRG |= BRG_DCTQ << 10 ;
 6493              	 .loc 3 1246 0
 6494 005e 454B     	 ldr r3,.L316+8
 6495 0060 444A     	 ldr r2,.L316+8
 6496 0062 5269     	 ldr r2,[r2,#20]
 6497 0064 F021     	 mov r1,#240
 6498 0066 8901     	 lsl r1,r1,#6
 6499 0068 0A43     	 orr r2,r1
 6500 006a 5A61     	 str r2,[r3,#20]
1247:../XMC1100-LibHaas.c **** 	USIC0_CH1->BRG |= BRG_PCTQ << 8 ;
 6501              	 .loc 3 1247 0
 6502 006c 414B     	 ldr r3,.L316+8
 6503 006e 414A     	 ldr r2,.L316+8
 6504 0070 5269     	 ldr r2,[r2,#20]
 6505 0072 5A61     	 str r2,[r3,#20]
1248:../XMC1100-LibHaas.c **** 
1249:../XMC1100-LibHaas.c **** 		//Configuration of USIC Shift Control
1250:../XMC1100-LibHaas.c **** 		//Transmit/Receive LSB first is selected, Transmission Mode (TRM) = 1, Passive Data Level (PDL) =
1251:../XMC1100-LibHaas.c **** 	WR_REG(USIC0_CH1->SCTR, USIC_CH_SCTR_PDL_Msk, USIC_CH_SCTR_PDL_Pos, 1);
 6506              	 .loc 3 1251 0
 6507 0074 3F4B     	 ldr r3,.L316+8
 6508 0076 3F4A     	 ldr r2,.L316+8
 6509 0078 526B     	 ldr r2,[r2,#52]
 6510 007a 0221     	 mov r1,#2
 6511 007c 0A43     	 orr r2,r1
 6512 007e 5A63     	 str r2,[r3,#52]
1252:../XMC1100-LibHaas.c **** 	WR_REG(USIC0_CH1->SCTR, USIC_CH_SCTR_TRM_Msk, USIC_CH_SCTR_TRM_Pos, 1);
 6513              	 .loc 3 1252 0
 6514 0080 3C4B     	 ldr r3,.L316+8
 6515 0082 3C4A     	 ldr r2,.L316+8
 6516 0084 526B     	 ldr r2,[r2,#52]
 6517 0086 3C49     	 ldr r1,.L316+12
 6518 0088 0A40     	 and r2,r1
 6519 008a 8021     	 mov r1,#128
 6520 008c 4900     	 lsl r1,r1,#1
 6521 008e 0A43     	 orr r2,r1
 6522 0090 5A63     	 str r2,[r3,#52]
1253:../XMC1100-LibHaas.c **** 		//Set Word Length (WLE) & Frame Length (FLE)
1254:../XMC1100-LibHaas.c **** 	WR_REG(USIC0_CH1->SCTR, USIC_CH_SCTR_FLE_Msk, USIC_CH_SCTR_FLE_Pos, 7);
 6523              	 .loc 3 1254 0
 6524 0092 384B     	 ldr r3,.L316+8
 6525 0094 374A     	 ldr r2,.L316+8
 6526 0096 526B     	 ldr r2,[r2,#52]
 6527 0098 3849     	 ldr r1,.L316+16
 6528 009a 0A40     	 and r2,r1
 6529 009c E021     	 mov r1,#224
 6530 009e C902     	 lsl r1,r1,#11
 6531 00a0 0A43     	 orr r2,r1
 6532 00a2 5A63     	 str r2,[r3,#52]
1255:../XMC1100-LibHaas.c **** 	WR_REG(USIC0_CH1->SCTR, USIC_CH_SCTR_WLE_Msk, USIC_CH_SCTR_WLE_Pos, 7);
 6533              	 .loc 3 1255 0
 6534 00a4 334B     	 ldr r3,.L316+8
 6535 00a6 334A     	 ldr r2,.L316+8
 6536 00a8 526B     	 ldr r2,[r2,#52]
 6537 00aa 3549     	 ldr r1,.L316+20
 6538 00ac 0A40     	 and r2,r1
 6539 00ae E021     	 mov r1,#224
 6540 00b0 C904     	 lsl r1,r1,#19
 6541 00b2 0A43     	 orr r2,r1
 6542 00b4 5A63     	 str r2,[r3,#52]
1256:../XMC1100-LibHaas.c **** 
1257:../XMC1100-LibHaas.c **** 		//Configuration of USIC Transmit Control/Status Register
1258:../XMC1100-LibHaas.c **** 		//TBUF Data Enable (TDEN) = 1, TBUF Data Single Shot Mode (TDSSM) = 1
1259:../XMC1100-LibHaas.c **** 	WR_REG(USIC0_CH1->TCSR, USIC_CH_TCSR_TDEN_Msk, USIC_CH_TCSR_TDEN_Pos, 1);
 6543              	 .loc 3 1259 0
 6544 00b6 2F4B     	 ldr r3,.L316+8
 6545 00b8 2E4A     	 ldr r2,.L316+8
 6546 00ba 926B     	 ldr r2,[r2,#56]
 6547 00bc 3149     	 ldr r1,.L316+24
 6548 00be 0A40     	 and r2,r1
 6549 00c0 8021     	 mov r1,#128
 6550 00c2 C900     	 lsl r1,r1,#3
 6551 00c4 0A43     	 orr r2,r1
 6552 00c6 9A63     	 str r2,[r3,#56]
1260:../XMC1100-LibHaas.c **** 	WR_REG(USIC0_CH1->TCSR, USIC_CH_TCSR_TDSSM_Msk, USIC_CH_TCSR_TDSSM_Pos, 1);
 6553              	 .loc 3 1260 0
 6554 00c8 2A4B     	 ldr r3,.L316+8
 6555 00ca 2A4A     	 ldr r2,.L316+8
 6556 00cc 926B     	 ldr r2,[r2,#56]
 6557 00ce 8021     	 mov r1,#128
 6558 00d0 4900     	 lsl r1,r1,#1
 6559 00d2 0A43     	 orr r2,r1
 6560 00d4 9A63     	 str r2,[r3,#56]
1261:../XMC1100-LibHaas.c **** 
1262:../XMC1100-LibHaas.c **** 		//Configuration of Protocol Control Register
1263:../XMC1100-LibHaas.c **** 		//Sample Mode (SMD) = 1, 1 Stop bit is selected, Sample Point (SP) = 2, Pulse Length (PL) = 0
1264:../XMC1100-LibHaas.c **** 	WR_REG(USIC0_CH1->PCR_ASCMode, USIC_CH_PCR_ASCMode_SMD_Msk,
 6561              	 .loc 3 1264 0
 6562 00d6 274B     	 ldr r3,.L316+8
 6563 00d8 264A     	 ldr r2,.L316+8
 6564 00da D26B     	 ldr r2,[r2,#60]
 6565 00dc 0121     	 mov r1,#1
 6566 00de 0A43     	 orr r2,r1
 6567 00e0 DA63     	 str r2,[r3,#60]
1265:../XMC1100-LibHaas.c **** 				USIC_CH_PCR_ASCMode_SMD_Pos, 1);
1266:../XMC1100-LibHaas.c **** 	WR_REG(USIC0_CH1->PCR_ASCMode, USIC_CH_PCR_ASCMode_STPB_Msk, USIC_CH_PCR_ASCMode_STPB_Pos, 0);
 6568              	 .loc 3 1266 0
 6569 00e2 244B     	 ldr r3,.L316+8
 6570 00e4 234A     	 ldr r2,.L316+8
 6571 00e6 D26B     	 ldr r2,[r2,#60]
 6572 00e8 0221     	 mov r1,#2
 6573 00ea 8A43     	 bic r2,r1
 6574 00ec DA63     	 str r2,[r3,#60]
1267:../XMC1100-LibHaas.c **** 	WR_REG(USIC0_CH1->PCR_ASCMode, USIC_CH_PCR_ASCMode_SP_Msk, USIC_CH_PCR_ASCMode_SP_Pos, 9);
 6575              	 .loc 3 1267 0
 6576 00ee 214B     	 ldr r3,.L316+8
 6577 00f0 204A     	 ldr r2,.L316+8
 6578 00f2 D26B     	 ldr r2,[r2,#60]
 6579 00f4 2449     	 ldr r1,.L316+28
 6580 00f6 0A40     	 and r2,r1
 6581 00f8 9021     	 mov r1,#144
 6582 00fa 0901     	 lsl r1,r1,#4
 6583 00fc 0A43     	 orr r2,r1
 6584 00fe DA63     	 str r2,[r3,#60]
1268:../XMC1100-LibHaas.c **** 		//TBIF is set to simplify polling
1269:../XMC1100-LibHaas.c **** 	WR_REG(USIC0_CH1->PSR_ASCMode, USIC_CH_PSR_TBIF_Msk, USIC_CH_PSR_TBIF_Pos, 1);
 6585              	 .loc 3 1269 0
 6586 0100 1C4B     	 ldr r3,.L316+8
 6587 0102 1C4A     	 ldr r2,.L316+8
 6588 0104 926C     	 ldr r2,[r2,#72]
 6589 0106 8021     	 mov r1,#128
 6590 0108 8901     	 lsl r1,r1,#6
 6591 010a 0A43     	 orr r2,r1
 6592 010c 9A64     	 str r2,[r3,#72]
1270:../XMC1100-LibHaas.c **** 		//Configuration of Transmitter Buffer Control Register
1271:../XMC1100-LibHaas.c **** 	WR_REG(USIC0_CH1->TBCTR, USIC_CH_TBCTR_LIMIT_Msk, USIC_CH_TBCTR_LIMIT_Pos, 0);
 6593              	 .loc 3 1271 0
 6594 010e 1949     	 ldr r1,.L316+8
 6595 0110 184A     	 ldr r2,.L316+8
 6596 0112 8423     	 mov r3,#132
 6597 0114 5B00     	 lsl r3,r3,#1
 6598 0116 D358     	 ldr r3,[r2,r3]
 6599 0118 1C4A     	 ldr r2,.L316+32
 6600 011a 1A40     	 and r2,r3
 6601 011c 8423     	 mov r3,#132
 6602 011e 5B00     	 lsl r3,r3,#1
 6603 0120 CA50     	 str r2,[r1,r3]
1272:../XMC1100-LibHaas.c **** 
1273:../XMC1100-LibHaas.c **** 		//Configuration of Channel Control Register
1274:../XMC1100-LibHaas.c **** 		//parity generation is disabled
1275:../XMC1100-LibHaas.c **** 	USIC0_CH1->CCR |=  0x02;	// ASC Mode
 6604              	 .loc 3 1275 0
 6605 0122 144B     	 ldr r3,.L316+8
 6606 0124 134A     	 ldr r2,.L316+8
 6607 0126 126C     	 ldr r2,[r2,#64]
 6608 0128 0221     	 mov r1,#2
 6609 012a 0A43     	 orr r2,r1
 6610 012c 1A64     	 str r2,[r3,#64]
1276:../XMC1100-LibHaas.c **** 
1277:../XMC1100-LibHaas.c **** 		//Data Pointer & Buffer Size for Transmitter Buffer Control - DPTR = 64,  SIZE = 6
1278:../XMC1100-LibHaas.c **** 	WR_REG(USIC0_CH1->TBCTR, USIC_CH_TBCTR_DPTRSIZE_Msk, USIC_CH_TBCTR_DPTRSIZE_Pos, 0x06000040);
 6611              	 .loc 3 1278 0
 6612 012e 1149     	 ldr r1,.L316+8
 6613 0130 104A     	 ldr r2,.L316+8
 6614 0132 8423     	 mov r3,#132
 6615 0134 5B00     	 lsl r3,r3,#1
 6616 0136 D358     	 ldr r3,[r2,r3]
 6617 0138 154A     	 ldr r2,.L316+36
 6618 013a 1340     	 and r3,r2
 6619 013c C022     	 mov r2,#192
 6620 013e D204     	 lsl r2,r2,#19
 6621 0140 1A43     	 orr r2,r3
 6622 0142 8423     	 mov r3,#132
 6623 0144 5B00     	 lsl r3,r3,#1
 6624 0146 CA50     	 str r2,[r1,r3]
1279:../XMC1100-LibHaas.c **** 		// Rx Pin:
1280:../XMC1100-LibHaas.c **** 	USIC0_CH1->DX0CR = 0x00;	// Kanal: USIC0_CH1 => DXnB auf P1.3 ( siehe Pin Mapping)
 6625              	 .loc 3 1280 0
 6626 0148 0A4B     	 ldr r3,.L316+8
 6627 014a 0022     	 mov r2,#0
 6628 014c DA61     	 str r2,[r3,#28]
1281:../XMC1100-LibHaas.c **** 	PORT1->IOCR0  |= 0b10111 << 19 ; // ALT 7 fuer P1.2 => TxD d.h. XMC1100 sendet auf P1.2
 6629              	 .loc 3 1281 0
 6630 014e 114B     	 ldr r3,.L316+40
 6631 0150 104A     	 ldr r2,.L316+40
 6632 0152 1269     	 ldr r2,[r2,#16]
 6633 0154 B821     	 mov r1,#184
 6634 0156 0904     	 lsl r1,r1,#16
 6635 0158 0A43     	 orr r2,r1
 6636 015a 1A61     	 str r2,[r3,#16]
1282:../XMC1100-LibHaas.c **** 	PORT1->IOCR0 &= 0x00ffffff;	// P1.3 => INPUT =>  RxD
 6637              	 .loc 3 1282 0
 6638 015c 0D4B     	 ldr r3,.L316+40
 6639 015e 0D4A     	 ldr r2,.L316+40
 6640 0160 1269     	 ldr r2,[r2,#16]
 6641 0162 1202     	 lsl r2,r2,#8
 6642 0164 120A     	 lsr r2,r2,#8
 6643 0166 1A61     	 str r2,[r3,#16]
1283:../XMC1100-LibHaas.c **** }
 6644              	 .loc 3 1283 0
 6645 0168 BD46     	 mov sp,r7
 6646              	 
 6647 016a 80BD     	 pop {r7,pc}
 6648              	.L317:
 6649              	 .align 2
 6650              	.L316:
 6651 016c 00000140 	 .word 1073807360
 6652 0170 00030140 	 .word 1073808128
 6653 0174 00020048 	 .word 1207960064
 6654 0178 FFFCFFFF 	 .word -769
 6655 017c FFFFC0FF 	 .word -4128769
 6656 0180 FFFFFFF0 	 .word -251658241
 6657 0184 FFF3FFFF 	 .word -3073
 6658 0188 FFE0FFFF 	 .word -7937
 6659 018c FFC0FFFF 	 .word -16129
 6660 0190 C0FFFFF8 	 .word -117440576
 6661 0194 00010440 	 .word 1074004224
 6662              	 .cfi_endproc
 6663              	.LFE90:
 6665              	 .section .text.rs232_init_bd,"ax",%progbits
 6666              	 .align 2
 6667              	 .global rs232_init_bd
 6668              	 .code 16
 6669              	 .thumb_func
 6671              	rs232_init_bd:
 6672              	.LFB91:
1284:../XMC1100-LibHaas.c **** 
1285:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
1286:../XMC1100-LibHaas.c **** // Serielle Schnittstelle initialisieren
1287:../XMC1100-LibHaas.c **** // RxD auf P1.3 , XMC1100 TxD auf P1.2, 9600 Baud, 8N1
1288:../XMC1100-LibHaas.c **** // über USB als virtuelle Schnittstelle COM x am PC verwendbar
1289:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
1290:../XMC1100-LibHaas.c **** void rs232_init_bd (int bd)
1291:../XMC1100-LibHaas.c **** {	//USIC0 Cannel 1 wird verwendet:
 6673              	 .loc 3 1291 0
 6674              	 .cfi_startproc
 6675 0000 80B5     	 push {r7,lr}
 6676              	.LCFI152:
 6677              	 .cfi_def_cfa_offset 8
 6678              	 .cfi_offset 7,-8
 6679              	 .cfi_offset 14,-4
 6680 0002 84B0     	 sub sp,sp,#16
 6681              	.LCFI153:
 6682              	 .cfi_def_cfa_offset 24
 6683 0004 00AF     	 add r7,sp,#0
 6684              	.LCFI154:
 6685              	 .cfi_def_cfa_register 7
 6686 0006 7860     	 str r0,[r7,#4]
1292:../XMC1100-LibHaas.c **** 	uint8_t brgPdivUART=1;
 6687              	 .loc 3 1292 0
 6688 0008 0F23     	 mov r3,#15
 6689 000a FB18     	 add r3,r7,r3
 6690 000c 0122     	 mov r2,#1
 6691 000e 1A70     	 strb r2,[r3]
1293:../XMC1100-LibHaas.c **** 
1294:../XMC1100-LibHaas.c **** 	SCU_GENERAL->PASSWD = 0x000000C0UL;
 6692              	 .loc 3 1294 0
 6693 0010 744B     	 ldr r3,.L325
 6694 0012 C022     	 mov r2,#192
 6695 0014 5A62     	 str r2,[r3,#36]
1295:../XMC1100-LibHaas.c **** 	SCU_CLK->CGATCLR0 |= 0x00000008;		// stop gating USIC
 6696              	 .loc 3 1295 0
 6697 0016 744B     	 ldr r3,.L325+4
 6698 0018 734A     	 ldr r2,.L325+4
 6699 001a 1269     	 ldr r2,[r2,#16]
 6700 001c 0821     	 mov r1,#8
 6701 001e 0A43     	 orr r2,r1
 6702 0020 1A61     	 str r2,[r3,#16]
1296:../XMC1100-LibHaas.c **** 		while((SCU_CLK->CLKCR)&0x40000000UL);	// wait for VDDC to stabilize
 6703              	 .loc 3 1296 0
 6704 0022 C046     	 mov r8,r8
 6705              	.L319:
 6706              	 .loc 3 1296 0 is_stmt 0 discriminator 1
 6707 0024 704B     	 ldr r3,.L325+4
 6708 0026 1A68     	 ldr r2,[r3]
 6709 0028 8023     	 mov r3,#128
 6710 002a DB05     	 lsl r3,r3,#23
 6711 002c 1340     	 and r3,r2
 6712 002e F9D1     	 bne .L319
1297:../XMC1100-LibHaas.c **** 	SCU_GENERAL->PASSWD = 0x000000C3UL;
 6713              	 .loc 3 1297 0 is_stmt 1
 6714 0030 6C4B     	 ldr r3,.L325
 6715 0032 C322     	 mov r2,#195
 6716 0034 5A62     	 str r2,[r3,#36]
1298:../XMC1100-LibHaas.c **** 
1299:../XMC1100-LibHaas.c **** 	USIC0_CH1->KSCFG |= 3UL ;	//  Mode enable + Freigabe write
 6717              	 .loc 3 1299 0
 6718 0036 6D4B     	 ldr r3,.L325+8
 6719 0038 6C4A     	 ldr r2,.L325+8
 6720 003a D268     	 ldr r2,[r2,#12]
 6721 003c 0321     	 mov r1,#3
 6722 003e 0A43     	 orr r2,r1
 6723 0040 DA60     	 str r2,[r3,#12]
1300:../XMC1100-LibHaas.c **** 	//WR_REG(USIC0_CH1->FDR, USIC_CH_FDR_DM_Msk, USIC_CH_FDR_DM_Pos, 2);
1301:../XMC1100-LibHaas.c **** 	USIC0_CH1->FDR |= 1UL << 15 ;	//Fractional divider mode selected
 6724              	 .loc 3 1301 0
 6725 0042 6A4B     	 ldr r3,.L325+8
 6726 0044 694A     	 ldr r2,.L325+8
 6727 0046 1269     	 ldr r2,[r2,#16]
 6728 0048 8021     	 mov r1,#128
 6729 004a 0902     	 lsl r1,r1,#8
 6730 004c 0A43     	 orr r2,r1
 6731 004e 1A61     	 str r2,[r3,#16]
1302:../XMC1100-LibHaas.c **** 		//Step value
1303:../XMC1100-LibHaas.c **** 	USIC0_CH1->FDR|= FDR_STEP ;
 6732              	 .loc 3 1303 0
 6733 0050 664B     	 ldr r3,.L325+8
 6734 0052 664A     	 ldr r2,.L325+8
 6735 0054 1269     	 ldr r2,[r2,#16]
 6736 0056 7621     	 mov r1,#118
 6737 0058 0A43     	 orr r2,r1
 6738 005a 1A61     	 str r2,[r3,#16]
1304:../XMC1100-LibHaas.c **** 		//Vorteiler:
1305:../XMC1100-LibHaas.c **** 		// Baudrate = 32 MHz * Step/1024 * 1/(PDIV +1)  * 1/ (PCTQ +1) * 1/ (DCTQ +1)
1306:../XMC1100-LibHaas.c **** 	USIC0_CH1->BRG &=0xFC00FFFF;  //Pdiv loeschen
 6739              	 .loc 3 1306 0
 6740 005c 634B     	 ldr r3,.L325+8
 6741 005e 634A     	 ldr r2,.L325+8
 6742 0060 5269     	 ldr r2,[r2,#20]
 6743 0062 6349     	 ldr r1,.L325+12
 6744 0064 0A40     	 and r2,r1
 6745 0066 5A61     	 str r2,[r3,#20]
1307:../XMC1100-LibHaas.c **** 	if (bd == 115200)  brgPdivUART=1;
 6746              	 .loc 3 1307 0
 6747 0068 7A68     	 ldr r2,[r7,#4]
 6748 006a E123     	 mov r3,#225
 6749 006c 5B02     	 lsl r3,r3,#9
 6750 006e 9A42     	 cmp r2,r3
 6751 0070 04D1     	 bne .L320
 6752              	 .loc 3 1307 0 is_stmt 0 discriminator 1
 6753 0072 0F23     	 mov r3,#15
 6754 0074 FB18     	 add r3,r7,r3
 6755 0076 0122     	 mov r2,#1
 6756 0078 1A70     	 strb r2,[r3]
 6757 007a 21E0     	 b .L321
 6758              	.L320:
1308:../XMC1100-LibHaas.c **** 	else if (bd == 57600) brgPdivUART=3;
 6759              	 .loc 3 1308 0 is_stmt 1
 6760 007c 7A68     	 ldr r2,[r7,#4]
 6761 007e E123     	 mov r3,#225
 6762 0080 1B02     	 lsl r3,r3,#8
 6763 0082 9A42     	 cmp r2,r3
 6764 0084 04D1     	 bne .L322
 6765              	 .loc 3 1308 0 is_stmt 0 discriminator 1
 6766 0086 0F23     	 mov r3,#15
 6767 0088 FB18     	 add r3,r7,r3
 6768 008a 0322     	 mov r2,#3
 6769 008c 1A70     	 strb r2,[r3]
 6770 008e 17E0     	 b .L321
 6771              	.L322:
1309:../XMC1100-LibHaas.c **** 	else if (bd == 38400) brgPdivUART=5;
 6772              	 .loc 3 1309 0 is_stmt 1
 6773 0090 7A68     	 ldr r2,[r7,#4]
 6774 0092 9623     	 mov r3,#150
 6775 0094 1B02     	 lsl r3,r3,#8
 6776 0096 9A42     	 cmp r2,r3
 6777 0098 04D1     	 bne .L323
 6778              	 .loc 3 1309 0 is_stmt 0 discriminator 1
 6779 009a 0F23     	 mov r3,#15
 6780 009c FB18     	 add r3,r7,r3
 6781 009e 0522     	 mov r2,#5
 6782 00a0 1A70     	 strb r2,[r3]
 6783 00a2 0DE0     	 b .L321
 6784              	.L323:
1310:../XMC1100-LibHaas.c **** 	else if (bd == 19200) brgPdivUART=11;
 6785              	 .loc 3 1310 0 is_stmt 1
 6786 00a4 7A68     	 ldr r2,[r7,#4]
 6787 00a6 9623     	 mov r3,#150
 6788 00a8 DB01     	 lsl r3,r3,#7
 6789 00aa 9A42     	 cmp r2,r3
 6790 00ac 04D1     	 bne .L324
 6791              	 .loc 3 1310 0 is_stmt 0 discriminator 1
 6792 00ae 0F23     	 mov r3,#15
 6793 00b0 FB18     	 add r3,r7,r3
 6794 00b2 0B22     	 mov r2,#11
 6795 00b4 1A70     	 strb r2,[r3]
 6796 00b6 03E0     	 b .L321
 6797              	.L324:
1311:../XMC1100-LibHaas.c **** 	else brgPdivUART=23; //if (bd == 9600)
 6798              	 .loc 3 1311 0 is_stmt 1
 6799 00b8 0F23     	 mov r3,#15
 6800 00ba FB18     	 add r3,r7,r3
 6801 00bc 1722     	 mov r2,#23
 6802 00be 1A70     	 strb r2,[r3]
 6803              	.L321:
1312:../XMC1100-LibHaas.c **** 	USIC0_CH1->BRG |= (brgPdivUART << 16) ;
 6804              	 .loc 3 1312 0
 6805 00c0 4A4B     	 ldr r3,.L325+8
 6806 00c2 4A4A     	 ldr r2,.L325+8
 6807 00c4 5269     	 ldr r2,[r2,#20]
 6808 00c6 0F21     	 mov r1,#15
 6809 00c8 7918     	 add r1,r7,r1
 6810 00ca 0978     	 ldrb r1,[r1]
 6811 00cc 0904     	 lsl r1,r1,#16
 6812 00ce 0A43     	 orr r2,r1
 6813 00d0 5A61     	 str r2,[r3,#20]
1313:../XMC1100-LibHaas.c **** 	USIC0_CH1->BRG |= BRG_DCTQ << 10 ;
 6814              	 .loc 3 1313 0
 6815 00d2 464B     	 ldr r3,.L325+8
 6816 00d4 454A     	 ldr r2,.L325+8
 6817 00d6 5269     	 ldr r2,[r2,#20]
 6818 00d8 F021     	 mov r1,#240
 6819 00da 8901     	 lsl r1,r1,#6
 6820 00dc 0A43     	 orr r2,r1
 6821 00de 5A61     	 str r2,[r3,#20]
1314:../XMC1100-LibHaas.c **** 	USIC0_CH1->BRG |= BRG_PCTQ << 8 ;
 6822              	 .loc 3 1314 0
 6823 00e0 424B     	 ldr r3,.L325+8
 6824 00e2 424A     	 ldr r2,.L325+8
 6825 00e4 5269     	 ldr r2,[r2,#20]
 6826 00e6 5A61     	 str r2,[r3,#20]
1315:../XMC1100-LibHaas.c **** 
1316:../XMC1100-LibHaas.c **** 		//Configuration of USIC Shift Control
1317:../XMC1100-LibHaas.c **** 		//Transmit/Receive LSB first is selected, Transmission Mode (TRM) = 1, Passive Data Level (PDL) =
1318:../XMC1100-LibHaas.c **** 	WR_REG(USIC0_CH1->SCTR, USIC_CH_SCTR_PDL_Msk, USIC_CH_SCTR_PDL_Pos, 1);
 6827              	 .loc 3 1318 0
 6828 00e8 404B     	 ldr r3,.L325+8
 6829 00ea 404A     	 ldr r2,.L325+8
 6830 00ec 526B     	 ldr r2,[r2,#52]
 6831 00ee 0221     	 mov r1,#2
 6832 00f0 0A43     	 orr r2,r1
 6833 00f2 5A63     	 str r2,[r3,#52]
1319:../XMC1100-LibHaas.c **** 	WR_REG(USIC0_CH1->SCTR, USIC_CH_SCTR_TRM_Msk, USIC_CH_SCTR_TRM_Pos, 1);
 6834              	 .loc 3 1319 0
 6835 00f4 3D4B     	 ldr r3,.L325+8
 6836 00f6 3D4A     	 ldr r2,.L325+8
 6837 00f8 526B     	 ldr r2,[r2,#52]
 6838 00fa 3E49     	 ldr r1,.L325+16
 6839 00fc 0A40     	 and r2,r1
 6840 00fe 8021     	 mov r1,#128
 6841 0100 4900     	 lsl r1,r1,#1
 6842 0102 0A43     	 orr r2,r1
 6843 0104 5A63     	 str r2,[r3,#52]
1320:../XMC1100-LibHaas.c **** 		//Set Word Length (WLE) & Frame Length (FLE)
1321:../XMC1100-LibHaas.c **** 	WR_REG(USIC0_CH1->SCTR, USIC_CH_SCTR_FLE_Msk, USIC_CH_SCTR_FLE_Pos, 7);
 6844              	 .loc 3 1321 0
 6845 0106 394B     	 ldr r3,.L325+8
 6846 0108 384A     	 ldr r2,.L325+8
 6847 010a 526B     	 ldr r2,[r2,#52]
 6848 010c 3A49     	 ldr r1,.L325+20
 6849 010e 0A40     	 and r2,r1
 6850 0110 E021     	 mov r1,#224
 6851 0112 C902     	 lsl r1,r1,#11
 6852 0114 0A43     	 orr r2,r1
 6853 0116 5A63     	 str r2,[r3,#52]
1322:../XMC1100-LibHaas.c **** 	WR_REG(USIC0_CH1->SCTR, USIC_CH_SCTR_WLE_Msk, USIC_CH_SCTR_WLE_Pos, 7);
 6854              	 .loc 3 1322 0
 6855 0118 344B     	 ldr r3,.L325+8
 6856 011a 344A     	 ldr r2,.L325+8
 6857 011c 526B     	 ldr r2,[r2,#52]
 6858 011e 3749     	 ldr r1,.L325+24
 6859 0120 0A40     	 and r2,r1
 6860 0122 E021     	 mov r1,#224
 6861 0124 C904     	 lsl r1,r1,#19
 6862 0126 0A43     	 orr r2,r1
 6863 0128 5A63     	 str r2,[r3,#52]
1323:../XMC1100-LibHaas.c **** 
1324:../XMC1100-LibHaas.c **** 		//Configuration of USIC Transmit Control/Status Register
1325:../XMC1100-LibHaas.c **** 		//TBUF Data Enable (TDEN) = 1, TBUF Data Single Shot Mode (TDSSM) = 1
1326:../XMC1100-LibHaas.c **** 	WR_REG(USIC0_CH1->TCSR, USIC_CH_TCSR_TDEN_Msk, USIC_CH_TCSR_TDEN_Pos, 1);
 6864              	 .loc 3 1326 0
 6865 012a 304B     	 ldr r3,.L325+8
 6866 012c 2F4A     	 ldr r2,.L325+8
 6867 012e 926B     	 ldr r2,[r2,#56]
 6868 0130 3349     	 ldr r1,.L325+28
 6869 0132 0A40     	 and r2,r1
 6870 0134 8021     	 mov r1,#128
 6871 0136 C900     	 lsl r1,r1,#3
 6872 0138 0A43     	 orr r2,r1
 6873 013a 9A63     	 str r2,[r3,#56]
1327:../XMC1100-LibHaas.c **** 	WR_REG(USIC0_CH1->TCSR, USIC_CH_TCSR_TDSSM_Msk, USIC_CH_TCSR_TDSSM_Pos, 1);
 6874              	 .loc 3 1327 0
 6875 013c 2B4B     	 ldr r3,.L325+8
 6876 013e 2B4A     	 ldr r2,.L325+8
 6877 0140 926B     	 ldr r2,[r2,#56]
 6878 0142 8021     	 mov r1,#128
 6879 0144 4900     	 lsl r1,r1,#1
 6880 0146 0A43     	 orr r2,r1
 6881 0148 9A63     	 str r2,[r3,#56]
1328:../XMC1100-LibHaas.c **** 
1329:../XMC1100-LibHaas.c **** 		//Configuration of Protocol Control Register
1330:../XMC1100-LibHaas.c **** 		//Sample Mode (SMD) = 1, 1 Stop bit is selected, Sample Point (SP) = 2, Pulse Length (PL) = 0
1331:../XMC1100-LibHaas.c **** 	WR_REG(USIC0_CH1->PCR_ASCMode, USIC_CH_PCR_ASCMode_SMD_Msk,
 6882              	 .loc 3 1331 0
 6883 014a 284B     	 ldr r3,.L325+8
 6884 014c 274A     	 ldr r2,.L325+8
 6885 014e D26B     	 ldr r2,[r2,#60]
 6886 0150 0121     	 mov r1,#1
 6887 0152 0A43     	 orr r2,r1
 6888 0154 DA63     	 str r2,[r3,#60]
1332:../XMC1100-LibHaas.c **** 				USIC_CH_PCR_ASCMode_SMD_Pos, 1);
1333:../XMC1100-LibHaas.c **** 	WR_REG(USIC0_CH1->PCR_ASCMode, USIC_CH_PCR_ASCMode_STPB_Msk, USIC_CH_PCR_ASCMode_STPB_Pos, 0);
 6889              	 .loc 3 1333 0
 6890 0156 254B     	 ldr r3,.L325+8
 6891 0158 244A     	 ldr r2,.L325+8
 6892 015a D26B     	 ldr r2,[r2,#60]
 6893 015c 0221     	 mov r1,#2
 6894 015e 8A43     	 bic r2,r1
 6895 0160 DA63     	 str r2,[r3,#60]
1334:../XMC1100-LibHaas.c **** 	WR_REG(USIC0_CH1->PCR_ASCMode, USIC_CH_PCR_ASCMode_SP_Msk, USIC_CH_PCR_ASCMode_SP_Pos, 9);
 6896              	 .loc 3 1334 0
 6897 0162 224B     	 ldr r3,.L325+8
 6898 0164 214A     	 ldr r2,.L325+8
 6899 0166 D26B     	 ldr r2,[r2,#60]
 6900 0168 2649     	 ldr r1,.L325+32
 6901 016a 0A40     	 and r2,r1
 6902 016c 9021     	 mov r1,#144
 6903 016e 0901     	 lsl r1,r1,#4
 6904 0170 0A43     	 orr r2,r1
 6905 0172 DA63     	 str r2,[r3,#60]
1335:../XMC1100-LibHaas.c **** 		//TBIF is set to simplify polling
1336:../XMC1100-LibHaas.c **** 	WR_REG(USIC0_CH1->PSR_ASCMode, USIC_CH_PSR_TBIF_Msk, USIC_CH_PSR_TBIF_Pos, 1);
 6906              	 .loc 3 1336 0
 6907 0174 1D4B     	 ldr r3,.L325+8
 6908 0176 1D4A     	 ldr r2,.L325+8
 6909 0178 926C     	 ldr r2,[r2,#72]
 6910 017a 8021     	 mov r1,#128
 6911 017c 8901     	 lsl r1,r1,#6
 6912 017e 0A43     	 orr r2,r1
 6913 0180 9A64     	 str r2,[r3,#72]
1337:../XMC1100-LibHaas.c **** 		//Configuration of Transmitter Buffer Control Register
1338:../XMC1100-LibHaas.c **** 	WR_REG(USIC0_CH1->TBCTR, USIC_CH_TBCTR_LIMIT_Msk, USIC_CH_TBCTR_LIMIT_Pos, 0);
 6914              	 .loc 3 1338 0
 6915 0182 1A49     	 ldr r1,.L325+8
 6916 0184 194A     	 ldr r2,.L325+8
 6917 0186 8423     	 mov r3,#132
 6918 0188 5B00     	 lsl r3,r3,#1
 6919 018a D358     	 ldr r3,[r2,r3]
 6920 018c 1E4A     	 ldr r2,.L325+36
 6921 018e 1A40     	 and r2,r3
 6922 0190 8423     	 mov r3,#132
 6923 0192 5B00     	 lsl r3,r3,#1
 6924 0194 CA50     	 str r2,[r1,r3]
1339:../XMC1100-LibHaas.c **** 
1340:../XMC1100-LibHaas.c **** 		//Configuration of Channel Control Register
1341:../XMC1100-LibHaas.c **** 		//parity generation is disabled
1342:../XMC1100-LibHaas.c **** 	USIC0_CH1->CCR |=  0x02;	// ASC Mode
 6925              	 .loc 3 1342 0
 6926 0196 154B     	 ldr r3,.L325+8
 6927 0198 144A     	 ldr r2,.L325+8
 6928 019a 126C     	 ldr r2,[r2,#64]
 6929 019c 0221     	 mov r1,#2
 6930 019e 0A43     	 orr r2,r1
 6931 01a0 1A64     	 str r2,[r3,#64]
1343:../XMC1100-LibHaas.c **** 
1344:../XMC1100-LibHaas.c **** 		//Data Pointer & Buffer Size for Transmitter Buffer Control - DPTR = 64,  SIZE = 6
1345:../XMC1100-LibHaas.c **** 	WR_REG(USIC0_CH1->TBCTR, USIC_CH_TBCTR_DPTRSIZE_Msk, USIC_CH_TBCTR_DPTRSIZE_Pos, 0x06000040);
 6932              	 .loc 3 1345 0
 6933 01a2 1249     	 ldr r1,.L325+8
 6934 01a4 114A     	 ldr r2,.L325+8
 6935 01a6 8423     	 mov r3,#132
 6936 01a8 5B00     	 lsl r3,r3,#1
 6937 01aa D358     	 ldr r3,[r2,r3]
 6938 01ac 174A     	 ldr r2,.L325+40
 6939 01ae 1340     	 and r3,r2
 6940 01b0 C022     	 mov r2,#192
 6941 01b2 D204     	 lsl r2,r2,#19
 6942 01b4 1A43     	 orr r2,r3
 6943 01b6 8423     	 mov r3,#132
 6944 01b8 5B00     	 lsl r3,r3,#1
 6945 01ba CA50     	 str r2,[r1,r3]
1346:../XMC1100-LibHaas.c **** 		// Rx Pin:
1347:../XMC1100-LibHaas.c **** 	USIC0_CH1->DX0CR = 0x00;	// Kanal: USIC0_CH1 => DXnB auf P1.3 ( siehe Pin Mapping)
 6946              	 .loc 3 1347 0
 6947 01bc 0B4B     	 ldr r3,.L325+8
 6948 01be 0022     	 mov r2,#0
 6949 01c0 DA61     	 str r2,[r3,#28]
1348:../XMC1100-LibHaas.c **** 	PORT1->IOCR0  |= 0b10111 << 19 ; // ALT 7 fuer P1.2 => TxD d.h. XMC1100 sendet auf P1.2
 6950              	 .loc 3 1348 0
 6951 01c2 134B     	 ldr r3,.L325+44
 6952 01c4 124A     	 ldr r2,.L325+44
 6953 01c6 1269     	 ldr r2,[r2,#16]
 6954 01c8 B821     	 mov r1,#184
 6955 01ca 0904     	 lsl r1,r1,#16
 6956 01cc 0A43     	 orr r2,r1
 6957 01ce 1A61     	 str r2,[r3,#16]
1349:../XMC1100-LibHaas.c **** 	PORT1->IOCR0 &= 0x00ffffff;	// P1.3 => INPUT =>  RxD
 6958              	 .loc 3 1349 0
 6959 01d0 0F4B     	 ldr r3,.L325+44
 6960 01d2 0F4A     	 ldr r2,.L325+44
 6961 01d4 1269     	 ldr r2,[r2,#16]
 6962 01d6 1202     	 lsl r2,r2,#8
 6963 01d8 120A     	 lsr r2,r2,#8
 6964 01da 1A61     	 str r2,[r3,#16]
1350:../XMC1100-LibHaas.c **** }
 6965              	 .loc 3 1350 0
 6966 01dc BD46     	 mov sp,r7
 6967 01de 04B0     	 add sp,sp,#16
 6968              	 
 6969 01e0 80BD     	 pop {r7,pc}
 6970              	.L326:
 6971 01e2 C046     	 .align 2
 6972              	.L325:
 6973 01e4 00000140 	 .word 1073807360
 6974 01e8 00030140 	 .word 1073808128
 6975 01ec 00020048 	 .word 1207960064
 6976 01f0 FFFF00FC 	 .word -67043329
 6977 01f4 FFFCFFFF 	 .word -769
 6978 01f8 FFFFC0FF 	 .word -4128769
 6979 01fc FFFFFFF0 	 .word -251658241
 6980 0200 FFF3FFFF 	 .word -3073
 6981 0204 FFE0FFFF 	 .word -7937
 6982 0208 FFC0FFFF 	 .word -16129
 6983 020c C0FFFFF8 	 .word -117440576
 6984 0210 00010440 	 .word 1074004224
 6985              	 .cfi_endproc
 6986              	.LFE91:
 6988              	 .section .text.rs232_interrupt_enable,"ax",%progbits
 6989              	 .align 2
 6990              	 .global rs232_interrupt_enable
 6991              	 .code 16
 6992              	 .thumb_func
 6994              	rs232_interrupt_enable:
 6995              	.LFB92:
1351:../XMC1100-LibHaas.c **** 
1352:../XMC1100-LibHaas.c **** void rs232_interrupt_enable()
1353:../XMC1100-LibHaas.c **** {
 6996              	 .loc 3 1353 0
 6997              	 .cfi_startproc
 6998 0000 80B5     	 push {r7,lr}
 6999              	.LCFI155:
 7000              	 .cfi_def_cfa_offset 8
 7001              	 .cfi_offset 7,-8
 7002              	 .cfi_offset 14,-4
 7003 0002 00AF     	 add r7,sp,#0
 7004              	.LCFI156:
 7005              	 .cfi_def_cfa_register 7
1354:../XMC1100-LibHaas.c **** 	USIC0_CH1->CCR  |=0x00004000;
 7006              	 .loc 3 1354 0
 7007 0004 0C4B     	 ldr r3,.L328
 7008 0006 0C4A     	 ldr r2,.L328
 7009 0008 126C     	 ldr r2,[r2,#64]
 7010 000a 8021     	 mov r1,#128
 7011 000c C901     	 lsl r1,r1,#7
 7012 000e 0A43     	 orr r2,r1
 7013 0010 1A64     	 str r2,[r3,#64]
1355:../XMC1100-LibHaas.c **** 	USIC0_CH1->INPR &=0xFFFFF8FF;
 7014              	 .loc 3 1355 0
 7015 0012 094B     	 ldr r3,.L328
 7016 0014 084A     	 ldr r2,.L328
 7017 0016 9269     	 ldr r2,[r2,#24]
 7018 0018 0849     	 ldr r1,.L328+4
 7019 001a 0A40     	 and r2,r1
 7020 001c 9A61     	 str r2,[r3,#24]
1356:../XMC1100-LibHaas.c **** 	USIC0_CH1->PSCR |=0x00000400;
 7021              	 .loc 3 1356 0
 7022 001e 064B     	 ldr r3,.L328
 7023 0020 054A     	 ldr r2,.L328
 7024 0022 D26C     	 ldr r2,[r2,#76]
 7025 0024 8021     	 mov r1,#128
 7026 0026 C900     	 lsl r1,r1,#3
 7027 0028 0A43     	 orr r2,r1
 7028 002a DA64     	 str r2,[r3,#76]
1357:../XMC1100-LibHaas.c **** 	//NVIC_EnableIRQ(USIC0_0_IRQn); 	// Int Freigabe  SR0 für empfange Zeichen
1358:../XMC1100-LibHaas.c **** 	NVIC_EnableIRQ(9); 	// Int Freigabe  SR0 für empfange Zeichen
 7029              	 .loc 3 1358 0
 7030 002c 0920     	 mov r0,#9
 7031 002e FFF7FEFF 	 bl __NVIC_EnableIRQ
1359:../XMC1100-LibHaas.c **** }
 7032              	 .loc 3 1359 0
 7033 0032 BD46     	 mov sp,r7
 7034              	 
 7035 0034 80BD     	 pop {r7,pc}
 7036              	.L329:
 7037 0036 C046     	 .align 2
 7038              	.L328:
 7039 0038 00020048 	 .word 1207960064
 7040 003c FFF8FFFF 	 .word -1793
 7041              	 .cfi_endproc
 7042              	.LFE92:
 7044              	 .section .text.rs232_get,"ax",%progbits
 7045              	 .align 2
 7046              	 .global rs232_get
 7047              	 .code 16
 7048              	 .thumb_func
 7050              	rs232_get:
 7051              	.LFB93:
1360:../XMC1100-LibHaas.c **** /*
1361:../XMC1100-LibHaas.c **** void USIC0_0_IRQHandler(void)
1362:../XMC1100-LibHaas.c **** {
1363:../XMC1100-LibHaas.c **** 	empfangsdaten[0]=USIC0_CH0->RBUF & 0xff ;	// RX Buffer auslesen
1364:../XMC1100-LibHaas.c **** }
1365:../XMC1100-LibHaas.c **** */
1366:../XMC1100-LibHaas.c **** 
1367:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
1368:../XMC1100-LibHaas.c **** // liest ein Byte (1..255) von COM, liefert 0 wenn kein Zeichen vorhanden
1369:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
1370:../XMC1100-LibHaas.c **** char rs232_get ( void )
1371:../XMC1100-LibHaas.c **** {
 7052              	 .loc 3 1371 0
 7053              	 .cfi_startproc
 7054 0000 80B5     	 push {r7,lr}
 7055              	.LCFI157:
 7056              	 .cfi_def_cfa_offset 8
 7057              	 .cfi_offset 7,-8
 7058              	 .cfi_offset 14,-4
 7059 0002 82B0     	 sub sp,sp,#8
 7060              	.LCFI158:
 7061              	 .cfi_def_cfa_offset 16
 7062 0004 00AF     	 add r7,sp,#0
 7063              	.LCFI159:
 7064              	 .cfi_def_cfa_register 7
1372:../XMC1100-LibHaas.c ****   uint8_t buffer;
1373:../XMC1100-LibHaas.c **** 	buffer = 0;
 7065              	 .loc 3 1373 0
 7066 0006 FB1D     	 add r3,r7,#7
 7067 0008 0022     	 mov r2,#0
 7068 000a 1A70     	 strb r2,[r3]
1374:../XMC1100-LibHaas.c **** 	if ((USIC0_CH1->PSR &(1UL <<14)) != 0)  // wenn Zeichen vorhanden
 7069              	 .loc 3 1374 0
 7070 000c 0B4B     	 ldr r3,.L333
 7071 000e 9A6C     	 ldr r2,[r3,#72]
 7072 0010 8023     	 mov r3,#128
 7073 0012 DB01     	 lsl r3,r3,#7
 7074 0014 1340     	 and r3,r2
 7075 0016 0AD0     	 beq .L331
1375:../XMC1100-LibHaas.c **** 	 {
1376:../XMC1100-LibHaas.c **** 		buffer = USIC0_CH1->RBUF & 0xff ;	// RX Buffer auslesen
 7076              	 .loc 3 1376 0
 7077 0018 084B     	 ldr r3,.L333
 7078 001a 5A6D     	 ldr r2,[r3,#84]
 7079 001c FB1D     	 add r3,r7,#7
 7080 001e 1A70     	 strb r2,[r3]
1377:../XMC1100-LibHaas.c **** 		USIC0_CH1->PSCR |= 1UL <<14 ;		// Receive Flag löschen
 7081              	 .loc 3 1377 0
 7082 0020 064B     	 ldr r3,.L333
 7083 0022 064A     	 ldr r2,.L333
 7084 0024 D26C     	 ldr r2,[r2,#76]
 7085 0026 8021     	 mov r1,#128
 7086 0028 C901     	 lsl r1,r1,#7
 7087 002a 0A43     	 orr r2,r1
 7088 002c DA64     	 str r2,[r3,#76]
 7089              	.L331:
1378:../XMC1100-LibHaas.c **** 	 }
1379:../XMC1100-LibHaas.c **** 	return buffer;
 7090              	 .loc 3 1379 0
 7091 002e FB1D     	 add r3,r7,#7
 7092 0030 1B78     	 ldrb r3,[r3]
1380:../XMC1100-LibHaas.c **** }
 7093              	 .loc 3 1380 0
 7094 0032 181C     	 mov r0,r3
 7095 0034 BD46     	 mov sp,r7
 7096 0036 02B0     	 add sp,sp,#8
 7097              	 
 7098 0038 80BD     	 pop {r7,pc}
 7099              	.L334:
 7100 003a C046     	 .align 2
 7101              	.L333:
 7102 003c 00020048 	 .word 1207960064
 7103              	 .cfi_endproc
 7104              	.LFE93:
 7106              	 .section .text.rs232_char_received,"ax",%progbits
 7107              	 .align 2
 7108              	 .global rs232_char_received
 7109              	 .code 16
 7110              	 .thumb_func
 7112              	rs232_char_received:
 7113              	.LFB94:
1381:../XMC1100-LibHaas.c **** //-----------------------------------------------------------------
1382:../XMC1100-LibHaas.c **** // liefert 1 wenn Zeichen empfangen und 0 wenn kein Zeichen empfangen
1383:../XMC1100-LibHaas.c **** //----------------------------------------------------------------
1384:../XMC1100-LibHaas.c **** uint8_t rs232_char_received (void)
1385:../XMC1100-LibHaas.c **** {
 7114              	 .loc 3 1385 0
 7115              	 .cfi_startproc
 7116 0000 80B5     	 push {r7,lr}
 7117              	.LCFI160:
 7118              	 .cfi_def_cfa_offset 8
 7119              	 .cfi_offset 7,-8
 7120              	 .cfi_offset 14,-4
 7121 0002 00AF     	 add r7,sp,#0
 7122              	.LCFI161:
 7123              	 .cfi_def_cfa_register 7
1386:../XMC1100-LibHaas.c **** 	if ((USIC0_CH1->PSR &(1UL <<14)) != 0) return 1; // wenn Zeichen vorhanden
 7124              	 .loc 3 1386 0
 7125 0004 054B     	 ldr r3,.L338
 7126 0006 9A6C     	 ldr r2,[r3,#72]
 7127 0008 8023     	 mov r3,#128
 7128 000a DB01     	 lsl r3,r3,#7
 7129 000c 1340     	 and r3,r2
 7130 000e 01D0     	 beq .L336
 7131              	 .loc 3 1386 0 is_stmt 0 discriminator 1
 7132 0010 0123     	 mov r3,#1
 7133 0012 00E0     	 b .L337
 7134              	.L336:
1387:../XMC1100-LibHaas.c **** 		else return 0;
 7135              	 .loc 3 1387 0 is_stmt 1
 7136 0014 0023     	 mov r3,#0
 7137              	.L337:
1388:../XMC1100-LibHaas.c **** }
 7138              	 .loc 3 1388 0
 7139 0016 181C     	 mov r0,r3
 7140 0018 BD46     	 mov sp,r7
 7141              	 
 7142 001a 80BD     	 pop {r7,pc}
 7143              	.L339:
 7144              	 .align 2
 7145              	.L338:
 7146 001c 00020048 	 .word 1207960064
 7147              	 .cfi_endproc
 7148              	.LFE94:
 7150              	 .section .text.rs232_wait_get,"ax",%progbits
 7151              	 .align 2
 7152              	 .global rs232_wait_get
 7153              	 .code 16
 7154              	 .thumb_func
 7156              	rs232_wait_get:
 7157              	.LFB95:
1389:../XMC1100-LibHaas.c **** 
1390:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
1391:../XMC1100-LibHaas.c **** // wartet auf ein Byte von COM und liest es ein (0..255)
1392:../XMC1100-LibHaas.c **** // Achtung! Programm bleibt solange in dieser Funktion, bis ein Zeichen eintrifft!
1393:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
1394:../XMC1100-LibHaas.c **** char rs232_wait_get ( void )
1395:../XMC1100-LibHaas.c **** {
 7158              	 .loc 3 1395 0
 7159              	 .cfi_startproc
 7160 0000 80B5     	 push {r7,lr}
 7161              	.LCFI162:
 7162              	 .cfi_def_cfa_offset 8
 7163              	 .cfi_offset 7,-8
 7164              	 .cfi_offset 14,-4
 7165 0002 82B0     	 sub sp,sp,#8
 7166              	.LCFI163:
 7167              	 .cfi_def_cfa_offset 16
 7168 0004 00AF     	 add r7,sp,#0
 7169              	.LCFI164:
 7170              	 .cfi_def_cfa_register 7
1396:../XMC1100-LibHaas.c ****   uint8_t buffer;
1397:../XMC1100-LibHaas.c **** 	while ((USIC0_CH1->PSR &(1UL <<14)) == 0); 	// auf Zeichen warten
 7171              	 .loc 3 1397 0
 7172 0006 C046     	 mov r8,r8
 7173              	.L341:
 7174              	 .loc 3 1397 0 is_stmt 0 discriminator 1
 7175 0008 0B4B     	 ldr r3,.L343
 7176 000a 9A6C     	 ldr r2,[r3,#72]
 7177 000c 8023     	 mov r3,#128
 7178 000e DB01     	 lsl r3,r3,#7
 7179 0010 1340     	 and r3,r2
 7180 0012 F9D0     	 beq .L341
1398:../XMC1100-LibHaas.c **** 	buffer = USIC0_CH1->RBUF & 0xff ;			// RX Buffer auslesen
 7181              	 .loc 3 1398 0 is_stmt 1
 7182 0014 084B     	 ldr r3,.L343
 7183 0016 5A6D     	 ldr r2,[r3,#84]
 7184 0018 FB1D     	 add r3,r7,#7
 7185 001a 1A70     	 strb r2,[r3]
1399:../XMC1100-LibHaas.c **** 	USIC0_CH1->PSCR |= 1UL <<14 ;				// Receive Flag löschen
 7186              	 .loc 3 1399 0
 7187 001c 064B     	 ldr r3,.L343
 7188 001e 064A     	 ldr r2,.L343
 7189 0020 D26C     	 ldr r2,[r2,#76]
 7190 0022 8021     	 mov r1,#128
 7191 0024 C901     	 lsl r1,r1,#7
 7192 0026 0A43     	 orr r2,r1
 7193 0028 DA64     	 str r2,[r3,#76]
1400:../XMC1100-LibHaas.c **** 	return buffer;
 7194              	 .loc 3 1400 0
 7195 002a FB1D     	 add r3,r7,#7
 7196 002c 1B78     	 ldrb r3,[r3]
1401:../XMC1100-LibHaas.c **** }
 7197              	 .loc 3 1401 0
 7198 002e 181C     	 mov r0,r3
 7199 0030 BD46     	 mov sp,r7
 7200 0032 02B0     	 add sp,sp,#8
 7201              	 
 7202 0034 80BD     	 pop {r7,pc}
 7203              	.L344:
 7204 0036 C046     	 .align 2
 7205              	.L343:
 7206 0038 00020048 	 .word 1207960064
 7207              	 .cfi_endproc
 7208              	.LFE95:
 7210              	 .section .text.rs232_put,"ax",%progbits
 7211              	 .align 2
 7212              	 .global rs232_put
 7213              	 .code 16
 7214              	 .thumb_func
 7216              	rs232_put:
 7217              	.LFB96:
1402:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
1403:../XMC1100-LibHaas.c **** // schreibt ein Byte auf COM
1404:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
1405:../XMC1100-LibHaas.c **** void rs232_put ( char value )
1406:../XMC1100-LibHaas.c **** {
 7218              	 .loc 3 1406 0
 7219              	 .cfi_startproc
 7220 0000 80B5     	 push {r7,lr}
 7221              	.LCFI165:
 7222              	 .cfi_def_cfa_offset 8
 7223              	 .cfi_offset 7,-8
 7224              	 .cfi_offset 14,-4
 7225 0002 82B0     	 sub sp,sp,#8
 7226              	.LCFI166:
 7227              	 .cfi_def_cfa_offset 16
 7228 0004 00AF     	 add r7,sp,#0
 7229              	.LCFI167:
 7230              	 .cfi_def_cfa_register 7
 7231 0006 021C     	 mov r2,r0
 7232 0008 FB1D     	 add r3,r7,#7
 7233 000a 1A70     	 strb r2,[r3]
1407:../XMC1100-LibHaas.c **** 	USIC0_CH1->IN[0] = value;
 7234              	 .loc 3 1407 0
 7235 000c 0849     	 ldr r1,.L347
 7236 000e FB1D     	 add r3,r7,#7
 7237 0010 1A78     	 ldrb r2,[r3]
 7238 0012 C023     	 mov r3,#192
 7239 0014 5B00     	 lsl r3,r3,#1
 7240 0016 CA50     	 str r2,[r1,r3]
1408:../XMC1100-LibHaas.c **** 	while((USIC0_CH1->TRBSR & (1U<< 11))  == 0);  // Warten , falls Transmit Buffer empty
 7241              	 .loc 3 1408 0
 7242 0018 C046     	 mov r8,r8
 7243              	.L346:
 7244              	 .loc 3 1408 0 is_stmt 0 discriminator 1
 7245 001a 054A     	 ldr r2,.L347
 7246 001c 8A23     	 mov r3,#138
 7247 001e 5B00     	 lsl r3,r3,#1
 7248 0020 D258     	 ldr r2,[r2,r3]
 7249 0022 8023     	 mov r3,#128
 7250 0024 1B01     	 lsl r3,r3,#4
 7251 0026 1340     	 and r3,r2
 7252 0028 F7D0     	 beq .L346
1409:../XMC1100-LibHaas.c **** 
1410:../XMC1100-LibHaas.c **** }
 7253              	 .loc 3 1410 0 is_stmt 1
 7254 002a BD46     	 mov sp,r7
 7255 002c 02B0     	 add sp,sp,#8
 7256              	 
 7257 002e 80BD     	 pop {r7,pc}
 7258              	.L348:
 7259              	 .align 2
 7260              	.L347:
 7261 0030 00020048 	 .word 1207960064
 7262              	 .cfi_endproc
 7263              	.LFE96:
 7265              	 .section .text.rs232_print,"ax",%progbits
 7266              	 .align 2
 7267              	 .global rs232_print
 7268              	 .code 16
 7269              	 .thumb_func
 7271              	rs232_print:
 7272              	.LFB97:
1411:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
1412:../XMC1100-LibHaas.c **** // schreibt eine nullterminierte Zeichenfolge auf COM
1413:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
1414:../XMC1100-LibHaas.c **** void rs232_print ( char *text )
1415:../XMC1100-LibHaas.c **** {
 7273              	 .loc 3 1415 0
 7274              	 .cfi_startproc
 7275 0000 80B5     	 push {r7,lr}
 7276              	.LCFI168:
 7277              	 .cfi_def_cfa_offset 8
 7278              	 .cfi_offset 7,-8
 7279              	 .cfi_offset 14,-4
 7280 0002 82B0     	 sub sp,sp,#8
 7281              	.LCFI169:
 7282              	 .cfi_def_cfa_offset 16
 7283 0004 00AF     	 add r7,sp,#0
 7284              	.LCFI170:
 7285              	 .cfi_def_cfa_register 7
 7286 0006 7860     	 str r0,[r7,#4]
1416:../XMC1100-LibHaas.c ****   while (*text != '\0')
 7287              	 .loc 3 1416 0
 7288 0008 06E0     	 b .L350
 7289              	.L351:
1417:../XMC1100-LibHaas.c ****     rs232_put(*text++);
 7290              	 .loc 3 1417 0
 7291 000a 7B68     	 ldr r3,[r7,#4]
 7292 000c 5A1C     	 add r2,r3,#1
 7293 000e 7A60     	 str r2,[r7,#4]
 7294 0010 1B78     	 ldrb r3,[r3]
 7295 0012 181C     	 mov r0,r3
 7296 0014 FFF7FEFF 	 bl rs232_put
 7297              	.L350:
1416:../XMC1100-LibHaas.c ****   while (*text != '\0')
 7298              	 .loc 3 1416 0
 7299 0018 7B68     	 ldr r3,[r7,#4]
 7300 001a 1B78     	 ldrb r3,[r3]
 7301 001c 002B     	 cmp r3,#0
 7302 001e F4D1     	 bne .L351
1418:../XMC1100-LibHaas.c **** }
 7303              	 .loc 3 1418 0
 7304 0020 BD46     	 mov sp,r7
 7305 0022 02B0     	 add sp,sp,#8
 7306              	 
 7307 0024 80BD     	 pop {r7,pc}
 7308              	 .cfi_endproc
 7309              	.LFE97:
 7311 0026 C046     	 .section .text.USIC0_0_IRQHandler,"ax",%progbits
 7312              	 .align 2
 7313              	 .global USIC0_0_IRQHandler
 7314              	 .code 16
 7315              	 .thumb_func
 7317              	USIC0_0_IRQHandler:
 7318              	.LFB98:
1419:../XMC1100-LibHaas.c **** 
1420:../XMC1100-LibHaas.c **** /*------------------------------------------------------------------
1421:../XMC1100-LibHaas.c **** * Bei jedem empfangenen Zeichen wird diese Interrupt Service Routine aktiviert
1422:../XMC1100-LibHaas.c **** * Diese USIC-ISR kann ins eigene Programm kopiert werden dann muss diese
1423:../XMC1100-LibHaas.c **** * Variante auskommentiert werden.
1424:../XMC1100-LibHaas.c **** * Diese ISR arbeitet mit folgende Funktionen:
1425:../XMC1100-LibHaas.c **** * rs232_wait_of_enter(), rs232_clear_receivedata()
1426:../XMC1100-LibHaas.c **** * Es werden folgende globale Variablen benötigt:
1427:../XMC1100-LibHaas.c **** * rs232Receivedata, rs232ReceivedataPointer, rs232EnterReceive
1428:../XMC1100-LibHaas.c **** */
1429:../XMC1100-LibHaas.c **** void USIC0_0_IRQHandler(void)
1430:../XMC1100-LibHaas.c **** {
 7319              	 .loc 3 1430 0
 7320              	 .cfi_startproc
 7321 0000 80B5     	 push {r7,lr}
 7322              	.LCFI171:
 7323              	 .cfi_def_cfa_offset 8
 7324              	 .cfi_offset 7,-8
 7325              	 .cfi_offset 14,-4
 7326 0002 82B0     	 sub sp,sp,#8
 7327              	.LCFI172:
 7328              	 .cfi_def_cfa_offset 16
 7329 0004 00AF     	 add r7,sp,#0
 7330              	.LCFI173:
 7331              	 .cfi_def_cfa_register 7
1431:../XMC1100-LibHaas.c **** 	char temp=USIC0_CH1->RBUF & 0xff;	// Rx-Buffer auslesen
 7332              	 .loc 3 1431 0
 7333 0006 114B     	 ldr r3,.L356
 7334 0008 5A6D     	 ldr r2,[r3,#84]
 7335 000a FB1D     	 add r3,r7,#7
 7336 000c 1A70     	 strb r2,[r3]
1432:../XMC1100-LibHaas.c **** 	if (temp == '\r') {					// Enterzeichen empfangen?
 7337              	 .loc 3 1432 0
 7338 000e FB1D     	 add r3,r7,#7
 7339 0010 1B78     	 ldrb r3,[r3]
 7340 0012 0D2B     	 cmp r3,#13
 7341 0014 09D1     	 bne .L353
1433:../XMC1100-LibHaas.c **** 		rs232Receivedata[rs232ReceivedataPointer]='\0';
 7342              	 .loc 3 1433 0
 7343 0016 0E4B     	 ldr r3,.L356+4
 7344 0018 1B78     	 ldrb r3,[r3]
 7345 001a 1A1C     	 mov r2,r3
 7346 001c 0D4B     	 ldr r3,.L356+8
 7347 001e 0021     	 mov r1,#0
 7348 0020 9954     	 strb r1,[r3,r2]
1434:../XMC1100-LibHaas.c **** 		rs232EnterReceive = 1;
 7349              	 .loc 3 1434 0
 7350 0022 0D4B     	 ldr r3,.L356+12
 7351 0024 0122     	 mov r2,#1
 7352 0026 1A70     	 strb r2,[r3]
 7353 0028 06E0     	 b .L354
 7354              	.L353:
1435:../XMC1100-LibHaas.c **** 	} else {
1436:../XMC1100-LibHaas.c **** 		rs232Receivedata[rs232ReceivedataPointer]=temp;
 7355              	 .loc 3 1436 0
 7356 002a 094B     	 ldr r3,.L356+4
 7357 002c 1B78     	 ldrb r3,[r3]
 7358 002e 191C     	 mov r1,r3
 7359 0030 084B     	 ldr r3,.L356+8
 7360 0032 FA1D     	 add r2,r7,#7
 7361 0034 1278     	 ldrb r2,[r2]
 7362 0036 5A54     	 strb r2,[r3,r1]
 7363              	.L354:
1437:../XMC1100-LibHaas.c **** 	}
1438:../XMC1100-LibHaas.c **** 	rs232ReceivedataPointer++;
 7364              	 .loc 3 1438 0
 7365 0038 054B     	 ldr r3,.L356+4
 7366 003a 1B78     	 ldrb r3,[r3]
 7367 003c 0133     	 add r3,r3,#1
 7368 003e DAB2     	 uxtb r2,r3
 7369 0040 034B     	 ldr r3,.L356+4
 7370 0042 1A70     	 strb r2,[r3]
1439:../XMC1100-LibHaas.c **** 	return;
 7371              	 .loc 3 1439 0
 7372 0044 C046     	 mov r8,r8
1440:../XMC1100-LibHaas.c **** }
 7373              	 .loc 3 1440 0
 7374 0046 BD46     	 mov sp,r7
 7375 0048 02B0     	 add sp,sp,#8
 7376              	 
 7377 004a 80BD     	 pop {r7,pc}
 7378              	.L357:
 7379              	 .align 2
 7380              	.L356:
 7381 004c 00020048 	 .word 1207960064
 7382 0050 00000000 	 .word rs232ReceivedataPointer
 7383 0054 00000000 	 .word rs232Receivedata
 7384 0058 00000000 	 .word rs232EnterReceive
 7385              	 .cfi_endproc
 7386              	.LFE98:
 7388              	 .section .text.rs232_wait_of_enter,"ax",%progbits
 7389              	 .align 2
 7390              	 .global rs232_wait_of_enter
 7391              	 .code 16
 7392              	 .thumb_func
 7394              	rs232_wait_of_enter:
 7395              	.LFB99:
1441:../XMC1100-LibHaas.c **** void rs232_wait_of_enter()
1442:../XMC1100-LibHaas.c **** {
 7396              	 .loc 3 1442 0
 7397              	 .cfi_startproc
 7398 0000 80B5     	 push {r7,lr}
 7399              	.LCFI174:
 7400              	 .cfi_def_cfa_offset 8
 7401              	 .cfi_offset 7,-8
 7402              	 .cfi_offset 14,-4
 7403 0002 00AF     	 add r7,sp,#0
 7404              	.LCFI175:
 7405              	 .cfi_def_cfa_register 7
1443:../XMC1100-LibHaas.c **** 	while (rs232EnterReceive==0) {}
 7406              	 .loc 3 1443 0
 7407 0004 C046     	 mov r8,r8
 7408              	.L359:
 7409              	 .loc 3 1443 0 is_stmt 0 discriminator 1
 7410 0006 044B     	 ldr r3,.L360
 7411 0008 1B78     	 ldrb r3,[r3]
 7412 000a 002B     	 cmp r3,#0
 7413 000c FBD0     	 beq .L359
1444:../XMC1100-LibHaas.c **** 	rs232EnterReceive=0;
 7414              	 .loc 3 1444 0 is_stmt 1
 7415 000e 024B     	 ldr r3,.L360
 7416 0010 0022     	 mov r2,#0
 7417 0012 1A70     	 strb r2,[r3]
1445:../XMC1100-LibHaas.c **** }
 7418              	 .loc 3 1445 0
 7419 0014 BD46     	 mov sp,r7
 7420              	 
 7421 0016 80BD     	 pop {r7,pc}
 7422              	.L361:
 7423              	 .align 2
 7424              	.L360:
 7425 0018 00000000 	 .word rs232EnterReceive
 7426              	 .cfi_endproc
 7427              	.LFE99:
 7429              	 .section .text.rs232_clear_receivedata,"ax",%progbits
 7430              	 .align 2
 7431              	 .global rs232_clear_receivedata
 7432              	 .code 16
 7433              	 .thumb_func
 7435              	rs232_clear_receivedata:
 7436              	.LFB100:
1446:../XMC1100-LibHaas.c **** void rs232_clear_receivedata()
1447:../XMC1100-LibHaas.c **** {
 7437              	 .loc 3 1447 0
 7438              	 .cfi_startproc
 7439 0000 80B5     	 push {r7,lr}
 7440              	.LCFI176:
 7441              	 .cfi_def_cfa_offset 8
 7442              	 .cfi_offset 7,-8
 7443              	 .cfi_offset 14,-4
 7444 0002 00AF     	 add r7,sp,#0
 7445              	.LCFI177:
 7446              	 .cfi_def_cfa_register 7
1448:../XMC1100-LibHaas.c **** 	rs232Receivedata[0]='\0';
 7447              	 .loc 3 1448 0
 7448 0004 034B     	 ldr r3,.L363
 7449 0006 0022     	 mov r2,#0
 7450 0008 1A70     	 strb r2,[r3]
1449:../XMC1100-LibHaas.c **** 	rs232ReceivedataPointer=0;
 7451              	 .loc 3 1449 0
 7452 000a 034B     	 ldr r3,.L363+4
 7453 000c 0022     	 mov r2,#0
 7454 000e 1A70     	 strb r2,[r3]
1450:../XMC1100-LibHaas.c **** }
 7455              	 .loc 3 1450 0
 7456 0010 BD46     	 mov sp,r7
 7457              	 
 7458 0012 80BD     	 pop {r7,pc}
 7459              	.L364:
 7460              	 .align 2
 7461              	.L363:
 7462 0014 00000000 	 .word rs232Receivedata
 7463 0018 00000000 	 .word rs232ReceivedataPointer
 7464              	 .cfi_endproc
 7465              	.LFE100:
 7467              	 .section .text.rs232_read_number,"ax",%progbits
 7468              	 .align 2
 7469              	 .global rs232_read_number
 7470              	 .code 16
 7471              	 .thumb_func
 7473              	rs232_read_number:
 7474              	.LFB101:
1451:../XMC1100-LibHaas.c **** 
1452:../XMC1100-LibHaas.c **** uint8_t rs232_read_number()
1453:../XMC1100-LibHaas.c **** {
 7475              	 .loc 3 1453 0
 7476              	 .cfi_startproc
 7477 0000 80B5     	 push {r7,lr}
 7478              	.LCFI178:
 7479              	 .cfi_def_cfa_offset 8
 7480              	 .cfi_offset 7,-8
 7481              	 .cfi_offset 14,-4
 7482 0002 82B0     	 sub sp,sp,#8
 7483              	.LCFI179:
 7484              	 .cfi_def_cfa_offset 16
 7485 0004 00AF     	 add r7,sp,#0
 7486              	.LCFI180:
 7487              	 .cfi_def_cfa_register 7
1454:../XMC1100-LibHaas.c **** 	uint8_t stellen, zahl=0;
 7488              	 .loc 3 1454 0
 7489 0006 BB1D     	 add r3,r7,#6
 7490 0008 0022     	 mov r2,#0
 7491 000a 1A70     	 strb r2,[r3]
1455:../XMC1100-LibHaas.c **** 
1456:../XMC1100-LibHaas.c **** 	rs232_wait_of_enter();
 7492              	 .loc 3 1456 0
 7493 000c FFF7FEFF 	 bl rs232_wait_of_enter
1457:../XMC1100-LibHaas.c **** 	for (stellen=0; rs232Receivedata[stellen] != '\0'; stellen++);
 7494              	 .loc 3 1457 0
 7495 0010 FB1D     	 add r3,r7,#7
 7496 0012 0022     	 mov r2,#0
 7497 0014 1A70     	 strb r2,[r3]
 7498 0016 04E0     	 b .L366
 7499              	.L367:
 7500              	 .loc 3 1457 0 is_stmt 0 discriminator 3
 7501 0018 FB1D     	 add r3,r7,#7
 7502 001a 1A78     	 ldrb r2,[r3]
 7503 001c FB1D     	 add r3,r7,#7
 7504 001e 0132     	 add r2,r2,#1
 7505 0020 1A70     	 strb r2,[r3]
 7506              	.L366:
 7507              	 .loc 3 1457 0 discriminator 1
 7508 0022 FB1D     	 add r3,r7,#7
 7509 0024 1B78     	 ldrb r3,[r3]
 7510 0026 164A     	 ldr r2,.L371
 7511 0028 D35C     	 ldrb r3,[r2,r3]
 7512 002a 002B     	 cmp r3,#0
 7513 002c F4D1     	 bne .L367
 7514              	.LBB10:
1458:../XMC1100-LibHaas.c **** 
1459:../XMC1100-LibHaas.c **** 	for(uint8_t i=0;stellen >0; stellen--,i++) {
 7515              	 .loc 3 1459 0 is_stmt 1
 7516 002e 7B1D     	 add r3,r7,#5
 7517 0030 0022     	 mov r2,#0
 7518 0032 1A70     	 strb r2,[r3]
 7519 0034 19E0     	 b .L368
 7520              	.L369:
1460:../XMC1100-LibHaas.c **** 			zahl=rs232Receivedata[i] - 0x30 + zahl * 10;
 7521              	 .loc 3 1460 0 discriminator 3
 7522 0036 7B1D     	 add r3,r7,#5
 7523 0038 1B78     	 ldrb r3,[r3]
 7524 003a 114A     	 ldr r2,.L371
 7525 003c D25C     	 ldrb r2,[r2,r3]
 7526 003e BB1D     	 add r3,r7,#6
 7527 0040 1B78     	 ldrb r3,[r3]
 7528 0042 191C     	 add r1,r3,#0
 7529 0044 8900     	 lsl r1,r1,#2
 7530 0046 CB18     	 add r3,r1,r3
 7531 0048 DB18     	 add r3,r3,r3
 7532 004a DBB2     	 uxtb r3,r3
 7533 004c D318     	 add r3,r2,r3
 7534 004e DAB2     	 uxtb r2,r3
 7535 0050 BB1D     	 add r3,r7,#6
 7536 0052 303A     	 sub r2,r2,#48
 7537 0054 1A70     	 strb r2,[r3]
1459:../XMC1100-LibHaas.c **** 			zahl=rs232Receivedata[i] - 0x30 + zahl * 10;
 7538              	 .loc 3 1459 0 discriminator 3
 7539 0056 FB1D     	 add r3,r7,#7
 7540 0058 1A78     	 ldrb r2,[r3]
 7541 005a FB1D     	 add r3,r7,#7
 7542 005c 013A     	 sub r2,r2,#1
 7543 005e 1A70     	 strb r2,[r3]
 7544 0060 7B1D     	 add r3,r7,#5
 7545 0062 1A78     	 ldrb r2,[r3]
 7546 0064 7B1D     	 add r3,r7,#5
 7547 0066 0132     	 add r2,r2,#1
 7548 0068 1A70     	 strb r2,[r3]
 7549              	.L368:
1459:../XMC1100-LibHaas.c **** 			zahl=rs232Receivedata[i] - 0x30 + zahl * 10;
 7550              	 .loc 3 1459 0 is_stmt 0 discriminator 1
 7551 006a FB1D     	 add r3,r7,#7
 7552 006c 1B78     	 ldrb r3,[r3]
 7553 006e 002B     	 cmp r3,#0
 7554 0070 E1D1     	 bne .L369
 7555              	.LBE10:
1461:../XMC1100-LibHaas.c **** 	}
1462:../XMC1100-LibHaas.c **** 	return zahl;
 7556              	 .loc 3 1462 0 is_stmt 1
 7557 0072 BB1D     	 add r3,r7,#6
 7558 0074 1B78     	 ldrb r3,[r3]
1463:../XMC1100-LibHaas.c **** }
 7559              	 .loc 3 1463 0
 7560 0076 181C     	 mov r0,r3
 7561 0078 BD46     	 mov sp,r7
 7562 007a 02B0     	 add sp,sp,#8
 7563              	 
 7564 007c 80BD     	 pop {r7,pc}
 7565              	.L372:
 7566 007e C046     	 .align 2
 7567              	.L371:
 7568 0080 00000000 	 .word rs232Receivedata
 7569              	 .cfi_endproc
 7570              	.LFE101:
 7572              	 .section .text.rs232_read_int_number,"ax",%progbits
 7573              	 .align 2
 7574              	 .global rs232_read_int_number
 7575              	 .code 16
 7576              	 .thumb_func
 7578              	rs232_read_int_number:
 7579              	.LFB102:
1464:../XMC1100-LibHaas.c **** int rs232_read_int_number()
1465:../XMC1100-LibHaas.c **** {
 7580              	 .loc 3 1465 0
 7581              	 .cfi_startproc
 7582 0000 80B5     	 push {r7,lr}
 7583              	.LCFI181:
 7584              	 .cfi_def_cfa_offset 8
 7585              	 .cfi_offset 7,-8
 7586              	 .cfi_offset 14,-4
 7587 0002 84B0     	 sub sp,sp,#16
 7588              	.LCFI182:
 7589              	 .cfi_def_cfa_offset 24
 7590 0004 00AF     	 add r7,sp,#0
 7591              	.LCFI183:
 7592              	 .cfi_def_cfa_register 7
1466:../XMC1100-LibHaas.c **** 	uint8_t stellen;
1467:../XMC1100-LibHaas.c **** 	int zahl=0;
 7593              	 .loc 3 1467 0
 7594 0006 0023     	 mov r3,#0
 7595 0008 BB60     	 str r3,[r7,#8]
1468:../XMC1100-LibHaas.c **** 
1469:../XMC1100-LibHaas.c **** 	rs232_wait_of_enter();
 7596              	 .loc 3 1469 0
 7597 000a FFF7FEFF 	 bl rs232_wait_of_enter
1470:../XMC1100-LibHaas.c **** 	for (stellen=0; rs232Receivedata[stellen] != '\0'; stellen++);
 7598              	 .loc 3 1470 0
 7599 000e 0F23     	 mov r3,#15
 7600 0010 FB18     	 add r3,r7,r3
 7601 0012 0022     	 mov r2,#0
 7602 0014 1A70     	 strb r2,[r3]
 7603 0016 06E0     	 b .L374
 7604              	.L375:
 7605              	 .loc 3 1470 0 is_stmt 0 discriminator 3
 7606 0018 0F23     	 mov r3,#15
 7607 001a FB18     	 add r3,r7,r3
 7608 001c 1A78     	 ldrb r2,[r3]
 7609 001e 0F23     	 mov r3,#15
 7610 0020 FB18     	 add r3,r7,r3
 7611 0022 0132     	 add r2,r2,#1
 7612 0024 1A70     	 strb r2,[r3]
 7613              	.L374:
 7614              	 .loc 3 1470 0 discriminator 1
 7615 0026 0F23     	 mov r3,#15
 7616 0028 FB18     	 add r3,r7,r3
 7617 002a 1B78     	 ldrb r3,[r3]
 7618 002c 154A     	 ldr r2,.L379
 7619 002e D35C     	 ldrb r3,[r2,r3]
 7620 0030 002B     	 cmp r3,#0
 7621 0032 F1D1     	 bne .L375
 7622              	.LBB11:
1471:../XMC1100-LibHaas.c **** 
1472:../XMC1100-LibHaas.c **** 	for(uint8_t i=0;stellen >0; stellen--,i++) {
 7623              	 .loc 3 1472 0 is_stmt 1
 7624 0034 FB1D     	 add r3,r7,#7
 7625 0036 0022     	 mov r2,#0
 7626 0038 1A70     	 strb r2,[r3]
 7627 003a 18E0     	 b .L376
 7628              	.L377:
1473:../XMC1100-LibHaas.c **** 			zahl=rs232Receivedata[i] - 0x30 + zahl * 10;
 7629              	 .loc 3 1473 0 discriminator 3
 7630 003c FB1D     	 add r3,r7,#7
 7631 003e 1B78     	 ldrb r3,[r3]
 7632 0040 104A     	 ldr r2,.L379
 7633 0042 D35C     	 ldrb r3,[r2,r3]
 7634 0044 303B     	 sub r3,r3,#48
 7635 0046 191C     	 mov r1,r3
 7636 0048 BA68     	 ldr r2,[r7,#8]
 7637 004a 131C     	 mov r3,r2
 7638 004c 9B00     	 lsl r3,r3,#2
 7639 004e 9B18     	 add r3,r3,r2
 7640 0050 5B00     	 lsl r3,r3,#1
 7641 0052 CB18     	 add r3,r1,r3
 7642 0054 BB60     	 str r3,[r7,#8]
1472:../XMC1100-LibHaas.c **** 			zahl=rs232Receivedata[i] - 0x30 + zahl * 10;
 7643              	 .loc 3 1472 0 discriminator 3
 7644 0056 0F23     	 mov r3,#15
 7645 0058 FB18     	 add r3,r7,r3
 7646 005a 1A78     	 ldrb r2,[r3]
 7647 005c 0F23     	 mov r3,#15
 7648 005e FB18     	 add r3,r7,r3
 7649 0060 013A     	 sub r2,r2,#1
 7650 0062 1A70     	 strb r2,[r3]
 7651 0064 FB1D     	 add r3,r7,#7
 7652 0066 1A78     	 ldrb r2,[r3]
 7653 0068 FB1D     	 add r3,r7,#7
 7654 006a 0132     	 add r2,r2,#1
 7655 006c 1A70     	 strb r2,[r3]
 7656              	.L376:
1472:../XMC1100-LibHaas.c **** 			zahl=rs232Receivedata[i] - 0x30 + zahl * 10;
 7657              	 .loc 3 1472 0 is_stmt 0 discriminator 1
 7658 006e 0F23     	 mov r3,#15
 7659 0070 FB18     	 add r3,r7,r3
 7660 0072 1B78     	 ldrb r3,[r3]
 7661 0074 002B     	 cmp r3,#0
 7662 0076 E1D1     	 bne .L377
 7663              	.LBE11:
1474:../XMC1100-LibHaas.c **** 	}
1475:../XMC1100-LibHaas.c **** 	return zahl;
 7664              	 .loc 3 1475 0 is_stmt 1
 7665 0078 BB68     	 ldr r3,[r7,#8]
1476:../XMC1100-LibHaas.c **** }
 7666              	 .loc 3 1476 0
 7667 007a 181C     	 mov r0,r3
 7668 007c BD46     	 mov sp,r7
 7669 007e 04B0     	 add sp,sp,#16
 7670              	 
 7671 0080 80BD     	 pop {r7,pc}
 7672              	.L380:
 7673 0082 C046     	 .align 2
 7674              	.L379:
 7675 0084 00000000 	 .word rs232Receivedata
 7676              	 .cfi_endproc
 7677              	.LFE102:
 7679              	 .global __aeabi_uidiv
 7680              	 .section .text.rs232_print_number,"ax",%progbits
 7681              	 .align 2
 7682              	 .global rs232_print_number
 7683              	 .code 16
 7684              	 .thumb_func
 7686              	rs232_print_number:
 7687              	.LFB103:
1477:../XMC1100-LibHaas.c **** void rs232_print_number(uint8_t zahl)
1478:../XMC1100-LibHaas.c **** {
 7688              	 .loc 3 1478 0
 7689              	 .cfi_startproc
 7690 0000 90B5     	 push {r4,r7,lr}
 7691              	.LCFI184:
 7692              	 .cfi_def_cfa_offset 12
 7693              	 .cfi_offset 4,-12
 7694              	 .cfi_offset 7,-8
 7695              	 .cfi_offset 14,-4
 7696 0002 89B0     	 sub sp,sp,#36
 7697              	.LCFI185:
 7698              	 .cfi_def_cfa_offset 48
 7699 0004 00AF     	 add r7,sp,#0
 7700              	.LCFI186:
 7701              	 .cfi_def_cfa_register 7
 7702 0006 021C     	 mov r2,r0
 7703 0008 FB1D     	 add r3,r7,#7
 7704 000a 1A70     	 strb r2,[r3]
1479:../XMC1100-LibHaas.c **** 	uint8_t rest, stellen=1;
 7705              	 .loc 3 1479 0
 7706 000c 1E23     	 mov r3,#30
 7707 000e FB18     	 add r3,r7,r3
 7708 0010 0122     	 mov r2,#1
 7709 0012 1A70     	 strb r2,[r3]
1480:../XMC1100-LibHaas.c **** 	char string[20];
1481:../XMC1100-LibHaas.c **** 
1482:../XMC1100-LibHaas.c **** 	for (rest=zahl; (rest=rest/10) > 0; stellen++);
 7710              	 .loc 3 1482 0
 7711 0014 1F23     	 mov r3,#31
 7712 0016 FB18     	 add r3,r7,r3
 7713 0018 FA1D     	 add r2,r7,#7
 7714 001a 1278     	 ldrb r2,[r2]
 7715 001c 1A70     	 strb r2,[r3]
 7716 001e 06E0     	 b .L382
 7717              	.L383:
 7718              	 .loc 3 1482 0 is_stmt 0 discriminator 3
 7719 0020 1E23     	 mov r3,#30
 7720 0022 FB18     	 add r3,r7,r3
 7721 0024 1A78     	 ldrb r2,[r3]
 7722 0026 1E23     	 mov r3,#30
 7723 0028 FB18     	 add r3,r7,r3
 7724 002a 0132     	 add r2,r2,#1
 7725 002c 1A70     	 strb r2,[r3]
 7726              	.L382:
 7727              	 .loc 3 1482 0 discriminator 1
 7728 002e 1F23     	 mov r3,#31
 7729 0030 FC18     	 add r4,r7,r3
 7730 0032 1F23     	 mov r3,#31
 7731 0034 FB18     	 add r3,r7,r3
 7732 0036 1B78     	 ldrb r3,[r3]
 7733 0038 181C     	 mov r0,r3
 7734 003a 0A21     	 mov r1,#10
 7735 003c FFF7FEFF 	 bl __aeabi_uidiv
 7736 0040 031C     	 mov r3,r0
 7737 0042 2370     	 strb r3,[r4]
 7738 0044 1F23     	 mov r3,#31
 7739 0046 FB18     	 add r3,r7,r3
 7740 0048 1B78     	 ldrb r3,[r3]
 7741 004a 002B     	 cmp r3,#0
 7742 004c E8D1     	 bne .L383
1483:../XMC1100-LibHaas.c **** 
1484:../XMC1100-LibHaas.c **** 	string[stellen] = '\0';
 7743              	 .loc 3 1484 0 is_stmt 1
 7744 004e 1E23     	 mov r3,#30
 7745 0050 FB18     	 add r3,r7,r3
 7746 0052 1B78     	 ldrb r3,[r3]
 7747 0054 0822     	 mov r2,#8
 7748 0056 BA18     	 add r2,r7,r2
 7749 0058 0021     	 mov r1,#0
 7750 005a D154     	 strb r1,[r2,r3]
1485:../XMC1100-LibHaas.c **** 
1486:../XMC1100-LibHaas.c **** 	for (; stellen > 0; stellen--) {
 7751              	 .loc 3 1486 0
 7752 005c 25E0     	 b .L384
 7753              	.L385:
1487:../XMC1100-LibHaas.c **** 		rest=zahl % 10;
 7754              	 .loc 3 1487 0 discriminator 2
 7755 005e 1F23     	 mov r3,#31
 7756 0060 FC18     	 add r4,r7,r3
 7757 0062 FB1D     	 add r3,r7,#7
 7758 0064 1B78     	 ldrb r3,[r3]
 7759 0066 181C     	 mov r0,r3
 7760 0068 0A21     	 mov r1,#10
 7761 006a FFF7FEFF 	 bl __aeabi_uidivmod
 7762 006e 0B1C     	 mov r3,r1
 7763 0070 2370     	 strb r3,[r4]
1488:../XMC1100-LibHaas.c **** 		zahl=zahl / 10;
 7764              	 .loc 3 1488 0 discriminator 2
 7765 0072 FC1D     	 add r4,r7,#7
 7766 0074 FB1D     	 add r3,r7,#7
 7767 0076 1B78     	 ldrb r3,[r3]
 7768 0078 181C     	 mov r0,r3
 7769 007a 0A21     	 mov r1,#10
 7770 007c FFF7FEFF 	 bl __aeabi_uidiv
 7771 0080 031C     	 mov r3,r0
 7772 0082 2370     	 strb r3,[r4]
1489:../XMC1100-LibHaas.c **** 		string[stellen-1]=rest + 0x30;
 7773              	 .loc 3 1489 0 discriminator 2
 7774 0084 1E23     	 mov r3,#30
 7775 0086 FB18     	 add r3,r7,r3
 7776 0088 1B78     	 ldrb r3,[r3]
 7777 008a 013B     	 sub r3,r3,#1
 7778 008c 1F22     	 mov r2,#31
 7779 008e BA18     	 add r2,r7,r2
 7780 0090 1278     	 ldrb r2,[r2]
 7781 0092 3032     	 add r2,r2,#48
 7782 0094 D1B2     	 uxtb r1,r2
 7783 0096 0822     	 mov r2,#8
 7784 0098 BA18     	 add r2,r7,r2
 7785 009a D154     	 strb r1,[r2,r3]
1486:../XMC1100-LibHaas.c **** 		rest=zahl % 10;
 7786              	 .loc 3 1486 0 discriminator 2
 7787 009c 1E23     	 mov r3,#30
 7788 009e FB18     	 add r3,r7,r3
 7789 00a0 1A78     	 ldrb r2,[r3]
 7790 00a2 1E23     	 mov r3,#30
 7791 00a4 FB18     	 add r3,r7,r3
 7792 00a6 013A     	 sub r2,r2,#1
 7793 00a8 1A70     	 strb r2,[r3]
 7794              	.L384:
1486:../XMC1100-LibHaas.c **** 		rest=zahl % 10;
 7795              	 .loc 3 1486 0 is_stmt 0 discriminator 1
 7796 00aa 1E23     	 mov r3,#30
 7797 00ac FB18     	 add r3,r7,r3
 7798 00ae 1B78     	 ldrb r3,[r3]
 7799 00b0 002B     	 cmp r3,#0
 7800 00b2 D4D1     	 bne .L385
1490:../XMC1100-LibHaas.c **** 	}
1491:../XMC1100-LibHaas.c **** 	rs232_print(string);
 7801              	 .loc 3 1491 0 is_stmt 1
 7802 00b4 0823     	 mov r3,#8
 7803 00b6 FB18     	 add r3,r7,r3
 7804 00b8 181C     	 mov r0,r3
 7805 00ba FFF7FEFF 	 bl rs232_print
1492:../XMC1100-LibHaas.c **** }
 7806              	 .loc 3 1492 0
 7807 00be BD46     	 mov sp,r7
 7808 00c0 09B0     	 add sp,sp,#36
 7809              	 
 7810 00c2 90BD     	 pop {r4,r7,pc}
 7811              	 .cfi_endproc
 7812              	.LFE103:
 7814              	 .global __aeabi_idiv
 7815              	 .global __aeabi_idivmod
 7816              	 .section .text.rs232_print_int_number,"ax",%progbits
 7817              	 .align 2
 7818              	 .global rs232_print_int_number
 7819              	 .code 16
 7820              	 .thumb_func
 7822              	rs232_print_int_number:
 7823              	.LFB104:
1493:../XMC1100-LibHaas.c **** void rs232_print_int_number(int zahl)
1494:../XMC1100-LibHaas.c **** {
 7824              	 .loc 3 1494 0
 7825              	 .cfi_startproc
 7826 0000 80B5     	 push {r7,lr}
 7827              	.LCFI187:
 7828              	 .cfi_def_cfa_offset 8
 7829              	 .cfi_offset 7,-8
 7830              	 .cfi_offset 14,-4
 7831 0002 8AB0     	 sub sp,sp,#40
 7832              	.LCFI188:
 7833              	 .cfi_def_cfa_offset 48
 7834 0004 00AF     	 add r7,sp,#0
 7835              	.LCFI189:
 7836              	 .cfi_def_cfa_register 7
 7837 0006 7860     	 str r0,[r7,#4]
1495:../XMC1100-LibHaas.c **** 	uint8_t stellen=1;
 7838              	 .loc 3 1495 0
 7839 0008 2723     	 mov r3,#39
 7840 000a FB18     	 add r3,r7,r3
 7841 000c 0122     	 mov r2,#1
 7842 000e 1A70     	 strb r2,[r3]
1496:../XMC1100-LibHaas.c **** 	int rest;
1497:../XMC1100-LibHaas.c **** 	char string[20];
1498:../XMC1100-LibHaas.c **** 
1499:../XMC1100-LibHaas.c **** 	for (rest=zahl; (rest=rest/10) > 0; stellen++);
 7843              	 .loc 3 1499 0
 7844 0010 7B68     	 ldr r3,[r7,#4]
 7845 0012 3B62     	 str r3,[r7,#32]
 7846 0014 06E0     	 b .L387
 7847              	.L388:
 7848              	 .loc 3 1499 0 is_stmt 0 discriminator 3
 7849 0016 2723     	 mov r3,#39
 7850 0018 FB18     	 add r3,r7,r3
 7851 001a 1A78     	 ldrb r2,[r3]
 7852 001c 2723     	 mov r3,#39
 7853 001e FB18     	 add r3,r7,r3
 7854 0020 0132     	 add r2,r2,#1
 7855 0022 1A70     	 strb r2,[r3]
 7856              	.L387:
 7857              	 .loc 3 1499 0 discriminator 1
 7858 0024 3B6A     	 ldr r3,[r7,#32]
 7859 0026 181C     	 mov r0,r3
 7860 0028 0A21     	 mov r1,#10
 7861 002a FFF7FEFF 	 bl __aeabi_idiv
 7862 002e 031C     	 mov r3,r0
 7863 0030 3B62     	 str r3,[r7,#32]
 7864 0032 3B6A     	 ldr r3,[r7,#32]
 7865 0034 002B     	 cmp r3,#0
 7866 0036 EEDC     	 bgt .L388
1500:../XMC1100-LibHaas.c **** 
1501:../XMC1100-LibHaas.c **** 	string[stellen] = '\0';
 7867              	 .loc 3 1501 0 is_stmt 1
 7868 0038 2723     	 mov r3,#39
 7869 003a FB18     	 add r3,r7,r3
 7870 003c 1B78     	 ldrb r3,[r3]
 7871 003e 0C22     	 mov r2,#12
 7872 0040 BA18     	 add r2,r7,r2
 7873 0042 0021     	 mov r1,#0
 7874 0044 D154     	 strb r1,[r2,r3]
1502:../XMC1100-LibHaas.c **** 
1503:../XMC1100-LibHaas.c **** 	for (; stellen > 0; stellen--) {
 7875              	 .loc 3 1503 0
 7876 0046 1FE0     	 b .L389
 7877              	.L390:
1504:../XMC1100-LibHaas.c **** 		rest=zahl % 10;
 7878              	 .loc 3 1504 0 discriminator 2
 7879 0048 7B68     	 ldr r3,[r7,#4]
 7880 004a 181C     	 mov r0,r3
 7881 004c 0A21     	 mov r1,#10
 7882 004e FFF7FEFF 	 bl __aeabi_idivmod
 7883 0052 0B1C     	 mov r3,r1
 7884 0054 3B62     	 str r3,[r7,#32]
1505:../XMC1100-LibHaas.c **** 		zahl=zahl / 10;
 7885              	 .loc 3 1505 0 discriminator 2
 7886 0056 7B68     	 ldr r3,[r7,#4]
 7887 0058 181C     	 mov r0,r3
 7888 005a 0A21     	 mov r1,#10
 7889 005c FFF7FEFF 	 bl __aeabi_idiv
 7890 0060 031C     	 mov r3,r0
 7891 0062 7B60     	 str r3,[r7,#4]
1506:../XMC1100-LibHaas.c **** 		string[stellen-1]=rest + 0x30;
 7892              	 .loc 3 1506 0 discriminator 2
 7893 0064 2723     	 mov r3,#39
 7894 0066 FB18     	 add r3,r7,r3
 7895 0068 1B78     	 ldrb r3,[r3]
 7896 006a 013B     	 sub r3,r3,#1
 7897 006c 3A6A     	 ldr r2,[r7,#32]
 7898 006e D2B2     	 uxtb r2,r2
 7899 0070 3032     	 add r2,r2,#48
 7900 0072 D1B2     	 uxtb r1,r2
 7901 0074 0C22     	 mov r2,#12
 7902 0076 BA18     	 add r2,r7,r2
 7903 0078 D154     	 strb r1,[r2,r3]
1503:../XMC1100-LibHaas.c **** 		rest=zahl % 10;
 7904              	 .loc 3 1503 0 discriminator 2
 7905 007a 2723     	 mov r3,#39
 7906 007c FB18     	 add r3,r7,r3
 7907 007e 1A78     	 ldrb r2,[r3]
 7908 0080 2723     	 mov r3,#39
 7909 0082 FB18     	 add r3,r7,r3
 7910 0084 013A     	 sub r2,r2,#1
 7911 0086 1A70     	 strb r2,[r3]
 7912              	.L389:
1503:../XMC1100-LibHaas.c **** 		rest=zahl % 10;
 7913              	 .loc 3 1503 0 is_stmt 0 discriminator 1
 7914 0088 2723     	 mov r3,#39
 7915 008a FB18     	 add r3,r7,r3
 7916 008c 1B78     	 ldrb r3,[r3]
 7917 008e 002B     	 cmp r3,#0
 7918 0090 DAD1     	 bne .L390
1507:../XMC1100-LibHaas.c **** 	}
1508:../XMC1100-LibHaas.c **** 	rs232_print(string);
 7919              	 .loc 3 1508 0 is_stmt 1
 7920 0092 0C23     	 mov r3,#12
 7921 0094 FB18     	 add r3,r7,r3
 7922 0096 181C     	 mov r0,r3
 7923 0098 FFF7FEFF 	 bl rs232_print
1509:../XMC1100-LibHaas.c **** }
 7924              	 .loc 3 1509 0
 7925 009c BD46     	 mov sp,r7
 7926 009e 0AB0     	 add sp,sp,#40
 7927              	 
 7928 00a0 80BD     	 pop {r7,pc}
 7929              	 .cfi_endproc
 7930              	.LFE104:
 7932 00a2 C046     	 .section .text.uart_init,"ax",%progbits
 7933              	 .align 2
 7934              	 .global uart_init
 7935              	 .code 16
 7936              	 .thumb_func
 7938              	uart_init:
 7939              	.LFB105:
1510:../XMC1100-LibHaas.c **** // ****************************************************************************
1511:../XMC1100-LibHaas.c **** // UART-Routinen zur Kommunikation mit PC-Terminal
1512:../XMC1100-LibHaas.c **** // ****************************************************************************
1513:../XMC1100-LibHaas.c **** // RxD auf P0.6 , XMC1100 TxD auf P0.7
1514:../XMC1100-LibHaas.c **** // values calculated for 9.6 kbaud @ 32 MHz
1515:../XMC1100-LibHaas.c **** // Baudrate = 32 MHz * Step/1024 * 1/(PDIV +1)  * 1/ (PCTQ +1) * 1/ (DCTQ +1)
1516:../XMC1100-LibHaas.c **** //#define FDR_STEP_UART	25	// fuer 9.6 kBaud
1517:../XMC1100-LibHaas.c **** //#define BRG_PDIV_UART	4
1518:../XMC1100-LibHaas.c **** //#define BRG_DCTQ_UART	15
1519:../XMC1100-LibHaas.c **** //#define BRG_PCTQ_UART	0
1520:../XMC1100-LibHaas.c **** 
1521:../XMC1100-LibHaas.c **** #define FDR_STEP_UART	118
1522:../XMC1100-LibHaas.c **** #define BRG_PDIV_UART	23 //9600  11=>19,2k  5=>38,4k  3=>57,6k  1=>115,2k
1523:../XMC1100-LibHaas.c **** #define BRG_DCTQ_UART	15
1524:../XMC1100-LibHaas.c **** #define BRG_PCTQ_UART	0
1525:../XMC1100-LibHaas.c **** 
1526:../XMC1100-LibHaas.c **** // USIC : FIFO DPTR & SIZE MASK and POS Values
1527:../XMC1100-LibHaas.c **** #define   USIC_CH_TBCTR_DPTRSIZE_Pos_UART  	(0U)
1528:../XMC1100-LibHaas.c **** #define   USIC_CH_TBCTR_DPTRSIZE_Msk_UART  	(0x0700003FU << USIC_CH_TBCTR_DPTRSIZE_Pos_UART)
1529:../XMC1100-LibHaas.c **** 
1530:../XMC1100-LibHaas.c **** #define   USIC_CH_RBCTR_DPTRSIZE_Pos_UART  	(0U)
1531:../XMC1100-LibHaas.c **** #define   USIC_CH_RBCTR_DPTRSIZE_Msk_UART  	(0x0700003FU << USIC_CH_RBCTR_DPTRSIZE_Pos_UART)
1532:../XMC1100-LibHaas.c **** 
1533:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
1534:../XMC1100-LibHaas.c **** // Serielle Schnittstelle initialisieren
1535:../XMC1100-LibHaas.c **** // RxD auf P1.1 0.6, TxD auf P1.0 0.7, 9600 Baud, 8N1
1536:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
1537:../XMC1100-LibHaas.c **** void uart_init ( void )
1538:../XMC1100-LibHaas.c **** {	//USIC0 Cannel 0 wird verwendet:
 7940              	 .loc 3 1538 0
 7941              	 .cfi_startproc
 7942 0000 80B5     	 push {r7,lr}
 7943              	.LCFI190:
 7944              	 .cfi_def_cfa_offset 8
 7945              	 .cfi_offset 7,-8
 7946              	 .cfi_offset 14,-4
 7947 0002 00AF     	 add r7,sp,#0
 7948              	.LCFI191:
 7949              	 .cfi_def_cfa_register 7
1539:../XMC1100-LibHaas.c **** 	SCU_GENERAL->PASSWD = 0x000000C0UL;
 7950              	 .loc 3 1539 0
 7951 0004 7F4B     	 ldr r3,.L393
 7952 0006 C022     	 mov r2,#192
 7953 0008 5A62     	 str r2,[r3,#36]
1540:../XMC1100-LibHaas.c **** 	SCU_CLK->CGATCLR0 |= 0x00000008;		// stop gating USIC
 7954              	 .loc 3 1540 0
 7955 000a 7F4B     	 ldr r3,.L393+4
 7956 000c 7E4A     	 ldr r2,.L393+4
 7957 000e 1269     	 ldr r2,[r2,#16]
 7958 0010 0821     	 mov r1,#8
 7959 0012 0A43     	 orr r2,r1
 7960 0014 1A61     	 str r2,[r3,#16]
1541:../XMC1100-LibHaas.c **** 		while((SCU_CLK->CLKCR)&0x40000000UL);	// wait for VDDC to stabilize
 7961              	 .loc 3 1541 0
 7962 0016 C046     	 mov r8,r8
 7963              	.L392:
 7964              	 .loc 3 1541 0 is_stmt 0 discriminator 1
 7965 0018 7B4B     	 ldr r3,.L393+4
 7966 001a 1A68     	 ldr r2,[r3]
 7967 001c 8023     	 mov r3,#128
 7968 001e DB05     	 lsl r3,r3,#23
 7969 0020 1340     	 and r3,r2
 7970 0022 F9D1     	 bne .L392
1542:../XMC1100-LibHaas.c **** 	SCU_GENERAL->PASSWD = 0x000000C3UL;
 7971              	 .loc 3 1542 0 is_stmt 1
 7972 0024 774B     	 ldr r3,.L393
 7973 0026 C322     	 mov r2,#195
 7974 0028 5A62     	 str r2,[r3,#36]
1543:../XMC1100-LibHaas.c **** 
1544:../XMC1100-LibHaas.c **** 	USIC0_CH0->KSCFG |= 3UL ;	//  Mode enable + Freigabe write
 7975              	 .loc 3 1544 0
 7976 002a 9023     	 mov r3,#144
 7977 002c DB05     	 lsl r3,r3,#23
 7978 002e 9022     	 mov r2,#144
 7979 0030 D205     	 lsl r2,r2,#23
 7980 0032 D268     	 ldr r2,[r2,#12]
 7981 0034 0321     	 mov r1,#3
 7982 0036 0A43     	 orr r2,r1
 7983 0038 DA60     	 str r2,[r3,#12]
1545:../XMC1100-LibHaas.c **** 	//WR_REG(USIC0_CH1->FDR, USIC_CH_FDR_DM_Msk, USIC_CH_FDR_DM_Pos, 2);
1546:../XMC1100-LibHaas.c **** 	USIC0_CH0->FDR |= 1UL << 15 ;	//Fractional divider mode selected
 7984              	 .loc 3 1546 0
 7985 003a 9023     	 mov r3,#144
 7986 003c DB05     	 lsl r3,r3,#23
 7987 003e 9022     	 mov r2,#144
 7988 0040 D205     	 lsl r2,r2,#23
 7989 0042 1269     	 ldr r2,[r2,#16]
 7990 0044 8021     	 mov r1,#128
 7991 0046 0902     	 lsl r1,r1,#8
 7992 0048 0A43     	 orr r2,r1
 7993 004a 1A61     	 str r2,[r3,#16]
1547:../XMC1100-LibHaas.c **** 		//Step value
1548:../XMC1100-LibHaas.c **** 	USIC0_CH0->FDR|= FDR_STEP_UART;
 7994              	 .loc 3 1548 0
 7995 004c 9023     	 mov r3,#144
 7996 004e DB05     	 lsl r3,r3,#23
 7997 0050 9022     	 mov r2,#144
 7998 0052 D205     	 lsl r2,r2,#23
 7999 0054 1269     	 ldr r2,[r2,#16]
 8000 0056 7621     	 mov r1,#118
 8001 0058 0A43     	 orr r2,r1
 8002 005a 1A61     	 str r2,[r3,#16]
1549:../XMC1100-LibHaas.c **** 		//Vorteiler:
1550:../XMC1100-LibHaas.c **** 		// Baudrate = 32 MHz * Step/1024 * 1/(PDIV +1)  * 1/ (PCTQ +1) * 1/ (DCTQ +1)
1551:../XMC1100-LibHaas.c **** 	USIC0_CH0->BRG |= (BRG_PDIV_UART << 16) ;
 8003              	 .loc 3 1551 0
 8004 005c 9023     	 mov r3,#144
 8005 005e DB05     	 lsl r3,r3,#23
 8006 0060 9022     	 mov r2,#144
 8007 0062 D205     	 lsl r2,r2,#23
 8008 0064 5269     	 ldr r2,[r2,#20]
 8009 0066 B821     	 mov r1,#184
 8010 0068 4903     	 lsl r1,r1,#13
 8011 006a 0A43     	 orr r2,r1
 8012 006c 5A61     	 str r2,[r3,#20]
1552:../XMC1100-LibHaas.c **** 	USIC0_CH0->BRG |= BRG_DCTQ_UART << 10 ;
 8013              	 .loc 3 1552 0
 8014 006e 9023     	 mov r3,#144
 8015 0070 DB05     	 lsl r3,r3,#23
 8016 0072 9022     	 mov r2,#144
 8017 0074 D205     	 lsl r2,r2,#23
 8018 0076 5269     	 ldr r2,[r2,#20]
 8019 0078 F021     	 mov r1,#240
 8020 007a 8901     	 lsl r1,r1,#6
 8021 007c 0A43     	 orr r2,r1
 8022 007e 5A61     	 str r2,[r3,#20]
1553:../XMC1100-LibHaas.c **** 	USIC0_CH0->BRG |= BRG_PCTQ_UART << 8 ;
 8023              	 .loc 3 1553 0
 8024 0080 9023     	 mov r3,#144
 8025 0082 DB05     	 lsl r3,r3,#23
 8026 0084 9022     	 mov r2,#144
 8027 0086 D205     	 lsl r2,r2,#23
 8028 0088 5269     	 ldr r2,[r2,#20]
 8029 008a 5A61     	 str r2,[r3,#20]
1554:../XMC1100-LibHaas.c **** 
1555:../XMC1100-LibHaas.c **** 		//Configuration of USIC Shift Control
1556:../XMC1100-LibHaas.c **** 		//Transmit/Receive LSB first is selected, Transmission Mode (TRM) = 1, Passive Data Level (PDL) =
1557:../XMC1100-LibHaas.c **** 	WR_REG(USIC0_CH0->SCTR, USIC_CH_SCTR_PDL_Msk, USIC_CH_SCTR_PDL_Pos, 1);
 8030              	 .loc 3 1557 0
 8031 008c 9023     	 mov r3,#144
 8032 008e DB05     	 lsl r3,r3,#23
 8033 0090 9022     	 mov r2,#144
 8034 0092 D205     	 lsl r2,r2,#23
 8035 0094 526B     	 ldr r2,[r2,#52]
 8036 0096 0221     	 mov r1,#2
 8037 0098 0A43     	 orr r2,r1
 8038 009a 5A63     	 str r2,[r3,#52]
1558:../XMC1100-LibHaas.c **** 	WR_REG(USIC0_CH0->SCTR, USIC_CH_SCTR_TRM_Msk, USIC_CH_SCTR_TRM_Pos, 1);
 8039              	 .loc 3 1558 0
 8040 009c 9023     	 mov r3,#144
 8041 009e DB05     	 lsl r3,r3,#23
 8042 00a0 9022     	 mov r2,#144
 8043 00a2 D205     	 lsl r2,r2,#23
 8044 00a4 526B     	 ldr r2,[r2,#52]
 8045 00a6 5949     	 ldr r1,.L393+8
 8046 00a8 0A40     	 and r2,r1
 8047 00aa 8021     	 mov r1,#128
 8048 00ac 4900     	 lsl r1,r1,#1
 8049 00ae 0A43     	 orr r2,r1
 8050 00b0 5A63     	 str r2,[r3,#52]
1559:../XMC1100-LibHaas.c **** 		//Set Word Length (WLE) & Frame Length (FLE)
1560:../XMC1100-LibHaas.c **** 	WR_REG(USIC0_CH0->SCTR, USIC_CH_SCTR_FLE_Msk, USIC_CH_SCTR_FLE_Pos, 7);
 8051              	 .loc 3 1560 0
 8052 00b2 9023     	 mov r3,#144
 8053 00b4 DB05     	 lsl r3,r3,#23
 8054 00b6 9022     	 mov r2,#144
 8055 00b8 D205     	 lsl r2,r2,#23
 8056 00ba 526B     	 ldr r2,[r2,#52]
 8057 00bc 5449     	 ldr r1,.L393+12
 8058 00be 0A40     	 and r2,r1
 8059 00c0 E021     	 mov r1,#224
 8060 00c2 C902     	 lsl r1,r1,#11
 8061 00c4 0A43     	 orr r2,r1
 8062 00c6 5A63     	 str r2,[r3,#52]
1561:../XMC1100-LibHaas.c **** 	WR_REG(USIC0_CH0->SCTR, USIC_CH_SCTR_WLE_Msk, USIC_CH_SCTR_WLE_Pos, 7);
 8063              	 .loc 3 1561 0
 8064 00c8 9023     	 mov r3,#144
 8065 00ca DB05     	 lsl r3,r3,#23
 8066 00cc 9022     	 mov r2,#144
 8067 00ce D205     	 lsl r2,r2,#23
 8068 00d0 526B     	 ldr r2,[r2,#52]
 8069 00d2 5049     	 ldr r1,.L393+16
 8070 00d4 0A40     	 and r2,r1
 8071 00d6 E021     	 mov r1,#224
 8072 00d8 C904     	 lsl r1,r1,#19
 8073 00da 0A43     	 orr r2,r1
 8074 00dc 5A63     	 str r2,[r3,#52]
1562:../XMC1100-LibHaas.c **** 
1563:../XMC1100-LibHaas.c **** 		//Configuration of USIC Transmit Control/Status Register
1564:../XMC1100-LibHaas.c **** 		//TBUF Data Enable (TDEN) = 1, TBUF Data Single Shot Mode (TDSSM) = 1
1565:../XMC1100-LibHaas.c **** 	WR_REG(USIC0_CH0->TCSR, USIC_CH_TCSR_TDEN_Msk, USIC_CH_TCSR_TDEN_Pos, 1);
 8075              	 .loc 3 1565 0
 8076 00de 9023     	 mov r3,#144
 8077 00e0 DB05     	 lsl r3,r3,#23
 8078 00e2 9022     	 mov r2,#144
 8079 00e4 D205     	 lsl r2,r2,#23
 8080 00e6 926B     	 ldr r2,[r2,#56]
 8081 00e8 4B49     	 ldr r1,.L393+20
 8082 00ea 0A40     	 and r2,r1
 8083 00ec 8021     	 mov r1,#128
 8084 00ee C900     	 lsl r1,r1,#3
 8085 00f0 0A43     	 orr r2,r1
 8086 00f2 9A63     	 str r2,[r3,#56]
1566:../XMC1100-LibHaas.c **** 	WR_REG(USIC0_CH0->TCSR, USIC_CH_TCSR_TDSSM_Msk, USIC_CH_TCSR_TDSSM_Pos, 1);
 8087              	 .loc 3 1566 0
 8088 00f4 9023     	 mov r3,#144
 8089 00f6 DB05     	 lsl r3,r3,#23
 8090 00f8 9022     	 mov r2,#144
 8091 00fa D205     	 lsl r2,r2,#23
 8092 00fc 926B     	 ldr r2,[r2,#56]
 8093 00fe 8021     	 mov r1,#128
 8094 0100 4900     	 lsl r1,r1,#1
 8095 0102 0A43     	 orr r2,r1
 8096 0104 9A63     	 str r2,[r3,#56]
1567:../XMC1100-LibHaas.c **** 
1568:../XMC1100-LibHaas.c **** 		//Configuration of Protocol Control Register
1569:../XMC1100-LibHaas.c **** 		//Sample Mode (SMD) = 1, 1 Stop bit is selected, Sample Point (SP) = 2, Pulse Length (PL) = 0
1570:../XMC1100-LibHaas.c **** 	WR_REG(USIC0_CH0->PCR_ASCMode, USIC_CH_PCR_ASCMode_SMD_Msk,
 8097              	 .loc 3 1570 0
 8098 0106 9023     	 mov r3,#144
 8099 0108 DB05     	 lsl r3,r3,#23
 8100 010a 9022     	 mov r2,#144
 8101 010c D205     	 lsl r2,r2,#23
 8102 010e D26B     	 ldr r2,[r2,#60]
 8103 0110 0121     	 mov r1,#1
 8104 0112 0A43     	 orr r2,r1
 8105 0114 DA63     	 str r2,[r3,#60]
1571:../XMC1100-LibHaas.c **** 				USIC_CH_PCR_ASCMode_SMD_Pos, 1);
1572:../XMC1100-LibHaas.c **** 	WR_REG(USIC0_CH0->PCR_ASCMode, USIC_CH_PCR_ASCMode_STPB_Msk, USIC_CH_PCR_ASCMode_STPB_Pos, 0);
 8106              	 .loc 3 1572 0
 8107 0116 9023     	 mov r3,#144
 8108 0118 DB05     	 lsl r3,r3,#23
 8109 011a 9022     	 mov r2,#144
 8110 011c D205     	 lsl r2,r2,#23
 8111 011e D26B     	 ldr r2,[r2,#60]
 8112 0120 0221     	 mov r1,#2
 8113 0122 8A43     	 bic r2,r1
 8114 0124 DA63     	 str r2,[r3,#60]
1573:../XMC1100-LibHaas.c **** 	WR_REG(USIC0_CH0->PCR_ASCMode, USIC_CH_PCR_ASCMode_SP_Msk, USIC_CH_PCR_ASCMode_SP_Pos, 9);
 8115              	 .loc 3 1573 0
 8116 0126 9023     	 mov r3,#144
 8117 0128 DB05     	 lsl r3,r3,#23
 8118 012a 9022     	 mov r2,#144
 8119 012c D205     	 lsl r2,r2,#23
 8120 012e D26B     	 ldr r2,[r2,#60]
 8121 0130 3A49     	 ldr r1,.L393+24
 8122 0132 0A40     	 and r2,r1
 8123 0134 9021     	 mov r1,#144
 8124 0136 0901     	 lsl r1,r1,#4
 8125 0138 0A43     	 orr r2,r1
 8126 013a DA63     	 str r2,[r3,#60]
1574:../XMC1100-LibHaas.c **** 		//TBIF is set to simplify polling
1575:../XMC1100-LibHaas.c **** 	WR_REG(USIC0_CH0->PSR_ASCMode, USIC_CH_PSR_TBIF_Msk, USIC_CH_PSR_TBIF_Pos, 1);
 8127              	 .loc 3 1575 0
 8128 013c 9023     	 mov r3,#144
 8129 013e DB05     	 lsl r3,r3,#23
 8130 0140 9022     	 mov r2,#144
 8131 0142 D205     	 lsl r2,r2,#23
 8132 0144 926C     	 ldr r2,[r2,#72]
 8133 0146 8021     	 mov r1,#128
 8134 0148 8901     	 lsl r1,r1,#6
 8135 014a 0A43     	 orr r2,r1
 8136 014c 9A64     	 str r2,[r3,#72]
1576:../XMC1100-LibHaas.c **** 		//Configuration of Transmitter Buffer Control Register
1577:../XMC1100-LibHaas.c **** 	WR_REG(USIC0_CH0->TBCTR, USIC_CH_TBCTR_LIMIT_Msk, USIC_CH_TBCTR_LIMIT_Pos, 0);
 8137              	 .loc 3 1577 0
 8138 014e 9023     	 mov r3,#144
 8139 0150 DA05     	 lsl r2,r3,#23
 8140 0152 9023     	 mov r3,#144
 8141 0154 D905     	 lsl r1,r3,#23
 8142 0156 8423     	 mov r3,#132
 8143 0158 5B00     	 lsl r3,r3,#1
 8144 015a CB58     	 ldr r3,[r1,r3]
 8145 015c 3049     	 ldr r1,.L393+28
 8146 015e 1940     	 and r1,r3
 8147 0160 8423     	 mov r3,#132
 8148 0162 5B00     	 lsl r3,r3,#1
 8149 0164 D150     	 str r1,[r2,r3]
1578:../XMC1100-LibHaas.c **** 
1579:../XMC1100-LibHaas.c **** 		//Configuration of Channel Control Register
1580:../XMC1100-LibHaas.c **** 		//parity generation is disabled
1581:../XMC1100-LibHaas.c **** 	USIC0_CH0->CCR |=  0x02;	// ASC Mode
 8150              	 .loc 3 1581 0
 8151 0166 9023     	 mov r3,#144
 8152 0168 DB05     	 lsl r3,r3,#23
 8153 016a 9022     	 mov r2,#144
 8154 016c D205     	 lsl r2,r2,#23
 8155 016e 126C     	 ldr r2,[r2,#64]
 8156 0170 0221     	 mov r1,#2
 8157 0172 0A43     	 orr r2,r1
 8158 0174 1A64     	 str r2,[r3,#64]
1582:../XMC1100-LibHaas.c **** 
1583:../XMC1100-LibHaas.c **** 		//Data Pointer & Buffer Size for Transmitter Buffer Control - DPTR = 64,  SIZE = 6
1584:../XMC1100-LibHaas.c **** 	WR_REG(USIC0_CH0->TBCTR, USIC_CH_TBCTR_DPTRSIZE_Msk_UART, USIC_CH_TBCTR_DPTRSIZE_Pos_UART, 0x06000
 8159              	 .loc 3 1584 0
 8160 0176 9023     	 mov r3,#144
 8161 0178 DA05     	 lsl r2,r3,#23
 8162 017a 9023     	 mov r3,#144
 8163 017c D905     	 lsl r1,r3,#23
 8164 017e 8423     	 mov r3,#132
 8165 0180 5B00     	 lsl r3,r3,#1
 8166 0182 CB58     	 ldr r3,[r1,r3]
 8167 0184 2749     	 ldr r1,.L393+32
 8168 0186 0B40     	 and r3,r1
 8169 0188 C021     	 mov r1,#192
 8170 018a C904     	 lsl r1,r1,#19
 8171 018c 1943     	 orr r1,r3
 8172 018e 8423     	 mov r3,#132
 8173 0190 5B00     	 lsl r3,r3,#1
 8174 0192 D150     	 str r1,[r2,r3]
1585:../XMC1100-LibHaas.c **** 
1586:../XMC1100-LibHaas.c **** 	// Rx Pin: P1.1
1587:../XMC1100-LibHaas.c **** 	bit_init(P1,1,INP); //P1.1 als Eingang definieren
 8175              	 .loc 3 1587 0
 8176 0194 0120     	 mov r0,#1
 8177 0196 0121     	 mov r1,#1
 8178 0198 0022     	 mov r2,#0
 8179 019a FFF7FEFF 	 bl bit_init
1588:../XMC1100-LibHaas.c **** 	USIC0_CH0->DX0CR &= ~(0x7);	// Kanal: USIC0_CH0 => DX0D auf P1.1 ( siehe Pin Mapping)
 8180              	 .loc 3 1588 0
 8181 019e 9023     	 mov r3,#144
 8182 01a0 DB05     	 lsl r3,r3,#23
 8183 01a2 9022     	 mov r2,#144
 8184 01a4 D205     	 lsl r2,r2,#23
 8185 01a6 D269     	 ldr r2,[r2,#28]
 8186 01a8 0721     	 mov r1,#7
 8187 01aa 8A43     	 bic r2,r1
 8188 01ac DA61     	 str r2,[r3,#28]
1589:../XMC1100-LibHaas.c **** 	USIC0_CH0->DX0CR |= 3;
 8189              	 .loc 3 1589 0
 8190 01ae 9023     	 mov r3,#144
 8191 01b0 DB05     	 lsl r3,r3,#23
 8192 01b2 9022     	 mov r2,#144
 8193 01b4 D205     	 lsl r2,r2,#23
 8194 01b6 D269     	 ldr r2,[r2,#28]
 8195 01b8 0321     	 mov r1,#3
 8196 01ba 0A43     	 orr r2,r1
 8197 01bc DA61     	 str r2,[r3,#28]
1590:../XMC1100-LibHaas.c **** 
1591:../XMC1100-LibHaas.c **** 	//Tx Pin P1.0
1592:../XMC1100-LibHaas.c **** 	PORT1->IOCR0 &= 0xffffff07;	// P1.0
 8198              	 .loc 3 1592 0
 8199 01be 1A4B     	 ldr r3,.L393+36
 8200 01c0 194A     	 ldr r2,.L393+36
 8201 01c2 1269     	 ldr r2,[r2,#16]
 8202 01c4 F821     	 mov r1,#248
 8203 01c6 8A43     	 bic r2,r1
 8204 01c8 1A61     	 str r2,[r3,#16]
1593:../XMC1100-LibHaas.c **** 	PORT1->IOCR0  |= 0x000000B8; // ALT 7 fuer P1.0 => TxD d.h. XMC1100 sendet auf P1.0
 8205              	 .loc 3 1593 0
 8206 01ca 174B     	 ldr r3,.L393+36
 8207 01cc 164A     	 ldr r2,.L393+36
 8208 01ce 1269     	 ldr r2,[r2,#16]
 8209 01d0 B821     	 mov r1,#184
 8210 01d2 0A43     	 orr r2,r1
 8211 01d4 1A61     	 str r2,[r3,#16]
1594:../XMC1100-LibHaas.c **** 
1595:../XMC1100-LibHaas.c **** 	//UART Channel Auswahl auf DCE
1596:../XMC1100-LibHaas.c **** 	bit_init(0,12,OUTP);
 8212              	 .loc 3 1596 0
 8213 01d6 0020     	 mov r0,#0
 8214 01d8 0C21     	 mov r1,#12
 8215 01da 0122     	 mov r2,#1
 8216 01dc FFF7FEFF 	 bl bit_init
1597:../XMC1100-LibHaas.c **** 	bit_write(0,12,1);
 8217              	 .loc 3 1597 0
 8218 01e0 0020     	 mov r0,#0
 8219 01e2 0C21     	 mov r1,#12
 8220 01e4 0122     	 mov r2,#1
 8221 01e6 FFF7FEFF 	 bl bit_write
1598:../XMC1100-LibHaas.c **** 	bit_init(0,13,OUTP);
 8222              	 .loc 3 1598 0
 8223 01ea 0020     	 mov r0,#0
 8224 01ec 0D21     	 mov r1,#13
 8225 01ee 0122     	 mov r2,#1
 8226 01f0 FFF7FEFF 	 bl bit_init
1599:../XMC1100-LibHaas.c **** 	bit_write(0,13,1);
 8227              	 .loc 3 1599 0
 8228 01f4 0020     	 mov r0,#0
 8229 01f6 0D21     	 mov r1,#13
 8230 01f8 0122     	 mov r2,#1
 8231 01fa FFF7FEFF 	 bl bit_write
1600:../XMC1100-LibHaas.c **** }
 8232              	 .loc 3 1600 0
 8233 01fe BD46     	 mov sp,r7
 8234              	 
 8235 0200 80BD     	 pop {r7,pc}
 8236              	.L394:
 8237 0202 C046     	 .align 2
 8238              	.L393:
 8239 0204 00000140 	 .word 1073807360
 8240 0208 00030140 	 .word 1073808128
 8241 020c FFFCFFFF 	 .word -769
 8242 0210 FFFFC0FF 	 .word -4128769
 8243 0214 FFFFFFF0 	 .word -251658241
 8244 0218 FFF3FFFF 	 .word -3073
 8245 021c FFE0FFFF 	 .word -7937
 8246 0220 FFC0FFFF 	 .word -16129
 8247 0224 C0FFFFF8 	 .word -117440576
 8248 0228 00010440 	 .word 1074004224
 8249              	 .cfi_endproc
 8250              	.LFE105:
 8252              	 .section .text.uart_init_bd,"ax",%progbits
 8253              	 .align 2
 8254              	 .global uart_init_bd
 8255              	 .code 16
 8256              	 .thumb_func
 8258              	uart_init_bd:
 8259              	.LFB106:
1601:../XMC1100-LibHaas.c **** 
1602:../XMC1100-LibHaas.c **** //Initialisierung mit waehlbare Baudrate
1603:../XMC1100-LibHaas.c **** void uart_init_bd(int bd)
1604:../XMC1100-LibHaas.c **** {	//USIC0 Cannel 0 wird verwendet:
 8260              	 .loc 3 1604 0
 8261              	 .cfi_startproc
 8262 0000 80B5     	 push {r7,lr}
 8263              	.LCFI192:
 8264              	 .cfi_def_cfa_offset 8
 8265              	 .cfi_offset 7,-8
 8266              	 .cfi_offset 14,-4
 8267 0002 84B0     	 sub sp,sp,#16
 8268              	.LCFI193:
 8269              	 .cfi_def_cfa_offset 24
 8270 0004 00AF     	 add r7,sp,#0
 8271              	.LCFI194:
 8272              	 .cfi_def_cfa_register 7
 8273 0006 7860     	 str r0,[r7,#4]
1605:../XMC1100-LibHaas.c **** 	uint8_t brgPdivUART=1;
 8274              	 .loc 3 1605 0
 8275 0008 0F23     	 mov r3,#15
 8276 000a FB18     	 add r3,r7,r3
 8277 000c 0122     	 mov r2,#1
 8278 000e 1A70     	 strb r2,[r3]
1606:../XMC1100-LibHaas.c **** 
1607:../XMC1100-LibHaas.c **** 	SCU_GENERAL->PASSWD = 0x000000C0UL;
 8279              	 .loc 3 1607 0
 8280 0010 9A4B     	 ldr r3,.L402
 8281 0012 C022     	 mov r2,#192
 8282 0014 5A62     	 str r2,[r3,#36]
1608:../XMC1100-LibHaas.c **** 	SCU_CLK->CGATCLR0 |= 0x00000008;		// stop gating USIC
 8283              	 .loc 3 1608 0
 8284 0016 9A4B     	 ldr r3,.L402+4
 8285 0018 994A     	 ldr r2,.L402+4
 8286 001a 1269     	 ldr r2,[r2,#16]
 8287 001c 0821     	 mov r1,#8
 8288 001e 0A43     	 orr r2,r1
 8289 0020 1A61     	 str r2,[r3,#16]
1609:../XMC1100-LibHaas.c **** 		while((SCU_CLK->CLKCR)&0x40000000UL);	// wait for VDDC to stabilize
 8290              	 .loc 3 1609 0
 8291 0022 C046     	 mov r8,r8
 8292              	.L396:
 8293              	 .loc 3 1609 0 is_stmt 0 discriminator 1
 8294 0024 964B     	 ldr r3,.L402+4
 8295 0026 1A68     	 ldr r2,[r3]
 8296 0028 8023     	 mov r3,#128
 8297 002a DB05     	 lsl r3,r3,#23
 8298 002c 1340     	 and r3,r2
 8299 002e F9D1     	 bne .L396
1610:../XMC1100-LibHaas.c **** 	SCU_GENERAL->PASSWD = 0x000000C3UL;
 8300              	 .loc 3 1610 0 is_stmt 1
 8301 0030 924B     	 ldr r3,.L402
 8302 0032 C322     	 mov r2,#195
 8303 0034 5A62     	 str r2,[r3,#36]
1611:../XMC1100-LibHaas.c **** 
1612:../XMC1100-LibHaas.c **** 	USIC0_CH0->KSCFG |= 3UL ;	//  Mode enable + Freigabe write
 8304              	 .loc 3 1612 0
 8305 0036 9023     	 mov r3,#144
 8306 0038 DB05     	 lsl r3,r3,#23
 8307 003a 9022     	 mov r2,#144
 8308 003c D205     	 lsl r2,r2,#23
 8309 003e D268     	 ldr r2,[r2,#12]
 8310 0040 0321     	 mov r1,#3
 8311 0042 0A43     	 orr r2,r1
 8312 0044 DA60     	 str r2,[r3,#12]
1613:../XMC1100-LibHaas.c **** 	//WR_REG(USIC0_CH1->FDR, USIC_CH_FDR_DM_Msk, USIC_CH_FDR_DM_Pos, 2);
1614:../XMC1100-LibHaas.c **** 	USIC0_CH0->FDR |= 1UL << 15 ;	//Fractional divider mode selected
 8313              	 .loc 3 1614 0
 8314 0046 9023     	 mov r3,#144
 8315 0048 DB05     	 lsl r3,r3,#23
 8316 004a 9022     	 mov r2,#144
 8317 004c D205     	 lsl r2,r2,#23
 8318 004e 1269     	 ldr r2,[r2,#16]
 8319 0050 8021     	 mov r1,#128
 8320 0052 0902     	 lsl r1,r1,#8
 8321 0054 0A43     	 orr r2,r1
 8322 0056 1A61     	 str r2,[r3,#16]
1615:../XMC1100-LibHaas.c **** 		//Step value
1616:../XMC1100-LibHaas.c **** 	USIC0_CH0->FDR|= FDR_STEP_UART;
 8323              	 .loc 3 1616 0
 8324 0058 9023     	 mov r3,#144
 8325 005a DB05     	 lsl r3,r3,#23
 8326 005c 9022     	 mov r2,#144
 8327 005e D205     	 lsl r2,r2,#23
 8328 0060 1269     	 ldr r2,[r2,#16]
 8329 0062 7621     	 mov r1,#118
 8330 0064 0A43     	 orr r2,r1
 8331 0066 1A61     	 str r2,[r3,#16]
1617:../XMC1100-LibHaas.c **** 		//Vorteiler:
1618:../XMC1100-LibHaas.c **** 		// Baudrate = 32 MHz * Step/1024 * 1/(PDIV +1)  * 1/ (PCTQ +1) * 1/ (DCTQ +1)
1619:../XMC1100-LibHaas.c **** 	USIC0_CH0->BRG &=0xFC00FFFF;  //Pdiv loeschen
 8332              	 .loc 3 1619 0
 8333 0068 9023     	 mov r3,#144
 8334 006a DB05     	 lsl r3,r3,#23
 8335 006c 9022     	 mov r2,#144
 8336 006e D205     	 lsl r2,r2,#23
 8337 0070 5269     	 ldr r2,[r2,#20]
 8338 0072 8449     	 ldr r1,.L402+8
 8339 0074 0A40     	 and r2,r1
 8340 0076 5A61     	 str r2,[r3,#20]
1620:../XMC1100-LibHaas.c **** 	if (bd == 115200)  brgPdivUART=1;
 8341              	 .loc 3 1620 0
 8342 0078 7A68     	 ldr r2,[r7,#4]
 8343 007a E123     	 mov r3,#225
 8344 007c 5B02     	 lsl r3,r3,#9
 8345 007e 9A42     	 cmp r2,r3
 8346 0080 04D1     	 bne .L397
 8347              	 .loc 3 1620 0 is_stmt 0 discriminator 1
 8348 0082 0F23     	 mov r3,#15
 8349 0084 FB18     	 add r3,r7,r3
 8350 0086 0122     	 mov r2,#1
 8351 0088 1A70     	 strb r2,[r3]
 8352 008a 21E0     	 b .L398
 8353              	.L397:
1621:../XMC1100-LibHaas.c **** 	else if (bd == 57600) brgPdivUART=3;
 8354              	 .loc 3 1621 0 is_stmt 1
 8355 008c 7A68     	 ldr r2,[r7,#4]
 8356 008e E123     	 mov r3,#225
 8357 0090 1B02     	 lsl r3,r3,#8
 8358 0092 9A42     	 cmp r2,r3
 8359 0094 04D1     	 bne .L399
 8360              	 .loc 3 1621 0 is_stmt 0 discriminator 1
 8361 0096 0F23     	 mov r3,#15
 8362 0098 FB18     	 add r3,r7,r3
 8363 009a 0322     	 mov r2,#3
 8364 009c 1A70     	 strb r2,[r3]
 8365 009e 17E0     	 b .L398
 8366              	.L399:
1622:../XMC1100-LibHaas.c **** 	else if (bd == 38400) brgPdivUART=5;
 8367              	 .loc 3 1622 0 is_stmt 1
 8368 00a0 7A68     	 ldr r2,[r7,#4]
 8369 00a2 9623     	 mov r3,#150
 8370 00a4 1B02     	 lsl r3,r3,#8
 8371 00a6 9A42     	 cmp r2,r3
 8372 00a8 04D1     	 bne .L400
 8373              	 .loc 3 1622 0 is_stmt 0 discriminator 1
 8374 00aa 0F23     	 mov r3,#15
 8375 00ac FB18     	 add r3,r7,r3
 8376 00ae 0522     	 mov r2,#5
 8377 00b0 1A70     	 strb r2,[r3]
 8378 00b2 0DE0     	 b .L398
 8379              	.L400:
1623:../XMC1100-LibHaas.c **** 	else if (bd == 19200) brgPdivUART=11;
 8380              	 .loc 3 1623 0 is_stmt 1
 8381 00b4 7A68     	 ldr r2,[r7,#4]
 8382 00b6 9623     	 mov r3,#150
 8383 00b8 DB01     	 lsl r3,r3,#7
 8384 00ba 9A42     	 cmp r2,r3
 8385 00bc 04D1     	 bne .L401
 8386              	 .loc 3 1623 0 is_stmt 0 discriminator 1
 8387 00be 0F23     	 mov r3,#15
 8388 00c0 FB18     	 add r3,r7,r3
 8389 00c2 0B22     	 mov r2,#11
 8390 00c4 1A70     	 strb r2,[r3]
 8391 00c6 03E0     	 b .L398
 8392              	.L401:
1624:../XMC1100-LibHaas.c **** 	else brgPdivUART=23; //if (bd == 9600)
 8393              	 .loc 3 1624 0 is_stmt 1
 8394 00c8 0F23     	 mov r3,#15
 8395 00ca FB18     	 add r3,r7,r3
 8396 00cc 1722     	 mov r2,#23
 8397 00ce 1A70     	 strb r2,[r3]
 8398              	.L398:
1625:../XMC1100-LibHaas.c **** 	USIC0_CH0->BRG |= (brgPdivUART << 16) ;
 8399              	 .loc 3 1625 0
 8400 00d0 9023     	 mov r3,#144
 8401 00d2 DB05     	 lsl r3,r3,#23
 8402 00d4 9022     	 mov r2,#144
 8403 00d6 D205     	 lsl r2,r2,#23
 8404 00d8 5269     	 ldr r2,[r2,#20]
 8405 00da 0F21     	 mov r1,#15
 8406 00dc 7918     	 add r1,r7,r1
 8407 00de 0978     	 ldrb r1,[r1]
 8408 00e0 0904     	 lsl r1,r1,#16
 8409 00e2 0A43     	 orr r2,r1
 8410 00e4 5A61     	 str r2,[r3,#20]
1626:../XMC1100-LibHaas.c **** 	USIC0_CH0->BRG |= BRG_DCTQ_UART << 10 ;
 8411              	 .loc 3 1626 0
 8412 00e6 9023     	 mov r3,#144
 8413 00e8 DB05     	 lsl r3,r3,#23
 8414 00ea 9022     	 mov r2,#144
 8415 00ec D205     	 lsl r2,r2,#23
 8416 00ee 5269     	 ldr r2,[r2,#20]
 8417 00f0 F021     	 mov r1,#240
 8418 00f2 8901     	 lsl r1,r1,#6
 8419 00f4 0A43     	 orr r2,r1
 8420 00f6 5A61     	 str r2,[r3,#20]
1627:../XMC1100-LibHaas.c **** 	USIC0_CH0->BRG |= BRG_PCTQ_UART << 8 ;
 8421              	 .loc 3 1627 0
 8422 00f8 9023     	 mov r3,#144
 8423 00fa DB05     	 lsl r3,r3,#23
 8424 00fc 9022     	 mov r2,#144
 8425 00fe D205     	 lsl r2,r2,#23
 8426 0100 5269     	 ldr r2,[r2,#20]
 8427 0102 5A61     	 str r2,[r3,#20]
1628:../XMC1100-LibHaas.c **** 
1629:../XMC1100-LibHaas.c **** 		//Configuration of USIC Shift Control
1630:../XMC1100-LibHaas.c **** 		//Transmit/Receive LSB first is selected, Transmission Mode (TRM) = 1, Passive Data Level (PDL) =
1631:../XMC1100-LibHaas.c **** 	WR_REG(USIC0_CH0->SCTR, USIC_CH_SCTR_PDL_Msk, USIC_CH_SCTR_PDL_Pos, 1);
 8428              	 .loc 3 1631 0
 8429 0104 9023     	 mov r3,#144
 8430 0106 DB05     	 lsl r3,r3,#23
 8431 0108 9022     	 mov r2,#144
 8432 010a D205     	 lsl r2,r2,#23
 8433 010c 526B     	 ldr r2,[r2,#52]
 8434 010e 0221     	 mov r1,#2
 8435 0110 0A43     	 orr r2,r1
 8436 0112 5A63     	 str r2,[r3,#52]
1632:../XMC1100-LibHaas.c **** 	WR_REG(USIC0_CH0->SCTR, USIC_CH_SCTR_TRM_Msk, USIC_CH_SCTR_TRM_Pos, 1);
 8437              	 .loc 3 1632 0
 8438 0114 9023     	 mov r3,#144
 8439 0116 DB05     	 lsl r3,r3,#23
 8440 0118 9022     	 mov r2,#144
 8441 011a D205     	 lsl r2,r2,#23
 8442 011c 526B     	 ldr r2,[r2,#52]
 8443 011e 5A49     	 ldr r1,.L402+12
 8444 0120 0A40     	 and r2,r1
 8445 0122 8021     	 mov r1,#128
 8446 0124 4900     	 lsl r1,r1,#1
 8447 0126 0A43     	 orr r2,r1
 8448 0128 5A63     	 str r2,[r3,#52]
1633:../XMC1100-LibHaas.c **** 		//Set Word Length (WLE) & Frame Length (FLE)
1634:../XMC1100-LibHaas.c **** 	WR_REG(USIC0_CH0->SCTR, USIC_CH_SCTR_FLE_Msk, USIC_CH_SCTR_FLE_Pos, 7);
 8449              	 .loc 3 1634 0
 8450 012a 9023     	 mov r3,#144
 8451 012c DB05     	 lsl r3,r3,#23
 8452 012e 9022     	 mov r2,#144
 8453 0130 D205     	 lsl r2,r2,#23
 8454 0132 526B     	 ldr r2,[r2,#52]
 8455 0134 5549     	 ldr r1,.L402+16
 8456 0136 0A40     	 and r2,r1
 8457 0138 E021     	 mov r1,#224
 8458 013a C902     	 lsl r1,r1,#11
 8459 013c 0A43     	 orr r2,r1
 8460 013e 5A63     	 str r2,[r3,#52]
1635:../XMC1100-LibHaas.c **** 	WR_REG(USIC0_CH0->SCTR, USIC_CH_SCTR_WLE_Msk, USIC_CH_SCTR_WLE_Pos, 7);
 8461              	 .loc 3 1635 0
 8462 0140 9023     	 mov r3,#144
 8463 0142 DB05     	 lsl r3,r3,#23
 8464 0144 9022     	 mov r2,#144
 8465 0146 D205     	 lsl r2,r2,#23
 8466 0148 526B     	 ldr r2,[r2,#52]
 8467 014a 5149     	 ldr r1,.L402+20
 8468 014c 0A40     	 and r2,r1
 8469 014e E021     	 mov r1,#224
 8470 0150 C904     	 lsl r1,r1,#19
 8471 0152 0A43     	 orr r2,r1
 8472 0154 5A63     	 str r2,[r3,#52]
1636:../XMC1100-LibHaas.c **** 
1637:../XMC1100-LibHaas.c **** 		//Configuration of USIC Transmit Control/Status Register
1638:../XMC1100-LibHaas.c **** 		//TBUF Data Enable (TDEN) = 1, TBUF Data Single Shot Mode (TDSSM) = 1
1639:../XMC1100-LibHaas.c **** 	WR_REG(USIC0_CH0->TCSR, USIC_CH_TCSR_TDEN_Msk, USIC_CH_TCSR_TDEN_Pos, 1);
 8473              	 .loc 3 1639 0
 8474 0156 9023     	 mov r3,#144
 8475 0158 DB05     	 lsl r3,r3,#23
 8476 015a 9022     	 mov r2,#144
 8477 015c D205     	 lsl r2,r2,#23
 8478 015e 926B     	 ldr r2,[r2,#56]
 8479 0160 4C49     	 ldr r1,.L402+24
 8480 0162 0A40     	 and r2,r1
 8481 0164 8021     	 mov r1,#128
 8482 0166 C900     	 lsl r1,r1,#3
 8483 0168 0A43     	 orr r2,r1
 8484 016a 9A63     	 str r2,[r3,#56]
1640:../XMC1100-LibHaas.c **** 	WR_REG(USIC0_CH0->TCSR, USIC_CH_TCSR_TDSSM_Msk, USIC_CH_TCSR_TDSSM_Pos, 1);
 8485              	 .loc 3 1640 0
 8486 016c 9023     	 mov r3,#144
 8487 016e DB05     	 lsl r3,r3,#23
 8488 0170 9022     	 mov r2,#144
 8489 0172 D205     	 lsl r2,r2,#23
 8490 0174 926B     	 ldr r2,[r2,#56]
 8491 0176 8021     	 mov r1,#128
 8492 0178 4900     	 lsl r1,r1,#1
 8493 017a 0A43     	 orr r2,r1
 8494 017c 9A63     	 str r2,[r3,#56]
1641:../XMC1100-LibHaas.c **** 
1642:../XMC1100-LibHaas.c **** 		//Configuration of Protocol Control Register
1643:../XMC1100-LibHaas.c **** 		//Sample Mode (SMD) = 1, 1 Stop bit is selected, Sample Point (SP) = 2, Pulse Length (PL) = 0
1644:../XMC1100-LibHaas.c **** 	WR_REG(USIC0_CH0->PCR_ASCMode, USIC_CH_PCR_ASCMode_SMD_Msk,
 8495              	 .loc 3 1644 0
 8496 017e 9023     	 mov r3,#144
 8497 0180 DB05     	 lsl r3,r3,#23
 8498 0182 9022     	 mov r2,#144
 8499 0184 D205     	 lsl r2,r2,#23
 8500 0186 D26B     	 ldr r2,[r2,#60]
 8501 0188 0121     	 mov r1,#1
 8502 018a 0A43     	 orr r2,r1
 8503 018c DA63     	 str r2,[r3,#60]
1645:../XMC1100-LibHaas.c **** 				USIC_CH_PCR_ASCMode_SMD_Pos, 1);
1646:../XMC1100-LibHaas.c **** 	WR_REG(USIC0_CH0->PCR_ASCMode, USIC_CH_PCR_ASCMode_STPB_Msk, USIC_CH_PCR_ASCMode_STPB_Pos, 0);
 8504              	 .loc 3 1646 0
 8505 018e 9023     	 mov r3,#144
 8506 0190 DB05     	 lsl r3,r3,#23
 8507 0192 9022     	 mov r2,#144
 8508 0194 D205     	 lsl r2,r2,#23
 8509 0196 D26B     	 ldr r2,[r2,#60]
 8510 0198 0221     	 mov r1,#2
 8511 019a 8A43     	 bic r2,r1
 8512 019c DA63     	 str r2,[r3,#60]
1647:../XMC1100-LibHaas.c **** 	WR_REG(USIC0_CH0->PCR_ASCMode, USIC_CH_PCR_ASCMode_SP_Msk, USIC_CH_PCR_ASCMode_SP_Pos, 9);
 8513              	 .loc 3 1647 0
 8514 019e 9023     	 mov r3,#144
 8515 01a0 DB05     	 lsl r3,r3,#23
 8516 01a2 9022     	 mov r2,#144
 8517 01a4 D205     	 lsl r2,r2,#23
 8518 01a6 D26B     	 ldr r2,[r2,#60]
 8519 01a8 3B49     	 ldr r1,.L402+28
 8520 01aa 0A40     	 and r2,r1
 8521 01ac 9021     	 mov r1,#144
 8522 01ae 0901     	 lsl r1,r1,#4
 8523 01b0 0A43     	 orr r2,r1
 8524 01b2 DA63     	 str r2,[r3,#60]
1648:../XMC1100-LibHaas.c **** 		//TBIF is set to simplify polling
1649:../XMC1100-LibHaas.c **** 	WR_REG(USIC0_CH0->PSR_ASCMode, USIC_CH_PSR_TBIF_Msk, USIC_CH_PSR_TBIF_Pos, 1);
 8525              	 .loc 3 1649 0
 8526 01b4 9023     	 mov r3,#144
 8527 01b6 DB05     	 lsl r3,r3,#23
 8528 01b8 9022     	 mov r2,#144
 8529 01ba D205     	 lsl r2,r2,#23
 8530 01bc 926C     	 ldr r2,[r2,#72]
 8531 01be 8021     	 mov r1,#128
 8532 01c0 8901     	 lsl r1,r1,#6
 8533 01c2 0A43     	 orr r2,r1
 8534 01c4 9A64     	 str r2,[r3,#72]
1650:../XMC1100-LibHaas.c **** 		//Configuration of Transmitter Buffer Control Register
1651:../XMC1100-LibHaas.c **** 	WR_REG(USIC0_CH0->TBCTR, USIC_CH_TBCTR_LIMIT_Msk, USIC_CH_TBCTR_LIMIT_Pos, 0);
 8535              	 .loc 3 1651 0
 8536 01c6 9023     	 mov r3,#144
 8537 01c8 DA05     	 lsl r2,r3,#23
 8538 01ca 9023     	 mov r3,#144
 8539 01cc D905     	 lsl r1,r3,#23
 8540 01ce 8423     	 mov r3,#132
 8541 01d0 5B00     	 lsl r3,r3,#1
 8542 01d2 CB58     	 ldr r3,[r1,r3]
 8543 01d4 3149     	 ldr r1,.L402+32
 8544 01d6 1940     	 and r1,r3
 8545 01d8 8423     	 mov r3,#132
 8546 01da 5B00     	 lsl r3,r3,#1
 8547 01dc D150     	 str r1,[r2,r3]
1652:../XMC1100-LibHaas.c **** 
1653:../XMC1100-LibHaas.c **** 		//Configuration of Channel Control Register
1654:../XMC1100-LibHaas.c **** 		//parity generation is disabled
1655:../XMC1100-LibHaas.c **** 	USIC0_CH0->CCR |=  0x02;	// ASC Mode
 8548              	 .loc 3 1655 0
 8549 01de 9023     	 mov r3,#144
 8550 01e0 DB05     	 lsl r3,r3,#23
 8551 01e2 9022     	 mov r2,#144
 8552 01e4 D205     	 lsl r2,r2,#23
 8553 01e6 126C     	 ldr r2,[r2,#64]
 8554 01e8 0221     	 mov r1,#2
 8555 01ea 0A43     	 orr r2,r1
 8556 01ec 1A64     	 str r2,[r3,#64]
1656:../XMC1100-LibHaas.c **** 
1657:../XMC1100-LibHaas.c **** 		//Data Pointer & Buffer Size for Transmitter Buffer Control - DPTR = 64,  SIZE = 6
1658:../XMC1100-LibHaas.c **** 	WR_REG(USIC0_CH0->TBCTR, USIC_CH_TBCTR_DPTRSIZE_Msk_UART, USIC_CH_TBCTR_DPTRSIZE_Pos_UART, 0x06000
 8557              	 .loc 3 1658 0
 8558 01ee 9023     	 mov r3,#144
 8559 01f0 DA05     	 lsl r2,r3,#23
 8560 01f2 9023     	 mov r3,#144
 8561 01f4 D905     	 lsl r1,r3,#23
 8562 01f6 8423     	 mov r3,#132
 8563 01f8 5B00     	 lsl r3,r3,#1
 8564 01fa CB58     	 ldr r3,[r1,r3]
 8565 01fc 2849     	 ldr r1,.L402+36
 8566 01fe 0B40     	 and r3,r1
 8567 0200 C021     	 mov r1,#192
 8568 0202 C904     	 lsl r1,r1,#19
 8569 0204 1943     	 orr r1,r3
 8570 0206 8423     	 mov r3,#132
 8571 0208 5B00     	 lsl r3,r3,#1
 8572 020a D150     	 str r1,[r2,r3]
1659:../XMC1100-LibHaas.c **** 
1660:../XMC1100-LibHaas.c **** 	// Rx Pin: P1.1
1661:../XMC1100-LibHaas.c **** 	bit_init(P1,1,INP); //P1.1 als Eingang definieren
 8573              	 .loc 3 1661 0
 8574 020c 0120     	 mov r0,#1
 8575 020e 0121     	 mov r1,#1
 8576 0210 0022     	 mov r2,#0
 8577 0212 FFF7FEFF 	 bl bit_init
1662:../XMC1100-LibHaas.c **** 	USIC0_CH0->DX0CR &= ~(0x7);	// Kanal: USIC0_CH0 => DX0D auf P1.1 ( siehe Pin Mapping)
 8578              	 .loc 3 1662 0
 8579 0216 9023     	 mov r3,#144
 8580 0218 DB05     	 lsl r3,r3,#23
 8581 021a 9022     	 mov r2,#144
 8582 021c D205     	 lsl r2,r2,#23
 8583 021e D269     	 ldr r2,[r2,#28]
 8584 0220 0721     	 mov r1,#7
 8585 0222 8A43     	 bic r2,r1
 8586 0224 DA61     	 str r2,[r3,#28]
1663:../XMC1100-LibHaas.c **** 	USIC0_CH0->DX0CR |= 3;
 8587              	 .loc 3 1663 0
 8588 0226 9023     	 mov r3,#144
 8589 0228 DB05     	 lsl r3,r3,#23
 8590 022a 9022     	 mov r2,#144
 8591 022c D205     	 lsl r2,r2,#23
 8592 022e D269     	 ldr r2,[r2,#28]
 8593 0230 0321     	 mov r1,#3
 8594 0232 0A43     	 orr r2,r1
 8595 0234 DA61     	 str r2,[r3,#28]
1664:../XMC1100-LibHaas.c **** 
1665:../XMC1100-LibHaas.c **** 	//Tx Pin P1.0
1666:../XMC1100-LibHaas.c **** 	PORT1->IOCR0 &= 0xffffff07;	// P1.0
 8596              	 .loc 3 1666 0
 8597 0236 1B4B     	 ldr r3,.L402+40
 8598 0238 1A4A     	 ldr r2,.L402+40
 8599 023a 1269     	 ldr r2,[r2,#16]
 8600 023c F821     	 mov r1,#248
 8601 023e 8A43     	 bic r2,r1
 8602 0240 1A61     	 str r2,[r3,#16]
1667:../XMC1100-LibHaas.c **** 	PORT1->IOCR0  |= 0x000000B8; // ALT 7 fuer P1.0 => TxD d.h. XMC1100 sendet auf P1.0
 8603              	 .loc 3 1667 0
 8604 0242 184B     	 ldr r3,.L402+40
 8605 0244 174A     	 ldr r2,.L402+40
 8606 0246 1269     	 ldr r2,[r2,#16]
 8607 0248 B821     	 mov r1,#184
 8608 024a 0A43     	 orr r2,r1
 8609 024c 1A61     	 str r2,[r3,#16]
1668:../XMC1100-LibHaas.c **** 
1669:../XMC1100-LibHaas.c **** 	//UART Channel Auswahl auf DCE
1670:../XMC1100-LibHaas.c **** 	bit_init(0,12,OUTP);
 8610              	 .loc 3 1670 0
 8611 024e 0020     	 mov r0,#0
 8612 0250 0C21     	 mov r1,#12
 8613 0252 0122     	 mov r2,#1
 8614 0254 FFF7FEFF 	 bl bit_init
1671:../XMC1100-LibHaas.c **** 	bit_write(0,12,1);
 8615              	 .loc 3 1671 0
 8616 0258 0020     	 mov r0,#0
 8617 025a 0C21     	 mov r1,#12
 8618 025c 0122     	 mov r2,#1
 8619 025e FFF7FEFF 	 bl bit_write
1672:../XMC1100-LibHaas.c **** 	bit_init(0,13,OUTP);
 8620              	 .loc 3 1672 0
 8621 0262 0020     	 mov r0,#0
 8622 0264 0D21     	 mov r1,#13
 8623 0266 0122     	 mov r2,#1
 8624 0268 FFF7FEFF 	 bl bit_init
1673:../XMC1100-LibHaas.c **** 	bit_write(0,13,1);
 8625              	 .loc 3 1673 0
 8626 026c 0020     	 mov r0,#0
 8627 026e 0D21     	 mov r1,#13
 8628 0270 0122     	 mov r2,#1
 8629 0272 FFF7FEFF 	 bl bit_write
1674:../XMC1100-LibHaas.c **** }
 8630              	 .loc 3 1674 0
 8631 0276 BD46     	 mov sp,r7
 8632 0278 04B0     	 add sp,sp,#16
 8633              	 
 8634 027a 80BD     	 pop {r7,pc}
 8635              	.L403:
 8636              	 .align 2
 8637              	.L402:
 8638 027c 00000140 	 .word 1073807360
 8639 0280 00030140 	 .word 1073808128
 8640 0284 FFFF00FC 	 .word -67043329
 8641 0288 FFFCFFFF 	 .word -769
 8642 028c FFFFC0FF 	 .word -4128769
 8643 0290 FFFFFFF0 	 .word -251658241
 8644 0294 FFF3FFFF 	 .word -3073
 8645 0298 FFE0FFFF 	 .word -7937
 8646 029c FFC0FFFF 	 .word -16129
 8647 02a0 C0FFFFF8 	 .word -117440576
 8648 02a4 00010440 	 .word 1074004224
 8649              	 .cfi_endproc
 8650              	.LFE106:
 8652              	 .section .text.uart_interrupt_enable,"ax",%progbits
 8653              	 .align 2
 8654              	 .global uart_interrupt_enable
 8655              	 .code 16
 8656              	 .thumb_func
 8658              	uart_interrupt_enable:
 8659              	.LFB107:
1675:../XMC1100-LibHaas.c **** 
1676:../XMC1100-LibHaas.c **** 
1677:../XMC1100-LibHaas.c **** void uart_interrupt_enable()
1678:../XMC1100-LibHaas.c **** {
 8660              	 .loc 3 1678 0
 8661              	 .cfi_startproc
 8662 0000 80B5     	 push {r7,lr}
 8663              	.LCFI195:
 8664              	 .cfi_def_cfa_offset 8
 8665              	 .cfi_offset 7,-8
 8666              	 .cfi_offset 14,-4
 8667 0002 00AF     	 add r7,sp,#0
 8668              	.LCFI196:
 8669              	 .cfi_def_cfa_register 7
1679:../XMC1100-LibHaas.c **** 	USIC0_CH0->CCR  |=0x00004000;
 8670              	 .loc 3 1679 0
 8671 0004 9023     	 mov r3,#144
 8672 0006 DB05     	 lsl r3,r3,#23
 8673 0008 9022     	 mov r2,#144
 8674 000a D205     	 lsl r2,r2,#23
 8675 000c 126C     	 ldr r2,[r2,#64]
 8676 000e 8021     	 mov r1,#128
 8677 0010 C901     	 lsl r1,r1,#7
 8678 0012 0A43     	 orr r2,r1
 8679 0014 1A64     	 str r2,[r3,#64]
1680:../XMC1100-LibHaas.c **** 	USIC0_CH0->INPR &=0xFFFFF8FF;
 8680              	 .loc 3 1680 0
 8681 0016 9023     	 mov r3,#144
 8682 0018 DB05     	 lsl r3,r3,#23
 8683 001a 9022     	 mov r2,#144
 8684 001c D205     	 lsl r2,r2,#23
 8685 001e 9269     	 ldr r2,[r2,#24]
 8686 0020 0C49     	 ldr r1,.L405
 8687 0022 0A40     	 and r2,r1
 8688 0024 9A61     	 str r2,[r3,#24]
1681:../XMC1100-LibHaas.c **** 	USIC0_CH0->INPR |=0x00000100; // Interrupt wird auf SR1 gelegt
 8689              	 .loc 3 1681 0
 8690 0026 9023     	 mov r3,#144
 8691 0028 DB05     	 lsl r3,r3,#23
 8692 002a 9022     	 mov r2,#144
 8693 002c D205     	 lsl r2,r2,#23
 8694 002e 9269     	 ldr r2,[r2,#24]
 8695 0030 8021     	 mov r1,#128
 8696 0032 4900     	 lsl r1,r1,#1
 8697 0034 0A43     	 orr r2,r1
 8698 0036 9A61     	 str r2,[r3,#24]
1682:../XMC1100-LibHaas.c **** 	USIC0_CH0->PSCR |=0x00000400;
 8699              	 .loc 3 1682 0
 8700 0038 9023     	 mov r3,#144
 8701 003a DB05     	 lsl r3,r3,#23
 8702 003c 9022     	 mov r2,#144
 8703 003e D205     	 lsl r2,r2,#23
 8704 0040 D26C     	 ldr r2,[r2,#76]
 8705 0042 8021     	 mov r1,#128
 8706 0044 C900     	 lsl r1,r1,#3
 8707 0046 0A43     	 orr r2,r1
 8708 0048 DA64     	 str r2,[r3,#76]
1683:../XMC1100-LibHaas.c **** 	NVIC_EnableIRQ(USIC0_1_IRQn); 	// Int Freigabe  SR1 für empfange Zeichen
 8709              	 .loc 3 1683 0
 8710 004a 0A20     	 mov r0,#10
 8711 004c FFF7FEFF 	 bl __NVIC_EnableIRQ
1684:../XMC1100-LibHaas.c **** 	//NVIC_EnableIRQ(10); 	// Int Freigabe  SR0 für empfange Zeichen
1685:../XMC1100-LibHaas.c **** }
 8712              	 .loc 3 1685 0
 8713 0050 BD46     	 mov sp,r7
 8714              	 
 8715 0052 80BD     	 pop {r7,pc}
 8716              	.L406:
 8717              	 .align 2
 8718              	.L405:
 8719 0054 FFF8FFFF 	 .word -1793
 8720              	 .cfi_endproc
 8721              	.LFE107:
 8723              	 .section .text.uart_get,"ax",%progbits
 8724              	 .align 2
 8725              	 .global uart_get
 8726              	 .code 16
 8727              	 .thumb_func
 8729              	uart_get:
 8730              	.LFB108:
1686:../XMC1100-LibHaas.c **** /*
1687:../XMC1100-LibHaas.c **** void USIC0_1_IRQHandler(void)
1688:../XMC1100-LibHaas.c **** {
1689:../XMC1100-LibHaas.c **** 	empfangsdaten[0]=USIC0_CH0->RBUF & 0xff ;	// RX Buffer auslesen
1690:../XMC1100-LibHaas.c **** }
1691:../XMC1100-LibHaas.c **** */
1692:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
1693:../XMC1100-LibHaas.c **** // liest ein Byte (1..255) von COM, liefert 0 wenn kein Zeichen vorhanden
1694:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
1695:../XMC1100-LibHaas.c **** char uart_get ( void )
1696:../XMC1100-LibHaas.c **** {
 8731              	 .loc 3 1696 0
 8732              	 .cfi_startproc
 8733 0000 80B5     	 push {r7,lr}
 8734              	.LCFI197:
 8735              	 .cfi_def_cfa_offset 8
 8736              	 .cfi_offset 7,-8
 8737              	 .cfi_offset 14,-4
 8738 0002 82B0     	 sub sp,sp,#8
 8739              	.LCFI198:
 8740              	 .cfi_def_cfa_offset 16
 8741 0004 00AF     	 add r7,sp,#0
 8742              	.LCFI199:
 8743              	 .cfi_def_cfa_register 7
1697:../XMC1100-LibHaas.c ****   uint8_t buffer;
1698:../XMC1100-LibHaas.c **** 	buffer = 0;
 8744              	 .loc 3 1698 0
 8745 0006 FB1D     	 add r3,r7,#7
 8746 0008 0022     	 mov r2,#0
 8747 000a 1A70     	 strb r2,[r3]
1699:../XMC1100-LibHaas.c **** 	if ((USIC0_CH0->PSR &(1UL <<14)) != 0)  // wenn Zeichen vorhanden
 8748              	 .loc 3 1699 0
 8749 000c 9023     	 mov r3,#144
 8750 000e DB05     	 lsl r3,r3,#23
 8751 0010 9A6C     	 ldr r2,[r3,#72]
 8752 0012 8023     	 mov r3,#128
 8753 0014 DB01     	 lsl r3,r3,#7
 8754 0016 1340     	 and r3,r2
 8755 0018 0DD0     	 beq .L408
1700:../XMC1100-LibHaas.c **** 	 {
1701:../XMC1100-LibHaas.c **** 		buffer = USIC0_CH0->RBUF & 0xff ;	// RX Buffer auslesen
 8756              	 .loc 3 1701 0
 8757 001a 9023     	 mov r3,#144
 8758 001c DB05     	 lsl r3,r3,#23
 8759 001e 5A6D     	 ldr r2,[r3,#84]
 8760 0020 FB1D     	 add r3,r7,#7
 8761 0022 1A70     	 strb r2,[r3]
1702:../XMC1100-LibHaas.c **** 		USIC0_CH0->PSCR |= 1UL <<14 ;		// Receive Flag löschen
 8762              	 .loc 3 1702 0
 8763 0024 9023     	 mov r3,#144
 8764 0026 DB05     	 lsl r3,r3,#23
 8765 0028 9022     	 mov r2,#144
 8766 002a D205     	 lsl r2,r2,#23
 8767 002c D26C     	 ldr r2,[r2,#76]
 8768 002e 8021     	 mov r1,#128
 8769 0030 C901     	 lsl r1,r1,#7
 8770 0032 0A43     	 orr r2,r1
 8771 0034 DA64     	 str r2,[r3,#76]
 8772              	.L408:
1703:../XMC1100-LibHaas.c **** 	 }
1704:../XMC1100-LibHaas.c **** 	return buffer;
 8773              	 .loc 3 1704 0
 8774 0036 FB1D     	 add r3,r7,#7
 8775 0038 1B78     	 ldrb r3,[r3]
1705:../XMC1100-LibHaas.c **** }
 8776              	 .loc 3 1705 0
 8777 003a 181C     	 mov r0,r3
 8778 003c BD46     	 mov sp,r7
 8779 003e 02B0     	 add sp,sp,#8
 8780              	 
 8781 0040 80BD     	 pop {r7,pc}
 8782              	 .cfi_endproc
 8783              	.LFE108:
 8785 0042 C046     	 .section .text.uart_char_received,"ax",%progbits
 8786              	 .align 2
 8787              	 .global uart_char_received
 8788              	 .code 16
 8789              	 .thumb_func
 8791              	uart_char_received:
 8792              	.LFB109:
1706:../XMC1100-LibHaas.c **** //-----------------------------------------------------------------
1707:../XMC1100-LibHaas.c **** // liefert 1 wenn Zeichen empfangen und 0 wenn kein Zeichen empfangen
1708:../XMC1100-LibHaas.c **** //----------------------------------------------------------------
1709:../XMC1100-LibHaas.c **** uint8_t uart_char_received (void)
1710:../XMC1100-LibHaas.c **** {
 8793              	 .loc 3 1710 0
 8794              	 .cfi_startproc
 8795 0000 80B5     	 push {r7,lr}
 8796              	.LCFI200:
 8797              	 .cfi_def_cfa_offset 8
 8798              	 .cfi_offset 7,-8
 8799              	 .cfi_offset 14,-4
 8800 0002 00AF     	 add r7,sp,#0
 8801              	.LCFI201:
 8802              	 .cfi_def_cfa_register 7
1711:../XMC1100-LibHaas.c **** 	if ((USIC0_CH0->PSR &(1UL <<14)) != 0) return 1; // wenn Zeichen vorhanden
 8803              	 .loc 3 1711 0
 8804 0004 9023     	 mov r3,#144
 8805 0006 DB05     	 lsl r3,r3,#23
 8806 0008 9A6C     	 ldr r2,[r3,#72]
 8807 000a 8023     	 mov r3,#128
 8808 000c DB01     	 lsl r3,r3,#7
 8809 000e 1340     	 and r3,r2
 8810 0010 01D0     	 beq .L411
 8811              	 .loc 3 1711 0 is_stmt 0 discriminator 1
 8812 0012 0123     	 mov r3,#1
 8813 0014 00E0     	 b .L412
 8814              	.L411:
1712:../XMC1100-LibHaas.c **** 		else return 0;
 8815              	 .loc 3 1712 0 is_stmt 1
 8816 0016 0023     	 mov r3,#0
 8817              	.L412:
1713:../XMC1100-LibHaas.c **** }
 8818              	 .loc 3 1713 0
 8819 0018 181C     	 mov r0,r3
 8820 001a BD46     	 mov sp,r7
 8821              	 
 8822 001c 80BD     	 pop {r7,pc}
 8823              	 .cfi_endproc
 8824              	.LFE109:
 8826 001e C046     	 .section .text.uart_wait_get,"ax",%progbits
 8827              	 .align 2
 8828              	 .global uart_wait_get
 8829              	 .code 16
 8830              	 .thumb_func
 8832              	uart_wait_get:
 8833              	.LFB110:
1714:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
1715:../XMC1100-LibHaas.c **** // wartet auf ein Byte von COM und liest es ein (0..255)
1716:../XMC1100-LibHaas.c **** // Achtung! Programm bleibt solange in dieser Funktion, bis ein Zeichen eintrifft!
1717:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
1718:../XMC1100-LibHaas.c **** char uart_wait_get ( void )
1719:../XMC1100-LibHaas.c **** {
 8834              	 .loc 3 1719 0
 8835              	 .cfi_startproc
 8836 0000 80B5     	 push {r7,lr}
 8837              	.LCFI202:
 8838              	 .cfi_def_cfa_offset 8
 8839              	 .cfi_offset 7,-8
 8840              	 .cfi_offset 14,-4
 8841 0002 82B0     	 sub sp,sp,#8
 8842              	.LCFI203:
 8843              	 .cfi_def_cfa_offset 16
 8844 0004 00AF     	 add r7,sp,#0
 8845              	.LCFI204:
 8846              	 .cfi_def_cfa_register 7
1720:../XMC1100-LibHaas.c ****   uint8_t buffer;
1721:../XMC1100-LibHaas.c **** 	while ((USIC0_CH0->PSR &(1UL <<14)) == 0); 	// auf Zeichen warten
 8847              	 .loc 3 1721 0
 8848 0006 C046     	 mov r8,r8
 8849              	.L414:
 8850              	 .loc 3 1721 0 is_stmt 0 discriminator 1
 8851 0008 9023     	 mov r3,#144
 8852 000a DB05     	 lsl r3,r3,#23
 8853 000c 9A6C     	 ldr r2,[r3,#72]
 8854 000e 8023     	 mov r3,#128
 8855 0010 DB01     	 lsl r3,r3,#7
 8856 0012 1340     	 and r3,r2
 8857 0014 F8D0     	 beq .L414
1722:../XMC1100-LibHaas.c **** 	buffer = USIC0_CH0->RBUF & 0xff ;			// RX Buffer auslesen
 8858              	 .loc 3 1722 0 is_stmt 1
 8859 0016 9023     	 mov r3,#144
 8860 0018 DB05     	 lsl r3,r3,#23
 8861 001a 5A6D     	 ldr r2,[r3,#84]
 8862 001c FB1D     	 add r3,r7,#7
 8863 001e 1A70     	 strb r2,[r3]
1723:../XMC1100-LibHaas.c **** 	USIC0_CH0->PSCR |= 1UL <<14 ;				// Receive Flag löschen
 8864              	 .loc 3 1723 0
 8865 0020 9023     	 mov r3,#144
 8866 0022 DB05     	 lsl r3,r3,#23
 8867 0024 9022     	 mov r2,#144
 8868 0026 D205     	 lsl r2,r2,#23
 8869 0028 D26C     	 ldr r2,[r2,#76]
 8870 002a 8021     	 mov r1,#128
 8871 002c C901     	 lsl r1,r1,#7
 8872 002e 0A43     	 orr r2,r1
 8873 0030 DA64     	 str r2,[r3,#76]
1724:../XMC1100-LibHaas.c **** 	return buffer;
 8874              	 .loc 3 1724 0
 8875 0032 FB1D     	 add r3,r7,#7
 8876 0034 1B78     	 ldrb r3,[r3]
1725:../XMC1100-LibHaas.c **** }
 8877              	 .loc 3 1725 0
 8878 0036 181C     	 mov r0,r3
 8879 0038 BD46     	 mov sp,r7
 8880 003a 02B0     	 add sp,sp,#8
 8881              	 
 8882 003c 80BD     	 pop {r7,pc}
 8883              	 .cfi_endproc
 8884              	.LFE110:
 8886 003e C046     	 .section .text.uart_put,"ax",%progbits
 8887              	 .align 2
 8888              	 .global uart_put
 8889              	 .code 16
 8890              	 .thumb_func
 8892              	uart_put:
 8893              	.LFB111:
1726:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
1727:../XMC1100-LibHaas.c **** // schreibt ein Byte auf COM
1728:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
1729:../XMC1100-LibHaas.c **** void uart_put ( char value )
1730:../XMC1100-LibHaas.c **** {
 8894              	 .loc 3 1730 0
 8895              	 .cfi_startproc
 8896 0000 80B5     	 push {r7,lr}
 8897              	.LCFI205:
 8898              	 .cfi_def_cfa_offset 8
 8899              	 .cfi_offset 7,-8
 8900              	 .cfi_offset 14,-4
 8901 0002 82B0     	 sub sp,sp,#8
 8902              	.LCFI206:
 8903              	 .cfi_def_cfa_offset 16
 8904 0004 00AF     	 add r7,sp,#0
 8905              	.LCFI207:
 8906              	 .cfi_def_cfa_register 7
 8907 0006 021C     	 mov r2,r0
 8908 0008 FB1D     	 add r3,r7,#7
 8909 000a 1A70     	 strb r2,[r3]
1731:../XMC1100-LibHaas.c **** 	USIC0_CH0->IN[0] = value;
 8910              	 .loc 3 1731 0
 8911 000c 9023     	 mov r3,#144
 8912 000e DA05     	 lsl r2,r3,#23
 8913 0010 FB1D     	 add r3,r7,#7
 8914 0012 1978     	 ldrb r1,[r3]
 8915 0014 C023     	 mov r3,#192
 8916 0016 5B00     	 lsl r3,r3,#1
 8917 0018 D150     	 str r1,[r2,r3]
1732:../XMC1100-LibHaas.c **** 	while((USIC0_CH0->TRBSR & (1U<< 11))  == 0);  // Warten , bis Transmit Buffer empty
 8918              	 .loc 3 1732 0
 8919 001a C046     	 mov r8,r8
 8920              	.L417:
 8921              	 .loc 3 1732 0 is_stmt 0 discriminator 1
 8922 001c 9023     	 mov r3,#144
 8923 001e DA05     	 lsl r2,r3,#23
 8924 0020 8A23     	 mov r3,#138
 8925 0022 5B00     	 lsl r3,r3,#1
 8926 0024 D258     	 ldr r2,[r2,r3]
 8927 0026 8023     	 mov r3,#128
 8928 0028 1B01     	 lsl r3,r3,#4
 8929 002a 1340     	 and r3,r2
 8930 002c F6D0     	 beq .L417
1733:../XMC1100-LibHaas.c **** 
1734:../XMC1100-LibHaas.c **** }
 8931              	 .loc 3 1734 0 is_stmt 1
 8932 002e BD46     	 mov sp,r7
 8933 0030 02B0     	 add sp,sp,#8
 8934              	 
 8935 0032 80BD     	 pop {r7,pc}
 8936              	 .cfi_endproc
 8937              	.LFE111:
 8939              	 .section .text.uart_print,"ax",%progbits
 8940              	 .align 2
 8941              	 .global uart_print
 8942              	 .code 16
 8943              	 .thumb_func
 8945              	uart_print:
 8946              	.LFB112:
1735:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
1736:../XMC1100-LibHaas.c **** // schreibt eine nullterminierte Zeichenfolge auf COM
1737:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
1738:../XMC1100-LibHaas.c **** void uart_print ( char *text )
1739:../XMC1100-LibHaas.c **** {
 8947              	 .loc 3 1739 0
 8948              	 .cfi_startproc
 8949 0000 80B5     	 push {r7,lr}
 8950              	.LCFI208:
 8951              	 .cfi_def_cfa_offset 8
 8952              	 .cfi_offset 7,-8
 8953              	 .cfi_offset 14,-4
 8954 0002 82B0     	 sub sp,sp,#8
 8955              	.LCFI209:
 8956              	 .cfi_def_cfa_offset 16
 8957 0004 00AF     	 add r7,sp,#0
 8958              	.LCFI210:
 8959              	 .cfi_def_cfa_register 7
 8960 0006 7860     	 str r0,[r7,#4]
1740:../XMC1100-LibHaas.c ****   while (*text != '\0')
 8961              	 .loc 3 1740 0
 8962 0008 06E0     	 b .L419
 8963              	.L420:
1741:../XMC1100-LibHaas.c ****     uart_put(*text++);
 8964              	 .loc 3 1741 0
 8965 000a 7B68     	 ldr r3,[r7,#4]
 8966 000c 5A1C     	 add r2,r3,#1
 8967 000e 7A60     	 str r2,[r7,#4]
 8968 0010 1B78     	 ldrb r3,[r3]
 8969 0012 181C     	 mov r0,r3
 8970 0014 FFF7FEFF 	 bl uart_put
 8971              	.L419:
1740:../XMC1100-LibHaas.c ****   while (*text != '\0')
 8972              	 .loc 3 1740 0
 8973 0018 7B68     	 ldr r3,[r7,#4]
 8974 001a 1B78     	 ldrb r3,[r3]
 8975 001c 002B     	 cmp r3,#0
 8976 001e F4D1     	 bne .L420
1742:../XMC1100-LibHaas.c **** }
 8977              	 .loc 3 1742 0
 8978 0020 BD46     	 mov sp,r7
 8979 0022 02B0     	 add sp,sp,#8
 8980              	 
 8981 0024 80BD     	 pop {r7,pc}
 8982              	 .cfi_endproc
 8983              	.LFE112:
 8985 0026 C046     	 .section .text.USIC0_1_IRQHandler,"ax",%progbits
 8986              	 .align 2
 8987              	 .global USIC0_1_IRQHandler
 8988              	 .code 16
 8989              	 .thumb_func
 8991              	USIC0_1_IRQHandler:
 8992              	.LFB113:
1743:../XMC1100-LibHaas.c **** 
1744:../XMC1100-LibHaas.c **** /*------------------------------------------------------------------
1745:../XMC1100-LibHaas.c **** * Bei jedem empfangenen Zeichen wird diese Interrupt Service Routine aktiviert
1746:../XMC1100-LibHaas.c **** * Diese USIC-ISR kann ins eigene Programm kopiert werden dann muss diese
1747:../XMC1100-LibHaas.c **** * Variante auskommentiert werden.
1748:../XMC1100-LibHaas.c **** * Diese ISR arbeitet mit folgende Funktionen:
1749:../XMC1100-LibHaas.c **** * rs232_wait_of_enter(), rs232_clear_receivedata()
1750:../XMC1100-LibHaas.c **** * Es werden folgende globale Variablen benötigt:
1751:../XMC1100-LibHaas.c **** * rs232Receivedata, rs232ReceivedataPointer, rs232EnterReceive
1752:../XMC1100-LibHaas.c **** */
1753:../XMC1100-LibHaas.c **** void USIC0_1_IRQHandler(void)
1754:../XMC1100-LibHaas.c **** {
 8993              	 .loc 3 1754 0
 8994              	 .cfi_startproc
 8995 0000 80B5     	 push {r7,lr}
 8996              	.LCFI211:
 8997              	 .cfi_def_cfa_offset 8
 8998              	 .cfi_offset 7,-8
 8999              	 .cfi_offset 14,-4
 9000 0002 82B0     	 sub sp,sp,#8
 9001              	.LCFI212:
 9002              	 .cfi_def_cfa_offset 16
 9003 0004 00AF     	 add r7,sp,#0
 9004              	.LCFI213:
 9005              	 .cfi_def_cfa_register 7
1755:../XMC1100-LibHaas.c **** 	char temp=USIC0_CH0->RBUF & 0xff;	// Rx-Buffer auslesen
 9006              	 .loc 3 1755 0
 9007 0006 9023     	 mov r3,#144
 9008 0008 DB05     	 lsl r3,r3,#23
 9009 000a 5A6D     	 ldr r2,[r3,#84]
 9010 000c FB1D     	 add r3,r7,#7
 9011 000e 1A70     	 strb r2,[r3]
1756:../XMC1100-LibHaas.c **** 	if (temp == '\r') {					// Enterzeichen empfangen?
 9012              	 .loc 3 1756 0
 9013 0010 FB1D     	 add r3,r7,#7
 9014 0012 1B78     	 ldrb r3,[r3]
 9015 0014 0D2B     	 cmp r3,#13
 9016 0016 09D1     	 bne .L422
1757:../XMC1100-LibHaas.c **** 		uartReceivedata[uartReceivedataPointer]='\0';
 9017              	 .loc 3 1757 0
 9018 0018 0D4B     	 ldr r3,.L425
 9019 001a 1B78     	 ldrb r3,[r3]
 9020 001c 1A1C     	 mov r2,r3
 9021 001e 0D4B     	 ldr r3,.L425+4
 9022 0020 0021     	 mov r1,#0
 9023 0022 9954     	 strb r1,[r3,r2]
1758:../XMC1100-LibHaas.c **** 		uartEnterReceive = 1;
 9024              	 .loc 3 1758 0
 9025 0024 0C4B     	 ldr r3,.L425+8
 9026 0026 0122     	 mov r2,#1
 9027 0028 1A70     	 strb r2,[r3]
 9028 002a 06E0     	 b .L423
 9029              	.L422:
1759:../XMC1100-LibHaas.c **** 	} else {
1760:../XMC1100-LibHaas.c **** 		uartReceivedata[uartReceivedataPointer]=temp;
 9030              	 .loc 3 1760 0
 9031 002c 084B     	 ldr r3,.L425
 9032 002e 1B78     	 ldrb r3,[r3]
 9033 0030 191C     	 mov r1,r3
 9034 0032 084B     	 ldr r3,.L425+4
 9035 0034 FA1D     	 add r2,r7,#7
 9036 0036 1278     	 ldrb r2,[r2]
 9037 0038 5A54     	 strb r2,[r3,r1]
 9038              	.L423:
1761:../XMC1100-LibHaas.c **** 	}
1762:../XMC1100-LibHaas.c **** 	uartReceivedataPointer++;
 9039              	 .loc 3 1762 0
 9040 003a 054B     	 ldr r3,.L425
 9041 003c 1B78     	 ldrb r3,[r3]
 9042 003e 0133     	 add r3,r3,#1
 9043 0040 DAB2     	 uxtb r2,r3
 9044 0042 034B     	 ldr r3,.L425
 9045 0044 1A70     	 strb r2,[r3]
1763:../XMC1100-LibHaas.c **** 	//USIC0_CH0->PSCR |=0x00000400;
1764:../XMC1100-LibHaas.c **** 	return;
 9046              	 .loc 3 1764 0
 9047 0046 C046     	 mov r8,r8
1765:../XMC1100-LibHaas.c **** }
 9048              	 .loc 3 1765 0
 9049 0048 BD46     	 mov sp,r7
 9050 004a 02B0     	 add sp,sp,#8
 9051              	 
 9052 004c 80BD     	 pop {r7,pc}
 9053              	.L426:
 9054 004e C046     	 .align 2
 9055              	.L425:
 9056 0050 00000000 	 .word uartReceivedataPointer
 9057 0054 00000000 	 .word uartReceivedata
 9058 0058 00000000 	 .word uartEnterReceive
 9059              	 .cfi_endproc
 9060              	.LFE113:
 9062              	 .section .text.uart_wait_of_enter,"ax",%progbits
 9063              	 .align 2
 9064              	 .global uart_wait_of_enter
 9065              	 .code 16
 9066              	 .thumb_func
 9068              	uart_wait_of_enter:
 9069              	.LFB114:
1766:../XMC1100-LibHaas.c **** void uart_wait_of_enter()
1767:../XMC1100-LibHaas.c **** {
 9070              	 .loc 3 1767 0
 9071              	 .cfi_startproc
 9072 0000 80B5     	 push {r7,lr}
 9073              	.LCFI214:
 9074              	 .cfi_def_cfa_offset 8
 9075              	 .cfi_offset 7,-8
 9076              	 .cfi_offset 14,-4
 9077 0002 00AF     	 add r7,sp,#0
 9078              	.LCFI215:
 9079              	 .cfi_def_cfa_register 7
1768:../XMC1100-LibHaas.c **** 	while (uartEnterReceive==0) {}
 9080              	 .loc 3 1768 0
 9081 0004 C046     	 mov r8,r8
 9082              	.L428:
 9083              	 .loc 3 1768 0 is_stmt 0 discriminator 1
 9084 0006 044B     	 ldr r3,.L429
 9085 0008 1B78     	 ldrb r3,[r3]
 9086 000a 002B     	 cmp r3,#0
 9087 000c FBD0     	 beq .L428
1769:../XMC1100-LibHaas.c **** 	uartEnterReceive=0;
 9088              	 .loc 3 1769 0 is_stmt 1
 9089 000e 024B     	 ldr r3,.L429
 9090 0010 0022     	 mov r2,#0
 9091 0012 1A70     	 strb r2,[r3]
1770:../XMC1100-LibHaas.c **** }
 9092              	 .loc 3 1770 0
 9093 0014 BD46     	 mov sp,r7
 9094              	 
 9095 0016 80BD     	 pop {r7,pc}
 9096              	.L430:
 9097              	 .align 2
 9098              	.L429:
 9099 0018 00000000 	 .word uartEnterReceive
 9100              	 .cfi_endproc
 9101              	.LFE114:
 9103              	 .section .text.uart_clear_receivedata,"ax",%progbits
 9104              	 .align 2
 9105              	 .global uart_clear_receivedata
 9106              	 .code 16
 9107              	 .thumb_func
 9109              	uart_clear_receivedata:
 9110              	.LFB115:
1771:../XMC1100-LibHaas.c **** void uart_clear_receivedata()
1772:../XMC1100-LibHaas.c **** {
 9111              	 .loc 3 1772 0
 9112              	 .cfi_startproc
 9113 0000 80B5     	 push {r7,lr}
 9114              	.LCFI216:
 9115              	 .cfi_def_cfa_offset 8
 9116              	 .cfi_offset 7,-8
 9117              	 .cfi_offset 14,-4
 9118 0002 00AF     	 add r7,sp,#0
 9119              	.LCFI217:
 9120              	 .cfi_def_cfa_register 7
1773:../XMC1100-LibHaas.c **** 	uartReceivedata[0]='\0';
 9121              	 .loc 3 1773 0
 9122 0004 034B     	 ldr r3,.L432
 9123 0006 0022     	 mov r2,#0
 9124 0008 1A70     	 strb r2,[r3]
1774:../XMC1100-LibHaas.c **** 	uartReceivedataPointer=0;
 9125              	 .loc 3 1774 0
 9126 000a 034B     	 ldr r3,.L432+4
 9127 000c 0022     	 mov r2,#0
 9128 000e 1A70     	 strb r2,[r3]
1775:../XMC1100-LibHaas.c **** }
 9129              	 .loc 3 1775 0
 9130 0010 BD46     	 mov sp,r7
 9131              	 
 9132 0012 80BD     	 pop {r7,pc}
 9133              	.L433:
 9134              	 .align 2
 9135              	.L432:
 9136 0014 00000000 	 .word uartReceivedata
 9137 0018 00000000 	 .word uartReceivedataPointer
 9138              	 .cfi_endproc
 9139              	.LFE115:
 9141              	 .section .text.uart_select_channel,"ax",%progbits
 9142              	 .align 2
 9143              	 .global uart_select_channel
 9144              	 .code 16
 9145              	 .thumb_func
 9147              	uart_select_channel:
 9148              	.LFB116:
1776:../XMC1100-LibHaas.c **** 
1777:../XMC1100-LibHaas.c **** /*********uart_select_channel ***************************
1778:../XMC1100-LibHaas.c ****  * Die Kanäle der UART Schnittstelle werden umgeschaltet
1779:../XMC1100-LibHaas.c ****  * UARTCHANNEL_DCE : P0.12=1 und P0.13=1 => Stecker-Ausgang
1780:../XMC1100-LibHaas.c ****  * UARTCHANNEL_DTE : P0.12=0 und P0.13=1 => Buchse Ausgang
1781:../XMC1100-LibHaas.c ****  * UARTCHANNEL_0 : P0.12=1 und P0.13=0 => TTL Pegel Kanal 0
1782:../XMC1100-LibHaas.c ****  * UARTCHANNEL_1 : P0.12=0 und P0.13=0 => TTL Pegel Kanal 1
1783:../XMC1100-LibHaas.c ****  */
1784:../XMC1100-LibHaas.c **** void uart_select_channel(uint8_t select) {
 9149              	 .loc 3 1784 0
 9150              	 .cfi_startproc
 9151 0000 80B5     	 push {r7,lr}
 9152              	.LCFI218:
 9153              	 .cfi_def_cfa_offset 8
 9154              	 .cfi_offset 7,-8
 9155              	 .cfi_offset 14,-4
 9156 0002 82B0     	 sub sp,sp,#8
 9157              	.LCFI219:
 9158              	 .cfi_def_cfa_offset 16
 9159 0004 00AF     	 add r7,sp,#0
 9160              	.LCFI220:
 9161              	 .cfi_def_cfa_register 7
 9162 0006 021C     	 mov r2,r0
 9163 0008 FB1D     	 add r3,r7,#7
 9164 000a 1A70     	 strb r2,[r3]
1785:../XMC1100-LibHaas.c **** 	while((USIC0_CH0->TRBSR & (1U<< 11))  == 0);  // Warten , bis Transmit Buffer empty
 9165              	 .loc 3 1785 0
 9166 000c C046     	 mov r8,r8
 9167              	.L435:
 9168              	 .loc 3 1785 0 is_stmt 0 discriminator 1
 9169 000e 9023     	 mov r3,#144
 9170 0010 DA05     	 lsl r2,r3,#23
 9171 0012 8A23     	 mov r3,#138
 9172 0014 5B00     	 lsl r3,r3,#1
 9173 0016 D258     	 ldr r2,[r2,r3]
 9174 0018 8023     	 mov r3,#128
 9175 001a 1B01     	 lsl r3,r3,#4
 9176 001c 1340     	 and r3,r2
 9177 001e F6D0     	 beq .L435
1786:../XMC1100-LibHaas.c **** 	//delay_ms(2);
1787:../XMC1100-LibHaas.c **** 	switch (select) {
 9178              	 .loc 3 1787 0 is_stmt 1
 9179 0020 FB1D     	 add r3,r7,#7
 9180 0022 1B78     	 ldrb r3,[r3]
 9181 0024 012B     	 cmp r3,#1
 9182 0026 13D0     	 beq .L437
 9183 0028 02DC     	 bgt .L438
 9184 002a 002B     	 cmp r3,#0
 9185 002c 05D0     	 beq .L439
 9186 002e 30E0     	 b .L434
 9187              	.L438:
 9188 0030 022B     	 cmp r3,#2
 9189 0032 18D0     	 beq .L440
 9190 0034 032B     	 cmp r3,#3
 9191 0036 21D0     	 beq .L441
 9192 0038 2BE0     	 b .L434
 9193              	.L439:
1788:../XMC1100-LibHaas.c **** 	  case UARTCHANNEL_DCE:
1789:../XMC1100-LibHaas.c **** 	    bit_write(0,12,1);
 9194              	 .loc 3 1789 0
 9195 003a 0020     	 mov r0,#0
 9196 003c 0C21     	 mov r1,#12
 9197 003e 0122     	 mov r2,#1
 9198 0040 FFF7FEFF 	 bl bit_write
1790:../XMC1100-LibHaas.c **** 	    bit_write(0,13,1);
 9199              	 .loc 3 1790 0
 9200 0044 0020     	 mov r0,#0
 9201 0046 0D21     	 mov r1,#13
 9202 0048 0122     	 mov r2,#1
 9203 004a FFF7FEFF 	 bl bit_write
1791:../XMC1100-LibHaas.c **** 	    break;
 9204              	 .loc 3 1791 0
 9205 004e 20E0     	 b .L434
 9206              	.L437:
1792:../XMC1100-LibHaas.c **** 	  case UARTCHANNEL_DTE:
1793:../XMC1100-LibHaas.c **** 		bit_write(0,12,0);
 9207              	 .loc 3 1793 0
 9208 0050 0020     	 mov r0,#0
 9209 0052 0C21     	 mov r1,#12
 9210 0054 0022     	 mov r2,#0
 9211 0056 FFF7FEFF 	 bl bit_write
1794:../XMC1100-LibHaas.c **** 		bit_write(0,13,1);
 9212              	 .loc 3 1794 0
 9213 005a 0020     	 mov r0,#0
 9214 005c 0D21     	 mov r1,#13
 9215 005e 0122     	 mov r2,#1
 9216 0060 FFF7FEFF 	 bl bit_write
1795:../XMC1100-LibHaas.c **** 		break;
 9217              	 .loc 3 1795 0
 9218 0064 15E0     	 b .L434
 9219              	.L440:
1796:../XMC1100-LibHaas.c **** 	  case UARTCHANNEL_1:
1797:../XMC1100-LibHaas.c **** 	    bit_write(0,12,1);
 9220              	 .loc 3 1797 0
 9221 0066 0020     	 mov r0,#0
 9222 0068 0C21     	 mov r1,#12
 9223 006a 0122     	 mov r2,#1
 9224 006c FFF7FEFF 	 bl bit_write
1798:../XMC1100-LibHaas.c **** 	    bit_write(0,13,0);
 9225              	 .loc 3 1798 0
 9226 0070 0020     	 mov r0,#0
 9227 0072 0D21     	 mov r1,#13
 9228 0074 0022     	 mov r2,#0
 9229 0076 FFF7FEFF 	 bl bit_write
1799:../XMC1100-LibHaas.c **** 	    break;
 9230              	 .loc 3 1799 0
 9231 007a 0AE0     	 b .L434
 9232              	.L441:
1800:../XMC1100-LibHaas.c **** 	  case UARTCHANNEL_0:
1801:../XMC1100-LibHaas.c **** 		bit_write(0,12,0);
 9233              	 .loc 3 1801 0
 9234 007c 0020     	 mov r0,#0
 9235 007e 0C21     	 mov r1,#12
 9236 0080 0022     	 mov r2,#0
 9237 0082 FFF7FEFF 	 bl bit_write
1802:../XMC1100-LibHaas.c **** 		bit_write(0,13,0);
 9238              	 .loc 3 1802 0
 9239 0086 0020     	 mov r0,#0
 9240 0088 0D21     	 mov r1,#13
 9241 008a 0022     	 mov r2,#0
 9242 008c FFF7FEFF 	 bl bit_write
1803:../XMC1100-LibHaas.c **** 		break;
 9243              	 .loc 3 1803 0
 9244 0090 C046     	 mov r8,r8
 9245              	.L434:
1804:../XMC1100-LibHaas.c **** 	}
1805:../XMC1100-LibHaas.c **** }
 9246              	 .loc 3 1805 0
 9247 0092 BD46     	 mov sp,r7
 9248 0094 02B0     	 add sp,sp,#8
 9249              	 
 9250 0096 80BD     	 pop {r7,pc}
 9251              	 .cfi_endproc
 9252              	.LFE116:
 9254              	 .section .text.uart_read_number,"ax",%progbits
 9255              	 .align 2
 9256              	 .global uart_read_number
 9257              	 .code 16
 9258              	 .thumb_func
 9260              	uart_read_number:
 9261              	.LFB117:
1806:../XMC1100-LibHaas.c **** 
1807:../XMC1100-LibHaas.c **** uint8_t uart_read_number()
1808:../XMC1100-LibHaas.c **** {
 9262              	 .loc 3 1808 0
 9263              	 .cfi_startproc
 9264 0000 80B5     	 push {r7,lr}
 9265              	.LCFI221:
 9266              	 .cfi_def_cfa_offset 8
 9267              	 .cfi_offset 7,-8
 9268              	 .cfi_offset 14,-4
 9269 0002 82B0     	 sub sp,sp,#8
 9270              	.LCFI222:
 9271              	 .cfi_def_cfa_offset 16
 9272 0004 00AF     	 add r7,sp,#0
 9273              	.LCFI223:
 9274              	 .cfi_def_cfa_register 7
1809:../XMC1100-LibHaas.c **** 	uint8_t stellen, zahl=0;
 9275              	 .loc 3 1809 0
 9276 0006 BB1D     	 add r3,r7,#6
 9277 0008 0022     	 mov r2,#0
 9278 000a 1A70     	 strb r2,[r3]
1810:../XMC1100-LibHaas.c **** 	uart_wait_of_enter();
 9279              	 .loc 3 1810 0
 9280 000c FFF7FEFF 	 bl uart_wait_of_enter
1811:../XMC1100-LibHaas.c **** 	for (stellen=0; uartReceivedata[stellen] != '\0'; stellen++);
 9281              	 .loc 3 1811 0
 9282 0010 FB1D     	 add r3,r7,#7
 9283 0012 0022     	 mov r2,#0
 9284 0014 1A70     	 strb r2,[r3]
 9285 0016 04E0     	 b .L443
 9286              	.L444:
 9287              	 .loc 3 1811 0 is_stmt 0 discriminator 3
 9288 0018 FB1D     	 add r3,r7,#7
 9289 001a 1A78     	 ldrb r2,[r3]
 9290 001c FB1D     	 add r3,r7,#7
 9291 001e 0132     	 add r2,r2,#1
 9292 0020 1A70     	 strb r2,[r3]
 9293              	.L443:
 9294              	 .loc 3 1811 0 discriminator 1
 9295 0022 FB1D     	 add r3,r7,#7
 9296 0024 1B78     	 ldrb r3,[r3]
 9297 0026 164A     	 ldr r2,.L448
 9298 0028 D35C     	 ldrb r3,[r2,r3]
 9299 002a 002B     	 cmp r3,#0
 9300 002c F4D1     	 bne .L444
 9301              	.LBB12:
1812:../XMC1100-LibHaas.c **** 
1813:../XMC1100-LibHaas.c **** 	for(uint8_t i=0;stellen >0; stellen--,i++) {
 9302              	 .loc 3 1813 0 is_stmt 1
 9303 002e 7B1D     	 add r3,r7,#5
 9304 0030 0022     	 mov r2,#0
 9305 0032 1A70     	 strb r2,[r3]
 9306 0034 19E0     	 b .L445
 9307              	.L446:
1814:../XMC1100-LibHaas.c **** 			zahl=uartReceivedata[i] - 0x30 + zahl * 10;
 9308              	 .loc 3 1814 0 discriminator 3
 9309 0036 7B1D     	 add r3,r7,#5
 9310 0038 1B78     	 ldrb r3,[r3]
 9311 003a 114A     	 ldr r2,.L448
 9312 003c D25C     	 ldrb r2,[r2,r3]
 9313 003e BB1D     	 add r3,r7,#6
 9314 0040 1B78     	 ldrb r3,[r3]
 9315 0042 191C     	 add r1,r3,#0
 9316 0044 8900     	 lsl r1,r1,#2
 9317 0046 CB18     	 add r3,r1,r3
 9318 0048 DB18     	 add r3,r3,r3
 9319 004a DBB2     	 uxtb r3,r3
 9320 004c D318     	 add r3,r2,r3
 9321 004e DAB2     	 uxtb r2,r3
 9322 0050 BB1D     	 add r3,r7,#6
 9323 0052 303A     	 sub r2,r2,#48
 9324 0054 1A70     	 strb r2,[r3]
1813:../XMC1100-LibHaas.c **** 			zahl=uartReceivedata[i] - 0x30 + zahl * 10;
 9325              	 .loc 3 1813 0 discriminator 3
 9326 0056 FB1D     	 add r3,r7,#7
 9327 0058 1A78     	 ldrb r2,[r3]
 9328 005a FB1D     	 add r3,r7,#7
 9329 005c 013A     	 sub r2,r2,#1
 9330 005e 1A70     	 strb r2,[r3]
 9331 0060 7B1D     	 add r3,r7,#5
 9332 0062 1A78     	 ldrb r2,[r3]
 9333 0064 7B1D     	 add r3,r7,#5
 9334 0066 0132     	 add r2,r2,#1
 9335 0068 1A70     	 strb r2,[r3]
 9336              	.L445:
1813:../XMC1100-LibHaas.c **** 			zahl=uartReceivedata[i] - 0x30 + zahl * 10;
 9337              	 .loc 3 1813 0 is_stmt 0 discriminator 1
 9338 006a FB1D     	 add r3,r7,#7
 9339 006c 1B78     	 ldrb r3,[r3]
 9340 006e 002B     	 cmp r3,#0
 9341 0070 E1D1     	 bne .L446
 9342              	.LBE12:
1815:../XMC1100-LibHaas.c **** 	}
1816:../XMC1100-LibHaas.c **** 	return zahl;
 9343              	 .loc 3 1816 0 is_stmt 1
 9344 0072 BB1D     	 add r3,r7,#6
 9345 0074 1B78     	 ldrb r3,[r3]
1817:../XMC1100-LibHaas.c **** }
 9346              	 .loc 3 1817 0
 9347 0076 181C     	 mov r0,r3
 9348 0078 BD46     	 mov sp,r7
 9349 007a 02B0     	 add sp,sp,#8
 9350              	 
 9351 007c 80BD     	 pop {r7,pc}
 9352              	.L449:
 9353 007e C046     	 .align 2
 9354              	.L448:
 9355 0080 00000000 	 .word uartReceivedata
 9356              	 .cfi_endproc
 9357              	.LFE117:
 9359              	 .section .text.uart_print_number,"ax",%progbits
 9360              	 .align 2
 9361              	 .global uart_print_number
 9362              	 .code 16
 9363              	 .thumb_func
 9365              	uart_print_number:
 9366              	.LFB118:
1818:../XMC1100-LibHaas.c **** 
1819:../XMC1100-LibHaas.c **** void uart_print_number(uint8_t zahl)
1820:../XMC1100-LibHaas.c **** {
 9367              	 .loc 3 1820 0
 9368              	 .cfi_startproc
 9369 0000 90B5     	 push {r4,r7,lr}
 9370              	.LCFI224:
 9371              	 .cfi_def_cfa_offset 12
 9372              	 .cfi_offset 4,-12
 9373              	 .cfi_offset 7,-8
 9374              	 .cfi_offset 14,-4
 9375 0002 89B0     	 sub sp,sp,#36
 9376              	.LCFI225:
 9377              	 .cfi_def_cfa_offset 48
 9378 0004 00AF     	 add r7,sp,#0
 9379              	.LCFI226:
 9380              	 .cfi_def_cfa_register 7
 9381 0006 021C     	 mov r2,r0
 9382 0008 FB1D     	 add r3,r7,#7
 9383 000a 1A70     	 strb r2,[r3]
1821:../XMC1100-LibHaas.c **** 	uint8_t rest, stellen=1;
 9384              	 .loc 3 1821 0
 9385 000c 1E23     	 mov r3,#30
 9386 000e FB18     	 add r3,r7,r3
 9387 0010 0122     	 mov r2,#1
 9388 0012 1A70     	 strb r2,[r3]
1822:../XMC1100-LibHaas.c **** 	char string[20];
1823:../XMC1100-LibHaas.c **** 
1824:../XMC1100-LibHaas.c **** 	for (rest=zahl; (rest=rest/10) > 0; stellen++);
 9389              	 .loc 3 1824 0
 9390 0014 1F23     	 mov r3,#31
 9391 0016 FB18     	 add r3,r7,r3
 9392 0018 FA1D     	 add r2,r7,#7
 9393 001a 1278     	 ldrb r2,[r2]
 9394 001c 1A70     	 strb r2,[r3]
 9395 001e 06E0     	 b .L451
 9396              	.L452:
 9397              	 .loc 3 1824 0 is_stmt 0 discriminator 3
 9398 0020 1E23     	 mov r3,#30
 9399 0022 FB18     	 add r3,r7,r3
 9400 0024 1A78     	 ldrb r2,[r3]
 9401 0026 1E23     	 mov r3,#30
 9402 0028 FB18     	 add r3,r7,r3
 9403 002a 0132     	 add r2,r2,#1
 9404 002c 1A70     	 strb r2,[r3]
 9405              	.L451:
 9406              	 .loc 3 1824 0 discriminator 1
 9407 002e 1F23     	 mov r3,#31
 9408 0030 FC18     	 add r4,r7,r3
 9409 0032 1F23     	 mov r3,#31
 9410 0034 FB18     	 add r3,r7,r3
 9411 0036 1B78     	 ldrb r3,[r3]
 9412 0038 181C     	 mov r0,r3
 9413 003a 0A21     	 mov r1,#10
 9414 003c FFF7FEFF 	 bl __aeabi_uidiv
 9415 0040 031C     	 mov r3,r0
 9416 0042 2370     	 strb r3,[r4]
 9417 0044 1F23     	 mov r3,#31
 9418 0046 FB18     	 add r3,r7,r3
 9419 0048 1B78     	 ldrb r3,[r3]
 9420 004a 002B     	 cmp r3,#0
 9421 004c E8D1     	 bne .L452
1825:../XMC1100-LibHaas.c **** 
1826:../XMC1100-LibHaas.c **** 	string[stellen] = '\0';
 9422              	 .loc 3 1826 0 is_stmt 1
 9423 004e 1E23     	 mov r3,#30
 9424 0050 FB18     	 add r3,r7,r3
 9425 0052 1B78     	 ldrb r3,[r3]
 9426 0054 0822     	 mov r2,#8
 9427 0056 BA18     	 add r2,r7,r2
 9428 0058 0021     	 mov r1,#0
 9429 005a D154     	 strb r1,[r2,r3]
1827:../XMC1100-LibHaas.c **** 
1828:../XMC1100-LibHaas.c **** 	for (; stellen > 0; stellen--) {
 9430              	 .loc 3 1828 0
 9431 005c 25E0     	 b .L453
 9432              	.L454:
1829:../XMC1100-LibHaas.c **** 		rest=zahl % 10;
 9433              	 .loc 3 1829 0 discriminator 2
 9434 005e 1F23     	 mov r3,#31
 9435 0060 FC18     	 add r4,r7,r3
 9436 0062 FB1D     	 add r3,r7,#7
 9437 0064 1B78     	 ldrb r3,[r3]
 9438 0066 181C     	 mov r0,r3
 9439 0068 0A21     	 mov r1,#10
 9440 006a FFF7FEFF 	 bl __aeabi_uidivmod
 9441 006e 0B1C     	 mov r3,r1
 9442 0070 2370     	 strb r3,[r4]
1830:../XMC1100-LibHaas.c **** 		zahl=zahl / 10;
 9443              	 .loc 3 1830 0 discriminator 2
 9444 0072 FC1D     	 add r4,r7,#7
 9445 0074 FB1D     	 add r3,r7,#7
 9446 0076 1B78     	 ldrb r3,[r3]
 9447 0078 181C     	 mov r0,r3
 9448 007a 0A21     	 mov r1,#10
 9449 007c FFF7FEFF 	 bl __aeabi_uidiv
 9450 0080 031C     	 mov r3,r0
 9451 0082 2370     	 strb r3,[r4]
1831:../XMC1100-LibHaas.c **** 		string[stellen-1]=rest + 0x30;
 9452              	 .loc 3 1831 0 discriminator 2
 9453 0084 1E23     	 mov r3,#30
 9454 0086 FB18     	 add r3,r7,r3
 9455 0088 1B78     	 ldrb r3,[r3]
 9456 008a 013B     	 sub r3,r3,#1
 9457 008c 1F22     	 mov r2,#31
 9458 008e BA18     	 add r2,r7,r2
 9459 0090 1278     	 ldrb r2,[r2]
 9460 0092 3032     	 add r2,r2,#48
 9461 0094 D1B2     	 uxtb r1,r2
 9462 0096 0822     	 mov r2,#8
 9463 0098 BA18     	 add r2,r7,r2
 9464 009a D154     	 strb r1,[r2,r3]
1828:../XMC1100-LibHaas.c **** 		rest=zahl % 10;
 9465              	 .loc 3 1828 0 discriminator 2
 9466 009c 1E23     	 mov r3,#30
 9467 009e FB18     	 add r3,r7,r3
 9468 00a0 1A78     	 ldrb r2,[r3]
 9469 00a2 1E23     	 mov r3,#30
 9470 00a4 FB18     	 add r3,r7,r3
 9471 00a6 013A     	 sub r2,r2,#1
 9472 00a8 1A70     	 strb r2,[r3]
 9473              	.L453:
1828:../XMC1100-LibHaas.c **** 		rest=zahl % 10;
 9474              	 .loc 3 1828 0 is_stmt 0 discriminator 1
 9475 00aa 1E23     	 mov r3,#30
 9476 00ac FB18     	 add r3,r7,r3
 9477 00ae 1B78     	 ldrb r3,[r3]
 9478 00b0 002B     	 cmp r3,#0
 9479 00b2 D4D1     	 bne .L454
1832:../XMC1100-LibHaas.c **** 	}
1833:../XMC1100-LibHaas.c **** 	uart_print(string);
 9480              	 .loc 3 1833 0 is_stmt 1
 9481 00b4 0823     	 mov r3,#8
 9482 00b6 FB18     	 add r3,r7,r3
 9483 00b8 181C     	 mov r0,r3
 9484 00ba FFF7FEFF 	 bl uart_print
1834:../XMC1100-LibHaas.c **** }
 9485              	 .loc 3 1834 0
 9486 00be BD46     	 mov sp,r7
 9487 00c0 09B0     	 add sp,sp,#36
 9488              	 
 9489 00c2 90BD     	 pop {r4,r7,pc}
 9490              	 .cfi_endproc
 9491              	.LFE118:
 9493              	 .section .text.warte_auf_eingabe,"ax",%progbits
 9494              	 .align 2
 9495              	 .global warte_auf_eingabe
 9496              	 .code 16
 9497              	 .thumb_func
 9499              	warte_auf_eingabe:
 9500              	.LFB119:
1835:../XMC1100-LibHaas.c **** 
1836:../XMC1100-LibHaas.c **** uint8_t warte_auf_eingabe(){
 9501              	 .loc 3 1836 0
 9502              	 .cfi_startproc
 9503 0000 80B5     	 push {r7,lr}
 9504              	.LCFI227:
 9505              	 .cfi_def_cfa_offset 8
 9506              	 .cfi_offset 7,-8
 9507              	 .cfi_offset 14,-4
 9508 0002 82B0     	 sub sp,sp,#8
 9509              	.LCFI228:
 9510              	 .cfi_def_cfa_offset 16
 9511 0004 00AF     	 add r7,sp,#0
 9512              	.LCFI229:
 9513              	 .cfi_def_cfa_register 7
1837:../XMC1100-LibHaas.c ****   uint8_t eingabeErfolgt=0;
 9514              	 .loc 3 1837 0
 9515 0006 FB1D     	 add r3,r7,#7
 9516 0008 0022     	 mov r2,#0
 9517 000a 1A70     	 strb r2,[r3]
1838:../XMC1100-LibHaas.c **** 
1839:../XMC1100-LibHaas.c ****   while (eingabeErfolgt==0) {
 9518              	 .loc 3 1839 0
 9519 000c 17E0     	 b .L456
 9520              	.L459:
1840:../XMC1100-LibHaas.c **** 	if (uartEnterReceive==1) {
 9521              	 .loc 3 1840 0
 9522 000e 104B     	 ldr r3,.L460
 9523 0010 1B78     	 ldrb r3,[r3]
 9524 0012 012B     	 cmp r3,#1
 9525 0014 07D1     	 bne .L457
1841:../XMC1100-LibHaas.c **** 	  eingabeErfolgt=1;
 9526              	 .loc 3 1841 0
 9527 0016 FB1D     	 add r3,r7,#7
 9528 0018 0122     	 mov r2,#1
 9529 001a 1A70     	 strb r2,[r3]
1842:../XMC1100-LibHaas.c **** 	  uartEnterReceive=0;
 9530              	 .loc 3 1842 0
 9531 001c 0C4B     	 ldr r3,.L460
 9532 001e 0022     	 mov r2,#0
 9533 0020 1A70     	 strb r2,[r3]
1843:../XMC1100-LibHaas.c **** 	  return UART;
 9534              	 .loc 3 1843 0
 9535 0022 0123     	 mov r3,#1
 9536 0024 10E0     	 b .L458
 9537              	.L457:
1844:../XMC1100-LibHaas.c **** 	}
1845:../XMC1100-LibHaas.c **** 	if (rs232EnterReceive==1) {
 9538              	 .loc 3 1845 0
 9539 0026 0B4B     	 ldr r3,.L460+4
 9540 0028 1B78     	 ldrb r3,[r3]
 9541 002a 012B     	 cmp r3,#1
 9542 002c 07D1     	 bne .L456
1846:../XMC1100-LibHaas.c **** 	  eingabeErfolgt=1;
 9543              	 .loc 3 1846 0
 9544 002e FB1D     	 add r3,r7,#7
 9545 0030 0122     	 mov r2,#1
 9546 0032 1A70     	 strb r2,[r3]
1847:../XMC1100-LibHaas.c **** 	  rs232EnterReceive=0;
 9547              	 .loc 3 1847 0
 9548 0034 074B     	 ldr r3,.L460+4
 9549 0036 0022     	 mov r2,#0
 9550 0038 1A70     	 strb r2,[r3]
1848:../XMC1100-LibHaas.c **** 	  return RS232;
 9551              	 .loc 3 1848 0
 9552 003a 0023     	 mov r3,#0
 9553 003c 04E0     	 b .L458
 9554              	.L456:
1839:../XMC1100-LibHaas.c **** 	if (uartEnterReceive==1) {
 9555              	 .loc 3 1839 0
 9556 003e FB1D     	 add r3,r7,#7
 9557 0040 1B78     	 ldrb r3,[r3]
 9558 0042 002B     	 cmp r3,#0
 9559 0044 E3D0     	 beq .L459
1849:../XMC1100-LibHaas.c **** 	}
1850:../XMC1100-LibHaas.c ****   }
1851:../XMC1100-LibHaas.c ****   return RS232;
 9560              	 .loc 3 1851 0
 9561 0046 0023     	 mov r3,#0
 9562              	.L458:
1852:../XMC1100-LibHaas.c **** }
 9563              	 .loc 3 1852 0
 9564 0048 181C     	 mov r0,r3
 9565 004a BD46     	 mov sp,r7
 9566 004c 02B0     	 add sp,sp,#8
 9567              	 
 9568 004e 80BD     	 pop {r7,pc}
 9569              	.L461:
 9570              	 .align 2
 9571              	.L460:
 9572 0050 00000000 	 .word uartEnterReceive
 9573 0054 00000000 	 .word rs232EnterReceive
 9574              	 .cfi_endproc
 9575              	.LFE119:
 9577              	 .section .text.send_byte,"ax",%progbits
 9578              	 .align 2
 9579              	 .global send_byte
 9580              	 .code 16
 9581              	 .thumb_func
 9583              	send_byte:
 9584              	.LFB120:
1853:../XMC1100-LibHaas.c **** // ***********************************************************************
1854:../XMC1100-LibHaas.c **** // LCD-Funktionen
1855:../XMC1100-LibHaas.c **** 
1856:../XMC1100-LibHaas.c **** // Deklaration lokale Funktionen
1857:../XMC1100-LibHaas.c **** void send_byte(unsigned char,unsigned char);
1858:../XMC1100-LibHaas.c **** uint8_t lcd_lookup(uint8_t ascii);
1859:../XMC1100-LibHaas.c **** void lcd_befehl(uint8_t befehl);
1860:../XMC1100-LibHaas.c **** void lcd_daten(uint8_t daten);
1861:../XMC1100-LibHaas.c **** void lcd_waitwhilebusy(void);
1862:../XMC1100-LibHaas.c **** void init_wait(uint16_t n);
1863:../XMC1100-LibHaas.c **** void wait_bsy2(void);
1864:../XMC1100-LibHaas.c **** void wait_bsy1(void);
1865:../XMC1100-LibHaas.c **** 
1866:../XMC1100-LibHaas.c **** // Anschluss des Displays XMC1100  Board an:
1867:../XMC1100-LibHaas.c **** #define sclk 0 // sclk = P2.0 => Clock Anschluss LCD
1868:../XMC1100-LibHaas.c **** #define sid 1  // sid  = P2.1 => seriell Input LCD
1869:../XMC1100-LibHaas.c **** #define sod 0  // sod  =
1870:../XMC1100-LibHaas.c **** 
1871:../XMC1100-LibHaas.c **** // Wartezeit-Konstante für Initialisierung und Busy-Abfrage berechnen
1872:../XMC1100-LibHaas.c **** #define LCD_WAIT 3 // ca. 7 uSek Takt
1873:../XMC1100-LibHaas.c **** 
1874:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
1875:../XMC1100-LibHaas.c **** // Sende ein Byte zum Display, senddata ist Bytewert
1876:../XMC1100-LibHaas.c **** // rs => Command = 0 und Data = 1
1877:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
1878:../XMC1100-LibHaas.c **** void send_byte(unsigned char senddata, unsigned char rs)
1879:../XMC1100-LibHaas.c **** {
 9585              	 .loc 3 1879 0
 9586              	 .cfi_startproc
 9587 0000 80B5     	 push {r7,lr}
 9588              	.LCFI230:
 9589              	 .cfi_def_cfa_offset 8
 9590              	 .cfi_offset 7,-8
 9591              	 .cfi_offset 14,-4
 9592 0002 86B0     	 sub sp,sp,#24
 9593              	.LCFI231:
 9594              	 .cfi_def_cfa_offset 32
 9595 0004 00AF     	 add r7,sp,#0
 9596              	.LCFI232:
 9597              	 .cfi_def_cfa_register 7
 9598 0006 021C     	 mov r2,r0
 9599 0008 FB1D     	 add r3,r7,#7
 9600 000a 1A70     	 strb r2,[r3]
 9601 000c BB1D     	 add r3,r7,#6
 9602 000e 0A1C     	 add r2,r1,#0
 9603 0010 1A70     	 strb r2,[r3]
1880:../XMC1100-LibHaas.c **** 	unsigned char i;
1881:../XMC1100-LibHaas.c **** 	unsigned long sendwert, zw;
1882:../XMC1100-LibHaas.c **** 	zw = (unsigned long)senddata;   // Typconvertierung
 9604              	 .loc 3 1882 0
 9605 0012 FB1D     	 add r3,r7,#7
 9606 0014 1B78     	 ldrb r3,[r3]
 9607 0016 FB60     	 str r3,[r7,#12]
1883:../XMC1100-LibHaas.c **** 	sendwert = 0x001f + ((zw & 0xf0)<<12) + ((zw&0x0f)<<8);
 9608              	 .loc 3 1883 0
 9609 0018 FB68     	 ldr r3,[r7,#12]
 9610 001a F022     	 mov r2,#240
 9611 001c 1340     	 and r3,r2
 9612 001e 1A03     	 lsl r2,r3,#12
 9613 0020 FB68     	 ldr r3,[r7,#12]
 9614 0022 0F21     	 mov r1,#15
 9615 0024 0B40     	 and r3,r1
 9616 0026 1B02     	 lsl r3,r3,#8
 9617 0028 D318     	 add r3,r2,r3
 9618 002a 1F33     	 add r3,r3,#31
 9619 002c 3B61     	 str r3,[r7,#16]
1884:../XMC1100-LibHaas.c **** 	if (rs == 1) sendwert = sendwert + 0x40;
 9620              	 .loc 3 1884 0
 9621 002e BB1D     	 add r3,r7,#6
 9622 0030 1B78     	 ldrb r3,[r3]
 9623 0032 012B     	 cmp r3,#1
 9624 0034 02D1     	 bne .L463
 9625              	 .loc 3 1884 0 is_stmt 0 discriminator 1
 9626 0036 3B69     	 ldr r3,[r7,#16]
 9627 0038 4033     	 add r3,r3,#64
 9628 003a 3B61     	 str r3,[r7,#16]
 9629              	.L463:
1885:../XMC1100-LibHaas.c **** 	for (i = 0; i<24;i++)	// serielle Ausgabe von 24Bit
 9630              	 .loc 3 1885 0 is_stmt 1
 9631 003c 1723     	 mov r3,#23
 9632 003e FB18     	 add r3,r7,r3
 9633 0040 0022     	 mov r2,#0
 9634 0042 1A70     	 strb r2,[r3]
 9635 0044 2AE0     	 b .L464
 9636              	.L467:
1886:../XMC1100-LibHaas.c **** 	{  	CLR_BIT (PORT2->OUT,sclk)  ; // clk = 0;
 9637              	 .loc 3 1886 0
 9638 0046 194B     	 ldr r3,.L468
 9639 0048 184A     	 ldr r2,.L468
 9640 004a 1268     	 ldr r2,[r2]
 9641 004c 0121     	 mov r1,#1
 9642 004e 8A43     	 bic r2,r1
 9643 0050 1A60     	 str r2,[r3]
1887:../XMC1100-LibHaas.c **** 		if ((sendwert & 0x00000001) == 0)  CLR_BIT(PORT2->OUT,sid);  //sid = 0;
 9644              	 .loc 3 1887 0
 9645 0052 3B69     	 ldr r3,[r7,#16]
 9646 0054 0122     	 mov r2,#1
 9647 0056 1340     	 and r3,r2
 9648 0058 06D1     	 bne .L465
 9649              	 .loc 3 1887 0 is_stmt 0 discriminator 1
 9650 005a 144B     	 ldr r3,.L468
 9651 005c 134A     	 ldr r2,.L468
 9652 005e 1268     	 ldr r2,[r2]
 9653 0060 0221     	 mov r1,#2
 9654 0062 8A43     	 bic r2,r1
 9655 0064 1A60     	 str r2,[r3]
 9656 0066 05E0     	 b .L466
 9657              	.L465:
1888:../XMC1100-LibHaas.c **** 		else SET_BIT(PORT2->OUT,sid);
 9658              	 .loc 3 1888 0 is_stmt 1
 9659 0068 104B     	 ldr r3,.L468
 9660 006a 104A     	 ldr r2,.L468
 9661 006c 1268     	 ldr r2,[r2]
 9662 006e 0221     	 mov r1,#2
 9663 0070 0A43     	 orr r2,r1
 9664 0072 1A60     	 str r2,[r3]
 9665              	.L466:
1889:../XMC1100-LibHaas.c **** 		wait_bsy1();
 9666              	 .loc 3 1889 0 discriminator 2
 9667 0074 FFF7FEFF 	 bl wait_bsy1
1890:../XMC1100-LibHaas.c **** 		SET_BIT ( PORT2->OUT,sclk);	//sclk = 1;
 9668              	 .loc 3 1890 0 discriminator 2
 9669 0078 0C4B     	 ldr r3,.L468
 9670 007a 0C4A     	 ldr r2,.L468
 9671 007c 1268     	 ldr r2,[r2]
 9672 007e 0121     	 mov r1,#1
 9673 0080 0A43     	 orr r2,r1
 9674 0082 1A60     	 str r2,[r3]
1891:../XMC1100-LibHaas.c **** 		wait_bsy1();
 9675              	 .loc 3 1891 0 discriminator 2
 9676 0084 FFF7FEFF 	 bl wait_bsy1
1892:../XMC1100-LibHaas.c **** 		sendwert = sendwert >> 1;
 9677              	 .loc 3 1892 0 discriminator 2
 9678 0088 3B69     	 ldr r3,[r7,#16]
 9679 008a 5B08     	 lsr r3,r3,#1
 9680 008c 3B61     	 str r3,[r7,#16]
1885:../XMC1100-LibHaas.c **** 	{  	CLR_BIT (PORT2->OUT,sclk)  ; // clk = 0;
 9681              	 .loc 3 1885 0 discriminator 2
 9682 008e 1723     	 mov r3,#23
 9683 0090 FB18     	 add r3,r7,r3
 9684 0092 1A78     	 ldrb r2,[r3]
 9685 0094 1723     	 mov r3,#23
 9686 0096 FB18     	 add r3,r7,r3
 9687 0098 0132     	 add r2,r2,#1
 9688 009a 1A70     	 strb r2,[r3]
 9689              	.L464:
1885:../XMC1100-LibHaas.c **** 	{  	CLR_BIT (PORT2->OUT,sclk)  ; // clk = 0;
 9690              	 .loc 3 1885 0 is_stmt 0 discriminator 1
 9691 009c 1723     	 mov r3,#23
 9692 009e FB18     	 add r3,r7,r3
 9693 00a0 1B78     	 ldrb r3,[r3]
 9694 00a2 172B     	 cmp r3,#23
 9695 00a4 CFD9     	 bls .L467
1893:../XMC1100-LibHaas.c **** 	}
1894:../XMC1100-LibHaas.c **** }
 9696              	 .loc 3 1894 0 is_stmt 1
 9697 00a6 BD46     	 mov sp,r7
 9698 00a8 06B0     	 add sp,sp,#24
 9699              	 
 9700 00aa 80BD     	 pop {r7,pc}
 9701              	.L469:
 9702              	 .align 2
 9703              	.L468:
 9704 00ac 00020440 	 .word 1074004480
 9705              	 .cfi_endproc
 9706              	.LFE120:
 9708              	 .section .text.wait_bsy2,"ax",%progbits
 9709              	 .align 2
 9710              	 .global wait_bsy2
 9711              	 .code 16
 9712              	 .thumb_func
 9714              	wait_bsy2:
 9715              	.LFB121:
1895:../XMC1100-LibHaas.c **** void wait_bsy2(void)	  // ca. 1.6 ms warten
1896:../XMC1100-LibHaas.c **** {
 9716              	 .loc 3 1896 0
 9717              	 .cfi_startproc
 9718 0000 80B5     	 push {r7,lr}
 9719              	.LCFI233:
 9720              	 .cfi_def_cfa_offset 8
 9721              	 .cfi_offset 7,-8
 9722              	 .cfi_offset 14,-4
 9723 0002 82B0     	 sub sp,sp,#8
 9724              	.LCFI234:
 9725              	 .cfi_def_cfa_offset 16
 9726 0004 00AF     	 add r7,sp,#0
 9727              	.LCFI235:
 9728              	 .cfi_def_cfa_register 7
1897:../XMC1100-LibHaas.c **** 	unsigned int zaehler ;
1898:../XMC1100-LibHaas.c **** 	for (zaehler = 0; zaehler < 0xaff; zaehler++);
 9729              	 .loc 3 1898 0
 9730 0006 0023     	 mov r3,#0
 9731 0008 7B60     	 str r3,[r7,#4]
 9732 000a 02E0     	 b .L471
 9733              	.L472:
 9734              	 .loc 3 1898 0 is_stmt 0 discriminator 3
 9735 000c 7B68     	 ldr r3,[r7,#4]
 9736 000e 0133     	 add r3,r3,#1
 9737 0010 7B60     	 str r3,[r7,#4]
 9738              	.L471:
 9739              	 .loc 3 1898 0 discriminator 1
 9740 0012 7B68     	 ldr r3,[r7,#4]
 9741 0014 024A     	 ldr r2,.L473
 9742 0016 9342     	 cmp r3,r2
 9743 0018 F8D9     	 bls .L472
1899:../XMC1100-LibHaas.c **** }
 9744              	 .loc 3 1899 0 is_stmt 1
 9745 001a BD46     	 mov sp,r7
 9746 001c 02B0     	 add sp,sp,#8
 9747              	 
 9748 001e 80BD     	 pop {r7,pc}
 9749              	.L474:
 9750              	 .align 2
 9751              	.L473:
 9752 0020 FE0A0000 	 .word 2814
 9753              	 .cfi_endproc
 9754              	.LFE121:
 9756              	 .section .text.wait_bsy1,"ax",%progbits
 9757              	 .align 2
 9758              	 .global wait_bsy1
 9759              	 .code 16
 9760              	 .thumb_func
 9762              	wait_bsy1:
 9763              	.LFB122:
1900:../XMC1100-LibHaas.c **** void wait_bsy1(void)	// ca. 50 us warten
1901:../XMC1100-LibHaas.c **** {
 9764              	 .loc 3 1901 0
 9765              	 .cfi_startproc
 9766 0000 80B5     	 push {r7,lr}
 9767              	.LCFI236:
 9768              	 .cfi_def_cfa_offset 8
 9769              	 .cfi_offset 7,-8
 9770              	 .cfi_offset 14,-4
 9771 0002 82B0     	 sub sp,sp,#8
 9772              	.LCFI237:
 9773              	 .cfi_def_cfa_offset 16
 9774 0004 00AF     	 add r7,sp,#0
 9775              	.LCFI238:
 9776              	 .cfi_def_cfa_register 7
1902:../XMC1100-LibHaas.c **** 	unsigned int zaehler ;
1903:../XMC1100-LibHaas.c **** 	for (zaehler = 0; zaehler < LCD_WAIT; zaehler++);
 9777              	 .loc 3 1903 0
 9778 0006 0023     	 mov r3,#0
 9779 0008 7B60     	 str r3,[r7,#4]
 9780 000a 02E0     	 b .L476
 9781              	.L477:
 9782              	 .loc 3 1903 0 is_stmt 0 discriminator 3
 9783 000c 7B68     	 ldr r3,[r7,#4]
 9784 000e 0133     	 add r3,r3,#1
 9785 0010 7B60     	 str r3,[r7,#4]
 9786              	.L476:
 9787              	 .loc 3 1903 0 discriminator 1
 9788 0012 7B68     	 ldr r3,[r7,#4]
 9789 0014 022B     	 cmp r3,#2
 9790 0016 F9D9     	 bls .L477
1904:../XMC1100-LibHaas.c **** }
 9791              	 .loc 3 1904 0 is_stmt 1
 9792 0018 BD46     	 mov sp,r7
 9793 001a 02B0     	 add sp,sp,#8
 9794              	 
 9795 001c 80BD     	 pop {r7,pc}
 9796              	 .cfi_endproc
 9797              	.LFE122:
 9799 001e C046     	 .section .text.lcd_befehl,"ax",%progbits
 9800              	 .align 2
 9801              	 .global lcd_befehl
 9802              	 .code 16
 9803              	 .thumb_func
 9805              	lcd_befehl:
 9806              	.LFB123:
1905:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
1906:../XMC1100-LibHaas.c **** // 	Gibt das Byte 'befehl' als Befehl ans LCD-Display
1907:../XMC1100-LibHaas.c **** //  Entweder Busy-Flag des LCD abfragen oder Zeitverzögerung verwenden
1908:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
1909:../XMC1100-LibHaas.c **** void lcd_befehl (uint8_t befehl)
1910:../XMC1100-LibHaas.c **** {
 9807              	 .loc 3 1910 0
 9808              	 .cfi_startproc
 9809 0000 80B5     	 push {r7,lr}
 9810              	.LCFI239:
 9811              	 .cfi_def_cfa_offset 8
 9812              	 .cfi_offset 7,-8
 9813              	 .cfi_offset 14,-4
 9814 0002 82B0     	 sub sp,sp,#8
 9815              	.LCFI240:
 9816              	 .cfi_def_cfa_offset 16
 9817 0004 00AF     	 add r7,sp,#0
 9818              	.LCFI241:
 9819              	 .cfi_def_cfa_register 7
 9820 0006 021C     	 mov r2,r0
 9821 0008 FB1D     	 add r3,r7,#7
 9822 000a 1A70     	 strb r2,[r3]
1911:../XMC1100-LibHaas.c ****   send_byte(befehl,0);
 9823              	 .loc 3 1911 0
 9824 000c FB1D     	 add r3,r7,#7
 9825 000e 1B78     	 ldrb r3,[r3]
 9826 0010 181C     	 mov r0,r3
 9827 0012 0021     	 mov r1,#0
 9828 0014 FFF7FEFF 	 bl send_byte
1912:../XMC1100-LibHaas.c ****   wait_bsy1();
 9829              	 .loc 3 1912 0
 9830 0018 FFF7FEFF 	 bl wait_bsy1
1913:../XMC1100-LibHaas.c **** }
 9831              	 .loc 3 1913 0
 9832 001c BD46     	 mov sp,r7
 9833 001e 02B0     	 add sp,sp,#8
 9834              	 
 9835 0020 80BD     	 pop {r7,pc}
 9836              	 .cfi_endproc
 9837              	.LFE123:
 9839 0022 C046     	 .section .text.lcd_daten,"ax",%progbits
 9840              	 .align 2
 9841              	 .global lcd_daten
 9842              	 .code 16
 9843              	 .thumb_func
 9845              	lcd_daten:
 9846              	.LFB124:
1914:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
1915:../XMC1100-LibHaas.c **** // 	Gibt das Byte 'daten' ans LCD-Display im SPI Mode aus.
1916:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
1917:../XMC1100-LibHaas.c **** void lcd_daten(unsigned char daten)
1918:../XMC1100-LibHaas.c **** {
 9847              	 .loc 3 1918 0
 9848              	 .cfi_startproc
 9849 0000 80B5     	 push {r7,lr}
 9850              	.LCFI242:
 9851              	 .cfi_def_cfa_offset 8
 9852              	 .cfi_offset 7,-8
 9853              	 .cfi_offset 14,-4
 9854 0002 82B0     	 sub sp,sp,#8
 9855              	.LCFI243:
 9856              	 .cfi_def_cfa_offset 16
 9857 0004 00AF     	 add r7,sp,#0
 9858              	.LCFI244:
 9859              	 .cfi_def_cfa_register 7
 9860 0006 021C     	 mov r2,r0
 9861 0008 FB1D     	 add r3,r7,#7
 9862 000a 1A70     	 strb r2,[r3]
1919:../XMC1100-LibHaas.c ****   send_byte(daten,1);
 9863              	 .loc 3 1919 0
 9864 000c FB1D     	 add r3,r7,#7
 9865 000e 1B78     	 ldrb r3,[r3]
 9866 0010 181C     	 mov r0,r3
 9867 0012 0121     	 mov r1,#1
 9868 0014 FFF7FEFF 	 bl send_byte
1920:../XMC1100-LibHaas.c **** 	wait_bsy1();
 9869              	 .loc 3 1920 0
 9870 0018 FFF7FEFF 	 bl wait_bsy1
1921:../XMC1100-LibHaas.c **** }
 9871              	 .loc 3 1921 0
 9872 001c BD46     	 mov sp,r7
 9873 001e 02B0     	 add sp,sp,#8
 9874              	 
 9875 0020 80BD     	 pop {r7,pc}
 9876              	 .cfi_endproc
 9877              	.LFE124:
 9879 0022 C046     	 .section .text.lcd_init,"ax",%progbits
 9880              	 .align 2
 9881              	 .global lcd_init
 9882              	 .code 16
 9883              	 .thumb_func
 9885              	lcd_init:
 9886              	.LFB125:
1922:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
1923:../XMC1100-LibHaas.c **** // Initialisierung des LCD- Displays für den 4-Bit-Modus
1924:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
1925:../XMC1100-LibHaas.c **** void lcd_init (void)
1926:../XMC1100-LibHaas.c **** {	delay_ms(500);				// warten bis LCD-Controller bereit
 9887              	 .loc 3 1926 0
 9888              	 .cfi_startproc
 9889 0000 80B5     	 push {r7,lr}
 9890              	.LCFI245:
 9891              	 .cfi_def_cfa_offset 8
 9892              	 .cfi_offset 7,-8
 9893              	 .cfi_offset 14,-4
 9894 0002 00AF     	 add r7,sp,#0
 9895              	.LCFI246:
 9896              	 .cfi_def_cfa_register 7
 9897              	 .loc 3 1926 0
 9898 0004 FA23     	 mov r3,#250
 9899 0006 5B00     	 lsl r3,r3,#1
 9900 0008 181C     	 mov r0,r3
 9901 000a FFF7FEFF 	 bl delay_ms
1927:../XMC1100-LibHaas.c **** 	PORT2->PDISC &=0xfffffffc;	// P2.0 / P2.1 dig. Fkt
 9902              	 .loc 3 1927 0
 9903 000e 1E4B     	 ldr r3,.L481
 9904 0010 1D4A     	 ldr r2,.L481
 9905 0012 126E     	 ldr r2,[r2,#96]
 9906 0014 0321     	 mov r1,#3
 9907 0016 8A43     	 bic r2,r1
 9908 0018 1A66     	 str r2,[r3,#96]
1928:../XMC1100-LibHaas.c **** 	PORT2->IOCR0 |= 0x8080;	// P2.0 / P2.1 = OUT
 9909              	 .loc 3 1928 0
 9910 001a 1B4B     	 ldr r3,.L481
 9911 001c 1A4A     	 ldr r2,.L481
 9912 001e 1269     	 ldr r2,[r2,#16]
 9913 0020 1A49     	 ldr r1,.L481+4
 9914 0022 0A43     	 orr r2,r1
 9915 0024 1A61     	 str r2,[r3,#16]
1929:../XMC1100-LibHaas.c **** 	PORT2->IOCR0 &= 0xffff8080;
 9916              	 .loc 3 1929 0
 9917 0026 184B     	 ldr r3,.L481
 9918 0028 174A     	 ldr r2,.L481
 9919 002a 1269     	 ldr r2,[r2,#16]
 9920 002c 1849     	 ldr r1,.L481+8
 9921 002e 0A40     	 and r2,r1
 9922 0030 1A61     	 str r2,[r3,#16]
1930:../XMC1100-LibHaas.c **** 
1931:../XMC1100-LibHaas.c **** 	wait_bsy2();
 9923              	 .loc 3 1931 0
 9924 0032 FFF7FEFF 	 bl wait_bsy2
1932:../XMC1100-LibHaas.c **** 	wait_bsy2();
 9925              	 .loc 3 1932 0
 9926 0036 FFF7FEFF 	 bl wait_bsy2
1933:../XMC1100-LibHaas.c **** 	// LCD Init
1934:../XMC1100-LibHaas.c **** 	send_byte(0x34,0); 			// 8 Bit Mode
 9927              	 .loc 3 1934 0
 9928 003a 3420     	 mov r0,#52
 9929 003c 0021     	 mov r1,#0
 9930 003e FFF7FEFF 	 bl send_byte
1935:../XMC1100-LibHaas.c **** 	wait_bsy2();
 9931              	 .loc 3 1935 0
 9932 0042 FFF7FEFF 	 bl wait_bsy2
1936:../XMC1100-LibHaas.c **** 	send_byte(0x09,0); 			// 4 Zeilen Mode
 9933              	 .loc 3 1936 0
 9934 0046 0920     	 mov r0,#9
 9935 0048 0021     	 mov r1,#0
 9936 004a FFF7FEFF 	 bl send_byte
1937:../XMC1100-LibHaas.c **** 	wait_bsy2();
 9937              	 .loc 3 1937 0
 9938 004e FFF7FEFF 	 bl wait_bsy2
1938:../XMC1100-LibHaas.c **** 	send_byte(0x30,0); 			// 8 Bit Datenläge
 9939              	 .loc 3 1938 0
 9940 0052 3020     	 mov r0,#48
 9941 0054 0021     	 mov r1,#0
 9942 0056 FFF7FEFF 	 bl send_byte
1939:../XMC1100-LibHaas.c **** 	wait_bsy2();
 9943              	 .loc 3 1939 0
 9944 005a FFF7FEFF 	 bl wait_bsy2
1940:../XMC1100-LibHaas.c **** 	send_byte(0x0f,0); 			// display ein , Cursor ein
 9945              	 .loc 3 1940 0
 9946 005e 0F20     	 mov r0,#15
 9947 0060 0021     	 mov r1,#0
 9948 0062 FFF7FEFF 	 bl send_byte
1941:../XMC1100-LibHaas.c **** 	wait_bsy2();
 9949              	 .loc 3 1941 0
 9950 0066 FFF7FEFF 	 bl wait_bsy2
1942:../XMC1100-LibHaas.c **** 	send_byte(0x01,0); 			// clear Display
 9951              	 .loc 3 1942 0
 9952 006a 0120     	 mov r0,#1
 9953 006c 0021     	 mov r1,#0
 9954 006e FFF7FEFF 	 bl send_byte
1943:../XMC1100-LibHaas.c **** 	wait_bsy2();
 9955              	 .loc 3 1943 0
 9956 0072 FFF7FEFF 	 bl wait_bsy2
1944:../XMC1100-LibHaas.c **** 	send_byte(0x07,0); 			// Cursor autoincremet
 9957              	 .loc 3 1944 0
 9958 0076 0720     	 mov r0,#7
 9959 0078 0021     	 mov r1,#0
 9960 007a FFF7FEFF 	 bl send_byte
1945:../XMC1100-LibHaas.c **** 	wait_bsy2();
 9961              	 .loc 3 1945 0
 9962 007e FFF7FEFF 	 bl wait_bsy2
1946:../XMC1100-LibHaas.c **** }
 9963              	 .loc 3 1946 0
 9964 0082 BD46     	 mov sp,r7
 9965              	 
 9966 0084 80BD     	 pop {r7,pc}
 9967              	.L482:
 9968 0086 C046     	 .align 2
 9969              	.L481:
 9970 0088 00020440 	 .word 1074004480
 9971 008c 80800000 	 .word 32896
 9972 0090 8080FFFF 	 .word -32640
 9973              	 .cfi_endproc
 9974              	.LFE125:
 9976              	 .section .text.lcd_clear,"ax",%progbits
 9977              	 .align 2
 9978              	 .global lcd_clear
 9979              	 .code 16
 9980              	 .thumb_func
 9982              	lcd_clear:
 9983              	.LFB126:
1947:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
1948:../XMC1100-LibHaas.c **** // Display löschen
1949:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
1950:../XMC1100-LibHaas.c **** void lcd_clear (void)
1951:../XMC1100-LibHaas.c **** 	{
 9984              	 .loc 3 1951 0
 9985              	 .cfi_startproc
 9986 0000 80B5     	 push {r7,lr}
 9987              	.LCFI247:
 9988              	 .cfi_def_cfa_offset 8
 9989              	 .cfi_offset 7,-8
 9990              	 .cfi_offset 14,-4
 9991 0002 00AF     	 add r7,sp,#0
 9992              	.LCFI248:
 9993              	 .cfi_def_cfa_register 7
1952:../XMC1100-LibHaas.c **** 		lcd_befehl (0x01);
 9994              	 .loc 3 1952 0
 9995 0004 0120     	 mov r0,#1
 9996 0006 FFF7FEFF 	 bl lcd_befehl
1953:../XMC1100-LibHaas.c **** 		wait_bsy2();
 9997              	 .loc 3 1953 0
 9998 000a FFF7FEFF 	 bl wait_bsy2
1954:../XMC1100-LibHaas.c **** 	  lcd_befehl( 0x0e); // Cursor on
 9999              	 .loc 3 1954 0
 10000 000e 0E20     	 mov r0,#14
 10001 0010 FFF7FEFF 	 bl lcd_befehl
1955:../XMC1100-LibHaas.c **** 		wait_bsy1();
 10002              	 .loc 3 1955 0
 10003 0014 FFF7FEFF 	 bl wait_bsy1
1956:../XMC1100-LibHaas.c **** 	}
 10004              	 .loc 3 1956 0
 10005 0018 BD46     	 mov sp,r7
 10006              	 
 10007 001a 80BD     	 pop {r7,pc}
 10008              	 .cfi_endproc
 10009              	.LFE126:
 10011              	 .section .text.lcd_setcursor,"ax",%progbits
 10012              	 .align 2
 10013              	 .global lcd_setcursor
 10014              	 .code 16
 10015              	 .thumb_func
 10017              	lcd_setcursor:
 10018              	.LFB127:
1957:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
1958:../XMC1100-LibHaas.c **** // LCD-Cursor auf eine Position setzen: Zeile 1..4, Spalte 1..16 (Displayabhängig)
1959:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
1960:../XMC1100-LibHaas.c **** void lcd_setcursor (uint8_t zeile, uint8_t spalte)
1961:../XMC1100-LibHaas.c **** {
 10019              	 .loc 3 1961 0
 10020              	 .cfi_startproc
 10021 0000 80B5     	 push {r7,lr}
 10022              	.LCFI249:
 10023              	 .cfi_def_cfa_offset 8
 10024              	 .cfi_offset 7,-8
 10025              	 .cfi_offset 14,-4
 10026 0002 84B0     	 sub sp,sp,#16
 10027              	.LCFI250:
 10028              	 .cfi_def_cfa_offset 24
 10029 0004 00AF     	 add r7,sp,#0
 10030              	.LCFI251:
 10031              	 .cfi_def_cfa_register 7
 10032 0006 021C     	 mov r2,r0
 10033 0008 FB1D     	 add r3,r7,#7
 10034 000a 1A70     	 strb r2,[r3]
 10035 000c BB1D     	 add r3,r7,#6
 10036 000e 0A1C     	 add r2,r1,#0
 10037 0010 1A70     	 strb r2,[r3]
1962:../XMC1100-LibHaas.c ****   uint8_t position;
1963:../XMC1100-LibHaas.c ****   switch(zeile)
 10038              	 .loc 3 1963 0
 10039 0012 FB1D     	 add r3,r7,#7
 10040 0014 1B78     	 ldrb r3,[r3]
 10041 0016 012B     	 cmp r3,#1
 10042 0018 0DD0     	 beq .L486
 10043 001a 02DC     	 bgt .L487
 10044 001c 002B     	 cmp r3,#0
 10045 001e 05D0     	 beq .L488
 10046 0020 18E0     	 b .L485
 10047              	.L487:
 10048 0022 022B     	 cmp r3,#2
 10049 0024 0CD0     	 beq .L489
 10050 0026 032B     	 cmp r3,#3
 10051 0028 0FD0     	 beq .L490
 10052 002a 13E0     	 b .L485
 10053              	.L488:
1964:../XMC1100-LibHaas.c ****   {
1965:../XMC1100-LibHaas.c ****     case 0:  position = ZEILE1; break;
 10054              	 .loc 3 1965 0
 10055 002c 0F23     	 mov r3,#15
 10056 002e FB18     	 add r3,r7,r3
 10057 0030 0022     	 mov r2,#0
 10058 0032 1A70     	 strb r2,[r3]
 10059 0034 13E0     	 b .L491
 10060              	.L486:
1966:../XMC1100-LibHaas.c ****     case 1:  position = ZEILE2; break;
 10061              	 .loc 3 1966 0
 10062 0036 0F23     	 mov r3,#15
 10063 0038 FB18     	 add r3,r7,r3
 10064 003a 2022     	 mov r2,#32
 10065 003c 1A70     	 strb r2,[r3]
 10066 003e 0EE0     	 b .L491
 10067              	.L489:
1967:../XMC1100-LibHaas.c ****     case 2:  position = ZEILE3; break;
 10068              	 .loc 3 1967 0
 10069 0040 0F23     	 mov r3,#15
 10070 0042 FB18     	 add r3,r7,r3
 10071 0044 4022     	 mov r2,#64
 10072 0046 1A70     	 strb r2,[r3]
 10073 0048 09E0     	 b .L491
 10074              	.L490:
1968:../XMC1100-LibHaas.c ****     case 3:  position = ZEILE4; break;
 10075              	 .loc 3 1968 0
 10076 004a 0F23     	 mov r3,#15
 10077 004c FB18     	 add r3,r7,r3
 10078 004e 6022     	 mov r2,#96
 10079 0050 1A70     	 strb r2,[r3]
 10080 0052 04E0     	 b .L491
 10081              	.L485:
1969:../XMC1100-LibHaas.c ****     default: position = ZEILE1; break;
 10082              	 .loc 3 1969 0
 10083 0054 0F23     	 mov r3,#15
 10084 0056 FB18     	 add r3,r7,r3
 10085 0058 0022     	 mov r2,#0
 10086 005a 1A70     	 strb r2,[r3]
 10087 005c C046     	 mov r8,r8
 10088              	.L491:
1970:../XMC1100-LibHaas.c ****   }
1971:../XMC1100-LibHaas.c **** 
1972:../XMC1100-LibHaas.c ****   position += (spalte);
 10089              	 .loc 3 1972 0
 10090 005e 0F23     	 mov r3,#15
 10091 0060 FB18     	 add r3,r7,r3
 10092 0062 0F22     	 mov r2,#15
 10093 0064 B918     	 add r1,r7,r2
 10094 0066 BA1D     	 add r2,r7,#6
 10095 0068 0978     	 ldrb r1,[r1]
 10096 006a 1278     	 ldrb r2,[r2]
 10097 006c 8A18     	 add r2,r1,r2
 10098 006e 1A70     	 strb r2,[r3]
1973:../XMC1100-LibHaas.c **** 
1974:../XMC1100-LibHaas.c ****   lcd_befehl ( position | 0x80 );         // 0x80 = Kennung für DD RAM address set
 10099              	 .loc 3 1974 0
 10100 0070 0F23     	 mov r3,#15
 10101 0072 FB18     	 add r3,r7,r3
 10102 0074 1B78     	 ldrb r3,[r3]
 10103 0076 8022     	 mov r2,#128
 10104 0078 5242     	 neg r2,r2
 10105 007a 1343     	 orr r3,r2
 10106 007c DBB2     	 uxtb r3,r3
 10107 007e 181C     	 mov r0,r3
 10108 0080 FFF7FEFF 	 bl lcd_befehl
1975:../XMC1100-LibHaas.c **** }
 10109              	 .loc 3 1975 0
 10110 0084 BD46     	 mov sp,r7
 10111 0086 04B0     	 add sp,sp,#16
 10112              	 
 10113 0088 80BD     	 pop {r7,pc}
 10114              	 .cfi_endproc
 10115              	.LFE127:
 10117 008a C046     	 .section .text.lcd_char,"ax",%progbits
 10118              	 .align 2
 10119              	 .global lcd_char
 10120              	 .code 16
 10121              	 .thumb_func
 10123              	lcd_char:
 10124              	.LFB128:
1976:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
1977:../XMC1100-LibHaas.c **** //  Ausgabe eines Zeichens an das LCD-Display
1978:../XMC1100-LibHaas.c **** //  Entweder Busy-Flag des LCD abfragen oder Zeitverzögerung verwenden
1979:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
1980:../XMC1100-LibHaas.c **** void lcd_char (uint8_t zeichen)
1981:../XMC1100-LibHaas.c **** {
 10125              	 .loc 3 1981 0
 10126              	 .cfi_startproc
 10127 0000 90B5     	 push {r4,r7,lr}
 10128              	.LCFI252:
 10129              	 .cfi_def_cfa_offset 12
 10130              	 .cfi_offset 4,-12
 10131              	 .cfi_offset 7,-8
 10132              	 .cfi_offset 14,-4
 10133 0002 83B0     	 sub sp,sp,#12
 10134              	.LCFI253:
 10135              	 .cfi_def_cfa_offset 24
 10136 0004 00AF     	 add r7,sp,#0
 10137              	.LCFI254:
 10138              	 .cfi_def_cfa_register 7
 10139 0006 021C     	 mov r2,r0
 10140 0008 FB1D     	 add r3,r7,#7
 10141 000a 1A70     	 strb r2,[r3]
1982:../XMC1100-LibHaas.c ****   zeichen = lcd_lookup(zeichen);    // Umlaute und Sonderzeichen ersetzen!
 10142              	 .loc 3 1982 0
 10143 000c FC1D     	 add r4,r7,#7
 10144 000e FB1D     	 add r3,r7,#7
 10145 0010 1B78     	 ldrb r3,[r3]
 10146 0012 181C     	 mov r0,r3
 10147 0014 FFF7FEFF 	 bl lcd_lookup
 10148 0018 031C     	 mov r3,r0
 10149 001a 2370     	 strb r3,[r4]
1983:../XMC1100-LibHaas.c ****   if (zeichen != 0xC3)							// ASCII Zeichen 0xC3 wird nicht ausgegeben.
 10150              	 .loc 3 1983 0
 10151 001c FB1D     	 add r3,r7,#7
 10152 001e 1B78     	 ldrb r3,[r3]
 10153 0020 C32B     	 cmp r3,#195
 10154 0022 04D0     	 beq .L492
1984:../XMC1100-LibHaas.c ****   	lcd_daten(zeichen);
 10155              	 .loc 3 1984 0
 10156 0024 FB1D     	 add r3,r7,#7
 10157 0026 1B78     	 ldrb r3,[r3]
 10158 0028 181C     	 mov r0,r3
 10159 002a FFF7FEFF 	 bl lcd_daten
 10160              	.L492:
1985:../XMC1100-LibHaas.c **** }
 10161              	 .loc 3 1985 0
 10162 002e BD46     	 mov sp,r7
 10163 0030 03B0     	 add sp,sp,#12
 10164              	 
 10165 0032 90BD     	 pop {r4,r7,pc}
 10166              	 .cfi_endproc
 10167              	.LFE128:
 10169              	 .section .text.lcd_print,"ax",%progbits
 10170              	 .align 2
 10171              	 .global lcd_print
 10172              	 .code 16
 10173              	 .thumb_func
 10175              	lcd_print:
 10176              	.LFB129:
1986:../XMC1100-LibHaas.c **** 
1987:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
1988:../XMC1100-LibHaas.c **** // \0-terminierten Text an das LCD-Display ausgeben.
1989:../XMC1100-LibHaas.c ****  //---------------------------------------------------------------
1990:../XMC1100-LibHaas.c **** void lcd_print (char *text)
1991:../XMC1100-LibHaas.c **** {
 10177              	 .loc 3 1991 0
 10178              	 .cfi_startproc
 10179 0000 80B5     	 push {r7,lr}
 10180              	.LCFI255:
 10181              	 .cfi_def_cfa_offset 8
 10182              	 .cfi_offset 7,-8
 10183              	 .cfi_offset 14,-4
 10184 0002 82B0     	 sub sp,sp,#8
 10185              	.LCFI256:
 10186              	 .cfi_def_cfa_offset 16
 10187 0004 00AF     	 add r7,sp,#0
 10188              	.LCFI257:
 10189              	 .cfi_def_cfa_register 7
 10190 0006 7860     	 str r0,[r7,#4]
1992:../XMC1100-LibHaas.c ****   while (*text != '\0')                 // Text
 10191              	 .loc 3 1992 0
 10192 0008 06E0     	 b .L495
 10193              	.L496:
1993:../XMC1100-LibHaas.c ****     lcd_char (*text++);                // zeichenweise ausgeben
 10194              	 .loc 3 1993 0
 10195 000a 7B68     	 ldr r3,[r7,#4]
 10196 000c 5A1C     	 add r2,r3,#1
 10197 000e 7A60     	 str r2,[r7,#4]
 10198 0010 1B78     	 ldrb r3,[r3]
 10199 0012 181C     	 mov r0,r3
 10200 0014 FFF7FEFF 	 bl lcd_char
 10201              	.L495:
1992:../XMC1100-LibHaas.c ****   while (*text != '\0')                 // Text
 10202              	 .loc 3 1992 0
 10203 0018 7B68     	 ldr r3,[r7,#4]
 10204 001a 1B78     	 ldrb r3,[r3]
 10205 001c 002B     	 cmp r3,#0
 10206 001e F4D1     	 bne .L496
1994:../XMC1100-LibHaas.c **** }
 10207              	 .loc 3 1994 0
 10208 0020 BD46     	 mov sp,r7
 10209 0022 02B0     	 add sp,sp,#8
 10210              	 
 10211 0024 80BD     	 pop {r7,pc}
 10212              	 .cfi_endproc
 10213              	.LFE129:
 10215 0026 C046     	 .section .text.lcd_byte,"ax",%progbits
 10216              	 .align 2
 10217              	 .global lcd_byte
 10218              	 .code 16
 10219              	 .thumb_func
 10221              	lcd_byte:
 10222              	.LFB130:
1995:../XMC1100-LibHaas.c **** 
1996:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
1997:../XMC1100-LibHaas.c **** // Gibt das Byte n als 3 stelligen Dez-Wert aufs  Display.
1998:../XMC1100-LibHaas.c **** // Führende Nullen werden zu blank.
1999:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
2000:../XMC1100-LibHaas.c **** void lcd_byte(uint8_t val)
2001:../XMC1100-LibHaas.c **** {
 10223              	 .loc 3 2001 0
 10224              	 .cfi_startproc
 10225 0000 90B5     	 push {r4,r7,lr}
 10226              	.LCFI258:
 10227              	 .cfi_def_cfa_offset 12
 10228              	 .cfi_offset 4,-12
 10229              	 .cfi_offset 7,-8
 10230              	 .cfi_offset 14,-4
 10231 0002 85B0     	 sub sp,sp,#20
 10232              	.LCFI259:
 10233              	 .cfi_def_cfa_offset 32
 10234 0004 00AF     	 add r7,sp,#0
 10235              	.LCFI260:
 10236              	 .cfi_def_cfa_register 7
 10237 0006 021C     	 mov r2,r0
 10238 0008 FB1D     	 add r3,r7,#7
 10239 000a 1A70     	 strb r2,[r3]
2002:../XMC1100-LibHaas.c ****   uint8_t buffer[3];
2003:../XMC1100-LibHaas.c ****   uint8_t n = 0;
 10240              	 .loc 3 2003 0
 10241 000c 0F23     	 mov r3,#15
 10242 000e FB18     	 add r3,r7,r3
 10243 0010 0022     	 mov r2,#0
 10244 0012 1A70     	 strb r2,[r3]
 10245              	.L498:
2004:../XMC1100-LibHaas.c **** 
2005:../XMC1100-LibHaas.c ****   do
2006:../XMC1100-LibHaas.c ****   {
2007:../XMC1100-LibHaas.c ****     buffer[n++] = val%10 + '0';
 10246              	 .loc 3 2007 0 discriminator 1
 10247 0014 0F23     	 mov r3,#15
 10248 0016 FB18     	 add r3,r7,r3
 10249 0018 1B78     	 ldrb r3,[r3]
 10250 001a 0F22     	 mov r2,#15
 10251 001c BA18     	 add r2,r7,r2
 10252 001e 591C     	 add r1,r3,#1
 10253 0020 1170     	 strb r1,[r2]
 10254 0022 1C1C     	 mov r4,r3
 10255 0024 FB1D     	 add r3,r7,#7
 10256 0026 1B78     	 ldrb r3,[r3]
 10257 0028 181C     	 mov r0,r3
 10258 002a 0A21     	 mov r1,#10
 10259 002c FFF7FEFF 	 bl __aeabi_uidivmod
 10260 0030 0B1C     	 mov r3,r1
 10261 0032 DBB2     	 uxtb r3,r3
 10262 0034 3033     	 add r3,r3,#48
 10263 0036 DAB2     	 uxtb r2,r3
 10264 0038 0C23     	 mov r3,#12
 10265 003a FB18     	 add r3,r7,r3
 10266 003c 1A55     	 strb r2,[r3,r4]
2008:../XMC1100-LibHaas.c ****   } while ((val /= 10) > 0);
 10267              	 .loc 3 2008 0 discriminator 1
 10268 003e FC1D     	 add r4,r7,#7
 10269 0040 FB1D     	 add r3,r7,#7
 10270 0042 1B78     	 ldrb r3,[r3]
 10271 0044 181C     	 mov r0,r3
 10272 0046 0A21     	 mov r1,#10
 10273 0048 FFF7FEFF 	 bl __aeabi_uidiv
 10274 004c 031C     	 mov r3,r0
 10275 004e 2370     	 strb r3,[r4]
 10276 0050 FB1D     	 add r3,r7,#7
 10277 0052 1B78     	 ldrb r3,[r3]
 10278 0054 002B     	 cmp r3,#0
 10279 0056 DDD1     	 bne .L498
2009:../XMC1100-LibHaas.c **** 
2010:../XMC1100-LibHaas.c ****   while (n<3)                              // Rest von buffer mit blank füllen
 10280              	 .loc 3 2010 0
 10281 0058 0BE0     	 b .L499
 10282              	.L500:
2011:../XMC1100-LibHaas.c ****   {
2012:../XMC1100-LibHaas.c ****     buffer[n++] = ' ';
 10283              	 .loc 3 2012 0
 10284 005a 0F23     	 mov r3,#15
 10285 005c FB18     	 add r3,r7,r3
 10286 005e 1B78     	 ldrb r3,[r3]
 10287 0060 0F22     	 mov r2,#15
 10288 0062 BA18     	 add r2,r7,r2
 10289 0064 591C     	 add r1,r3,#1
 10290 0066 1170     	 strb r1,[r2]
 10291 0068 1A1C     	 mov r2,r3
 10292 006a 0C23     	 mov r3,#12
 10293 006c FB18     	 add r3,r7,r3
 10294 006e 2021     	 mov r1,#32
 10295 0070 9954     	 strb r1,[r3,r2]
 10296              	.L499:
2010:../XMC1100-LibHaas.c ****   {
 10297              	 .loc 3 2010 0
 10298 0072 0F23     	 mov r3,#15
 10299 0074 FB18     	 add r3,r7,r3
 10300 0076 1B78     	 ldrb r3,[r3]
 10301 0078 022B     	 cmp r3,#2
 10302 007a EED9     	 bls .L500
2013:../XMC1100-LibHaas.c ****   }
2014:../XMC1100-LibHaas.c **** 
2015:../XMC1100-LibHaas.c ****   while (n > 0)                            // Ausgabe auf das Display (umgekehrt)
 10303              	 .loc 3 2015 0
 10304 007c 0FE0     	 b .L501
 10305              	.L502:
2016:../XMC1100-LibHaas.c ****   {
2017:../XMC1100-LibHaas.c ****     n--;
 10306              	 .loc 3 2017 0
 10307 007e 0F23     	 mov r3,#15
 10308 0080 FB18     	 add r3,r7,r3
 10309 0082 1A78     	 ldrb r2,[r3]
 10310 0084 0F23     	 mov r3,#15
 10311 0086 FB18     	 add r3,r7,r3
 10312 0088 013A     	 sub r2,r2,#1
 10313 008a 1A70     	 strb r2,[r3]
2018:../XMC1100-LibHaas.c ****     lcd_char(buffer[n]);
 10314              	 .loc 3 2018 0
 10315 008c 0F23     	 mov r3,#15
 10316 008e FB18     	 add r3,r7,r3
 10317 0090 1B78     	 ldrb r3,[r3]
 10318 0092 0C22     	 mov r2,#12
 10319 0094 BA18     	 add r2,r7,r2
 10320 0096 D35C     	 ldrb r3,[r2,r3]
 10321 0098 181C     	 mov r0,r3
 10322 009a FFF7FEFF 	 bl lcd_char
 10323              	.L501:
2015:../XMC1100-LibHaas.c ****   {
 10324              	 .loc 3 2015 0
 10325 009e 0F23     	 mov r3,#15
 10326 00a0 FB18     	 add r3,r7,r3
 10327 00a2 1B78     	 ldrb r3,[r3]
 10328 00a4 002B     	 cmp r3,#0
 10329 00a6 EAD1     	 bne .L502
2019:../XMC1100-LibHaas.c ****   }
2020:../XMC1100-LibHaas.c **** }
 10330              	 .loc 3 2020 0
 10331 00a8 BD46     	 mov sp,r7
 10332 00aa 05B0     	 add sp,sp,#20
 10333              	 
 10334 00ac 90BD     	 pop {r4,r7,pc}
 10335              	 .cfi_endproc
 10336              	.LFE130:
 10338 00ae C046     	 .section .text.lcd_int,"ax",%progbits
 10339              	 .align 2
 10340              	 .global lcd_int
 10341              	 .code 16
 10342              	 .thumb_func
 10344              	lcd_int:
 10345              	.LFB131:
2021:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
2022:../XMC1100-LibHaas.c **** // Gibt den Integer n als 5 stelligen Dez-Wert aufs Display.
2023:../XMC1100-LibHaas.c **** // Führende Nullen werden zu blank.
2024:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
2025:../XMC1100-LibHaas.c **** void lcd_int(uint16_t val)
2026:../XMC1100-LibHaas.c **** {
 10346              	 .loc 3 2026 0
 10347              	 .cfi_startproc
 10348 0000 90B5     	 push {r4,r7,lr}
 10349              	.LCFI261:
 10350              	 .cfi_def_cfa_offset 12
 10351              	 .cfi_offset 4,-12
 10352              	 .cfi_offset 7,-8
 10353              	 .cfi_offset 14,-4
 10354 0002 85B0     	 sub sp,sp,#20
 10355              	.LCFI262:
 10356              	 .cfi_def_cfa_offset 32
 10357 0004 00AF     	 add r7,sp,#0
 10358              	.LCFI263:
 10359              	 .cfi_def_cfa_register 7
 10360 0006 021C     	 mov r2,r0
 10361 0008 BB1D     	 add r3,r7,#6
 10362 000a 1A80     	 strh r2,[r3]
2027:../XMC1100-LibHaas.c ****   uint8_t buffer[5];
2028:../XMC1100-LibHaas.c ****   uint8_t n = 0;
 10363              	 .loc 3 2028 0
 10364 000c 0F23     	 mov r3,#15
 10365 000e FB18     	 add r3,r7,r3
 10366 0010 0022     	 mov r2,#0
 10367 0012 1A70     	 strb r2,[r3]
 10368              	.L504:
2029:../XMC1100-LibHaas.c **** 
2030:../XMC1100-LibHaas.c ****   do
2031:../XMC1100-LibHaas.c ****   {
2032:../XMC1100-LibHaas.c ****     buffer[n++] = val%10 + '0';
 10369              	 .loc 3 2032 0 discriminator 1
 10370 0014 0F23     	 mov r3,#15
 10371 0016 FB18     	 add r3,r7,r3
 10372 0018 1B78     	 ldrb r3,[r3]
 10373 001a 0F22     	 mov r2,#15
 10374 001c BA18     	 add r2,r7,r2
 10375 001e 591C     	 add r1,r3,#1
 10376 0020 1170     	 strb r1,[r2]
 10377 0022 1C1C     	 mov r4,r3
 10378 0024 BB1D     	 add r3,r7,#6
 10379 0026 1B88     	 ldrh r3,[r3]
 10380 0028 181C     	 mov r0,r3
 10381 002a 0A21     	 mov r1,#10
 10382 002c FFF7FEFF 	 bl __aeabi_uidivmod
 10383 0030 0B1C     	 mov r3,r1
 10384 0032 9BB2     	 uxth r3,r3
 10385 0034 DBB2     	 uxtb r3,r3
 10386 0036 3033     	 add r3,r3,#48
 10387 0038 DAB2     	 uxtb r2,r3
 10388 003a 0823     	 mov r3,#8
 10389 003c FB18     	 add r3,r7,r3
 10390 003e 1A55     	 strb r2,[r3,r4]
2033:../XMC1100-LibHaas.c ****   } while ((val /= 10) > 0);
 10391              	 .loc 3 2033 0 discriminator 1
 10392 0040 BC1D     	 add r4,r7,#6
 10393 0042 BB1D     	 add r3,r7,#6
 10394 0044 1B88     	 ldrh r3,[r3]
 10395 0046 181C     	 mov r0,r3
 10396 0048 0A21     	 mov r1,#10
 10397 004a FFF7FEFF 	 bl __aeabi_uidiv
 10398 004e 031C     	 mov r3,r0
 10399 0050 2380     	 strh r3,[r4]
 10400 0052 BB1D     	 add r3,r7,#6
 10401 0054 1B88     	 ldrh r3,[r3]
 10402 0056 002B     	 cmp r3,#0
 10403 0058 DCD1     	 bne .L504
2034:../XMC1100-LibHaas.c **** 
2035:../XMC1100-LibHaas.c ****   while (n<5)                              // Rest von buffer mit blank füllen
 10404              	 .loc 3 2035 0
 10405 005a 0BE0     	 b .L505
 10406              	.L506:
2036:../XMC1100-LibHaas.c ****   {
2037:../XMC1100-LibHaas.c ****     buffer[n++] = ' ';
 10407              	 .loc 3 2037 0
 10408 005c 0F23     	 mov r3,#15
 10409 005e FB18     	 add r3,r7,r3
 10410 0060 1B78     	 ldrb r3,[r3]
 10411 0062 0F22     	 mov r2,#15
 10412 0064 BA18     	 add r2,r7,r2
 10413 0066 591C     	 add r1,r3,#1
 10414 0068 1170     	 strb r1,[r2]
 10415 006a 1A1C     	 mov r2,r3
 10416 006c 0823     	 mov r3,#8
 10417 006e FB18     	 add r3,r7,r3
 10418 0070 2021     	 mov r1,#32
 10419 0072 9954     	 strb r1,[r3,r2]
 10420              	.L505:
2035:../XMC1100-LibHaas.c ****   {
 10421              	 .loc 3 2035 0
 10422 0074 0F23     	 mov r3,#15
 10423 0076 FB18     	 add r3,r7,r3
 10424 0078 1B78     	 ldrb r3,[r3]
 10425 007a 042B     	 cmp r3,#4
 10426 007c EED9     	 bls .L506
2038:../XMC1100-LibHaas.c ****   }
2039:../XMC1100-LibHaas.c **** 
2040:../XMC1100-LibHaas.c ****   while (n > 0)                            // Ausgabe auf das Display (umgekehrt)
 10427              	 .loc 3 2040 0
 10428 007e 0FE0     	 b .L507
 10429              	.L508:
2041:../XMC1100-LibHaas.c ****   {
2042:../XMC1100-LibHaas.c ****     n--;
 10430              	 .loc 3 2042 0
 10431 0080 0F23     	 mov r3,#15
 10432 0082 FB18     	 add r3,r7,r3
 10433 0084 1A78     	 ldrb r2,[r3]
 10434 0086 0F23     	 mov r3,#15
 10435 0088 FB18     	 add r3,r7,r3
 10436 008a 013A     	 sub r2,r2,#1
 10437 008c 1A70     	 strb r2,[r3]
2043:../XMC1100-LibHaas.c ****     lcd_char(buffer[n]);
 10438              	 .loc 3 2043 0
 10439 008e 0F23     	 mov r3,#15
 10440 0090 FB18     	 add r3,r7,r3
 10441 0092 1B78     	 ldrb r3,[r3]
 10442 0094 0822     	 mov r2,#8
 10443 0096 BA18     	 add r2,r7,r2
 10444 0098 D35C     	 ldrb r3,[r2,r3]
 10445 009a 181C     	 mov r0,r3
 10446 009c FFF7FEFF 	 bl lcd_char
 10447              	.L507:
2040:../XMC1100-LibHaas.c ****   {
 10448              	 .loc 3 2040 0
 10449 00a0 0F23     	 mov r3,#15
 10450 00a2 FB18     	 add r3,r7,r3
 10451 00a4 1B78     	 ldrb r3,[r3]
 10452 00a6 002B     	 cmp r3,#0
 10453 00a8 EAD1     	 bne .L508
2044:../XMC1100-LibHaas.c ****   }
2045:../XMC1100-LibHaas.c **** }
 10454              	 .loc 3 2045 0
 10455 00aa BD46     	 mov sp,r7
 10456 00ac 05B0     	 add sp,sp,#20
 10457              	 
 10458 00ae 90BD     	 pop {r4,r7,pc}
 10459              	 .cfi_endproc
 10460              	.LFE131:
 10462              	 .section .text.lcd_lookup,"ax",%progbits
 10463              	 .align 2
 10464              	 .global lcd_lookup
 10465              	 .code 16
 10466              	 .thumb_func
 10468              	lcd_lookup:
 10469              	.LFB132:
2046:../XMC1100-LibHaas.c **** 
2047:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
2048:../XMC1100-LibHaas.c **** // Ersetzt ein ASCII-Umlaut durch den entsprechenden Display-Code.
2049:../XMC1100-LibHaas.c **** // Da die Umlaute durch 16 Bit Werte übersetzt werden, können ein
2050:../XMC1100-LibHaas.c **** // paar ASCII Zeichen vertauscht werden.
2051:../XMC1100-LibHaas.c **** // ASCII Zeichen 0xC3 wird nicht ausgegeben.
2052:../XMC1100-LibHaas.c **** //---------------------------------------------------------------
2053:../XMC1100-LibHaas.c **** uint8_t lcd_lookup(uint8_t ascii)
2054:../XMC1100-LibHaas.c **** {
 10470              	 .loc 3 2054 0
 10471              	 .cfi_startproc
 10472 0000 80B5     	 push {r7,lr}
 10473              	.LCFI264:
 10474              	 .cfi_def_cfa_offset 8
 10475              	 .cfi_offset 7,-8
 10476              	 .cfi_offset 14,-4
 10477 0002 82B0     	 sub sp,sp,#8
 10478              	.LCFI265:
 10479              	 .cfi_def_cfa_offset 16
 10480 0004 00AF     	 add r7,sp,#0
 10481              	.LCFI266:
 10482              	 .cfi_def_cfa_register 7
 10483 0006 021C     	 mov r2,r0
 10484 0008 FB1D     	 add r3,r7,#7
 10485 000a 1A70     	 strb r2,[r3]
2055:../XMC1100-LibHaas.c ****   switch (ascii)
 10486              	 .loc 3 2055 0
 10487 000c FB1D     	 add r3,r7,#7
 10488 000e 1B78     	 ldrb r3,[r3]
 10489 0010 B02B     	 cmp r3,#176
 10490 0012 08D0     	 beq .L511
 10491 0014 02DC     	 bgt .L512
 10492 0016 A42B     	 cmp r3,#164
 10493 0018 07D0     	 beq .L513
 10494 001a 0CE0     	 b .L510
 10495              	.L512:
 10496 001c B62B     	 cmp r3,#182
 10497 001e 06D0     	 beq .L514
 10498 0020 BC2B     	 cmp r3,#188
 10499 0022 06D0     	 beq .L515
 10500 0024 07E0     	 b .L510
 10501              	.L511:
2056:../XMC1100-LibHaas.c ****   {
2057:../XMC1100-LibHaas.c ****     case 0xb0: return 0xdf; // '°'
 10502              	 .loc 3 2057 0
 10503 0026 DF23     	 mov r3,#223
 10504 0028 07E0     	 b .L516
 10505              	.L513:
2058:../XMC1100-LibHaas.c **** 
2059:../XMC1100-LibHaas.c ****     case 0xa4:  return 0x7b;
 10506              	 .loc 3 2059 0
 10507 002a 7B23     	 mov r3,#123
 10508 002c 05E0     	 b .L516
 10509              	.L514:
2060:../XMC1100-LibHaas.c ****     case 0xb6:  return 0x7C;
 10510              	 .loc 3 2060 0
 10511 002e 7C23     	 mov r3,#124
 10512 0030 03E0     	 b .L516
 10513              	.L515:
2061:../XMC1100-LibHaas.c ****     case 0xbc:  return 0x7E;
 10514              	 .loc 3 2061 0
 10515 0032 7E23     	 mov r3,#126
 10516 0034 01E0     	 b .L516
 10517              	.L510:
2062:../XMC1100-LibHaas.c ****     /*
2063:../XMC1100-LibHaas.c ****     case 'Ä':  return 0xe1;
2064:../XMC1100-LibHaas.c ****     case 'Ö':  return 0xef;
2065:../XMC1100-LibHaas.c ****     case 'Ü':  return 0xf5;
2066:../XMC1100-LibHaas.c ****     case 'ß':  return 0xe2;
2067:../XMC1100-LibHaas.c ****     case 'µ':  return 0xe4;
2068:../XMC1100-LibHaas.c ****     case '\\': return 0xa4;
2069:../XMC1100-LibHaas.c ****     case '€':  return 0xd3;
2070:../XMC1100-LibHaas.c **** */
2071:../XMC1100-LibHaas.c ****   }
2072:../XMC1100-LibHaas.c ****   return ascii;
 10518              	 .loc 3 2072 0
 10519 0036 FB1D     	 add r3,r7,#7
 10520 0038 1B78     	 ldrb r3,[r3]
 10521              	.L516:
2073:../XMC1100-LibHaas.c **** }
 10522              	 .loc 3 2073 0
 10523 003a 181C     	 mov r0,r3
 10524 003c BD46     	 mov sp,r7
 10525 003e 02B0     	 add sp,sp,#8
 10526              	 
 10527 0040 80BD     	 pop {r7,pc}
 10528              	 .cfi_endproc
 10529              	.LFE132:
 10531 0042 C046     	 .section .text.lcd_clearline,"ax",%progbits
 10532              	 .align 2
 10533              	 .global lcd_clearline
 10534              	 .code 16
 10535              	 .thumb_func
 10537              	lcd_clearline:
 10538              	.LFB133:
2074:../XMC1100-LibHaas.c **** 
2075:../XMC1100-LibHaas.c **** /////////////////////////////////////////////////////////////////////////////////
2076:../XMC1100-LibHaas.c **** // Ab hier sind ergänzende Funktionen
2077:../XMC1100-LibHaas.c **** /////////////////////////////////////////////////////////////////////////////////
2078:../XMC1100-LibHaas.c **** #ifdef LCD_EXTENSION
2079:../XMC1100-LibHaas.c **** /***********************************************************************************
2080:../XMC1100-LibHaas.c ****  * Pixelweise Definition eigener LCD-Zeichen, Ablegen von max 7 Zeichen im CG-RAM des LCD
2081:../XMC1100-LibHaas.c ****  ***********************************************************************************/
2082:../XMC1100-LibHaas.c **** void lcd_defchar (uint8_t *PixelTabelle, uint8_t ZeichenNr)
2083:../XMC1100-LibHaas.c **** {
2084:../XMC1100-LibHaas.c ****   uint8_t z;
2085:../XMC1100-LibHaas.c **** 
2086:../XMC1100-LibHaas.c ****   if (ZeichenNr<8)                  // Adr 0 nicht innerhalb eines Textstrings nutzbar!
2087:../XMC1100-LibHaas.c ****   lcd_befehl (((ZeichenNr*8) & 0x7F) | 0x40);
2088:../XMC1100-LibHaas.c ****   // Adresse der ersten Pixelzeile = 8 x Adresse des fertigen Zeichens im DD Ram
2089:../XMC1100-LibHaas.c ****   // Zugriff auf Adresse im CG-RAM (Character Generator) mit  Bit7 = 0, Bit6 = 1
2090:../XMC1100-LibHaas.c ****   for (z=0;z<8;z++)
2091:../XMC1100-LibHaas.c ****   lcd_char (*(PixelTabelle+z));     // 8 Pixelzeilen ins CR-Ram
2092:../XMC1100-LibHaas.c ****   lcd_setcursor (0,0);              // wieder auf DD-Ram-Zugriff umschalten
2093:../XMC1100-LibHaas.c **** }
2094:../XMC1100-LibHaas.c **** 
2095:../XMC1100-LibHaas.c **** /*************************************************************************
2096:../XMC1100-LibHaas.c **** Löschen der Zeilen 1 bis 4 des Displays
2097:../XMC1100-LibHaas.c **** Es wird ein Leerstring (16 Byte) auf die Zeile geschrieben
2098:../XMC1100-LibHaas.c **** ***************************************************************************/
2099:../XMC1100-LibHaas.c **** void lcd_clearline(uint8_t zeile)
2100:../XMC1100-LibHaas.c **** {
2101:../XMC1100-LibHaas.c ****   uint8_t n;
2102:../XMC1100-LibHaas.c **** 
2103:../XMC1100-LibHaas.c ****   lcd_setcursor(zeile,0);
2104:../XMC1100-LibHaas.c ****   for (n=0; n < LCD_LEN; n++)  lcd_char(' ');
2105:../XMC1100-LibHaas.c **** }
2106:../XMC1100-LibHaas.c **** 
2107:../XMC1100-LibHaas.c **** 
2108:../XMC1100-LibHaas.c **** #endif
2109:../XMC1100-LibHaas.c **** 
2110:../XMC1100-LibHaas.c **** /*************************************************************************
2111:../XMC1100-LibHaas.c **** Löschen der Zeilen 1 bis 4 des Displays
2112:../XMC1100-LibHaas.c **** Es wird ein Leerstring (16 Byte) auf die Zeile geschrieben
2113:../XMC1100-LibHaas.c **** ***************************************************************************/
2114:../XMC1100-LibHaas.c **** void lcd_clearline(uint8_t zeile)
2115:../XMC1100-LibHaas.c **** {
 10539              	 .loc 3 2115 0
 10540              	 .cfi_startproc
 10541 0000 80B5     	 push {r7,lr}
 10542              	.LCFI267:
 10543              	 .cfi_def_cfa_offset 8
 10544              	 .cfi_offset 7,-8
 10545              	 .cfi_offset 14,-4
 10546 0002 84B0     	 sub sp,sp,#16
 10547              	.LCFI268:
 10548              	 .cfi_def_cfa_offset 24
 10549 0004 00AF     	 add r7,sp,#0
 10550              	.LCFI269:
 10551              	 .cfi_def_cfa_register 7
 10552 0006 021C     	 mov r2,r0
 10553 0008 FB1D     	 add r3,r7,#7
 10554 000a 1A70     	 strb r2,[r3]
2116:../XMC1100-LibHaas.c ****   uint8_t n;
2117:../XMC1100-LibHaas.c **** 
2118:../XMC1100-LibHaas.c ****   lcd_setcursor(zeile,0);
 10555              	 .loc 3 2118 0
 10556 000c FB1D     	 add r3,r7,#7
 10557 000e 1B78     	 ldrb r3,[r3]
 10558 0010 181C     	 mov r0,r3
 10559 0012 0021     	 mov r1,#0
 10560 0014 FFF7FEFF 	 bl lcd_setcursor
2119:../XMC1100-LibHaas.c ****   for (n=0; n < LCD_LEN; n++)  lcd_char(' ');
 10561              	 .loc 3 2119 0
 10562 0018 0F23     	 mov r3,#15
 10563 001a FB18     	 add r3,r7,r3
 10564 001c 0022     	 mov r2,#0
 10565 001e 1A70     	 strb r2,[r3]
 10566 0020 09E0     	 b .L518
 10567              	.L519:
 10568              	 .loc 3 2119 0 is_stmt 0 discriminator 3
 10569 0022 2020     	 mov r0,#32
 10570 0024 FFF7FEFF 	 bl lcd_char
 10571 0028 0F23     	 mov r3,#15
 10572 002a FB18     	 add r3,r7,r3
 10573 002c 1A78     	 ldrb r2,[r3]
 10574 002e 0F23     	 mov r3,#15
 10575 0030 FB18     	 add r3,r7,r3
 10576 0032 0132     	 add r2,r2,#1
 10577 0034 1A70     	 strb r2,[r3]
 10578              	.L518:
 10579              	 .loc 3 2119 0 discriminator 1
 10580 0036 0F23     	 mov r3,#15
 10581 0038 FB18     	 add r3,r7,r3
 10582 003a 1B78     	 ldrb r3,[r3]
 10583 003c 132B     	 cmp r3,#19
 10584 003e F0D9     	 bls .L519
2120:../XMC1100-LibHaas.c ****   lcd_setcursor(zeile, 0);
 10585              	 .loc 3 2120 0 is_stmt 1
 10586 0040 FB1D     	 add r3,r7,#7
 10587 0042 1B78     	 ldrb r3,[r3]
 10588 0044 181C     	 mov r0,r3
 10589 0046 0021     	 mov r1,#0
 10590 0048 FFF7FEFF 	 bl lcd_setcursor
2121:../XMC1100-LibHaas.c **** }
 10591              	 .loc 3 2121 0
 10592 004c BD46     	 mov sp,r7
 10593 004e 04B0     	 add sp,sp,#16
 10594              	 
 10595 0050 80BD     	 pop {r7,pc}
 10596              	 .cfi_endproc
 10597              	.LFE133:
 10599 0052 C046     	 .section .text.ext_interrupt1_init,"ax",%progbits
 10600              	 .align 2
 10601              	 .global ext_interrupt1_init
 10602              	 .code 16
 10603              	 .thumb_func
 10605              	ext_interrupt1_init:
 10606              	.LFB134:
2122:../XMC1100-LibHaas.c **** 
2123:../XMC1100-LibHaas.c **** //**************************************************************************
2124:../XMC1100-LibHaas.c **** // Ab hier Int - Funktionen :
2125:../XMC1100-LibHaas.c **** //lokale Fkt :
2126:../XMC1100-LibHaas.c **** void ext_interrupt1_init(uint8_t flanke);
2127:../XMC1100-LibHaas.c **** void ext_interrupt2_init(uint8_t flanke);
2128:../XMC1100-LibHaas.c **** 
2129:../XMC1100-LibHaas.c **** 
2130:../XMC1100-LibHaas.c **** /* --------------------------------------------------------------------------
2131:../XMC1100-LibHaas.c ****    Externen Interrupt1 initialisieren, ERU0 Kanal 2B0 -> Eingang P2.10,
2132:../XMC1100-LibHaas.c ****    flanke=RE=1 Rising Edge ansteigende Flanke
2133:../XMC1100-LibHaas.c ****    flanke=FE=0 Falling Edge abfallende Flanke
2134:../XMC1100-LibHaas.c ****    Interrupt-Handler ins eigene Programm kopieren:
2135:../XMC1100-LibHaas.c **** void ERU0_2_IRQHandler(void)	// ext. Int an P2.10
2136:../XMC1100-LibHaas.c **** 	{
2137:../XMC1100-LibHaas.c **** 								// Interrupt-Servie-Routine
2138:../XMC1100-LibHaas.c **** 	}
2139:../XMC1100-LibHaas.c **** //--------------------------------------------------------------------------*/
2140:../XMC1100-LibHaas.c **** void ext_interrupt1_init(uint8_t flanke)
2141:../XMC1100-LibHaas.c **** {
 10607              	 .loc 3 2141 0
 10608              	 .cfi_startproc
 10609 0000 80B5     	 push {r7,lr}
 10610              	.LCFI270:
 10611              	 .cfi_def_cfa_offset 8
 10612              	 .cfi_offset 7,-8
 10613              	 .cfi_offset 14,-4
 10614 0002 82B0     	 sub sp,sp,#8
 10615              	.LCFI271:
 10616              	 .cfi_def_cfa_offset 16
 10617 0004 00AF     	 add r7,sp,#0
 10618              	.LCFI272:
 10619              	 .cfi_def_cfa_register 7
 10620 0006 021C     	 mov r2,r0
 10621 0008 FB1D     	 add r3,r7,#7
 10622 000a 1A70     	 strb r2,[r3]
2142:../XMC1100-LibHaas.c **** 	ERU0->EXISEL = 0x00000000;			//Eingang 2B0 auswählen (P2.10)
 10623              	 .loc 3 2142 0
 10624 000c 0F4B     	 ldr r3,.L523
 10625 000e 0022     	 mov r2,#0
 10626 0010 1A60     	 str r2,[r3]
2143:../XMC1100-LibHaas.c **** 	if (flanke == FE)
 10627              	 .loc 3 2143 0
 10628 0012 FB1D     	 add r3,r7,#7
 10629 0014 1B78     	 ldrb r3,[r3]
 10630 0016 002B     	 cmp r3,#0
 10631 0018 04D1     	 bne .L521
2144:../XMC1100-LibHaas.c **** 		 ERU0->EXICON[2]=0x00000129;	// PE=1 (Trigger Impuls erzeugen) , FE (auf fallende Flanke reagiere
 10632              	 .loc 3 2144 0
 10633 001a 0C4B     	 ldr r3,.L523
 10634 001c 2A22     	 mov r2,#42
 10635 001e FF32     	 add r2,r2,#255
 10636 0020 9A61     	 str r2,[r3,#24]
 10637 0022 03E0     	 b .L522
 10638              	.L521:
2145:../XMC1100-LibHaas.c **** 	else ERU0->EXICON[2]=0x00000125;	// PE=1 (Trigger Impuls erzeugen) , RE (auf ansteigende Flanke re
 10639              	 .loc 3 2145 0
 10640 0024 094B     	 ldr r3,.L523
 10641 0026 2622     	 mov r2,#38
 10642 0028 FF32     	 add r2,r2,#255
 10643 002a 9A61     	 str r2,[r3,#24]
 10644              	.L522:
2146:../XMC1100-LibHaas.c **** 	ERU0->EXOCON[2]= 0x00000010;		// GP=1 , OGU2 wird mit NVIC Request Line verbunden
 10645              	 .loc 3 2146 0
 10646 002c 074B     	 ldr r3,.L523
 10647 002e 1022     	 mov r2,#16
 10648 0030 9A62     	 str r2,[r3,#40]
2147:../XMC1100-LibHaas.c **** 	//CLR_BIT (PORT2->PDISC,10);			// Port 2.10 auf dig. Input
2148:../XMC1100-LibHaas.c **** 	bit_init_mode(P2, 10, INP, PULLUP);  // Port 2.10 digital, In, Pullup
 10649              	 .loc 3 2148 0
 10650 0032 0220     	 mov r0,#2
 10651 0034 0A21     	 mov r1,#10
 10652 0036 0022     	 mov r2,#0
 10653 0038 0123     	 mov r3,#1
 10654 003a FFF7FEFF 	 bl bit_init_mode
2149:../XMC1100-LibHaas.c **** 	ext_clear_IRQ(IRQ1);						 // ISR Anforderungsbit geloescht
 10655              	 .loc 3 2149 0
 10656 003e 0120     	 mov r0,#1
 10657 0040 FFF7FEFF 	 bl ext_clear_IRQ
2150:../XMC1100-LibHaas.c **** 	//NVIC_EnableIRQ(ERU0_2_IRQn); // Interrupt wird freigegeben Kanal 2 (CMSIS Bib)
2151:../XMC1100-LibHaas.c **** }
 10658              	 .loc 3 2151 0
 10659 0044 BD46     	 mov sp,r7
 10660 0046 02B0     	 add sp,sp,#8
 10661              	 
 10662 0048 80BD     	 pop {r7,pc}
 10663              	.L524:
 10664 004a C046     	 .align 2
 10665              	.L523:
 10666 004c 00060140 	 .word 1073808896
 10667              	 .cfi_endproc
 10668              	.LFE134:
 10670              	 .section .text.ext_interrupt2_init,"ax",%progbits
 10671              	 .align 2
 10672              	 .global ext_interrupt2_init
 10673              	 .code 16
 10674              	 .thumb_func
 10676              	ext_interrupt2_init:
 10677              	.LFB135:
2152:../XMC1100-LibHaas.c **** 
2153:../XMC1100-LibHaas.c **** 
2154:../XMC1100-LibHaas.c **** /* --------------------------------------------------------------------------
2155:../XMC1100-LibHaas.c ****    Externen Interrupt2 initialisieren,  ERU0 Kanal 3B0 -> Eingang P2.9,
2156:../XMC1100-LibHaas.c ****    flanke=RE=1 Rising Edge ansteigende Flanke
2157:../XMC1100-LibHaas.c ****    flanke=FE=0 Falling Edge abfallende Flanke
2158:../XMC1100-LibHaas.c ****    Interrupt-Service-Routinen ins eigene Programm kopieren:
2159:../XMC1100-LibHaas.c **** void ERU0_3_IRQHandler(void)	// ext. Int an P2.9
2160:../XMC1100-LibHaas.c **** 	{
2161:../XMC1100-LibHaas.c **** 								// Interrupt-Servie-Routine
2162:../XMC1100-LibHaas.c **** 	}
2163:../XMC1100-LibHaas.c **** //--------------------------------------------------------------------------*/
2164:../XMC1100-LibHaas.c **** void ext_interrupt2_init(uint8_t flanke)
2165:../XMC1100-LibHaas.c **** {
 10678              	 .loc 3 2165 0
 10679              	 .cfi_startproc
 10680 0000 80B5     	 push {r7,lr}
 10681              	.LCFI273:
 10682              	 .cfi_def_cfa_offset 8
 10683              	 .cfi_offset 7,-8
 10684              	 .cfi_offset 14,-4
 10685 0002 82B0     	 sub sp,sp,#8
 10686              	.LCFI274:
 10687              	 .cfi_def_cfa_offset 16
 10688 0004 00AF     	 add r7,sp,#0
 10689              	.LCFI275:
 10690              	 .cfi_def_cfa_register 7
 10691 0006 021C     	 mov r2,r0
 10692 0008 FB1D     	 add r3,r7,#7
 10693 000a 1A70     	 strb r2,[r3]
2166:../XMC1100-LibHaas.c **** 	ERU0->EXISEL |= 0x00000000; 		//Eingang 3B0 auswaehlen (P2.9)
 10694              	 .loc 3 2166 0
 10695 000c 0F4B     	 ldr r3,.L528
 10696 000e 0F4A     	 ldr r2,.L528
 10697 0010 1268     	 ldr r2,[r2]
 10698 0012 1A60     	 str r2,[r3]
2167:../XMC1100-LibHaas.c **** 	if (flanke == FE)
 10699              	 .loc 3 2167 0
 10700 0014 FB1D     	 add r3,r7,#7
 10701 0016 1B78     	 ldrb r3,[r3]
 10702 0018 002B     	 cmp r3,#0
 10703 001a 04D1     	 bne .L526
2168:../XMC1100-LibHaas.c **** 		 ERU0->EXICON[3]=0x00000139; 	// PE=1 , FE (auf fallende Flanke reagieren) , Trigger an OGU3 ,SS=
 10704              	 .loc 3 2168 0
 10705 001c 0B4B     	 ldr r3,.L528
 10706 001e 3A22     	 mov r2,#58
 10707 0020 FF32     	 add r2,r2,#255
 10708 0022 DA61     	 str r2,[r3,#28]
 10709 0024 03E0     	 b .L527
 10710              	.L526:
2169:../XMC1100-LibHaas.c **** 	else ERU0->EXICON[3]=0x00000135; 	// PE=1 , RE (steigende Flanke Kanal 2) , Trigger an OGU3 ,SS=01
 10711              	 .loc 3 2169 0
 10712 0026 094B     	 ldr r3,.L528
 10713 0028 3622     	 mov r2,#54
 10714 002a FF32     	 add r2,r2,#255
 10715 002c DA61     	 str r2,[r3,#28]
 10716              	.L527:
2170:../XMC1100-LibHaas.c **** 	ERU0->EXOCON[3]=0x00000010; 		// GP=1 , OGU3 wird mit NVIC Request Line verbunden
 10717              	 .loc 3 2170 0
 10718 002e 074B     	 ldr r3,.L528
 10719 0030 1022     	 mov r2,#16
 10720 0032 DA62     	 str r2,[r3,#44]
2171:../XMC1100-LibHaas.c **** 	//CLR_BIT (PORT2->PDISC,9);			// Port 2.9 auf dig. Input
2172:../XMC1100-LibHaas.c **** 	bit_init_mode(P2, 9, INP, PULLUP);  // Port 2.10 digital, In, Pullup
 10721              	 .loc 3 2172 0
 10722 0034 0220     	 mov r0,#2
 10723 0036 0921     	 mov r1,#9
 10724 0038 0022     	 mov r2,#0
 10725 003a 0123     	 mov r3,#1
 10726 003c FFF7FEFF 	 bl bit_init_mode
2173:../XMC1100-LibHaas.c **** 	ext_clear_IRQ(IRQ2);  						// ISR Anforderungsbit geloescht
 10727              	 .loc 3 2173 0
 10728 0040 0220     	 mov r0,#2
 10729 0042 FFF7FEFF 	 bl ext_clear_IRQ
2174:../XMC1100-LibHaas.c **** 	//NVIC_EnableIRQ(ERU0_3_IRQn); 		// Freigabe Interrupt Kanal 3 (CMSIS Bib)
2175:../XMC1100-LibHaas.c **** }
 10730              	 .loc 3 2175 0
 10731 0046 BD46     	 mov sp,r7
 10732 0048 02B0     	 add sp,sp,#8
 10733              	 
 10734 004a 80BD     	 pop {r7,pc}
 10735              	.L529:
 10736              	 .align 2
 10737              	.L528:
 10738 004c 00060140 	 .word 1073808896
 10739              	 .cfi_endproc
 10740              	.LFE135:
 10742              	 .section .text.ext_interrupt_init,"ax",%progbits
 10743              	 .align 2
 10744              	 .global ext_interrupt_init
 10745              	 .code 16
 10746              	 .thumb_func
 10748              	ext_interrupt_init:
 10749              	.LFB136:
2176:../XMC1100-LibHaas.c **** 
2177:../XMC1100-LibHaas.c **** /* Externen Interrupt1 initialisieren --------------------------------------
2178:../XMC1100-LibHaas.c ****    ERU0 Kanal 2B0 -> Eingang P2.10, abfallende Flanke
2179:../XMC1100-LibHaas.c ****    Interrupt-Handler ins eigene Programm kopieren:
2180:../XMC1100-LibHaas.c **** void ERU0_2_IRQHandler(void)	// ext. Int bei fallender Flanke an P2.10
2181:../XMC1100-LibHaas.c **** 	{							// Interrupt-Servie-Routine
2182:../XMC1100-LibHaas.c **** 	}
2183:../XMC1100-LibHaas.c ****    Externen Interrupt2 initialisieren -------------------------------------
2184:../XMC1100-LibHaas.c ****    ERU0 Kanal 3B0 -> Eingang P2.9, steigende Flanke
2185:../XMC1100-LibHaas.c ****    Interrupt-Service-Routinen ins eigene Programm kopieren:
2186:../XMC1100-LibHaas.c **** void ERU0_3_IRQHandler(void)	// ext. Int bei steigender Flanke an P2.9
2187:../XMC1100-LibHaas.c **** 	{							// Interrupt-Servie-Routine
2188:../XMC1100-LibHaas.c **** 	}*/
2189:../XMC1100-LibHaas.c **** void ext_interrupt_init ( void )	// beide Int Eingänge Init
2190:../XMC1100-LibHaas.c **** {
 10750              	 .loc 3 2190 0
 10751              	 .cfi_startproc
 10752 0000 80B5     	 push {r7,lr}
 10753              	.LCFI276:
 10754              	 .cfi_def_cfa_offset 8
 10755              	 .cfi_offset 7,-8
 10756              	 .cfi_offset 14,-4
 10757 0002 00AF     	 add r7,sp,#0
 10758              	.LCFI277:
 10759              	 .cfi_def_cfa_register 7
2191:../XMC1100-LibHaas.c **** 	ext_interrupt1_init(FE);
 10760              	 .loc 3 2191 0
 10761 0004 0020     	 mov r0,#0
 10762 0006 FFF7FEFF 	 bl ext_interrupt1_init
2192:../XMC1100-LibHaas.c **** 	ext_interrupt2_init(RE);
 10763              	 .loc 3 2192 0
 10764 000a 0120     	 mov r0,#1
 10765 000c FFF7FEFF 	 bl ext_interrupt2_init
2193:../XMC1100-LibHaas.c **** }
 10766              	 .loc 3 2193 0
 10767 0010 BD46     	 mov sp,r7
 10768              	 
 10769 0012 80BD     	 pop {r7,pc}
 10770              	 .cfi_endproc
 10771              	.LFE136:
 10773              	 .section .text.ext_interrupt1_enable,"ax",%progbits
 10774              	 .align 2
 10775              	 .global ext_interrupt1_enable
 10776              	 .code 16
 10777              	 .thumb_func
 10779              	ext_interrupt1_enable:
 10780              	.LFB137:
2194:../XMC1100-LibHaas.c **** /*Externen Interrupt1 freigeben --------------------------------------
2195:../XMC1100-LibHaas.c ****    ERU0 Kanal 2B0 -> Eingang P2.10, abfallende Flanke
2196:../XMC1100-LibHaas.c ****    Interrupt-Handler ins eigene Programm kopieren:
2197:../XMC1100-LibHaas.c **** void ERU0_2_IRQHandler(void)	// ext. Int bei an P2.10
2198:../XMC1100-LibHaas.c **** 	{							// Interrupt-Servie-Routine
2199:../XMC1100-LibHaas.c **** 	}*/
2200:../XMC1100-LibHaas.c **** void ext_interrupt1_enable ( void )
2201:../XMC1100-LibHaas.c **** {
 10781              	 .loc 3 2201 0
 10782              	 .cfi_startproc
 10783 0000 80B5     	 push {r7,lr}
 10784              	.LCFI278:
 10785              	 .cfi_def_cfa_offset 8
 10786              	 .cfi_offset 7,-8
 10787              	 .cfi_offset 14,-4
 10788 0002 00AF     	 add r7,sp,#0
 10789              	.LCFI279:
 10790              	 .cfi_def_cfa_register 7
2202:../XMC1100-LibHaas.c **** 	NVIC_EnableIRQ(ERU0_2_IRQn);
 10791              	 .loc 3 2202 0
 10792 0004 0520     	 mov r0,#5
 10793 0006 FFF7FEFF 	 bl __NVIC_EnableIRQ
2203:../XMC1100-LibHaas.c **** }
 10794              	 .loc 3 2203 0
 10795 000a BD46     	 mov sp,r7
 10796              	 
 10797 000c 80BD     	 pop {r7,pc}
 10798              	 .cfi_endproc
 10799              	.LFE137:
 10801 000e C046     	 .section .text.ext_interrupt2_enable,"ax",%progbits
 10802              	 .align 2
 10803              	 .global ext_interrupt2_enable
 10804              	 .code 16
 10805              	 .thumb_func
 10807              	ext_interrupt2_enable:
 10808              	.LFB138:
2204:../XMC1100-LibHaas.c **** /* --------------------------------------------------------------------------
2205:../XMC1100-LibHaas.c ****    Externen Interrupt2 freigeben
2206:../XMC1100-LibHaas.c ****    ERU0 Kanal 3B0 -> Eingang P2.9, steigende Flanke
2207:../XMC1100-LibHaas.c ****    Interrupt-Service-Routinen ins eigene Programm kopieren:
2208:../XMC1100-LibHaas.c **** void ERU0_3_IRQHandler(void)	// ext. Int an P2.9
2209:../XMC1100-LibHaas.c **** 	{							// Interrupt-Servie-Routine
2210:../XMC1100-LibHaas.c **** 	}*/
2211:../XMC1100-LibHaas.c **** void ext_interrupt2_enable ( void )
2212:../XMC1100-LibHaas.c **** {
 10809              	 .loc 3 2212 0
 10810              	 .cfi_startproc
 10811 0000 80B5     	 push {r7,lr}
 10812              	.LCFI280:
 10813              	 .cfi_def_cfa_offset 8
 10814              	 .cfi_offset 7,-8
 10815              	 .cfi_offset 14,-4
 10816 0002 00AF     	 add r7,sp,#0
 10817              	.LCFI281:
 10818              	 .cfi_def_cfa_register 7
2213:../XMC1100-LibHaas.c **** 	NVIC_EnableIRQ(ERU0_3_IRQn);
 10819              	 .loc 3 2213 0
 10820 0004 0620     	 mov r0,#6
 10821 0006 FFF7FEFF 	 bl __NVIC_EnableIRQ
2214:../XMC1100-LibHaas.c **** }
 10822              	 .loc 3 2214 0
 10823 000a BD46     	 mov sp,r7
 10824              	 
 10825 000c 80BD     	 pop {r7,pc}
 10826              	 .cfi_endproc
 10827              	.LFE138:
 10829 000e C046     	 .section .text.ext_interrupt1_disable,"ax",%progbits
 10830              	 .align 2
 10831              	 .global ext_interrupt1_disable
 10832              	 .code 16
 10833              	 .thumb_func
 10835              	ext_interrupt1_disable:
 10836              	.LFB139:
2215:../XMC1100-LibHaas.c **** void ext_interrupt1_disable( void )
2216:../XMC1100-LibHaas.c **** {
 10837              	 .loc 3 2216 0
 10838              	 .cfi_startproc
 10839 0000 80B5     	 push {r7,lr}
 10840              	.LCFI282:
 10841              	 .cfi_def_cfa_offset 8
 10842              	 .cfi_offset 7,-8
 10843              	 .cfi_offset 14,-4
 10844 0002 00AF     	 add r7,sp,#0
 10845              	.LCFI283:
 10846              	 .cfi_def_cfa_register 7
2217:../XMC1100-LibHaas.c **** 	NVIC_DisableIRQ(ERU0_2_IRQn);
 10847              	 .loc 3 2217 0
 10848 0004 0520     	 mov r0,#5
 10849 0006 FFF7FEFF 	 bl __NVIC_DisableIRQ
2218:../XMC1100-LibHaas.c **** }
 10850              	 .loc 3 2218 0
 10851 000a BD46     	 mov sp,r7
 10852              	 
 10853 000c 80BD     	 pop {r7,pc}
 10854              	 .cfi_endproc
 10855              	.LFE139:
 10857 000e C046     	 .section .text.ext_interrupt2_disable,"ax",%progbits
 10858              	 .align 2
 10859              	 .global ext_interrupt2_disable
 10860              	 .code 16
 10861              	 .thumb_func
 10863              	ext_interrupt2_disable:
 10864              	.LFB140:
2219:../XMC1100-LibHaas.c **** void ext_interrupt2_disable( void )
2220:../XMC1100-LibHaas.c **** {
 10865              	 .loc 3 2220 0
 10866              	 .cfi_startproc
 10867 0000 80B5     	 push {r7,lr}
 10868              	.LCFI284:
 10869              	 .cfi_def_cfa_offset 8
 10870              	 .cfi_offset 7,-8
 10871              	 .cfi_offset 14,-4
 10872 0002 00AF     	 add r7,sp,#0
 10873              	.LCFI285:
 10874              	 .cfi_def_cfa_register 7
2221:../XMC1100-LibHaas.c **** 	NVIC_DisableIRQ(ERU0_3_IRQn);
 10875              	 .loc 3 2221 0
 10876 0004 0620     	 mov r0,#6
 10877 0006 FFF7FEFF 	 bl __NVIC_DisableIRQ
2222:../XMC1100-LibHaas.c **** }
 10878              	 .loc 3 2222 0
 10879 000a BD46     	 mov sp,r7
 10880              	 
 10881 000c 80BD     	 pop {r7,pc}
 10882              	 .cfi_endproc
 10883              	.LFE140:
 10885 000e C046     	 .section .text.ext_interrupt1_prioritaet,"ax",%progbits
 10886              	 .align 2
 10887              	 .global ext_interrupt1_prioritaet
 10888              	 .code 16
 10889              	 .thumb_func
 10891              	ext_interrupt1_prioritaet:
 10892              	.LFB141:
2223:../XMC1100-LibHaas.c **** 
2224:../XMC1100-LibHaas.c **** void ext_interrupt1_prioritaet(uint8_t prio) {
 10893              	 .loc 3 2224 0
 10894              	 .cfi_startproc
 10895 0000 80B5     	 push {r7,lr}
 10896              	.LCFI286:
 10897              	 .cfi_def_cfa_offset 8
 10898              	 .cfi_offset 7,-8
 10899              	 .cfi_offset 14,-4
 10900 0002 82B0     	 sub sp,sp,#8
 10901              	.LCFI287:
 10902              	 .cfi_def_cfa_offset 16
 10903 0004 00AF     	 add r7,sp,#0
 10904              	.LCFI288:
 10905              	 .cfi_def_cfa_register 7
 10906 0006 021C     	 mov r2,r0
 10907 0008 FB1D     	 add r3,r7,#7
 10908 000a 1A70     	 strb r2,[r3]
2225:../XMC1100-LibHaas.c **** 	if (prio < 4) NVIC_SetPriority(ERU0_2_IRQn,prio);
 10909              	 .loc 3 2225 0
 10910 000c FB1D     	 add r3,r7,#7
 10911 000e 1B78     	 ldrb r3,[r3]
 10912 0010 032B     	 cmp r3,#3
 10913 0012 05D8     	 bhi .L535
 10914              	 .loc 3 2225 0 is_stmt 0 discriminator 1
 10915 0014 FB1D     	 add r3,r7,#7
 10916 0016 1B78     	 ldrb r3,[r3]
 10917 0018 0520     	 mov r0,#5
 10918 001a 191C     	 mov r1,r3
 10919 001c FFF7FEFF 	 bl __NVIC_SetPriority
 10920              	.L535:
2226:../XMC1100-LibHaas.c **** }
 10921              	 .loc 3 2226 0 is_stmt 1
 10922 0020 BD46     	 mov sp,r7
 10923 0022 02B0     	 add sp,sp,#8
 10924              	 
 10925 0024 80BD     	 pop {r7,pc}
 10926              	 .cfi_endproc
 10927              	.LFE141:
 10929 0026 C046     	 .section .text.ext_interrupt2_prioritaet,"ax",%progbits
 10930              	 .align 2
 10931              	 .global ext_interrupt2_prioritaet
 10932              	 .code 16
 10933              	 .thumb_func
 10935              	ext_interrupt2_prioritaet:
 10936              	.LFB142:
2227:../XMC1100-LibHaas.c **** 
2228:../XMC1100-LibHaas.c **** void ext_interrupt2_prioritaet(uint8_t prio) {
 10937              	 .loc 3 2228 0
 10938              	 .cfi_startproc
 10939 0000 80B5     	 push {r7,lr}
 10940              	.LCFI289:
 10941              	 .cfi_def_cfa_offset 8
 10942              	 .cfi_offset 7,-8
 10943              	 .cfi_offset 14,-4
 10944 0002 82B0     	 sub sp,sp,#8
 10945              	.LCFI290:
 10946              	 .cfi_def_cfa_offset 16
 10947 0004 00AF     	 add r7,sp,#0
 10948              	.LCFI291:
 10949              	 .cfi_def_cfa_register 7
 10950 0006 021C     	 mov r2,r0
 10951 0008 FB1D     	 add r3,r7,#7
 10952 000a 1A70     	 strb r2,[r3]
2229:../XMC1100-LibHaas.c **** 	if (prio < 4) NVIC_SetPriority(ERU0_3_IRQn,prio);
 10953              	 .loc 3 2229 0
 10954 000c FB1D     	 add r3,r7,#7
 10955 000e 1B78     	 ldrb r3,[r3]
 10956 0010 032B     	 cmp r3,#3
 10957 0012 05D8     	 bhi .L537
 10958              	 .loc 3 2229 0 is_stmt 0 discriminator 1
 10959 0014 FB1D     	 add r3,r7,#7
 10960 0016 1B78     	 ldrb r3,[r3]
 10961 0018 0620     	 mov r0,#6
 10962 001a 191C     	 mov r1,r3
 10963 001c FFF7FEFF 	 bl __NVIC_SetPriority
 10964              	.L537:
2230:../XMC1100-LibHaas.c **** }
 10965              	 .loc 3 2230 0 is_stmt 1
 10966 0020 BD46     	 mov sp,r7
 10967 0022 02B0     	 add sp,sp,#8
 10968              	 
 10969 0024 80BD     	 pop {r7,pc}
 10970              	 .cfi_endproc
 10971              	.LFE142:
 10973 0026 C046     	 .section .text.ext_clear_IRQ,"ax",%progbits
 10974              	 .align 2
 10975              	 .global ext_clear_IRQ
 10976              	 .code 16
 10977              	 .thumb_func
 10979              	ext_clear_IRQ:
 10980              	.LFB143:
2231:../XMC1100-LibHaas.c **** //NVIC_SetPriority(ERU0_2_IRQn,0);
2232:../XMC1100-LibHaas.c **** //***********************************************
2233:../XMC1100-LibHaas.c **** /*Interrupt-Service-Routinen*/
2234:../XMC1100-LibHaas.c **** // void ERU0_2_IRQHandler(void)// P2.10
2235:../XMC1100-LibHaas.c **** //{
2236:../XMC1100-LibHaas.c **** 			// Interrupt-Servie-Routine
2237:../XMC1100-LibHaas.c **** //}
2238:../XMC1100-LibHaas.c **** //**********************************************
2239:../XMC1100-LibHaas.c **** //void ERU0_3_IRQHandler(void) // P2.9
2240:../XMC1100-LibHaas.c **** //{
2241:../XMC1100-LibHaas.c **** 			// Interrupt-Servie-Routine
2242:../XMC1100-LibHaas.c **** //}
2243:../XMC1100-LibHaas.c **** //neu
2244:../XMC1100-LibHaas.c **** /***********************************************
2245:../XMC1100-LibHaas.c ****  * löscht Interrupt-Anforderungsbit
2246:../XMC1100-LibHaas.c ****  * IRQ1 für Interrupt 1
2247:../XMC1100-LibHaas.c ****  * IRQ2 für Interrupt 2
2248:../XMC1100-LibHaas.c ****  */
2249:../XMC1100-LibHaas.c **** void ext_clear_IRQ(uint8_t interruptquelle)
2250:../XMC1100-LibHaas.c **** {
 10981              	 .loc 3 2250 0
 10982              	 .cfi_startproc
 10983 0000 80B5     	 push {r7,lr}
 10984              	.LCFI292:
 10985              	 .cfi_def_cfa_offset 8
 10986              	 .cfi_offset 7,-8
 10987              	 .cfi_offset 14,-4
 10988 0002 82B0     	 sub sp,sp,#8
 10989              	.LCFI293:
 10990              	 .cfi_def_cfa_offset 16
 10991 0004 00AF     	 add r7,sp,#0
 10992              	.LCFI294:
 10993              	 .cfi_def_cfa_register 7
 10994 0006 021C     	 mov r2,r0
 10995 0008 FB1D     	 add r3,r7,#7
 10996 000a 1A70     	 strb r2,[r3]
2251:../XMC1100-LibHaas.c ****   if (interruptquelle== IRQ1) {
 10997              	 .loc 3 2251 0
 10998 000c FB1D     	 add r3,r7,#7
 10999 000e 1B78     	 ldrb r3,[r3]
 11000 0010 012B     	 cmp r3,#1
 11001 0012 03D1     	 bne .L540
2252:../XMC1100-LibHaas.c **** 	  NVIC_ClearPendingIRQ(ERU0_2_IRQn);
 11002              	 .loc 3 2252 0
 11003 0014 0520     	 mov r0,#5
 11004 0016 FFF7FEFF 	 bl __NVIC_ClearPendingIRQ
 11005 001a 02E0     	 b .L539
 11006              	.L540:
2253:../XMC1100-LibHaas.c ****   } else {
2254:../XMC1100-LibHaas.c **** 	  NVIC_ClearPendingIRQ(ERU0_3_IRQn);
 11007              	 .loc 3 2254 0
 11008 001c 0620     	 mov r0,#6
 11009 001e FFF7FEFF 	 bl __NVIC_ClearPendingIRQ
 11010              	.L539:
2255:../XMC1100-LibHaas.c ****   }
2256:../XMC1100-LibHaas.c **** }
 11011              	 .loc 3 2256 0
 11012 0022 BD46     	 mov sp,r7
 11013 0024 02B0     	 add sp,sp,#8
 11014              	 
 11015 0026 80BD     	 pop {r7,pc}
 11016              	 .cfi_endproc
 11017              	.LFE143:
 11019              	 .section .text.timer1ms_init,"ax",%progbits
 11020              	 .align 2
 11021              	 .global timer1ms_init
 11022              	 .code 16
 11023              	 .thumb_func
 11025              	timer1ms_init:
 11026              	.LFB144:
2257:../XMC1100-LibHaas.c **** 
2258:../XMC1100-LibHaas.c **** 
2259:../XMC1100-LibHaas.c **** 
2260:../XMC1100-LibHaas.c **** 
2261:../XMC1100-LibHaas.c **** /*///////////////////// Achtung!!!!! //////////////////////
2262:../XMC1100-LibHaas.c **** Bei der gleichzeitigen Verwendung von Timer und PWM muss darauf
2263:../XMC1100-LibHaas.c **** geachtet werden, dass nicht die gleiche CCU40-CCx benutzt wird.
2264:../XMC1100-LibHaas.c **** ///////////////////////////////////////////////////////////*/
2265:../XMC1100-LibHaas.c **** 
2266:../XMC1100-LibHaas.c **** /* --------------------------------------------------------
2267:../XMC1100-LibHaas.c ****    Timer-Interrupt 1ms initialisieren
2268:../XMC1100-LibHaas.c ****    Timer-Interrupt-Handler ins eigene Programm kopieren:
2269:../XMC1100-LibHaas.c **** void CCU40_3_IRQHandler (void)  // Timer-Interrupt jede 1 ms
2270:../XMC1100-LibHaas.c **** 	{
2271:../XMC1100-LibHaas.c **** 								// Interrupt-Servie-Routine
2272:../XMC1100-LibHaas.c ****     }
2273:../XMC1100-LibHaas.c ****  */
2274:../XMC1100-LibHaas.c **** void timer1ms_init ( void )
2275:../XMC1100-LibHaas.c **** {
 11027              	 .loc 3 2275 0
 11028              	 .cfi_startproc
 11029 0000 80B5     	 push {r7,lr}
 11030              	.LCFI295:
 11031              	 .cfi_def_cfa_offset 8
 11032              	 .cfi_offset 7,-8
 11033              	 .cfi_offset 14,-4
 11034 0002 00AF     	 add r7,sp,#0
 11035              	.LCFI296:
 11036              	 .cfi_def_cfa_register 7
2276:../XMC1100-LibHaas.c **** 	clock_init();
 11037              	 .loc 3 2276 0
 11038 0004 FFF7FEFF 	 bl clock_init
2277:../XMC1100-LibHaas.c **** 	SCU_GENERAL->CCUCON |= 1;	// Enable CCU40 Modul
 11039              	 .loc 3 2277 0
 11040 0008 174B     	 ldr r3,.L543
 11041 000a 174A     	 ldr r2,.L543
 11042 000c 126B     	 ldr r2,[r2,#48]
 11043 000e 0121     	 mov r1,#1
 11044 0010 0A43     	 orr r2,r1
 11045 0012 1A63     	 str r2,[r3,#48]
2278:../XMC1100-LibHaas.c **** 			// CCU43 Init:
2279:../XMC1100-LibHaas.c **** 	CCU40->GIDLC 	= 0x10F; 	//Vorteiler enable für alle Timer , IDLE clear
 11046              	 .loc 3 2279 0
 11047 0014 154B     	 ldr r3,.L543+4
 11048 0016 1022     	 mov r2,#16
 11049 0018 FF32     	 add r2,r2,#255
 11050 001a DA60     	 str r2,[r3,#12]
2280:../XMC1100-LibHaas.c **** 	CCU40_CC43->TC	= 0x08;		//Shadow transfer enable
 11051              	 .loc 3 2280 0
 11052 001c 144B     	 ldr r3,.L543+8
 11053 001e 0822     	 mov r2,#8
 11054 0020 5A61     	 str r2,[r3,#20]
2281:../XMC1100-LibHaas.c **** 	CCU40_CC43->PSC = 0x1;		// Vorteiler , hier 64Mhz/2 => 32 MHzclock
 11055              	 .loc 3 2281 0
 11056 0022 134B     	 ldr r3,.L543+8
 11057 0024 0122     	 mov r2,#1
 11058 0026 5A62     	 str r2,[r3,#36]
2282:../XMC1100-LibHaas.c **** 	CCU40_CC43->PRS	= 32000;	//Period Register für 1ms
 11059              	 .loc 3 2282 0
 11060 0028 114B     	 ldr r3,.L543+8
 11061 002a FA22     	 mov r2,#250
 11062 002c D201     	 lsl r2,r2,#7
 11063 002e 5A63     	 str r2,[r3,#52]
2283:../XMC1100-LibHaas.c **** 	CCU40->GCSS = 0b001 << 12; 	//Shadow transfer request  Timer CCU40->CC43
 11064              	 .loc 3 2283 0
 11065 0030 0E4B     	 ldr r3,.L543+4
 11066 0032 8022     	 mov r2,#128
 11067 0034 5201     	 lsl r2,r2,#5
 11068 0036 1A61     	 str r2,[r3,#16]
2284:../XMC1100-LibHaas.c **** 	CCU40_CC43->TCSET = 1; 		//starts counting
 11069              	 .loc 3 2284 0
 11070 0038 0D4B     	 ldr r3,.L543+8
 11071 003a 0122     	 mov r2,#1
 11072 003c DA60     	 str r2,[r3,#12]
2285:../XMC1100-LibHaas.c **** 	// Interrupt Freigaben:
2286:../XMC1100-LibHaas.c **** 	CCU40_CC43->SRS |= 0b11;	// Service Req. Line 3
 11073              	 .loc 3 2286 0
 11074 003e 0C49     	 ldr r1,.L543+8
 11075 0040 0B4A     	 ldr r2,.L543+8
 11076 0042 A823     	 mov r3,#168
 11077 0044 D358     	 ldr r3,[r2,r3]
 11078 0046 0322     	 mov r2,#3
 11079 0048 1343     	 orr r3,r2
 11080 004a A822     	 mov r2,#168
 11081 004c 8B50     	 str r3,[r1,r2]
2287:../XMC1100-LibHaas.c **** 	CCU40_CC43->INTE |= 1;		// PME => Period match  Int. enable
 11082              	 .loc 3 2287 0
 11083 004e 0849     	 ldr r1,.L543+8
 11084 0050 074A     	 ldr r2,.L543+8
 11085 0052 A423     	 mov r3,#164
 11086 0054 D358     	 ldr r3,[r2,r3]
 11087 0056 0122     	 mov r2,#1
 11088 0058 1343     	 orr r3,r2
 11089 005a A422     	 mov r2,#164
 11090 005c 8B50     	 str r3,[r1,r2]
2288:../XMC1100-LibHaas.c **** 	NVIC_EnableIRQ(CCU40_3_IRQn);  // Freigabe CCU40SR3
 11091              	 .loc 3 2288 0
 11092 005e 1820     	 mov r0,#24
 11093 0060 FFF7FEFF 	 bl __NVIC_EnableIRQ
2289:../XMC1100-LibHaas.c **** }
 11094              	 .loc 3 2289 0
 11095 0064 BD46     	 mov sp,r7
 11096              	 
 11097 0066 80BD     	 pop {r7,pc}
 11098              	.L544:
 11099              	 .align 2
 11100              	.L543:
 11101 0068 00000140 	 .word 1073807360
 11102 006c 00000448 	 .word 1208221696
 11103 0070 00040448 	 .word 1208222720
 11104              	 .cfi_endproc
 11105              	.LFE144:
 11107              	 .section .text.timer1ms_enable,"ax",%progbits
 11108              	 .align 2
 11109              	 .global timer1ms_enable
 11110              	 .code 16
 11111              	 .thumb_func
 11113              	timer1ms_enable:
 11114              	.LFB145:
2290:../XMC1100-LibHaas.c **** /* wie timer_start_interrupt();
2291:../XMC1100-LibHaas.c ****    Timer-Interrupt-Handler ins eigene Programm kopieren:
2292:../XMC1100-LibHaas.c **** 	void CCU40_3_IRQHandler (void)  // Timer-Interrupt nach eingestellter Periodendauer
2293:../XMC1100-LibHaas.c **** 		{
2294:../XMC1100-LibHaas.c **** 								// Interrupt-Servie-Routine
2295:../XMC1100-LibHaas.c ****     	}*/
2296:../XMC1100-LibHaas.c **** /* Timer-Interrupt freigeben */
2297:../XMC1100-LibHaas.c **** void timer1ms_enable ( void )
2298:../XMC1100-LibHaas.c **** {
 11115              	 .loc 3 2298 0
 11116              	 .cfi_startproc
 11117 0000 80B5     	 push {r7,lr}
 11118              	.LCFI297:
 11119              	 .cfi_def_cfa_offset 8
 11120              	 .cfi_offset 7,-8
 11121              	 .cfi_offset 14,-4
 11122 0002 00AF     	 add r7,sp,#0
 11123              	.LCFI298:
 11124              	 .cfi_def_cfa_register 7
2299:../XMC1100-LibHaas.c **** 	CCU40_CC43->TCSET = 1; 			//starts counting
 11125              	 .loc 3 2299 0
 11126 0004 074B     	 ldr r3,.L546
 11127 0006 0122     	 mov r2,#1
 11128 0008 DA60     	 str r2,[r3,#12]
2300:../XMC1100-LibHaas.c **** 		// Interrupt Freigaben:
2301:../XMC1100-LibHaas.c **** 	CCU40_CC43->INTE |= 1;			// PME => Period match  Int. enable
 11129              	 .loc 3 2301 0
 11130 000a 0649     	 ldr r1,.L546
 11131 000c 054A     	 ldr r2,.L546
 11132 000e A423     	 mov r3,#164
 11133 0010 D358     	 ldr r3,[r2,r3]
 11134 0012 0122     	 mov r2,#1
 11135 0014 1343     	 orr r3,r2
 11136 0016 A422     	 mov r2,#164
 11137 0018 8B50     	 str r3,[r1,r2]
2302:../XMC1100-LibHaas.c **** 	NVIC_EnableIRQ(CCU40_3_IRQn);  // Freigabe CCU40SR0
 11138              	 .loc 3 2302 0
 11139 001a 1820     	 mov r0,#24
 11140 001c FFF7FEFF 	 bl __NVIC_EnableIRQ
2303:../XMC1100-LibHaas.c **** }
 11141              	 .loc 3 2303 0
 11142 0020 BD46     	 mov sp,r7
 11143              	 
 11144 0022 80BD     	 pop {r7,pc}
 11145              	.L547:
 11146              	 .align 2
 11147              	.L546:
 11148 0024 00040448 	 .word 1208222720
 11149              	 .cfi_endproc
 11150              	.LFE145:
 11152              	 .section .text.timer1ms_disable,"ax",%progbits
 11153              	 .align 2
 11154              	 .global timer1ms_disable
 11155              	 .code 16
 11156              	 .thumb_func
 11158              	timer1ms_disable:
 11159              	.LFB146:
2304:../XMC1100-LibHaas.c **** 
2305:../XMC1100-LibHaas.c **** void timer1ms_disable ( void )
2306:../XMC1100-LibHaas.c **** {
 11160              	 .loc 3 2306 0
 11161              	 .cfi_startproc
 11162 0000 80B5     	 push {r7,lr}
 11163              	.LCFI299:
 11164              	 .cfi_def_cfa_offset 8
 11165              	 .cfi_offset 7,-8
 11166              	 .cfi_offset 14,-4
 11167 0002 00AF     	 add r7,sp,#0
 11168              	.LCFI300:
 11169              	 .cfi_def_cfa_register 7
2307:../XMC1100-LibHaas.c **** 	CCU40_CC43->TCCLR = 1; 			//stop counting
 11170              	 .loc 3 2307 0
 11171 0004 024B     	 ldr r3,.L549
 11172 0006 0122     	 mov r2,#1
 11173 0008 1A61     	 str r2,[r3,#16]
2308:../XMC1100-LibHaas.c **** }
 11174              	 .loc 3 2308 0
 11175 000a BD46     	 mov sp,r7
 11176              	 
 11177 000c 80BD     	 pop {r7,pc}
 11178              	.L550:
 11179 000e C046     	 .align 2
 11180              	.L549:
 11181 0010 00040448 	 .word 1208222720
 11182              	 .cfi_endproc
 11183              	.LFE146:
 11185              	 .section .text.timer_init,"ax",%progbits
 11186              	 .align 2
 11187              	 .global timer_init
 11188              	 .code 16
 11189              	 .thumb_func
 11191              	timer_init:
 11192              	.LFB147:
2309:../XMC1100-LibHaas.c **** //***********  Timer ISR : *******************************
2310:../XMC1100-LibHaas.c **** //void CCU40_3_IRQHandler (void)
2311:../XMC1100-LibHaas.c **** //{
2312:../XMC1100-LibHaas.c **** 									// Interrupt-Servie-Routine
2313:../XMC1100-LibHaas.c **** // }
2314:../XMC1100-LibHaas.c **** 
2315:../XMC1100-LibHaas.c **** /* ---------------------------------------alte Funktion
2316:../XMC1100-LibHaas.c **** Zeitmessfunktionen mit Timer CCU40_CC43
2317:../XMC1100-LibHaas.c **** kann anstelle der 1ms Sek Funktion benutzt werden
2318:../XMC1100-LibHaas.c **** Hinweis: zusätzlich verwenden: timer_start();timer_stop();timer_value();
2319:../XMC1100-LibHaas.c **** void timer_init(uint8_t teiler)
2320:../XMC1100-LibHaas.c **** {	teiler %= 0x10;				// max. 15
2321:../XMC1100-LibHaas.c **** 	clock_init();
2322:../XMC1100-LibHaas.c **** 	SCU_GENERAL->CCUCON |= 1;	// Enable CCU40 Modul
2323:../XMC1100-LibHaas.c **** 				// CCU43 Init:
2324:../XMC1100-LibHaas.c **** 	CCU40->GIDLC 	= 0x10F; 	// Vorteiler enable für alle Timer , IDLE clear
2325:../XMC1100-LibHaas.c **** 	CCU40_CC43->TC	= 0x08;		// Shadow transfer enable
2326:../XMC1100-LibHaas.c **** 	CCU40_CC43->PSC = teiler;	// Vorteiler , hier 64Mhz/2 => 32 MHzclock
2327:../XMC1100-LibHaas.c **** 	CCU40_CC43->PRS	= 0xffff;	// Period Register für 1ms
2328:../XMC1100-LibHaas.c **** 	CCU40->GCSS = 0b001 <<12 ; 	// Shadow transfer request  Timer
2329:../XMC1100-LibHaas.c **** }*/
2330:../XMC1100-LibHaas.c **** /* ---------------------------------------------------------------------
2331:../XMC1100-LibHaas.c **** Initialisierung Timer CCU40_CC43, vorteiler 0...15 ergibt Teilung mit 2^vorteiler
2332:../XMC1100-LibHaas.c ****                                   periode 1...65536, 64MHz-Takt
2333:../XMC1100-LibHaas.c **** Hinweise: Für Zeitmessungen zusätzlich verwenden:
2334:../XMC1100-LibHaas.c **** timer_start();timer_stop();timer_value(); timer_reset();
2335:../XMC1100-LibHaas.c **** Für timergesteuerte Interrupts zusätzlich verwenden:
2336:../XMC1100-LibHaas.c **** timer_start_interrupt();
2337:../XMC1100-LibHaas.c **** Timer-Interrupt-Handler ins eigene Programm kopieren:
2338:../XMC1100-LibHaas.c **** 	void CCU40_3_IRQHandler (void)  // Timer-Interrupt nach eingestellter Periodendauer
2339:../XMC1100-LibHaas.c **** 		{							// Interrupt-Servie-Routine
2340:../XMC1100-LibHaas.c ****     	} */
2341:../XMC1100-LibHaas.c **** void timer_init(uint8_t vorteiler, uint16_t periode)
2342:../XMC1100-LibHaas.c **** {	vorteiler %= 0x10;				// max. 15
 11193              	 .loc 3 2342 0
 11194              	 .cfi_startproc
 11195 0000 80B5     	 push {r7,lr}
 11196              	.LCFI301:
 11197              	 .cfi_def_cfa_offset 8
 11198              	 .cfi_offset 7,-8
 11199              	 .cfi_offset 14,-4
 11200 0002 82B0     	 sub sp,sp,#8
 11201              	.LCFI302:
 11202              	 .cfi_def_cfa_offset 16
 11203 0004 00AF     	 add r7,sp,#0
 11204              	.LCFI303:
 11205              	 .cfi_def_cfa_register 7
 11206 0006 021C     	 mov r2,r0
 11207 0008 FB1D     	 add r3,r7,#7
 11208 000a 1A70     	 strb r2,[r3]
 11209 000c 3B1D     	 add r3,r7,#4
 11210 000e 0A1C     	 add r2,r1,#0
 11211 0010 1A80     	 strh r2,[r3]
 11212              	 .loc 3 2342 0
 11213 0012 FB1D     	 add r3,r7,#7
 11214 0014 FA1D     	 add r2,r7,#7
 11215 0016 1278     	 ldrb r2,[r2]
 11216 0018 0F21     	 mov r1,#15
 11217 001a 0A40     	 and r2,r1
 11218 001c 1A70     	 strb r2,[r3]
2343:../XMC1100-LibHaas.c **** 	clock_init();
 11219              	 .loc 3 2343 0
 11220 001e FFF7FEFF 	 bl clock_init
2344:../XMC1100-LibHaas.c **** 	SCU_GENERAL->CCUCON |= 1;	// Enable CCU40 Modul
 11221              	 .loc 3 2344 0
 11222 0022 0E4B     	 ldr r3,.L552
 11223 0024 0D4A     	 ldr r2,.L552
 11224 0026 126B     	 ldr r2,[r2,#48]
 11225 0028 0121     	 mov r1,#1
 11226 002a 0A43     	 orr r2,r1
 11227 002c 1A63     	 str r2,[r3,#48]
2345:../XMC1100-LibHaas.c **** 				// CCU43 Init:
2346:../XMC1100-LibHaas.c **** 	CCU40->GIDLC 	= 0x10F; 	// Vorteiler enable für alle Timer , IDLE clear
 11228              	 .loc 3 2346 0
 11229 002e 0C4B     	 ldr r3,.L552+4
 11230 0030 1022     	 mov r2,#16
 11231 0032 FF32     	 add r2,r2,#255
 11232 0034 DA60     	 str r2,[r3,#12]
2347:../XMC1100-LibHaas.c **** 	CCU40_CC43->TC	= 0x08;		// Shadow transfer enable
 11233              	 .loc 3 2347 0
 11234 0036 0B4B     	 ldr r3,.L552+8
 11235 0038 0822     	 mov r2,#8
 11236 003a 5A61     	 str r2,[r3,#20]
2348:../XMC1100-LibHaas.c **** 	CCU40_CC43->PSC = vorteiler;	// Vorteiler , hier 64Mhz/2 hoch Vorteiler
 11237              	 .loc 3 2348 0
 11238 003c 094B     	 ldr r3,.L552+8
 11239 003e FA1D     	 add r2,r7,#7
 11240 0040 1278     	 ldrb r2,[r2]
 11241 0042 5A62     	 str r2,[r3,#36]
2349:../XMC1100-LibHaas.c **** 	CCU40_CC43->PRS	= periode;	// Period Register
 11242              	 .loc 3 2349 0
 11243 0044 074B     	 ldr r3,.L552+8
 11244 0046 3A1D     	 add r2,r7,#4
 11245 0048 1288     	 ldrh r2,[r2]
 11246 004a 5A63     	 str r2,[r3,#52]
2350:../XMC1100-LibHaas.c **** 	CCU40->GCSS = 0b001 <<12 ; 	// Shadow transfer request  Timer
 11247              	 .loc 3 2350 0
 11248 004c 044B     	 ldr r3,.L552+4
 11249 004e 8022     	 mov r2,#128
 11250 0050 5201     	 lsl r2,r2,#5
 11251 0052 1A61     	 str r2,[r3,#16]
2351:../XMC1100-LibHaas.c **** }
 11252              	 .loc 3 2351 0
 11253 0054 BD46     	 mov sp,r7
 11254 0056 02B0     	 add sp,sp,#8
 11255              	 
 11256 0058 80BD     	 pop {r7,pc}
 11257              	.L553:
 11258 005a C046     	 .align 2
 11259              	.L552:
 11260 005c 00000140 	 .word 1073807360
 11261 0060 00000448 	 .word 1208221696
 11262 0064 00040448 	 .word 1208222720
 11263              	 .cfi_endproc
 11264              	.LFE147:
 11266              	 .section .text.timer_start,"ax",%progbits
 11267              	 .align 2
 11268              	 .global timer_start
 11269              	 .code 16
 11270              	 .thumb_func
 11272              	timer_start:
 11273              	.LFB148:
2352:../XMC1100-LibHaas.c **** 
2353:../XMC1100-LibHaas.c **** 
2354:../XMC1100-LibHaas.c **** // Timer für Zeitmessung starten
2355:../XMC1100-LibHaas.c **** void timer_start(void)
2356:../XMC1100-LibHaas.c **** {
 11274              	 .loc 3 2356 0
 11275              	 .cfi_startproc
 11276 0000 80B5     	 push {r7,lr}
 11277              	.LCFI304:
 11278              	 .cfi_def_cfa_offset 8
 11279              	 .cfi_offset 7,-8
 11280              	 .cfi_offset 14,-4
 11281 0002 00AF     	 add r7,sp,#0
 11282              	.LCFI305:
 11283              	 .cfi_def_cfa_register 7
2357:../XMC1100-LibHaas.c **** 	CCU40_CC43->TCSET = 1; 		//starts counting
 11284              	 .loc 3 2357 0
 11285 0004 024B     	 ldr r3,.L555
 11286 0006 0122     	 mov r2,#1
 11287 0008 DA60     	 str r2,[r3,#12]
2358:../XMC1100-LibHaas.c **** }
 11288              	 .loc 3 2358 0
 11289 000a BD46     	 mov sp,r7
 11290              	 
 11291 000c 80BD     	 pop {r7,pc}
 11292              	.L556:
 11293 000e C046     	 .align 2
 11294              	.L555:
 11295 0010 00040448 	 .word 1208222720
 11296              	 .cfi_endproc
 11297              	.LFE148:
 11299              	 .section .text.timer_start_interrupt,"ax",%progbits
 11300              	 .align 2
 11301              	 .global timer_start_interrupt
 11302              	 .code 16
 11303              	 .thumb_func
 11305              	timer_start_interrupt:
 11306              	.LFB149:
2359:../XMC1100-LibHaas.c **** /* Timer starten mit Interruptfreigabe
2360:../XMC1100-LibHaas.c ****    Timer-Interrupt-Handler ins eigene Programm kopieren:
2361:../XMC1100-LibHaas.c **** void CCU40_3_IRQHandler (void)  // Timer-Interrupt nach eingestellter Periodendauer
2362:../XMC1100-LibHaas.c **** {
2363:../XMC1100-LibHaas.c **** 						// Interrupt-Servie-Routine
2364:../XMC1100-LibHaas.c **** } */
2365:../XMC1100-LibHaas.c **** void timer_start_interrupt(void)
2366:../XMC1100-LibHaas.c **** {
 11307              	 .loc 3 2366 0
 11308              	 .cfi_startproc
 11309 0000 80B5     	 push {r7,lr}
 11310              	.LCFI306:
 11311              	 .cfi_def_cfa_offset 8
 11312              	 .cfi_offset 7,-8
 11313              	 .cfi_offset 14,-4
 11314 0002 00AF     	 add r7,sp,#0
 11315              	.LCFI307:
 11316              	 .cfi_def_cfa_register 7
2367:../XMC1100-LibHaas.c **** 	CCU40_CC43->TCSET = 1; 		//starts counting
 11317              	 .loc 3 2367 0
 11318 0004 0B4B     	 ldr r3,.L558
 11319 0006 0122     	 mov r2,#1
 11320 0008 DA60     	 str r2,[r3,#12]
2368:../XMC1100-LibHaas.c **** 	// Interrupt Freigaben:
2369:../XMC1100-LibHaas.c **** 	CCU40_CC43->SRS |= 0b11;	// Service Req. Line 3
 11321              	 .loc 3 2369 0
 11322 000a 0A49     	 ldr r1,.L558
 11323 000c 094A     	 ldr r2,.L558
 11324 000e A823     	 mov r3,#168
 11325 0010 D358     	 ldr r3,[r2,r3]
 11326 0012 0322     	 mov r2,#3
 11327 0014 1343     	 orr r3,r2
 11328 0016 A822     	 mov r2,#168
 11329 0018 8B50     	 str r3,[r1,r2]
2370:../XMC1100-LibHaas.c **** 	CCU40_CC43->INTE |= 1;		// PME => Period match  Int. enable
 11330              	 .loc 3 2370 0
 11331 001a 0649     	 ldr r1,.L558
 11332 001c 054A     	 ldr r2,.L558
 11333 001e A423     	 mov r3,#164
 11334 0020 D358     	 ldr r3,[r2,r3]
 11335 0022 0122     	 mov r2,#1
 11336 0024 1343     	 orr r3,r2
 11337 0026 A422     	 mov r2,#164
 11338 0028 8B50     	 str r3,[r1,r2]
2371:../XMC1100-LibHaas.c **** 	NVIC_EnableIRQ(CCU40_3_IRQn);  // Freigabe CCU40SR3
 11339              	 .loc 3 2371 0
 11340 002a 1820     	 mov r0,#24
 11341 002c FFF7FEFF 	 bl __NVIC_EnableIRQ
2372:../XMC1100-LibHaas.c **** }
 11342              	 .loc 3 2372 0
 11343 0030 BD46     	 mov sp,r7
 11344              	 
 11345 0032 80BD     	 pop {r7,pc}
 11346              	.L559:
 11347              	 .align 2
 11348              	.L558:
 11349 0034 00040448 	 .word 1208222720
 11350              	 .cfi_endproc
 11351              	.LFE149:
 11353              	 .section .text.timer_stop,"ax",%progbits
 11354              	 .align 2
 11355              	 .global timer_stop
 11356              	 .code 16
 11357              	 .thumb_func
 11359              	timer_stop:
 11360              	.LFB150:
2373:../XMC1100-LibHaas.c **** 
2374:../XMC1100-LibHaas.c **** // Timer stoppen
2375:../XMC1100-LibHaas.c **** void timer_stop(void)
2376:../XMC1100-LibHaas.c **** {
 11361              	 .loc 3 2376 0
 11362              	 .cfi_startproc
 11363 0000 80B5     	 push {r7,lr}
 11364              	.LCFI308:
 11365              	 .cfi_def_cfa_offset 8
 11366              	 .cfi_offset 7,-8
 11367              	 .cfi_offset 14,-4
 11368 0002 00AF     	 add r7,sp,#0
 11369              	.LCFI309:
 11370              	 .cfi_def_cfa_register 7
2377:../XMC1100-LibHaas.c **** 	CCU40_CC43->TCCLR = 0x1;	// Timer stop
 11371              	 .loc 3 2377 0
 11372 0004 024B     	 ldr r3,.L561
 11373 0006 0122     	 mov r2,#1
 11374 0008 1A61     	 str r2,[r3,#16]
2378:../XMC1100-LibHaas.c **** }
 11375              	 .loc 3 2378 0
 11376 000a BD46     	 mov sp,r7
 11377              	 
 11378 000c 80BD     	 pop {r7,pc}
 11379              	.L562:
 11380 000e C046     	 .align 2
 11381              	.L561:
 11382 0010 00040448 	 .word 1208222720
 11383              	 .cfi_endproc
 11384              	.LFE150:
 11386              	 .section .text.timer_value,"ax",%progbits
 11387              	 .align 2
 11388              	 .global timer_value
 11389              	 .code 16
 11390              	 .thumb_func
 11392              	timer_value:
 11393              	.LFB151:
2379:../XMC1100-LibHaas.c **** // Timerwert lesen
2380:../XMC1100-LibHaas.c **** uint16_t timer_value(void)
2381:../XMC1100-LibHaas.c **** {
 11394              	 .loc 3 2381 0
 11395              	 .cfi_startproc
 11396 0000 80B5     	 push {r7,lr}
 11397              	.LCFI310:
 11398              	 .cfi_def_cfa_offset 8
 11399              	 .cfi_offset 7,-8
 11400              	 .cfi_offset 14,-4
 11401 0002 82B0     	 sub sp,sp,#8
 11402              	.LCFI311:
 11403              	 .cfi_def_cfa_offset 16
 11404 0004 00AF     	 add r7,sp,#0
 11405              	.LCFI312:
 11406              	 .cfi_def_cfa_register 7
2382:../XMC1100-LibHaas.c **** 	uint16_t wert;
2383:../XMC1100-LibHaas.c **** 	wert = CCU40_CC43->TIMER;
 11407              	 .loc 3 2383 0
 11408 0006 054B     	 ldr r3,.L565
 11409 0008 1A6F     	 ldr r2,[r3,#112]
 11410 000a BB1D     	 add r3,r7,#6
 11411 000c 1A80     	 strh r2,[r3]
2384:../XMC1100-LibHaas.c **** 	return (wert);
 11412              	 .loc 3 2384 0
 11413 000e BB1D     	 add r3,r7,#6
 11414 0010 1B88     	 ldrh r3,[r3]
2385:../XMC1100-LibHaas.c **** }
 11415              	 .loc 3 2385 0
 11416 0012 181C     	 mov r0,r3
 11417 0014 BD46     	 mov sp,r7
 11418 0016 02B0     	 add sp,sp,#8
 11419              	 
 11420 0018 80BD     	 pop {r7,pc}
 11421              	.L566:
 11422 001a C046     	 .align 2
 11423              	.L565:
 11424 001c 00040448 	 .word 1208222720
 11425              	 .cfi_endproc
 11426              	.LFE151:
 11428              	 .section .text.timer_reset,"ax",%progbits
 11429              	 .align 2
 11430              	 .global timer_reset
 11431              	 .code 16
 11432              	 .thumb_func
 11434              	timer_reset:
 11435              	.LFB152:
2386:../XMC1100-LibHaas.c **** // Timer zurücksetzen
2387:../XMC1100-LibHaas.c **** void timer_reset(void) // Timer rücksetzen, früher in timer_value enthalten
2388:../XMC1100-LibHaas.c **** {
 11436              	 .loc 3 2388 0
 11437              	 .cfi_startproc
 11438 0000 80B5     	 push {r7,lr}
 11439              	.LCFI313:
 11440              	 .cfi_def_cfa_offset 8
 11441              	 .cfi_offset 7,-8
 11442              	 .cfi_offset 14,-4
 11443 0002 00AF     	 add r7,sp,#0
 11444              	.LCFI314:
 11445              	 .cfi_def_cfa_register 7
2389:../XMC1100-LibHaas.c **** 	CCU40_CC43->TCCLR = 0x3;	// Timer stop und clear
 11446              	 .loc 3 2389 0
 11447 0004 024B     	 ldr r3,.L568
 11448 0006 0322     	 mov r2,#3
 11449 0008 1A61     	 str r2,[r3,#16]
2390:../XMC1100-LibHaas.c **** }
 11450              	 .loc 3 2390 0
 11451 000a BD46     	 mov sp,r7
 11452              	 
 11453 000c 80BD     	 pop {r7,pc}
 11454              	.L569:
 11455 000e C046     	 .align 2
 11456              	.L568:
 11457 0010 00040448 	 .word 1208222720
 11458              	 .cfi_endproc
 11459              	.LFE152:
 11461              	 .section .text.timer2_init,"ax",%progbits
 11462              	 .align 2
 11463              	 .global timer2_init
 11464              	 .code 16
 11465              	 .thumb_func
 11467              	timer2_init:
 11468              	.LFB153:
2391:../XMC1100-LibHaas.c **** 
2392:../XMC1100-LibHaas.c **** //Timer 2
2393:../XMC1100-LibHaas.c **** void timer2_init(uint8_t vorteiler, uint16_t periode)
2394:../XMC1100-LibHaas.c **** {	vorteiler %= 0x10;				// max. 15
 11469              	 .loc 3 2394 0
 11470              	 .cfi_startproc
 11471 0000 80B5     	 push {r7,lr}
 11472              	.LCFI315:
 11473              	 .cfi_def_cfa_offset 8
 11474              	 .cfi_offset 7,-8
 11475              	 .cfi_offset 14,-4
 11476 0002 82B0     	 sub sp,sp,#8
 11477              	.LCFI316:
 11478              	 .cfi_def_cfa_offset 16
 11479 0004 00AF     	 add r7,sp,#0
 11480              	.LCFI317:
 11481              	 .cfi_def_cfa_register 7
 11482 0006 021C     	 mov r2,r0
 11483 0008 FB1D     	 add r3,r7,#7
 11484 000a 1A70     	 strb r2,[r3]
 11485 000c 3B1D     	 add r3,r7,#4
 11486 000e 0A1C     	 add r2,r1,#0
 11487 0010 1A80     	 strh r2,[r3]
 11488              	 .loc 3 2394 0
 11489 0012 FB1D     	 add r3,r7,#7
 11490 0014 FA1D     	 add r2,r7,#7
 11491 0016 1278     	 ldrb r2,[r2]
 11492 0018 0F21     	 mov r1,#15
 11493 001a 0A40     	 and r2,r1
 11494 001c 1A70     	 strb r2,[r3]
2395:../XMC1100-LibHaas.c **** 	clock_init();
 11495              	 .loc 3 2395 0
 11496 001e FFF7FEFF 	 bl clock_init
2396:../XMC1100-LibHaas.c **** 	SCU_GENERAL->CCUCON |= 1;	// Enable CCU40 Modul
 11497              	 .loc 3 2396 0
 11498 0022 0E4B     	 ldr r3,.L571
 11499 0024 0D4A     	 ldr r2,.L571
 11500 0026 126B     	 ldr r2,[r2,#48]
 11501 0028 0121     	 mov r1,#1
 11502 002a 0A43     	 orr r2,r1
 11503 002c 1A63     	 str r2,[r3,#48]
2397:../XMC1100-LibHaas.c **** 				// CCU43 Init:
2398:../XMC1100-LibHaas.c **** 	CCU40->GIDLC 	= 0x10F; 	// Vorteiler enable für alle Timer , IDLE clear
 11504              	 .loc 3 2398 0
 11505 002e 0C4B     	 ldr r3,.L571+4
 11506 0030 1022     	 mov r2,#16
 11507 0032 FF32     	 add r2,r2,#255
 11508 0034 DA60     	 str r2,[r3,#12]
2399:../XMC1100-LibHaas.c **** 	CCU40_CC42->TC	= 0x08;		// Shadow transfer enable
 11509              	 .loc 3 2399 0
 11510 0036 0B4B     	 ldr r3,.L571+8
 11511 0038 0822     	 mov r2,#8
 11512 003a 5A61     	 str r2,[r3,#20]
2400:../XMC1100-LibHaas.c **** 	CCU40_CC42->PSC = vorteiler;	// Vorteiler , hier 64Mhz/2 => 32 MHzclock
 11513              	 .loc 3 2400 0
 11514 003c 094B     	 ldr r3,.L571+8
 11515 003e FA1D     	 add r2,r7,#7
 11516 0040 1278     	 ldrb r2,[r2]
 11517 0042 5A62     	 str r2,[r3,#36]
2401:../XMC1100-LibHaas.c **** 	CCU40_CC42->PRS	= periode;	// Period Register
 11518              	 .loc 3 2401 0
 11519 0044 074B     	 ldr r3,.L571+8
 11520 0046 3A1D     	 add r2,r7,#4
 11521 0048 1288     	 ldrh r2,[r2]
 11522 004a 5A63     	 str r2,[r3,#52]
2402:../XMC1100-LibHaas.c **** 	CCU40->GCSS = 0b001 <<8 ; 	// Shadow transfer request  Timer
 11523              	 .loc 3 2402 0
 11524 004c 044B     	 ldr r3,.L571+4
 11525 004e 8022     	 mov r2,#128
 11526 0050 5200     	 lsl r2,r2,#1
 11527 0052 1A61     	 str r2,[r3,#16]
2403:../XMC1100-LibHaas.c **** }
 11528              	 .loc 3 2403 0
 11529 0054 BD46     	 mov sp,r7
 11530 0056 02B0     	 add sp,sp,#8
 11531              	 
 11532 0058 80BD     	 pop {r7,pc}
 11533              	.L572:
 11534 005a C046     	 .align 2
 11535              	.L571:
 11536 005c 00000140 	 .word 1073807360
 11537 0060 00000448 	 .word 1208221696
 11538 0064 00030448 	 .word 1208222464
 11539              	 .cfi_endproc
 11540              	.LFE153:
 11542              	 .section .text.timer2_start,"ax",%progbits
 11543              	 .align 2
 11544              	 .global timer2_start
 11545              	 .code 16
 11546              	 .thumb_func
 11548              	timer2_start:
 11549              	.LFB154:
2404:../XMC1100-LibHaas.c **** 
2405:../XMC1100-LibHaas.c **** 
2406:../XMC1100-LibHaas.c **** // Timer für Zeitmessung starten
2407:../XMC1100-LibHaas.c **** void timer2_start(void)
2408:../XMC1100-LibHaas.c **** {
 11550              	 .loc 3 2408 0
 11551              	 .cfi_startproc
 11552 0000 80B5     	 push {r7,lr}
 11553              	.LCFI318:
 11554              	 .cfi_def_cfa_offset 8
 11555              	 .cfi_offset 7,-8
 11556              	 .cfi_offset 14,-4
 11557 0002 00AF     	 add r7,sp,#0
 11558              	.LCFI319:
 11559              	 .cfi_def_cfa_register 7
2409:../XMC1100-LibHaas.c **** 	CCU40_CC42->TCSET = 1; 		//starts counting
 11560              	 .loc 3 2409 0
 11561 0004 024B     	 ldr r3,.L574
 11562 0006 0122     	 mov r2,#1
 11563 0008 DA60     	 str r2,[r3,#12]
2410:../XMC1100-LibHaas.c **** }
 11564              	 .loc 3 2410 0
 11565 000a BD46     	 mov sp,r7
 11566              	 
 11567 000c 80BD     	 pop {r7,pc}
 11568              	.L575:
 11569 000e C046     	 .align 2
 11570              	.L574:
 11571 0010 00030448 	 .word 1208222464
 11572              	 .cfi_endproc
 11573              	.LFE154:
 11575              	 .section .text.timer2_start_interrupt,"ax",%progbits
 11576              	 .align 2
 11577              	 .global timer2_start_interrupt
 11578              	 .code 16
 11579              	 .thumb_func
 11581              	timer2_start_interrupt:
 11582              	.LFB155:
2411:../XMC1100-LibHaas.c **** /* Timer starten mit Interruptfreigabe
2412:../XMC1100-LibHaas.c ****    Timer-Interrupt-Handler ins eigene Programm kopieren:
2413:../XMC1100-LibHaas.c **** void CCU40_2_IRQHandler (void)  // Timer-Interrupt nach eingestellter Periodendauer
2414:../XMC1100-LibHaas.c **** {
2415:../XMC1100-LibHaas.c **** 							// Interrupt-Servie-Routine
2416:../XMC1100-LibHaas.c **** } */
2417:../XMC1100-LibHaas.c **** void timer2_start_interrupt(void)
2418:../XMC1100-LibHaas.c **** {
 11583              	 .loc 3 2418 0
 11584              	 .cfi_startproc
 11585 0000 80B5     	 push {r7,lr}
 11586              	.LCFI320:
 11587              	 .cfi_def_cfa_offset 8
 11588              	 .cfi_offset 7,-8
 11589              	 .cfi_offset 14,-4
 11590 0002 00AF     	 add r7,sp,#0
 11591              	.LCFI321:
 11592              	 .cfi_def_cfa_register 7
2419:../XMC1100-LibHaas.c **** 	CCU40_CC42->TCSET = 1; 		//starts counting
 11593              	 .loc 3 2419 0
 11594 0004 0B4B     	 ldr r3,.L577
 11595 0006 0122     	 mov r2,#1
 11596 0008 DA60     	 str r2,[r3,#12]
2420:../XMC1100-LibHaas.c **** 	// Interrupt Freigaben:
2421:../XMC1100-LibHaas.c **** 	CCU40_CC42->SRS |= 0b10;	// Service Req. Line 3
 11597              	 .loc 3 2421 0
 11598 000a 0A49     	 ldr r1,.L577
 11599 000c 094A     	 ldr r2,.L577
 11600 000e A823     	 mov r3,#168
 11601 0010 D358     	 ldr r3,[r2,r3]
 11602 0012 0222     	 mov r2,#2
 11603 0014 1343     	 orr r3,r2
 11604 0016 A822     	 mov r2,#168
 11605 0018 8B50     	 str r3,[r1,r2]
2422:../XMC1100-LibHaas.c **** 	CCU40_CC42->INTE |= 1;		// PME => Period match  Int. enable
 11606              	 .loc 3 2422 0
 11607 001a 0649     	 ldr r1,.L577
 11608 001c 054A     	 ldr r2,.L577
 11609 001e A423     	 mov r3,#164
 11610 0020 D358     	 ldr r3,[r2,r3]
 11611 0022 0122     	 mov r2,#1
 11612 0024 1343     	 orr r3,r2
 11613 0026 A422     	 mov r2,#164
 11614 0028 8B50     	 str r3,[r1,r2]
2423:../XMC1100-LibHaas.c **** 	NVIC_EnableIRQ(CCU40_2_IRQn);  // Freigabe CCU40SR3
 11615              	 .loc 3 2423 0
 11616 002a 1720     	 mov r0,#23
 11617 002c FFF7FEFF 	 bl __NVIC_EnableIRQ
2424:../XMC1100-LibHaas.c **** }
 11618              	 .loc 3 2424 0
 11619 0030 BD46     	 mov sp,r7
 11620              	 
 11621 0032 80BD     	 pop {r7,pc}
 11622              	.L578:
 11623              	 .align 2
 11624              	.L577:
 11625 0034 00030448 	 .word 1208222464
 11626              	 .cfi_endproc
 11627              	.LFE155:
 11629              	 .section .text.timer2_stop,"ax",%progbits
 11630              	 .align 2
 11631              	 .global timer2_stop
 11632              	 .code 16
 11633              	 .thumb_func
 11635              	timer2_stop:
 11636              	.LFB156:
2425:../XMC1100-LibHaas.c **** 
2426:../XMC1100-LibHaas.c **** // Timer stoppen
2427:../XMC1100-LibHaas.c **** void timer2_stop(void)
2428:../XMC1100-LibHaas.c **** {
 11637              	 .loc 3 2428 0
 11638              	 .cfi_startproc
 11639 0000 80B5     	 push {r7,lr}
 11640              	.LCFI322:
 11641              	 .cfi_def_cfa_offset 8
 11642              	 .cfi_offset 7,-8
 11643              	 .cfi_offset 14,-4
 11644 0002 00AF     	 add r7,sp,#0
 11645              	.LCFI323:
 11646              	 .cfi_def_cfa_register 7
2429:../XMC1100-LibHaas.c **** 	CCU40_CC42->TCCLR = 0x1;	// Timer stop
 11647              	 .loc 3 2429 0
 11648 0004 024B     	 ldr r3,.L580
 11649 0006 0122     	 mov r2,#1
 11650 0008 1A61     	 str r2,[r3,#16]
2430:../XMC1100-LibHaas.c **** }
 11651              	 .loc 3 2430 0
 11652 000a BD46     	 mov sp,r7
 11653              	 
 11654 000c 80BD     	 pop {r7,pc}
 11655              	.L581:
 11656 000e C046     	 .align 2
 11657              	.L580:
 11658 0010 00030448 	 .word 1208222464
 11659              	 .cfi_endproc
 11660              	.LFE156:
 11662              	 .section .text.timer2_value,"ax",%progbits
 11663              	 .align 2
 11664              	 .global timer2_value
 11665              	 .code 16
 11666              	 .thumb_func
 11668              	timer2_value:
 11669              	.LFB157:
2431:../XMC1100-LibHaas.c **** // Timerwert lesen
2432:../XMC1100-LibHaas.c **** uint16_t timer2_value(void)
2433:../XMC1100-LibHaas.c **** {
 11670              	 .loc 3 2433 0
 11671              	 .cfi_startproc
 11672 0000 80B5     	 push {r7,lr}
 11673              	.LCFI324:
 11674              	 .cfi_def_cfa_offset 8
 11675              	 .cfi_offset 7,-8
 11676              	 .cfi_offset 14,-4
 11677 0002 82B0     	 sub sp,sp,#8
 11678              	.LCFI325:
 11679              	 .cfi_def_cfa_offset 16
 11680 0004 00AF     	 add r7,sp,#0
 11681              	.LCFI326:
 11682              	 .cfi_def_cfa_register 7
2434:../XMC1100-LibHaas.c **** 	uint16_t wert;
2435:../XMC1100-LibHaas.c **** 	wert = CCU40_CC42->TIMER;
 11683              	 .loc 3 2435 0
 11684 0006 054B     	 ldr r3,.L584
 11685 0008 1A6F     	 ldr r2,[r3,#112]
 11686 000a BB1D     	 add r3,r7,#6
 11687 000c 1A80     	 strh r2,[r3]
2436:../XMC1100-LibHaas.c **** 	return (wert);
 11688              	 .loc 3 2436 0
 11689 000e BB1D     	 add r3,r7,#6
 11690 0010 1B88     	 ldrh r3,[r3]
2437:../XMC1100-LibHaas.c **** }
 11691              	 .loc 3 2437 0
 11692 0012 181C     	 mov r0,r3
 11693 0014 BD46     	 mov sp,r7
 11694 0016 02B0     	 add sp,sp,#8
 11695              	 
 11696 0018 80BD     	 pop {r7,pc}
 11697              	.L585:
 11698 001a C046     	 .align 2
 11699              	.L584:
 11700 001c 00030448 	 .word 1208222464
 11701              	 .cfi_endproc
 11702              	.LFE157:
 11704              	 .section .text.timer2_reset,"ax",%progbits
 11705              	 .align 2
 11706              	 .global timer2_reset
 11707              	 .code 16
 11708              	 .thumb_func
 11710              	timer2_reset:
 11711              	.LFB158:
2438:../XMC1100-LibHaas.c **** // Timer zurücksetzen
2439:../XMC1100-LibHaas.c **** void timer2_reset(void) // Timer rücksetzen, früher in timer_value enthalten
2440:../XMC1100-LibHaas.c **** {
 11712              	 .loc 3 2440 0
 11713              	 .cfi_startproc
 11714 0000 80B5     	 push {r7,lr}
 11715              	.LCFI327:
 11716              	 .cfi_def_cfa_offset 8
 11717              	 .cfi_offset 7,-8
 11718              	 .cfi_offset 14,-4
 11719 0002 00AF     	 add r7,sp,#0
 11720              	.LCFI328:
 11721              	 .cfi_def_cfa_register 7
2441:../XMC1100-LibHaas.c **** 	CCU40_CC42->TCCLR = 0x3;	// Timer stop und clear
 11722              	 .loc 3 2441 0
 11723 0004 024B     	 ldr r3,.L587
 11724 0006 0322     	 mov r2,#3
 11725 0008 1A61     	 str r2,[r3,#16]
2442:../XMC1100-LibHaas.c **** }
 11726              	 .loc 3 2442 0
 11727 000a BD46     	 mov sp,r7
 11728              	 
 11729 000c 80BD     	 pop {r7,pc}
 11730              	.L588:
 11731 000e C046     	 .align 2
 11732              	.L587:
 11733 0010 00030448 	 .word 1208222464
 11734              	 .cfi_endproc
 11735              	.LFE158:
 11737              	 .section .text.timer1_init,"ax",%progbits
 11738              	 .align 2
 11739              	 .global timer1_init
 11740              	 .code 16
 11741              	 .thumb_func
 11743              	timer1_init:
 11744              	.LFB159:
2443:../XMC1100-LibHaas.c **** 
2444:../XMC1100-LibHaas.c **** 
2445:../XMC1100-LibHaas.c **** //Timer 1
2446:../XMC1100-LibHaas.c **** void timer1_init(uint8_t vorteiler, uint16_t periode)
2447:../XMC1100-LibHaas.c **** {	vorteiler %= 0x10;				// max. 15
 11745              	 .loc 3 2447 0
 11746              	 .cfi_startproc
 11747 0000 80B5     	 push {r7,lr}
 11748              	.LCFI329:
 11749              	 .cfi_def_cfa_offset 8
 11750              	 .cfi_offset 7,-8
 11751              	 .cfi_offset 14,-4
 11752 0002 82B0     	 sub sp,sp,#8
 11753              	.LCFI330:
 11754              	 .cfi_def_cfa_offset 16
 11755 0004 00AF     	 add r7,sp,#0
 11756              	.LCFI331:
 11757              	 .cfi_def_cfa_register 7
 11758 0006 021C     	 mov r2,r0
 11759 0008 FB1D     	 add r3,r7,#7
 11760 000a 1A70     	 strb r2,[r3]
 11761 000c 3B1D     	 add r3,r7,#4
 11762 000e 0A1C     	 add r2,r1,#0
 11763 0010 1A80     	 strh r2,[r3]
 11764              	 .loc 3 2447 0
 11765 0012 FB1D     	 add r3,r7,#7
 11766 0014 FA1D     	 add r2,r7,#7
 11767 0016 1278     	 ldrb r2,[r2]
 11768 0018 0F21     	 mov r1,#15
 11769 001a 0A40     	 and r2,r1
 11770 001c 1A70     	 strb r2,[r3]
2448:../XMC1100-LibHaas.c **** 	clock_init();
 11771              	 .loc 3 2448 0
 11772 001e FFF7FEFF 	 bl clock_init
2449:../XMC1100-LibHaas.c **** 	SCU_GENERAL->CCUCON |= 1;	// Enable CCU40 Modul
 11773              	 .loc 3 2449 0
 11774 0022 0D4B     	 ldr r3,.L590
 11775 0024 0C4A     	 ldr r2,.L590
 11776 0026 126B     	 ldr r2,[r2,#48]
 11777 0028 0121     	 mov r1,#1
 11778 002a 0A43     	 orr r2,r1
 11779 002c 1A63     	 str r2,[r3,#48]
2450:../XMC1100-LibHaas.c **** 				// CCU43 Init:
2451:../XMC1100-LibHaas.c **** 	CCU40->GIDLC 	= 0x10F; 	// Vorteiler enable für alle Timer , IDLE clear
 11780              	 .loc 3 2451 0
 11781 002e 0B4B     	 ldr r3,.L590+4
 11782 0030 1022     	 mov r2,#16
 11783 0032 FF32     	 add r2,r2,#255
 11784 0034 DA60     	 str r2,[r3,#12]
2452:../XMC1100-LibHaas.c **** 	CCU40_CC41->TC	= 0x08;		// Shadow transfer enable
 11785              	 .loc 3 2452 0
 11786 0036 0A4B     	 ldr r3,.L590+8
 11787 0038 0822     	 mov r2,#8
 11788 003a 5A61     	 str r2,[r3,#20]
2453:../XMC1100-LibHaas.c **** 	CCU40_CC41->PSC = vorteiler;	// Vorteiler , hier 64Mhz/2 => 32 MHzclock
 11789              	 .loc 3 2453 0
 11790 003c 084B     	 ldr r3,.L590+8
 11791 003e FA1D     	 add r2,r7,#7
 11792 0040 1278     	 ldrb r2,[r2]
 11793 0042 5A62     	 str r2,[r3,#36]
2454:../XMC1100-LibHaas.c **** 	CCU40_CC41->PRS	= periode;	// Period Register
 11794              	 .loc 3 2454 0
 11795 0044 064B     	 ldr r3,.L590+8
 11796 0046 3A1D     	 add r2,r7,#4
 11797 0048 1288     	 ldrh r2,[r2]
 11798 004a 5A63     	 str r2,[r3,#52]
2455:../XMC1100-LibHaas.c **** 	CCU40->GCSS = 0b001 <<4 ; 	// Shadow transfer request  Timer
 11799              	 .loc 3 2455 0
 11800 004c 034B     	 ldr r3,.L590+4
 11801 004e 1022     	 mov r2,#16
 11802 0050 1A61     	 str r2,[r3,#16]
2456:../XMC1100-LibHaas.c **** }
 11803              	 .loc 3 2456 0
 11804 0052 BD46     	 mov sp,r7
 11805 0054 02B0     	 add sp,sp,#8
 11806              	 
 11807 0056 80BD     	 pop {r7,pc}
 11808              	.L591:
 11809              	 .align 2
 11810              	.L590:
 11811 0058 00000140 	 .word 1073807360
 11812 005c 00000448 	 .word 1208221696
 11813 0060 00020448 	 .word 1208222208
 11814              	 .cfi_endproc
 11815              	.LFE159:
 11817              	 .section .text.timer1_start,"ax",%progbits
 11818              	 .align 2
 11819              	 .global timer1_start
 11820              	 .code 16
 11821              	 .thumb_func
 11823              	timer1_start:
 11824              	.LFB160:
2457:../XMC1100-LibHaas.c **** 
2458:../XMC1100-LibHaas.c **** 
2459:../XMC1100-LibHaas.c **** // Timer für Zeitmessung starten
2460:../XMC1100-LibHaas.c **** void timer1_start(void)
2461:../XMC1100-LibHaas.c **** {
 11825              	 .loc 3 2461 0
 11826              	 .cfi_startproc
 11827 0000 80B5     	 push {r7,lr}
 11828              	.LCFI332:
 11829              	 .cfi_def_cfa_offset 8
 11830              	 .cfi_offset 7,-8
 11831              	 .cfi_offset 14,-4
 11832 0002 00AF     	 add r7,sp,#0
 11833              	.LCFI333:
 11834              	 .cfi_def_cfa_register 7
2462:../XMC1100-LibHaas.c **** 	CCU40_CC41->TCSET = 1; 		//starts counting
 11835              	 .loc 3 2462 0
 11836 0004 024B     	 ldr r3,.L593
 11837 0006 0122     	 mov r2,#1
 11838 0008 DA60     	 str r2,[r3,#12]
2463:../XMC1100-LibHaas.c **** }
 11839              	 .loc 3 2463 0
 11840 000a BD46     	 mov sp,r7
 11841              	 
 11842 000c 80BD     	 pop {r7,pc}
 11843              	.L594:
 11844 000e C046     	 .align 2
 11845              	.L593:
 11846 0010 00020448 	 .word 1208222208
 11847              	 .cfi_endproc
 11848              	.LFE160:
 11850              	 .section .text.timer1_start_interrupt,"ax",%progbits
 11851              	 .align 2
 11852              	 .global timer1_start_interrupt
 11853              	 .code 16
 11854              	 .thumb_func
 11856              	timer1_start_interrupt:
 11857              	.LFB161:
2464:../XMC1100-LibHaas.c **** /* Timer starten mit Interruptfreigabe
2465:../XMC1100-LibHaas.c ****    Timer-Interrupt-Handler ins eigene Programm kopieren:
2466:../XMC1100-LibHaas.c **** void CCU40_1_IRQHandler (void)  // Timer-Interrupt nach eingestellter Periodendauer
2467:../XMC1100-LibHaas.c **** {
2468:../XMC1100-LibHaas.c **** 							// Interrupt-Servie-Routine
2469:../XMC1100-LibHaas.c **** } */
2470:../XMC1100-LibHaas.c **** void timer1_start_interrupt(void)
2471:../XMC1100-LibHaas.c **** {
 11858              	 .loc 3 2471 0
 11859              	 .cfi_startproc
 11860 0000 80B5     	 push {r7,lr}
 11861              	.LCFI334:
 11862              	 .cfi_def_cfa_offset 8
 11863              	 .cfi_offset 7,-8
 11864              	 .cfi_offset 14,-4
 11865 0002 00AF     	 add r7,sp,#0
 11866              	.LCFI335:
 11867              	 .cfi_def_cfa_register 7
2472:../XMC1100-LibHaas.c **** 	CCU40_CC41->TCSET = 1; 		//starts counting
 11868              	 .loc 3 2472 0
 11869 0004 0B4B     	 ldr r3,.L596
 11870 0006 0122     	 mov r2,#1
 11871 0008 DA60     	 str r2,[r3,#12]
2473:../XMC1100-LibHaas.c **** 	// Interrupt Freigaben:
2474:../XMC1100-LibHaas.c **** 	CCU40_CC41->SRS |= 0b01;	// Service Req. Line 3
 11872              	 .loc 3 2474 0
 11873 000a 0A49     	 ldr r1,.L596
 11874 000c 094A     	 ldr r2,.L596
 11875 000e A823     	 mov r3,#168
 11876 0010 D358     	 ldr r3,[r2,r3]
 11877 0012 0122     	 mov r2,#1
 11878 0014 1343     	 orr r3,r2
 11879 0016 A822     	 mov r2,#168
 11880 0018 8B50     	 str r3,[r1,r2]
2475:../XMC1100-LibHaas.c **** 	CCU40_CC41->INTE |= 1;		// PME => Period match  Int. enable
 11881              	 .loc 3 2475 0
 11882 001a 0649     	 ldr r1,.L596
 11883 001c 054A     	 ldr r2,.L596
 11884 001e A423     	 mov r3,#164
 11885 0020 D358     	 ldr r3,[r2,r3]
 11886 0022 0122     	 mov r2,#1
 11887 0024 1343     	 orr r3,r2
 11888 0026 A422     	 mov r2,#164
 11889 0028 8B50     	 str r3,[r1,r2]
2476:../XMC1100-LibHaas.c **** 	NVIC_EnableIRQ(CCU40_1_IRQn);  // Freigabe CCU40SR3
 11890              	 .loc 3 2476 0
 11891 002a 1620     	 mov r0,#22
 11892 002c FFF7FEFF 	 bl __NVIC_EnableIRQ
2477:../XMC1100-LibHaas.c **** }
 11893              	 .loc 3 2477 0
 11894 0030 BD46     	 mov sp,r7
 11895              	 
 11896 0032 80BD     	 pop {r7,pc}
 11897              	.L597:
 11898              	 .align 2
 11899              	.L596:
 11900 0034 00020448 	 .word 1208222208
 11901              	 .cfi_endproc
 11902              	.LFE161:
 11904              	 .section .text.timer1_stop,"ax",%progbits
 11905              	 .align 2
 11906              	 .global timer1_stop
 11907              	 .code 16
 11908              	 .thumb_func
 11910              	timer1_stop:
 11911              	.LFB162:
2478:../XMC1100-LibHaas.c **** 
2479:../XMC1100-LibHaas.c **** // Timer stoppen
2480:../XMC1100-LibHaas.c **** void timer1_stop(void)
2481:../XMC1100-LibHaas.c **** {
 11912              	 .loc 3 2481 0
 11913              	 .cfi_startproc
 11914 0000 80B5     	 push {r7,lr}
 11915              	.LCFI336:
 11916              	 .cfi_def_cfa_offset 8
 11917              	 .cfi_offset 7,-8
 11918              	 .cfi_offset 14,-4
 11919 0002 00AF     	 add r7,sp,#0
 11920              	.LCFI337:
 11921              	 .cfi_def_cfa_register 7
2482:../XMC1100-LibHaas.c **** 	CCU40_CC41->TCCLR = 0x1;	// Timer stop
 11922              	 .loc 3 2482 0
 11923 0004 024B     	 ldr r3,.L599
 11924 0006 0122     	 mov r2,#1
 11925 0008 1A61     	 str r2,[r3,#16]
2483:../XMC1100-LibHaas.c **** }
 11926              	 .loc 3 2483 0
 11927 000a BD46     	 mov sp,r7
 11928              	 
 11929 000c 80BD     	 pop {r7,pc}
 11930              	.L600:
 11931 000e C046     	 .align 2
 11932              	.L599:
 11933 0010 00020448 	 .word 1208222208
 11934              	 .cfi_endproc
 11935              	.LFE162:
 11937              	 .section .text.timer1_value,"ax",%progbits
 11938              	 .align 2
 11939              	 .global timer1_value
 11940              	 .code 16
 11941              	 .thumb_func
 11943              	timer1_value:
 11944              	.LFB163:
2484:../XMC1100-LibHaas.c **** // Timerwert lesen
2485:../XMC1100-LibHaas.c **** uint16_t timer1_value(void)
2486:../XMC1100-LibHaas.c **** {
 11945              	 .loc 3 2486 0
 11946              	 .cfi_startproc
 11947 0000 80B5     	 push {r7,lr}
 11948              	.LCFI338:
 11949              	 .cfi_def_cfa_offset 8
 11950              	 .cfi_offset 7,-8
 11951              	 .cfi_offset 14,-4
 11952 0002 82B0     	 sub sp,sp,#8
 11953              	.LCFI339:
 11954              	 .cfi_def_cfa_offset 16
 11955 0004 00AF     	 add r7,sp,#0
 11956              	.LCFI340:
 11957              	 .cfi_def_cfa_register 7
2487:../XMC1100-LibHaas.c **** 	uint16_t wert;
2488:../XMC1100-LibHaas.c **** 	wert = CCU40_CC41->TIMER;
 11958              	 .loc 3 2488 0
 11959 0006 054B     	 ldr r3,.L603
 11960 0008 1A6F     	 ldr r2,[r3,#112]
 11961 000a BB1D     	 add r3,r7,#6
 11962 000c 1A80     	 strh r2,[r3]
2489:../XMC1100-LibHaas.c **** 	return (wert);
 11963              	 .loc 3 2489 0
 11964 000e BB1D     	 add r3,r7,#6
 11965 0010 1B88     	 ldrh r3,[r3]
2490:../XMC1100-LibHaas.c **** }
 11966              	 .loc 3 2490 0
 11967 0012 181C     	 mov r0,r3
 11968 0014 BD46     	 mov sp,r7
 11969 0016 02B0     	 add sp,sp,#8
 11970              	 
 11971 0018 80BD     	 pop {r7,pc}
 11972              	.L604:
 11973 001a C046     	 .align 2
 11974              	.L603:
 11975 001c 00020448 	 .word 1208222208
 11976              	 .cfi_endproc
 11977              	.LFE163:
 11979              	 .section .text.timer1_reset,"ax",%progbits
 11980              	 .align 2
 11981              	 .global timer1_reset
 11982              	 .code 16
 11983              	 .thumb_func
 11985              	timer1_reset:
 11986              	.LFB164:
2491:../XMC1100-LibHaas.c **** // Timer zurücksetzen
2492:../XMC1100-LibHaas.c **** void timer1_reset(void) // Timer rücksetzen, früher in timer_value enthalten
2493:../XMC1100-LibHaas.c **** {
 11987              	 .loc 3 2493 0
 11988              	 .cfi_startproc
 11989 0000 80B5     	 push {r7,lr}
 11990              	.LCFI341:
 11991              	 .cfi_def_cfa_offset 8
 11992              	 .cfi_offset 7,-8
 11993              	 .cfi_offset 14,-4
 11994 0002 00AF     	 add r7,sp,#0
 11995              	.LCFI342:
 11996              	 .cfi_def_cfa_register 7
2494:../XMC1100-LibHaas.c **** 	CCU40_CC41->TCCLR = 0x3;	// Timer stop und clear
 11997              	 .loc 3 2494 0
 11998 0004 024B     	 ldr r3,.L606
 11999 0006 0322     	 mov r2,#3
 12000 0008 1A61     	 str r2,[r3,#16]
2495:../XMC1100-LibHaas.c **** }
 12001              	 .loc 3 2495 0
 12002 000a BD46     	 mov sp,r7
 12003              	 
 12004 000c 80BD     	 pop {r7,pc}
 12005              	.L607:
 12006 000e C046     	 .align 2
 12007              	.L606:
 12008 0010 00020448 	 .word 1208222208
 12009              	 .cfi_endproc
 12010              	.LFE164:
 12012              	 .section .text.timer0_init,"ax",%progbits
 12013              	 .align 2
 12014              	 .global timer0_init
 12015              	 .code 16
 12016              	 .thumb_func
 12018              	timer0_init:
 12019              	.LFB165:
2496:../XMC1100-LibHaas.c **** 
2497:../XMC1100-LibHaas.c **** 
2498:../XMC1100-LibHaas.c **** //Timer 0
2499:../XMC1100-LibHaas.c **** void timer0_init(uint8_t vorteiler, uint16_t periode)
2500:../XMC1100-LibHaas.c **** {	vorteiler %= 0x10;				// max. 15
 12020              	 .loc 3 2500 0
 12021              	 .cfi_startproc
 12022 0000 80B5     	 push {r7,lr}
 12023              	.LCFI343:
 12024              	 .cfi_def_cfa_offset 8
 12025              	 .cfi_offset 7,-8
 12026              	 .cfi_offset 14,-4
 12027 0002 82B0     	 sub sp,sp,#8
 12028              	.LCFI344:
 12029              	 .cfi_def_cfa_offset 16
 12030 0004 00AF     	 add r7,sp,#0
 12031              	.LCFI345:
 12032              	 .cfi_def_cfa_register 7
 12033 0006 021C     	 mov r2,r0
 12034 0008 FB1D     	 add r3,r7,#7
 12035 000a 1A70     	 strb r2,[r3]
 12036 000c 3B1D     	 add r3,r7,#4
 12037 000e 0A1C     	 add r2,r1,#0
 12038 0010 1A80     	 strh r2,[r3]
 12039              	 .loc 3 2500 0
 12040 0012 FB1D     	 add r3,r7,#7
 12041 0014 FA1D     	 add r2,r7,#7
 12042 0016 1278     	 ldrb r2,[r2]
 12043 0018 0F21     	 mov r1,#15
 12044 001a 0A40     	 and r2,r1
 12045 001c 1A70     	 strb r2,[r3]
2501:../XMC1100-LibHaas.c **** 	clock_init();
 12046              	 .loc 3 2501 0
 12047 001e FFF7FEFF 	 bl clock_init
2502:../XMC1100-LibHaas.c **** 	SCU_GENERAL->CCUCON |= 1;	// Enable CCU40 Modul
 12048              	 .loc 3 2502 0
 12049 0022 0D4B     	 ldr r3,.L609
 12050 0024 0C4A     	 ldr r2,.L609
 12051 0026 126B     	 ldr r2,[r2,#48]
 12052 0028 0121     	 mov r1,#1
 12053 002a 0A43     	 orr r2,r1
 12054 002c 1A63     	 str r2,[r3,#48]
2503:../XMC1100-LibHaas.c **** 				// CCU43 Init:
2504:../XMC1100-LibHaas.c **** 	CCU40->GIDLC 	= 0x10F; 	// Vorteiler enable für alle Timer , IDLE clear
 12055              	 .loc 3 2504 0
 12056 002e 0B4B     	 ldr r3,.L609+4
 12057 0030 1022     	 mov r2,#16
 12058 0032 FF32     	 add r2,r2,#255
 12059 0034 DA60     	 str r2,[r3,#12]
2505:../XMC1100-LibHaas.c **** 	CCU40_CC40->TC	= 0x08;		// Shadow transfer enable
 12060              	 .loc 3 2505 0
 12061 0036 0A4B     	 ldr r3,.L609+8
 12062 0038 0822     	 mov r2,#8
 12063 003a 5A61     	 str r2,[r3,#20]
2506:../XMC1100-LibHaas.c **** 	CCU40_CC40->PSC = vorteiler;	// Vorteiler , hier 64Mhz/2 => 32 MHzclock
 12064              	 .loc 3 2506 0
 12065 003c 084B     	 ldr r3,.L609+8
 12066 003e FA1D     	 add r2,r7,#7
 12067 0040 1278     	 ldrb r2,[r2]
 12068 0042 5A62     	 str r2,[r3,#36]
2507:../XMC1100-LibHaas.c **** 	CCU40_CC40->PRS	= periode;	// Period Register
 12069              	 .loc 3 2507 0
 12070 0044 064B     	 ldr r3,.L609+8
 12071 0046 3A1D     	 add r2,r7,#4
 12072 0048 1288     	 ldrh r2,[r2]
 12073 004a 5A63     	 str r2,[r3,#52]
2508:../XMC1100-LibHaas.c **** 	CCU40->GCSS = 0b001 <<0 ; 	// Shadow transfer request  Timer
 12074              	 .loc 3 2508 0
 12075 004c 034B     	 ldr r3,.L609+4
 12076 004e 0122     	 mov r2,#1
 12077 0050 1A61     	 str r2,[r3,#16]
2509:../XMC1100-LibHaas.c **** }
 12078              	 .loc 3 2509 0
 12079 0052 BD46     	 mov sp,r7
 12080 0054 02B0     	 add sp,sp,#8
 12081              	 
 12082 0056 80BD     	 pop {r7,pc}
 12083              	.L610:
 12084              	 .align 2
 12085              	.L609:
 12086 0058 00000140 	 .word 1073807360
 12087 005c 00000448 	 .word 1208221696
 12088 0060 00010448 	 .word 1208221952
 12089              	 .cfi_endproc
 12090              	.LFE165:
 12092              	 .section .text.timer0_start,"ax",%progbits
 12093              	 .align 2
 12094              	 .global timer0_start
 12095              	 .code 16
 12096              	 .thumb_func
 12098              	timer0_start:
 12099              	.LFB166:
2510:../XMC1100-LibHaas.c **** 
2511:../XMC1100-LibHaas.c **** 
2512:../XMC1100-LibHaas.c **** // Timer für Zeitmessung starten
2513:../XMC1100-LibHaas.c **** void timer0_start(void)
2514:../XMC1100-LibHaas.c **** {
 12100              	 .loc 3 2514 0
 12101              	 .cfi_startproc
 12102 0000 80B5     	 push {r7,lr}
 12103              	.LCFI346:
 12104              	 .cfi_def_cfa_offset 8
 12105              	 .cfi_offset 7,-8
 12106              	 .cfi_offset 14,-4
 12107 0002 00AF     	 add r7,sp,#0
 12108              	.LCFI347:
 12109              	 .cfi_def_cfa_register 7
2515:../XMC1100-LibHaas.c **** 	CCU40_CC40->TCSET = 1; 		//starts counting
 12110              	 .loc 3 2515 0
 12111 0004 024B     	 ldr r3,.L612
 12112 0006 0122     	 mov r2,#1
 12113 0008 DA60     	 str r2,[r3,#12]
2516:../XMC1100-LibHaas.c **** }
 12114              	 .loc 3 2516 0
 12115 000a BD46     	 mov sp,r7
 12116              	 
 12117 000c 80BD     	 pop {r7,pc}
 12118              	.L613:
 12119 000e C046     	 .align 2
 12120              	.L612:
 12121 0010 00010448 	 .word 1208221952
 12122              	 .cfi_endproc
 12123              	.LFE166:
 12125              	 .section .text.timer0_start_interrupt,"ax",%progbits
 12126              	 .align 2
 12127              	 .global timer0_start_interrupt
 12128              	 .code 16
 12129              	 .thumb_func
 12131              	timer0_start_interrupt:
 12132              	.LFB167:
2517:../XMC1100-LibHaas.c **** /* Timer starten mit Interruptfreigabe
2518:../XMC1100-LibHaas.c ****    Timer-Interrupt-Handler ins eigene Programm kopieren:
2519:../XMC1100-LibHaas.c **** void CCU40_0_IRQHandler (void)  // Timer-Interrupt nach eingestellter Periodendauer
2520:../XMC1100-LibHaas.c **** {
2521:../XMC1100-LibHaas.c **** 				// Interrupt-Servie-Routine
2522:../XMC1100-LibHaas.c **** } */
2523:../XMC1100-LibHaas.c **** void timer0_start_interrupt(void)
2524:../XMC1100-LibHaas.c **** {
 12133              	 .loc 3 2524 0
 12134              	 .cfi_startproc
 12135 0000 80B5     	 push {r7,lr}
 12136              	.LCFI348:
 12137              	 .cfi_def_cfa_offset 8
 12138              	 .cfi_offset 7,-8
 12139              	 .cfi_offset 14,-4
 12140 0002 00AF     	 add r7,sp,#0
 12141              	.LCFI349:
 12142              	 .cfi_def_cfa_register 7
2525:../XMC1100-LibHaas.c **** 	CCU40_CC40->TCSET = 1; 		//starts counting
 12143              	 .loc 3 2525 0
 12144 0004 0A4B     	 ldr r3,.L615
 12145 0006 0122     	 mov r2,#1
 12146 0008 DA60     	 str r2,[r3,#12]
2526:../XMC1100-LibHaas.c **** 	// Interrupt Freigaben:
2527:../XMC1100-LibHaas.c **** 	CCU40_CC40->SRS |= 0b00;	// Service Req. Line 3
 12147              	 .loc 3 2527 0
 12148 000a 0949     	 ldr r1,.L615
 12149 000c 084A     	 ldr r2,.L615
 12150 000e A823     	 mov r3,#168
 12151 0010 D358     	 ldr r3,[r2,r3]
 12152 0012 A822     	 mov r2,#168
 12153 0014 8B50     	 str r3,[r1,r2]
2528:../XMC1100-LibHaas.c **** 	CCU40_CC40->INTE |= 1;		// PME => Period match  Int. enable
 12154              	 .loc 3 2528 0
 12155 0016 0649     	 ldr r1,.L615
 12156 0018 054A     	 ldr r2,.L615
 12157 001a A423     	 mov r3,#164
 12158 001c D358     	 ldr r3,[r2,r3]
 12159 001e 0122     	 mov r2,#1
 12160 0020 1343     	 orr r3,r2
 12161 0022 A422     	 mov r2,#164
 12162 0024 8B50     	 str r3,[r1,r2]
2529:../XMC1100-LibHaas.c **** 	NVIC_EnableIRQ(CCU40_0_IRQn);  // Freigabe CCU40SR3
 12163              	 .loc 3 2529 0
 12164 0026 1520     	 mov r0,#21
 12165 0028 FFF7FEFF 	 bl __NVIC_EnableIRQ
2530:../XMC1100-LibHaas.c **** }
 12166              	 .loc 3 2530 0
 12167 002c BD46     	 mov sp,r7
 12168              	 
 12169 002e 80BD     	 pop {r7,pc}
 12170              	.L616:
 12171              	 .align 2
 12172              	.L615:
 12173 0030 00010448 	 .word 1208221952
 12174              	 .cfi_endproc
 12175              	.LFE167:
 12177              	 .section .text.timer0_stop,"ax",%progbits
 12178              	 .align 2
 12179              	 .global timer0_stop
 12180              	 .code 16
 12181              	 .thumb_func
 12183              	timer0_stop:
 12184              	.LFB168:
2531:../XMC1100-LibHaas.c **** 
2532:../XMC1100-LibHaas.c **** // Timer stoppen
2533:../XMC1100-LibHaas.c **** void timer0_stop(void)
2534:../XMC1100-LibHaas.c **** {
 12185              	 .loc 3 2534 0
 12186              	 .cfi_startproc
 12187 0000 80B5     	 push {r7,lr}
 12188              	.LCFI350:
 12189              	 .cfi_def_cfa_offset 8
 12190              	 .cfi_offset 7,-8
 12191              	 .cfi_offset 14,-4
 12192 0002 00AF     	 add r7,sp,#0
 12193              	.LCFI351:
 12194              	 .cfi_def_cfa_register 7
2535:../XMC1100-LibHaas.c **** 	CCU40_CC40->TCCLR = 0x1;	// Timer stop
 12195              	 .loc 3 2535 0
 12196 0004 024B     	 ldr r3,.L618
 12197 0006 0122     	 mov r2,#1
 12198 0008 1A61     	 str r2,[r3,#16]
2536:../XMC1100-LibHaas.c **** }
 12199              	 .loc 3 2536 0
 12200 000a BD46     	 mov sp,r7
 12201              	 
 12202 000c 80BD     	 pop {r7,pc}
 12203              	.L619:
 12204 000e C046     	 .align 2
 12205              	.L618:
 12206 0010 00010448 	 .word 1208221952
 12207              	 .cfi_endproc
 12208              	.LFE168:
 12210              	 .section .text.timer0_value,"ax",%progbits
 12211              	 .align 2
 12212              	 .global timer0_value
 12213              	 .code 16
 12214              	 .thumb_func
 12216              	timer0_value:
 12217              	.LFB169:
2537:../XMC1100-LibHaas.c **** // Timerwert lesen
2538:../XMC1100-LibHaas.c **** uint16_t timer0_value(void)
2539:../XMC1100-LibHaas.c **** {
 12218              	 .loc 3 2539 0
 12219              	 .cfi_startproc
 12220 0000 80B5     	 push {r7,lr}
 12221              	.LCFI352:
 12222              	 .cfi_def_cfa_offset 8
 12223              	 .cfi_offset 7,-8
 12224              	 .cfi_offset 14,-4
 12225 0002 82B0     	 sub sp,sp,#8
 12226              	.LCFI353:
 12227              	 .cfi_def_cfa_offset 16
 12228 0004 00AF     	 add r7,sp,#0
 12229              	.LCFI354:
 12230              	 .cfi_def_cfa_register 7
2540:../XMC1100-LibHaas.c **** 	uint16_t wert;
2541:../XMC1100-LibHaas.c **** 	wert = CCU40_CC40->TIMER;
 12231              	 .loc 3 2541 0
 12232 0006 054B     	 ldr r3,.L622
 12233 0008 1A6F     	 ldr r2,[r3,#112]
 12234 000a BB1D     	 add r3,r7,#6
 12235 000c 1A80     	 strh r2,[r3]
2542:../XMC1100-LibHaas.c **** 	return (wert);
 12236              	 .loc 3 2542 0
 12237 000e BB1D     	 add r3,r7,#6
 12238 0010 1B88     	 ldrh r3,[r3]
2543:../XMC1100-LibHaas.c **** }
 12239              	 .loc 3 2543 0
 12240 0012 181C     	 mov r0,r3
 12241 0014 BD46     	 mov sp,r7
 12242 0016 02B0     	 add sp,sp,#8
 12243              	 
 12244 0018 80BD     	 pop {r7,pc}
 12245              	.L623:
 12246 001a C046     	 .align 2
 12247              	.L622:
 12248 001c 00010448 	 .word 1208221952
 12249              	 .cfi_endproc
 12250              	.LFE169:
 12252              	 .section .text.timer0_reset,"ax",%progbits
 12253              	 .align 2
 12254              	 .global timer0_reset
 12255              	 .code 16
 12256              	 .thumb_func
 12258              	timer0_reset:
 12259              	.LFB170:
2544:../XMC1100-LibHaas.c **** // Timer zurücksetzen
2545:../XMC1100-LibHaas.c **** void timer0_reset(void) // Timer rücksetzen, früher in timer_value enthalten
2546:../XMC1100-LibHaas.c **** {
 12260              	 .loc 3 2546 0
 12261              	 .cfi_startproc
 12262 0000 80B5     	 push {r7,lr}
 12263              	.LCFI355:
 12264              	 .cfi_def_cfa_offset 8
 12265              	 .cfi_offset 7,-8
 12266              	 .cfi_offset 14,-4
 12267 0002 00AF     	 add r7,sp,#0
 12268              	.LCFI356:
 12269              	 .cfi_def_cfa_register 7
2547:../XMC1100-LibHaas.c **** 	CCU40_CC40->TCCLR = 0x3;	// Timer stop und clear
 12270              	 .loc 3 2547 0
 12271 0004 024B     	 ldr r3,.L625
 12272 0006 0322     	 mov r2,#3
 12273 0008 1A61     	 str r2,[r3,#16]
2548:../XMC1100-LibHaas.c **** }
 12274              	 .loc 3 2548 0
 12275 000a BD46     	 mov sp,r7
 12276              	 
 12277 000c 80BD     	 pop {r7,pc}
 12278              	.L626:
 12279 000e C046     	 .align 2
 12280              	.L625:
 12281 0010 00010448 	 .word 1208221952
 12282              	 .cfi_endproc
 12283              	.LFE170:
 12285              	 .section .text.timer0_extern_controll,"ax",%progbits
 12286              	 .align 2
 12287              	 .global timer0_extern_controll
 12288              	 .code 16
 12289              	 .thumb_func
 12291              	timer0_extern_controll:
 12292              	.LFB171:
2549:../XMC1100-LibHaas.c **** 
2550:../XMC1100-LibHaas.c **** //Extrene kontrolle des Timer 0
2551:../XMC1100-LibHaas.c **** //Auswahl zwischen Pin 0, Pin 6 und Pin 12
2552:../XMC1100-LibHaas.c **** //Auswahl bei Start zwischen RE=Steigende Flanke und FE=Fallende Flanke
2553:../XMC1100-LibHaas.c **** //Auswahl bei Stop zwischen RE=Steigende Flanke und FE=Fallende Flanke
2554:../XMC1100-LibHaas.c **** 
2555:../XMC1100-LibHaas.c **** void timer0_extern_controll(uint8_t PIN, uint8_t Start, uint8_t Stopp)
2556:../XMC1100-LibHaas.c **** {
 12293              	 .loc 3 2556 0
 12294              	 .cfi_startproc
 12295 0000 90B5     	 push {r4,r7,lr}
 12296              	.LCFI357:
 12297              	 .cfi_def_cfa_offset 12
 12298              	 .cfi_offset 4,-12
 12299              	 .cfi_offset 7,-8
 12300              	 .cfi_offset 14,-4
 12301 0002 83B0     	 sub sp,sp,#12
 12302              	.LCFI358:
 12303              	 .cfi_def_cfa_offset 24
 12304 0004 00AF     	 add r7,sp,#0
 12305              	.LCFI359:
 12306              	 .cfi_def_cfa_register 7
 12307 0006 041C     	 mov r4,r0
 12308 0008 081C     	 mov r0,r1
 12309 000a 111C     	 mov r1,r2
 12310 000c FB1D     	 add r3,r7,#7
 12311 000e 221C     	 add r2,r4,#0
 12312 0010 1A70     	 strb r2,[r3]
 12313 0012 BB1D     	 add r3,r7,#6
 12314 0014 021C     	 add r2,r0,#0
 12315 0016 1A70     	 strb r2,[r3]
 12316 0018 7B1D     	 add r3,r7,#5
 12317 001a 0A1C     	 add r2,r1,#0
 12318 001c 1A70     	 strb r2,[r3]
2557:../XMC1100-LibHaas.c **** 	switch (PIN)
 12319              	 .loc 3 2557 0
 12320 001e FB1D     	 add r3,r7,#7
 12321 0020 1B78     	 ldrb r3,[r3]
 12322 0022 062B     	 cmp r3,#6
 12323 0024 44D0     	 beq .L629
 12324 0026 0C2B     	 cmp r3,#12
 12325 0028 00D1     	 bne .LCB11126
 12326 002a 80E0     	 b .L630
 12327              	.LCB11126:
 12328 002c 002B     	 cmp r3,#0
 12329 002e 00D0     	 beq .LCB11128
 12330 0030 BBE0     	 b .L627
 12331              	.LCB11128:
2558:../XMC1100-LibHaas.c **** 	{
2559:../XMC1100-LibHaas.c **** 
2560:../XMC1100-LibHaas.c **** 	case 0 :  //Pin 0 wurde Ausgewählt
2561:../XMC1100-LibHaas.c **** 		bit_init(P0, 0, INP);
 12332              	 .loc 3 2561 0
 12333 0032 0020     	 mov r0,#0
 12334 0034 0021     	 mov r1,#0
 12335 0036 0022     	 mov r2,#0
 12336 0038 FFF7FEFF 	 bl bit_init
2562:../XMC1100-LibHaas.c **** 		if (Start == RE)   //PIN 0 und steigende Flanke als Start
 12337              	 .loc 3 2562 0
 12338 003c BB1D     	 add r3,r7,#6
 12339 003e 1B78     	 ldrb r3,[r3]
 12340 0040 012B     	 cmp r3,#1
 12341 0042 17D1     	 bne .L632
2563:../XMC1100-LibHaas.c **** 		{
2564:../XMC1100-LibHaas.c **** 			CCU40_CC40->CMC &= 0xFFFFFFF9;
 12342              	 .loc 3 2564 0
 12343 0044 5A4B     	 ldr r3,.L638
 12344 0046 5A4A     	 ldr r2,.L638
 12345 0048 5268     	 ldr r2,[r2,#4]
 12346 004a 0621     	 mov r1,#6
 12347 004c 8A43     	 bic r2,r1
 12348 004e 5A60     	 str r2,[r3,#4]
2565:../XMC1100-LibHaas.c **** 			CCU40_CC40->CMC |= 0x00000009;
 12349              	 .loc 3 2565 0
 12350 0050 574B     	 ldr r3,.L638
 12351 0052 574A     	 ldr r2,.L638
 12352 0054 5268     	 ldr r2,[r2,#4]
 12353 0056 0921     	 mov r1,#9
 12354 0058 0A43     	 orr r2,r1
 12355 005a 5A60     	 str r2,[r3,#4]
2566:../XMC1100-LibHaas.c **** 
2567:../XMC1100-LibHaas.c **** 			CCU40_CC40->INS &= 0xFF39FF22;
 12356              	 .loc 3 2567 0
 12357 005c 544B     	 ldr r3,.L638
 12358 005e 544A     	 ldr r2,.L638
 12359 0060 1268     	 ldr r2,[r2]
 12360 0062 5449     	 ldr r1,.L638+4
 12361 0064 0A40     	 and r2,r1
 12362 0066 1A60     	 str r2,[r3]
2568:../XMC1100-LibHaas.c **** 			CCU40_CC40->INS |= 0x1E090022;
 12363              	 .loc 3 2568 0
 12364 0068 514B     	 ldr r3,.L638
 12365 006a 514A     	 ldr r2,.L638
 12366 006c 1268     	 ldr r2,[r2]
 12367 006e 5249     	 ldr r1,.L638+8
 12368 0070 0A43     	 orr r2,r1
 12369 0072 1A60     	 str r2,[r3]
 12370              	.L632:
2569:../XMC1100-LibHaas.c **** 		}
2570:../XMC1100-LibHaas.c **** 
2571:../XMC1100-LibHaas.c **** 		if (Start == FE)  //PIN 0 und fallende Flanke als Start
 12371              	 .loc 3 2571 0
 12372 0074 BB1D     	 add r3,r7,#6
 12373 0076 1B78     	 ldrb r3,[r3]
 12374 0078 002B     	 cmp r3,#0
 12375 007a 18D1     	 bne .L633
2572:../XMC1100-LibHaas.c **** 		{
2573:../XMC1100-LibHaas.c **** 			CCU40_CC40->CMC &= 0xFFFFFFF9;
 12376              	 .loc 3 2573 0
 12377 007c 4C4B     	 ldr r3,.L638
 12378 007e 4C4A     	 ldr r2,.L638
 12379 0080 5268     	 ldr r2,[r2,#4]
 12380 0082 0621     	 mov r1,#6
 12381 0084 8A43     	 bic r2,r1
 12382 0086 5A60     	 str r2,[r3,#4]
2574:../XMC1100-LibHaas.c **** 			CCU40_CC40->CMC |= 0x00000009;
 12383              	 .loc 3 2574 0
 12384 0088 494B     	 ldr r3,.L638
 12385 008a 494A     	 ldr r2,.L638
 12386 008c 5268     	 ldr r2,[r2,#4]
 12387 008e 0921     	 mov r1,#9
 12388 0090 0A43     	 orr r2,r1
 12389 0092 5A60     	 str r2,[r3,#4]
2575:../XMC1100-LibHaas.c **** 
2576:../XMC1100-LibHaas.c **** 			CCU40_CC40->INS &= 0xFF36FF22;
 12390              	 .loc 3 2576 0
 12391 0094 464B     	 ldr r3,.L638
 12392 0096 464A     	 ldr r2,.L638
 12393 0098 1268     	 ldr r2,[r2]
 12394 009a 4849     	 ldr r1,.L638+12
 12395 009c 0A40     	 and r2,r1
 12396 009e 1A60     	 str r2,[r3]
2577:../XMC1100-LibHaas.c **** 			CCU40_CC40->INS |= 0x1E060022;
 12397              	 .loc 3 2577 0
 12398 00a0 434B     	 ldr r3,.L638
 12399 00a2 434A     	 ldr r2,.L638
 12400 00a4 1268     	 ldr r2,[r2]
 12401 00a6 4649     	 ldr r1,.L638+16
 12402 00a8 0A43     	 orr r2,r1
 12403 00aa 1A60     	 str r2,[r3]
2578:../XMC1100-LibHaas.c **** 		}
2579:../XMC1100-LibHaas.c **** 		break;
 12404              	 .loc 3 2579 0
 12405 00ac 7DE0     	 b .L627
 12406              	.L633:
 12407 00ae 7CE0     	 b .L627
 12408              	.L629:
2580:../XMC1100-LibHaas.c **** 
2581:../XMC1100-LibHaas.c **** 
2582:../XMC1100-LibHaas.c **** 	case 6:  //Pin 6 wurde Ausgewählt
2583:../XMC1100-LibHaas.c **** 		bit_init(P0, 6, INP);
 12409              	 .loc 3 2583 0
 12410 00b0 0020     	 mov r0,#0
 12411 00b2 0621     	 mov r1,#6
 12412 00b4 0022     	 mov r2,#0
 12413 00b6 FFF7FEFF 	 bl bit_init
2584:../XMC1100-LibHaas.c **** 		if  (Start == RE)   //PIN 6 und steigende Flanke als Start
 12414              	 .loc 3 2584 0
 12415 00ba BB1D     	 add r3,r7,#6
 12416 00bc 1B78     	 ldrb r3,[r3]
 12417 00be 012B     	 cmp r3,#1
 12418 00c0 17D1     	 bne .L634
2585:../XMC1100-LibHaas.c **** 		{
2586:../XMC1100-LibHaas.c **** 			CCU40_CC40->CMC &= 0xFFFFFFF9;
 12419              	 .loc 3 2586 0
 12420 00c2 3B4B     	 ldr r3,.L638
 12421 00c4 3A4A     	 ldr r2,.L638
 12422 00c6 5268     	 ldr r2,[r2,#4]
 12423 00c8 0621     	 mov r1,#6
 12424 00ca 8A43     	 bic r2,r1
 12425 00cc 5A60     	 str r2,[r3,#4]
2587:../XMC1100-LibHaas.c **** 			CCU40_CC40->CMC |= 0x00000009;
 12426              	 .loc 3 2587 0
 12427 00ce 384B     	 ldr r3,.L638
 12428 00d0 374A     	 ldr r2,.L638
 12429 00d2 5268     	 ldr r2,[r2,#4]
 12430 00d4 0921     	 mov r1,#9
 12431 00d6 0A43     	 orr r2,r1
 12432 00d8 5A60     	 str r2,[r3,#4]
2588:../XMC1100-LibHaas.c **** 
2589:../XMC1100-LibHaas.c **** 			CCU40_CC40->INS &= 0xFF39FF11;
 12433              	 .loc 3 2589 0
 12434 00da 354B     	 ldr r3,.L638
 12435 00dc 344A     	 ldr r2,.L638
 12436 00de 1268     	 ldr r2,[r2]
 12437 00e0 3849     	 ldr r1,.L638+20
 12438 00e2 0A40     	 and r2,r1
 12439 00e4 1A60     	 str r2,[r3]
2590:../XMC1100-LibHaas.c **** 			CCU40_CC40->INS |= 0x1E090011;
 12440              	 .loc 3 2590 0
 12441 00e6 324B     	 ldr r3,.L638
 12442 00e8 314A     	 ldr r2,.L638
 12443 00ea 1268     	 ldr r2,[r2]
 12444 00ec 3649     	 ldr r1,.L638+24
 12445 00ee 0A43     	 orr r2,r1
 12446 00f0 1A60     	 str r2,[r3]
 12447              	.L634:
2591:../XMC1100-LibHaas.c **** 		}
2592:../XMC1100-LibHaas.c **** 
2593:../XMC1100-LibHaas.c **** 		if (Start == FE)   //PIN 6 und fallende Flanke als Start
 12448              	 .loc 3 2593 0
 12449 00f2 BB1D     	 add r3,r7,#6
 12450 00f4 1B78     	 ldrb r3,[r3]
 12451 00f6 002B     	 cmp r3,#0
 12452 00f8 18D1     	 bne .L635
2594:../XMC1100-LibHaas.c **** 		{
2595:../XMC1100-LibHaas.c **** 			CCU40_CC40->CMC &= 0xFFFFFFF9;
 12453              	 .loc 3 2595 0
 12454 00fa 2D4B     	 ldr r3,.L638
 12455 00fc 2C4A     	 ldr r2,.L638
 12456 00fe 5268     	 ldr r2,[r2,#4]
 12457 0100 0621     	 mov r1,#6
 12458 0102 8A43     	 bic r2,r1
 12459 0104 5A60     	 str r2,[r3,#4]
2596:../XMC1100-LibHaas.c **** 			CCU40_CC40->CMC |= 0x00000009;
 12460              	 .loc 3 2596 0
 12461 0106 2A4B     	 ldr r3,.L638
 12462 0108 294A     	 ldr r2,.L638
 12463 010a 5268     	 ldr r2,[r2,#4]
 12464 010c 0921     	 mov r1,#9
 12465 010e 0A43     	 orr r2,r1
 12466 0110 5A60     	 str r2,[r3,#4]
2597:../XMC1100-LibHaas.c **** 
2598:../XMC1100-LibHaas.c **** 			CCU40_CC40->INS &= 0xFF36FF11;
 12467              	 .loc 3 2598 0
 12468 0112 274B     	 ldr r3,.L638
 12469 0114 264A     	 ldr r2,.L638
 12470 0116 1268     	 ldr r2,[r2]
 12471 0118 2C49     	 ldr r1,.L638+28
 12472 011a 0A40     	 and r2,r1
 12473 011c 1A60     	 str r2,[r3]
2599:../XMC1100-LibHaas.c **** 			CCU40_CC40->INS |= 0x1E060011;
 12474              	 .loc 3 2599 0
 12475 011e 244B     	 ldr r3,.L638
 12476 0120 234A     	 ldr r2,.L638
 12477 0122 1268     	 ldr r2,[r2]
 12478 0124 2A49     	 ldr r1,.L638+32
 12479 0126 0A43     	 orr r2,r1
 12480 0128 1A60     	 str r2,[r3]
2600:../XMC1100-LibHaas.c **** 		}
2601:../XMC1100-LibHaas.c **** 		break;
 12481              	 .loc 3 2601 0
 12482 012a 3EE0     	 b .L627
 12483              	.L635:
 12484 012c 3DE0     	 b .L627
 12485              	.L630:
2602:../XMC1100-LibHaas.c **** 
2603:../XMC1100-LibHaas.c **** 	case 12:  //Pin 12 wurde Ausgewählt
2604:../XMC1100-LibHaas.c **** 		bit_init(P0, 12, INP);
 12486              	 .loc 3 2604 0
 12487 012e 0020     	 mov r0,#0
 12488 0130 0C21     	 mov r1,#12
 12489 0132 0022     	 mov r2,#0
 12490 0134 FFF7FEFF 	 bl bit_init
2605:../XMC1100-LibHaas.c **** 		if  (Start == RE)   //PIN 12 und steigende Flanke als Start
 12491              	 .loc 3 2605 0
 12492 0138 BB1D     	 add r3,r7,#6
 12493 013a 1B78     	 ldrb r3,[r3]
 12494 013c 012B     	 cmp r3,#1
 12495 013e 17D1     	 bne .L636
2606:../XMC1100-LibHaas.c **** 		{
2607:../XMC1100-LibHaas.c **** 			CCU40_CC40->CMC &= 0xFFFFFFF9;
 12496              	 .loc 3 2607 0
 12497 0140 1B4B     	 ldr r3,.L638
 12498 0142 1B4A     	 ldr r2,.L638
 12499 0144 5268     	 ldr r2,[r2,#4]
 12500 0146 0621     	 mov r1,#6
 12501 0148 8A43     	 bic r2,r1
 12502 014a 5A60     	 str r2,[r3,#4]
2608:../XMC1100-LibHaas.c **** 			CCU40_CC40->CMC |= 0x00000009;
 12503              	 .loc 3 2608 0
 12504 014c 184B     	 ldr r3,.L638
 12505 014e 184A     	 ldr r2,.L638
 12506 0150 5268     	 ldr r2,[r2,#4]
 12507 0152 0921     	 mov r1,#9
 12508 0154 0A43     	 orr r2,r1
 12509 0156 5A60     	 str r2,[r3,#4]
2609:../XMC1100-LibHaas.c **** 
2610:../XMC1100-LibHaas.c **** 			CCU40_CC40->INS &= 0xFF39FF00;
 12510              	 .loc 3 2610 0
 12511 0158 154B     	 ldr r3,.L638
 12512 015a 154A     	 ldr r2,.L638
 12513 015c 1268     	 ldr r2,[r2]
 12514 015e 1D49     	 ldr r1,.L638+36
 12515 0160 0A40     	 and r2,r1
 12516 0162 1A60     	 str r2,[r3]
2611:../XMC1100-LibHaas.c **** 			CCU40_CC40->INS |= 0x1E090000;
 12517              	 .loc 3 2611 0
 12518 0164 124B     	 ldr r3,.L638
 12519 0166 124A     	 ldr r2,.L638
 12520 0168 1268     	 ldr r2,[r2]
 12521 016a 1B49     	 ldr r1,.L638+40
 12522 016c 0A43     	 orr r2,r1
 12523 016e 1A60     	 str r2,[r3]
 12524              	.L636:
2612:../XMC1100-LibHaas.c **** 		}
2613:../XMC1100-LibHaas.c **** 
2614:../XMC1100-LibHaas.c **** 		if (Start == FE)   //PIN 12 und fallende Flanke als Start
 12525              	 .loc 3 2614 0
 12526 0170 BB1D     	 add r3,r7,#6
 12527 0172 1B78     	 ldrb r3,[r3]
 12528 0174 002B     	 cmp r3,#0
 12529 0176 17D1     	 bne .L637
2615:../XMC1100-LibHaas.c **** 		{
2616:../XMC1100-LibHaas.c **** 			CCU40_CC40->CMC &= 0xFFFFFFF9;
 12530              	 .loc 3 2616 0
 12531 0178 0D4B     	 ldr r3,.L638
 12532 017a 0D4A     	 ldr r2,.L638
 12533 017c 5268     	 ldr r2,[r2,#4]
 12534 017e 0621     	 mov r1,#6
 12535 0180 8A43     	 bic r2,r1
 12536 0182 5A60     	 str r2,[r3,#4]
2617:../XMC1100-LibHaas.c **** 			CCU40_CC40->CMC |= 0x00000009;
 12537              	 .loc 3 2617 0
 12538 0184 0A4B     	 ldr r3,.L638
 12539 0186 0A4A     	 ldr r2,.L638
 12540 0188 5268     	 ldr r2,[r2,#4]
 12541 018a 0921     	 mov r1,#9
 12542 018c 0A43     	 orr r2,r1
 12543 018e 5A60     	 str r2,[r3,#4]
2618:../XMC1100-LibHaas.c **** 
2619:../XMC1100-LibHaas.c **** 			CCU40_CC40->INS &= 0xFF36FF00;
 12544              	 .loc 3 2619 0
 12545 0190 074B     	 ldr r3,.L638
 12546 0192 074A     	 ldr r2,.L638
 12547 0194 1268     	 ldr r2,[r2]
 12548 0196 1149     	 ldr r1,.L638+44
 12549 0198 0A40     	 and r2,r1
 12550 019a 1A60     	 str r2,[r3]
2620:../XMC1100-LibHaas.c **** 			CCU40_CC40->INS |= 0x1E060000;
 12551              	 .loc 3 2620 0
 12552 019c 044B     	 ldr r3,.L638
 12553 019e 044A     	 ldr r2,.L638
 12554 01a0 1268     	 ldr r2,[r2]
 12555 01a2 0F49     	 ldr r1,.L638+48
 12556 01a4 0A43     	 orr r2,r1
 12557 01a6 1A60     	 str r2,[r3]
 12558              	.L637:
2621:../XMC1100-LibHaas.c **** 		}
2622:../XMC1100-LibHaas.c **** 		break;
 12559              	 .loc 3 2622 0
 12560 01a8 C046     	 mov r8,r8
 12561              	.L627:
2623:../XMC1100-LibHaas.c **** 	} // Ende switch
2624:../XMC1100-LibHaas.c **** }
 12562              	 .loc 3 2624 0
 12563 01aa BD46     	 mov sp,r7
 12564 01ac 03B0     	 add sp,sp,#12
 12565              	 
 12566 01ae 90BD     	 pop {r4,r7,pc}
 12567              	.L639:
 12568              	 .align 2
 12569              	.L638:
 12570 01b0 00010448 	 .word 1208221952
 12571 01b4 22FF39FF 	 .word -12976350
 12572 01b8 2200091E 	 .word 503906338
 12573 01bc 22FF36FF 	 .word -13172958
 12574 01c0 2200061E 	 .word 503709730
 12575 01c4 11FF39FF 	 .word -12976367
 12576 01c8 1100091E 	 .word 503906321
 12577 01cc 11FF36FF 	 .word -13172975
 12578 01d0 1100061E 	 .word 503709713
 12579 01d4 00FF39FF 	 .word -12976384
 12580 01d8 0000091E 	 .word 503906304
 12581 01dc 00FF36FF 	 .word -13172992
 12582 01e0 0000061E 	 .word 503709696
 12583              	 .cfi_endproc
 12584              	.LFE171:
 12586              	 .section .text.timer1_extern_controll,"ax",%progbits
 12587              	 .align 2
 12588              	 .global timer1_extern_controll
 12589              	 .code 16
 12590              	 .thumb_func
 12592              	timer1_extern_controll:
 12593              	.LFB172:
2625:../XMC1100-LibHaas.c **** 
2626:../XMC1100-LibHaas.c **** //Extrene kontrolle des Timer 1
2627:../XMC1100-LibHaas.c **** //Auswahl zwischen Pin 1, Pin 7 und Pin 12
2628:../XMC1100-LibHaas.c **** //Auswahl bei Start zwischen RE=Steigende Flanke und FE=Fallende Flanke
2629:../XMC1100-LibHaas.c **** //Auswahl bei Stop zwischen RE=Steigende Flanke und FE=Fallende Flanke
2630:../XMC1100-LibHaas.c **** void timer1_extern_controll(uint8_t PIN, uint8_t Start, uint8_t Stopp)
2631:../XMC1100-LibHaas.c **** {
 12594              	 .loc 3 2631 0
 12595              	 .cfi_startproc
 12596 0000 90B5     	 push {r4,r7,lr}
 12597              	.LCFI360:
 12598              	 .cfi_def_cfa_offset 12
 12599              	 .cfi_offset 4,-12
 12600              	 .cfi_offset 7,-8
 12601              	 .cfi_offset 14,-4
 12602 0002 83B0     	 sub sp,sp,#12
 12603              	.LCFI361:
 12604              	 .cfi_def_cfa_offset 24
 12605 0004 00AF     	 add r7,sp,#0
 12606              	.LCFI362:
 12607              	 .cfi_def_cfa_register 7
 12608 0006 041C     	 mov r4,r0
 12609 0008 081C     	 mov r0,r1
 12610 000a 111C     	 mov r1,r2
 12611 000c FB1D     	 add r3,r7,#7
 12612 000e 221C     	 add r2,r4,#0
 12613 0010 1A70     	 strb r2,[r3]
 12614 0012 BB1D     	 add r3,r7,#6
 12615 0014 021C     	 add r2,r0,#0
 12616 0016 1A70     	 strb r2,[r3]
 12617 0018 7B1D     	 add r3,r7,#5
 12618 001a 0A1C     	 add r2,r1,#0
 12619 001c 1A70     	 strb r2,[r3]
2632:../XMC1100-LibHaas.c **** 	switch (PIN)
 12620              	 .loc 3 2632 0
 12621 001e FB1D     	 add r3,r7,#7
 12622 0020 1B78     	 ldrb r3,[r3]
 12623 0022 072B     	 cmp r3,#7
 12624 0024 44D0     	 beq .L642
 12625 0026 0C2B     	 cmp r3,#12
 12626 0028 00D1     	 bne .LCB11397
 12627 002a 80E0     	 b .L643
 12628              	.LCB11397:
 12629 002c 012B     	 cmp r3,#1
 12630 002e 00D0     	 beq .LCB11399
 12631 0030 BBE0     	 b .L640
 12632              	.LCB11399:
2633:../XMC1100-LibHaas.c **** 	{
2634:../XMC1100-LibHaas.c **** 
2635:../XMC1100-LibHaas.c **** 	case 1 :  //Pin 1 wurde Ausgewählt
2636:../XMC1100-LibHaas.c **** 		bit_init(P0, 1, INP);
 12633              	 .loc 3 2636 0
 12634 0032 0020     	 mov r0,#0
 12635 0034 0121     	 mov r1,#1
 12636 0036 0022     	 mov r2,#0
 12637 0038 FFF7FEFF 	 bl bit_init
2637:../XMC1100-LibHaas.c **** 		if (Start == RE)   //PIN 1 und steigende Flanke als Start
 12638              	 .loc 3 2637 0
 12639 003c BB1D     	 add r3,r7,#6
 12640 003e 1B78     	 ldrb r3,[r3]
 12641 0040 012B     	 cmp r3,#1
 12642 0042 17D1     	 bne .L645
2638:../XMC1100-LibHaas.c **** 		{
2639:../XMC1100-LibHaas.c **** 			CCU40_CC41->CMC &= 0xFFFFFFF9;
 12643              	 .loc 3 2639 0
 12644 0044 5A4B     	 ldr r3,.L651
 12645 0046 5A4A     	 ldr r2,.L651
 12646 0048 5268     	 ldr r2,[r2,#4]
 12647 004a 0621     	 mov r1,#6
 12648 004c 8A43     	 bic r2,r1
 12649 004e 5A60     	 str r2,[r3,#4]
2640:../XMC1100-LibHaas.c **** 			CCU40_CC41->CMC |= 0x00000009;
 12650              	 .loc 3 2640 0
 12651 0050 574B     	 ldr r3,.L651
 12652 0052 574A     	 ldr r2,.L651
 12653 0054 5268     	 ldr r2,[r2,#4]
 12654 0056 0921     	 mov r1,#9
 12655 0058 0A43     	 orr r2,r1
 12656 005a 5A60     	 str r2,[r3,#4]
2641:../XMC1100-LibHaas.c **** 
2642:../XMC1100-LibHaas.c **** 			CCU40_CC41->INS &= 0xFF39FF22;
 12657              	 .loc 3 2642 0
 12658 005c 544B     	 ldr r3,.L651
 12659 005e 544A     	 ldr r2,.L651
 12660 0060 1268     	 ldr r2,[r2]
 12661 0062 5449     	 ldr r1,.L651+4
 12662 0064 0A40     	 and r2,r1
 12663 0066 1A60     	 str r2,[r3]
2643:../XMC1100-LibHaas.c **** 			CCU40_CC41->INS |= 0x1E090022;
 12664              	 .loc 3 2643 0
 12665 0068 514B     	 ldr r3,.L651
 12666 006a 514A     	 ldr r2,.L651
 12667 006c 1268     	 ldr r2,[r2]
 12668 006e 5249     	 ldr r1,.L651+8
 12669 0070 0A43     	 orr r2,r1
 12670 0072 1A60     	 str r2,[r3]
 12671              	.L645:
2644:../XMC1100-LibHaas.c **** 		}
2645:../XMC1100-LibHaas.c **** 
2646:../XMC1100-LibHaas.c **** 		if (Start == FE)  //PIN 1 und fallende Flanke als Start
 12672              	 .loc 3 2646 0
 12673 0074 BB1D     	 add r3,r7,#6
 12674 0076 1B78     	 ldrb r3,[r3]
 12675 0078 002B     	 cmp r3,#0
 12676 007a 18D1     	 bne .L646
2647:../XMC1100-LibHaas.c **** 		{
2648:../XMC1100-LibHaas.c **** 			CCU40_CC41->CMC &= 0xFFFFFFF9;
 12677              	 .loc 3 2648 0
 12678 007c 4C4B     	 ldr r3,.L651
 12679 007e 4C4A     	 ldr r2,.L651
 12680 0080 5268     	 ldr r2,[r2,#4]
 12681 0082 0621     	 mov r1,#6
 12682 0084 8A43     	 bic r2,r1
 12683 0086 5A60     	 str r2,[r3,#4]
2649:../XMC1100-LibHaas.c **** 			CCU40_CC41->CMC |= 0x00000009;
 12684              	 .loc 3 2649 0
 12685 0088 494B     	 ldr r3,.L651
 12686 008a 494A     	 ldr r2,.L651
 12687 008c 5268     	 ldr r2,[r2,#4]
 12688 008e 0921     	 mov r1,#9
 12689 0090 0A43     	 orr r2,r1
 12690 0092 5A60     	 str r2,[r3,#4]
2650:../XMC1100-LibHaas.c **** 
2651:../XMC1100-LibHaas.c **** 			CCU40_CC41->INS &= 0xFF36FF22;
 12691              	 .loc 3 2651 0
 12692 0094 464B     	 ldr r3,.L651
 12693 0096 464A     	 ldr r2,.L651
 12694 0098 1268     	 ldr r2,[r2]
 12695 009a 4849     	 ldr r1,.L651+12
 12696 009c 0A40     	 and r2,r1
 12697 009e 1A60     	 str r2,[r3]
2652:../XMC1100-LibHaas.c **** 			CCU40_CC41->INS |= 0x1E060022;
 12698              	 .loc 3 2652 0
 12699 00a0 434B     	 ldr r3,.L651
 12700 00a2 434A     	 ldr r2,.L651
 12701 00a4 1268     	 ldr r2,[r2]
 12702 00a6 4649     	 ldr r1,.L651+16
 12703 00a8 0A43     	 orr r2,r1
 12704 00aa 1A60     	 str r2,[r3]
2653:../XMC1100-LibHaas.c **** 		}
2654:../XMC1100-LibHaas.c **** 		break;
 12705              	 .loc 3 2654 0
 12706 00ac 7DE0     	 b .L640
 12707              	.L646:
 12708 00ae 7CE0     	 b .L640
 12709              	.L642:
2655:../XMC1100-LibHaas.c **** 
2656:../XMC1100-LibHaas.c **** 
2657:../XMC1100-LibHaas.c **** 	case 7:  //Pin 1 wurde Ausgewählt
2658:../XMC1100-LibHaas.c **** 
2659:../XMC1100-LibHaas.c **** 		bit_init(P0, 7, INP);
 12710              	 .loc 3 2659 0
 12711 00b0 0020     	 mov r0,#0
 12712 00b2 0721     	 mov r1,#7
 12713 00b4 0022     	 mov r2,#0
 12714 00b6 FFF7FEFF 	 bl bit_init
2660:../XMC1100-LibHaas.c **** 		if  (Start == RE)   //PIN 7 und steigende Flanke als Start
 12715              	 .loc 3 2660 0
 12716 00ba BB1D     	 add r3,r7,#6
 12717 00bc 1B78     	 ldrb r3,[r3]
 12718 00be 012B     	 cmp r3,#1
 12719 00c0 17D1     	 bne .L647
2661:../XMC1100-LibHaas.c **** 		{
2662:../XMC1100-LibHaas.c **** 			CCU40_CC41->CMC &= 0xFFFFFFF9;
 12720              	 .loc 3 2662 0
 12721 00c2 3B4B     	 ldr r3,.L651
 12722 00c4 3A4A     	 ldr r2,.L651
 12723 00c6 5268     	 ldr r2,[r2,#4]
 12724 00c8 0621     	 mov r1,#6
 12725 00ca 8A43     	 bic r2,r1
 12726 00cc 5A60     	 str r2,[r3,#4]
2663:../XMC1100-LibHaas.c **** 			CCU40_CC41->CMC |= 0x00000009;
 12727              	 .loc 3 2663 0
 12728 00ce 384B     	 ldr r3,.L651
 12729 00d0 374A     	 ldr r2,.L651
 12730 00d2 5268     	 ldr r2,[r2,#4]
 12731 00d4 0921     	 mov r1,#9
 12732 00d6 0A43     	 orr r2,r1
 12733 00d8 5A60     	 str r2,[r3,#4]
2664:../XMC1100-LibHaas.c **** 
2665:../XMC1100-LibHaas.c **** 			CCU40_CC41->INS &= 0xFF39FF11;
 12734              	 .loc 3 2665 0
 12735 00da 354B     	 ldr r3,.L651
 12736 00dc 344A     	 ldr r2,.L651
 12737 00de 1268     	 ldr r2,[r2]
 12738 00e0 3849     	 ldr r1,.L651+20
 12739 00e2 0A40     	 and r2,r1
 12740 00e4 1A60     	 str r2,[r3]
2666:../XMC1100-LibHaas.c **** 			CCU40_CC41->INS |= 0x1E090011;
 12741              	 .loc 3 2666 0
 12742 00e6 324B     	 ldr r3,.L651
 12743 00e8 314A     	 ldr r2,.L651
 12744 00ea 1268     	 ldr r2,[r2]
 12745 00ec 3649     	 ldr r1,.L651+24
 12746 00ee 0A43     	 orr r2,r1
 12747 00f0 1A60     	 str r2,[r3]
 12748              	.L647:
2667:../XMC1100-LibHaas.c **** 		}
2668:../XMC1100-LibHaas.c **** 
2669:../XMC1100-LibHaas.c **** 		if (Start == FE)   //PIN 7 und fallende Flanke als Start
 12749              	 .loc 3 2669 0
 12750 00f2 BB1D     	 add r3,r7,#6
 12751 00f4 1B78     	 ldrb r3,[r3]
 12752 00f6 002B     	 cmp r3,#0
 12753 00f8 18D1     	 bne .L648
2670:../XMC1100-LibHaas.c **** 		{
2671:../XMC1100-LibHaas.c **** 			CCU40_CC41->CMC &= 0xFFFFFFF9;
 12754              	 .loc 3 2671 0
 12755 00fa 2D4B     	 ldr r3,.L651
 12756 00fc 2C4A     	 ldr r2,.L651
 12757 00fe 5268     	 ldr r2,[r2,#4]
 12758 0100 0621     	 mov r1,#6
 12759 0102 8A43     	 bic r2,r1
 12760 0104 5A60     	 str r2,[r3,#4]
2672:../XMC1100-LibHaas.c **** 			CCU40_CC41->CMC |= 0x00000009;
 12761              	 .loc 3 2672 0
 12762 0106 2A4B     	 ldr r3,.L651
 12763 0108 294A     	 ldr r2,.L651
 12764 010a 5268     	 ldr r2,[r2,#4]
 12765 010c 0921     	 mov r1,#9
 12766 010e 0A43     	 orr r2,r1
 12767 0110 5A60     	 str r2,[r3,#4]
2673:../XMC1100-LibHaas.c **** 
2674:../XMC1100-LibHaas.c **** 			CCU40_CC41->INS &= 0xFF36FF11;
 12768              	 .loc 3 2674 0
 12769 0112 274B     	 ldr r3,.L651
 12770 0114 264A     	 ldr r2,.L651
 12771 0116 1268     	 ldr r2,[r2]
 12772 0118 2C49     	 ldr r1,.L651+28
 12773 011a 0A40     	 and r2,r1
 12774 011c 1A60     	 str r2,[r3]
2675:../XMC1100-LibHaas.c **** 			CCU40_CC41->INS |= 0x1E060011;
 12775              	 .loc 3 2675 0
 12776 011e 244B     	 ldr r3,.L651
 12777 0120 234A     	 ldr r2,.L651
 12778 0122 1268     	 ldr r2,[r2]
 12779 0124 2A49     	 ldr r1,.L651+32
 12780 0126 0A43     	 orr r2,r1
 12781 0128 1A60     	 str r2,[r3]
2676:../XMC1100-LibHaas.c **** 		}
2677:../XMC1100-LibHaas.c **** 		break;
 12782              	 .loc 3 2677 0
 12783 012a 3EE0     	 b .L640
 12784              	.L648:
 12785 012c 3DE0     	 b .L640
 12786              	.L643:
2678:../XMC1100-LibHaas.c **** 
2679:../XMC1100-LibHaas.c **** 	case 12:  //Pin 12 wurde Ausgewählt
2680:../XMC1100-LibHaas.c **** 		bit_init(P0, 12, INP);
 12787              	 .loc 3 2680 0
 12788 012e 0020     	 mov r0,#0
 12789 0130 0C21     	 mov r1,#12
 12790 0132 0022     	 mov r2,#0
 12791 0134 FFF7FEFF 	 bl bit_init
2681:../XMC1100-LibHaas.c **** 		if  (Start == RE)   //PIN 12 und steigende Flanke als Start
 12792              	 .loc 3 2681 0
 12793 0138 BB1D     	 add r3,r7,#6
 12794 013a 1B78     	 ldrb r3,[r3]
 12795 013c 012B     	 cmp r3,#1
 12796 013e 17D1     	 bne .L649
2682:../XMC1100-LibHaas.c **** 		{
2683:../XMC1100-LibHaas.c **** 			CCU40_CC41->CMC &= 0xFFFFFFF9;
 12797              	 .loc 3 2683 0
 12798 0140 1B4B     	 ldr r3,.L651
 12799 0142 1B4A     	 ldr r2,.L651
 12800 0144 5268     	 ldr r2,[r2,#4]
 12801 0146 0621     	 mov r1,#6
 12802 0148 8A43     	 bic r2,r1
 12803 014a 5A60     	 str r2,[r3,#4]
2684:../XMC1100-LibHaas.c **** 			CCU40_CC41->CMC |= 0x00000009;
 12804              	 .loc 3 2684 0
 12805 014c 184B     	 ldr r3,.L651
 12806 014e 184A     	 ldr r2,.L651
 12807 0150 5268     	 ldr r2,[r2,#4]
 12808 0152 0921     	 mov r1,#9
 12809 0154 0A43     	 orr r2,r1
 12810 0156 5A60     	 str r2,[r3,#4]
2685:../XMC1100-LibHaas.c **** 
2686:../XMC1100-LibHaas.c **** 			CCU40_CC41->INS &= 0xFF39FF00;
 12811              	 .loc 3 2686 0
 12812 0158 154B     	 ldr r3,.L651
 12813 015a 154A     	 ldr r2,.L651
 12814 015c 1268     	 ldr r2,[r2]
 12815 015e 1D49     	 ldr r1,.L651+36
 12816 0160 0A40     	 and r2,r1
 12817 0162 1A60     	 str r2,[r3]
2687:../XMC1100-LibHaas.c **** 			CCU40_CC41->INS |= 0x1E090000;
 12818              	 .loc 3 2687 0
 12819 0164 124B     	 ldr r3,.L651
 12820 0166 124A     	 ldr r2,.L651
 12821 0168 1268     	 ldr r2,[r2]
 12822 016a 1B49     	 ldr r1,.L651+40
 12823 016c 0A43     	 orr r2,r1
 12824 016e 1A60     	 str r2,[r3]
 12825              	.L649:
2688:../XMC1100-LibHaas.c **** 		}
2689:../XMC1100-LibHaas.c **** 
2690:../XMC1100-LibHaas.c **** 		if (Start == FE)   //PIN 12 und fallende Flanke als Start
 12826              	 .loc 3 2690 0
 12827 0170 BB1D     	 add r3,r7,#6
 12828 0172 1B78     	 ldrb r3,[r3]
 12829 0174 002B     	 cmp r3,#0
 12830 0176 17D1     	 bne .L650
2691:../XMC1100-LibHaas.c **** 		{
2692:../XMC1100-LibHaas.c **** 			CCU40_CC41->CMC &= 0xFFFFFFF9;
 12831              	 .loc 3 2692 0
 12832 0178 0D4B     	 ldr r3,.L651
 12833 017a 0D4A     	 ldr r2,.L651
 12834 017c 5268     	 ldr r2,[r2,#4]
 12835 017e 0621     	 mov r1,#6
 12836 0180 8A43     	 bic r2,r1
 12837 0182 5A60     	 str r2,[r3,#4]
2693:../XMC1100-LibHaas.c **** 			CCU40_CC41->CMC |= 0x00000009;
 12838              	 .loc 3 2693 0
 12839 0184 0A4B     	 ldr r3,.L651
 12840 0186 0A4A     	 ldr r2,.L651
 12841 0188 5268     	 ldr r2,[r2,#4]
 12842 018a 0921     	 mov r1,#9
 12843 018c 0A43     	 orr r2,r1
 12844 018e 5A60     	 str r2,[r3,#4]
2694:../XMC1100-LibHaas.c **** 
2695:../XMC1100-LibHaas.c **** 			CCU40_CC41->INS &= 0xFF36FF00;
 12845              	 .loc 3 2695 0
 12846 0190 074B     	 ldr r3,.L651
 12847 0192 074A     	 ldr r2,.L651
 12848 0194 1268     	 ldr r2,[r2]
 12849 0196 1149     	 ldr r1,.L651+44
 12850 0198 0A40     	 and r2,r1
 12851 019a 1A60     	 str r2,[r3]
2696:../XMC1100-LibHaas.c **** 			CCU40_CC41->INS |= 0x1E060000;
 12852              	 .loc 3 2696 0
 12853 019c 044B     	 ldr r3,.L651
 12854 019e 044A     	 ldr r2,.L651
 12855 01a0 1268     	 ldr r2,[r2]
 12856 01a2 0F49     	 ldr r1,.L651+48
 12857 01a4 0A43     	 orr r2,r1
 12858 01a6 1A60     	 str r2,[r3]
 12859              	.L650:
2697:../XMC1100-LibHaas.c **** 		}
2698:../XMC1100-LibHaas.c **** 		break;
 12860              	 .loc 3 2698 0
 12861 01a8 C046     	 mov r8,r8
 12862              	.L640:
2699:../XMC1100-LibHaas.c **** 	}
2700:../XMC1100-LibHaas.c **** }
 12863              	 .loc 3 2700 0
 12864 01aa BD46     	 mov sp,r7
 12865 01ac 03B0     	 add sp,sp,#12
 12866              	 
 12867 01ae 90BD     	 pop {r4,r7,pc}
 12868              	.L652:
 12869              	 .align 2
 12870              	.L651:
 12871 01b0 00020448 	 .word 1208222208
 12872 01b4 22FF39FF 	 .word -12976350
 12873 01b8 2200091E 	 .word 503906338
 12874 01bc 22FF36FF 	 .word -13172958
 12875 01c0 2200061E 	 .word 503709730
 12876 01c4 11FF39FF 	 .word -12976367
 12877 01c8 1100091E 	 .word 503906321
 12878 01cc 11FF36FF 	 .word -13172975
 12879 01d0 1100061E 	 .word 503709713
 12880 01d4 00FF39FF 	 .word -12976384
 12881 01d8 0000091E 	 .word 503906304
 12882 01dc 00FF36FF 	 .word -13172992
 12883 01e0 0000061E 	 .word 503709696
 12884              	 .cfi_endproc
 12885              	.LFE172:
 12887              	 .section .text.timer2_extern_controll,"ax",%progbits
 12888              	 .align 2
 12889              	 .global timer2_extern_controll
 12890              	 .code 16
 12891              	 .thumb_func
 12893              	timer2_extern_controll:
 12894              	.LFB173:
2701:../XMC1100-LibHaas.c **** 
2702:../XMC1100-LibHaas.c **** //Extrene kontrolle des Timer 2
2703:../XMC1100-LibHaas.c **** //Auswahl zwischen Pin 2, Pin 8 und Pin 12
2704:../XMC1100-LibHaas.c **** //Auswahl bei Start zwischen RE=Steigende Flanke und FE=Fallende Flanke
2705:../XMC1100-LibHaas.c **** //Auswahl bei Stop zwischen RE=Steigende Flanke und FE=Fallende Flanke
2706:../XMC1100-LibHaas.c **** void timer2_extern_controll(uint8_t PIN, uint8_t Start, uint8_t Stopp)
2707:../XMC1100-LibHaas.c **** {
 12895              	 .loc 3 2707 0
 12896              	 .cfi_startproc
 12897 0000 90B5     	 push {r4,r7,lr}
 12898              	.LCFI363:
 12899              	 .cfi_def_cfa_offset 12
 12900              	 .cfi_offset 4,-12
 12901              	 .cfi_offset 7,-8
 12902              	 .cfi_offset 14,-4
 12903 0002 83B0     	 sub sp,sp,#12
 12904              	.LCFI364:
 12905              	 .cfi_def_cfa_offset 24
 12906 0004 00AF     	 add r7,sp,#0
 12907              	.LCFI365:
 12908              	 .cfi_def_cfa_register 7
 12909 0006 041C     	 mov r4,r0
 12910 0008 081C     	 mov r0,r1
 12911 000a 111C     	 mov r1,r2
 12912 000c FB1D     	 add r3,r7,#7
 12913 000e 221C     	 add r2,r4,#0
 12914 0010 1A70     	 strb r2,[r3]
 12915 0012 BB1D     	 add r3,r7,#6
 12916 0014 021C     	 add r2,r0,#0
 12917 0016 1A70     	 strb r2,[r3]
 12918 0018 7B1D     	 add r3,r7,#5
 12919 001a 0A1C     	 add r2,r1,#0
 12920 001c 1A70     	 strb r2,[r3]
2708:../XMC1100-LibHaas.c **** 	switch (PIN)
 12921              	 .loc 3 2708 0
 12922 001e FB1D     	 add r3,r7,#7
 12923 0020 1B78     	 ldrb r3,[r3]
 12924 0022 082B     	 cmp r3,#8
 12925 0024 44D0     	 beq .L655
 12926 0026 0C2B     	 cmp r3,#12
 12927 0028 00D1     	 bne .LCB11668
 12928 002a 80E0     	 b .L656
 12929              	.LCB11668:
 12930 002c 022B     	 cmp r3,#2
 12931 002e 00D0     	 beq .LCB11670
 12932 0030 BBE0     	 b .L653
 12933              	.LCB11670:
2709:../XMC1100-LibHaas.c **** 	{
2710:../XMC1100-LibHaas.c **** 	case 2 :  //Pin 2 wurde Ausgewählt
2711:../XMC1100-LibHaas.c **** 		bit_init(P0, 2, INP);
 12934              	 .loc 3 2711 0
 12935 0032 0020     	 mov r0,#0
 12936 0034 0221     	 mov r1,#2
 12937 0036 0022     	 mov r2,#0
 12938 0038 FFF7FEFF 	 bl bit_init
2712:../XMC1100-LibHaas.c **** 		if (Start == RE)   //PIN 2 und steigende Flanke als Start
 12939              	 .loc 3 2712 0
 12940 003c BB1D     	 add r3,r7,#6
 12941 003e 1B78     	 ldrb r3,[r3]
 12942 0040 012B     	 cmp r3,#1
 12943 0042 17D1     	 bne .L658
2713:../XMC1100-LibHaas.c **** 		{
2714:../XMC1100-LibHaas.c **** 			CCU40_CC42->CMC &= 0xFFFFFFF9;
 12944              	 .loc 3 2714 0
 12945 0044 5A4B     	 ldr r3,.L664
 12946 0046 5A4A     	 ldr r2,.L664
 12947 0048 5268     	 ldr r2,[r2,#4]
 12948 004a 0621     	 mov r1,#6
 12949 004c 8A43     	 bic r2,r1
 12950 004e 5A60     	 str r2,[r3,#4]
2715:../XMC1100-LibHaas.c **** 			CCU40_CC42->CMC |= 0x00000009;
 12951              	 .loc 3 2715 0
 12952 0050 574B     	 ldr r3,.L664
 12953 0052 574A     	 ldr r2,.L664
 12954 0054 5268     	 ldr r2,[r2,#4]
 12955 0056 0921     	 mov r1,#9
 12956 0058 0A43     	 orr r2,r1
 12957 005a 5A60     	 str r2,[r3,#4]
2716:../XMC1100-LibHaas.c **** 
2717:../XMC1100-LibHaas.c **** 			CCU40_CC42->INS &= 0xFF39FF22;
 12958              	 .loc 3 2717 0
 12959 005c 544B     	 ldr r3,.L664
 12960 005e 544A     	 ldr r2,.L664
 12961 0060 1268     	 ldr r2,[r2]
 12962 0062 5449     	 ldr r1,.L664+4
 12963 0064 0A40     	 and r2,r1
 12964 0066 1A60     	 str r2,[r3]
2718:../XMC1100-LibHaas.c **** 			CCU40_CC42->INS |= 0x1E090022;
 12965              	 .loc 3 2718 0
 12966 0068 514B     	 ldr r3,.L664
 12967 006a 514A     	 ldr r2,.L664
 12968 006c 1268     	 ldr r2,[r2]
 12969 006e 5249     	 ldr r1,.L664+8
 12970 0070 0A43     	 orr r2,r1
 12971 0072 1A60     	 str r2,[r3]
 12972              	.L658:
2719:../XMC1100-LibHaas.c **** 		}
2720:../XMC1100-LibHaas.c **** 
2721:../XMC1100-LibHaas.c **** 		if (Start == FE)  //PIN 2 und fallende Flanke als Start
 12973              	 .loc 3 2721 0
 12974 0074 BB1D     	 add r3,r7,#6
 12975 0076 1B78     	 ldrb r3,[r3]
 12976 0078 002B     	 cmp r3,#0
 12977 007a 18D1     	 bne .L659
2722:../XMC1100-LibHaas.c **** 		{
2723:../XMC1100-LibHaas.c **** 			CCU40_CC42->CMC &= 0xFFFFFFF9;
 12978              	 .loc 3 2723 0
 12979 007c 4C4B     	 ldr r3,.L664
 12980 007e 4C4A     	 ldr r2,.L664
 12981 0080 5268     	 ldr r2,[r2,#4]
 12982 0082 0621     	 mov r1,#6
 12983 0084 8A43     	 bic r2,r1
 12984 0086 5A60     	 str r2,[r3,#4]
2724:../XMC1100-LibHaas.c **** 			CCU40_CC42->CMC |= 0x00000009;
 12985              	 .loc 3 2724 0
 12986 0088 494B     	 ldr r3,.L664
 12987 008a 494A     	 ldr r2,.L664
 12988 008c 5268     	 ldr r2,[r2,#4]
 12989 008e 0921     	 mov r1,#9
 12990 0090 0A43     	 orr r2,r1
 12991 0092 5A60     	 str r2,[r3,#4]
2725:../XMC1100-LibHaas.c **** 
2726:../XMC1100-LibHaas.c **** 			CCU40_CC42->INS &= 0xFF36FF22;
 12992              	 .loc 3 2726 0
 12993 0094 464B     	 ldr r3,.L664
 12994 0096 464A     	 ldr r2,.L664
 12995 0098 1268     	 ldr r2,[r2]
 12996 009a 4849     	 ldr r1,.L664+12
 12997 009c 0A40     	 and r2,r1
 12998 009e 1A60     	 str r2,[r3]
2727:../XMC1100-LibHaas.c **** 			CCU40_CC42->INS |= 0x1E060022;
 12999              	 .loc 3 2727 0
 13000 00a0 434B     	 ldr r3,.L664
 13001 00a2 434A     	 ldr r2,.L664
 13002 00a4 1268     	 ldr r2,[r2]
 13003 00a6 4649     	 ldr r1,.L664+16
 13004 00a8 0A43     	 orr r2,r1
 13005 00aa 1A60     	 str r2,[r3]
2728:../XMC1100-LibHaas.c **** 		}
2729:../XMC1100-LibHaas.c **** 		break;
 13006              	 .loc 3 2729 0
 13007 00ac 7DE0     	 b .L653
 13008              	.L659:
 13009 00ae 7CE0     	 b .L653
 13010              	.L655:
2730:../XMC1100-LibHaas.c **** 
2731:../XMC1100-LibHaas.c **** 	case 8:  //Pin 8 wurde Ausgewählt
2732:../XMC1100-LibHaas.c **** 		bit_init(P0, 8, INP);
 13011              	 .loc 3 2732 0
 13012 00b0 0020     	 mov r0,#0
 13013 00b2 0821     	 mov r1,#8
 13014 00b4 0022     	 mov r2,#0
 13015 00b6 FFF7FEFF 	 bl bit_init
2733:../XMC1100-LibHaas.c **** 		if  (Start == RE)   //PIN 8 und steigende Flanke als Start
 13016              	 .loc 3 2733 0
 13017 00ba BB1D     	 add r3,r7,#6
 13018 00bc 1B78     	 ldrb r3,[r3]
 13019 00be 012B     	 cmp r3,#1
 13020 00c0 17D1     	 bne .L660
2734:../XMC1100-LibHaas.c **** 		{
2735:../XMC1100-LibHaas.c **** 			CCU40_CC42->CMC &= 0xFFFFFFF9;
 13021              	 .loc 3 2735 0
 13022 00c2 3B4B     	 ldr r3,.L664
 13023 00c4 3A4A     	 ldr r2,.L664
 13024 00c6 5268     	 ldr r2,[r2,#4]
 13025 00c8 0621     	 mov r1,#6
 13026 00ca 8A43     	 bic r2,r1
 13027 00cc 5A60     	 str r2,[r3,#4]
2736:../XMC1100-LibHaas.c **** 			CCU40_CC42->CMC |= 0x00000009;
 13028              	 .loc 3 2736 0
 13029 00ce 384B     	 ldr r3,.L664
 13030 00d0 374A     	 ldr r2,.L664
 13031 00d2 5268     	 ldr r2,[r2,#4]
 13032 00d4 0921     	 mov r1,#9
 13033 00d6 0A43     	 orr r2,r1
 13034 00d8 5A60     	 str r2,[r3,#4]
2737:../XMC1100-LibHaas.c **** 
2738:../XMC1100-LibHaas.c **** 			CCU40_CC42->INS &= 0xFF39FF11;
 13035              	 .loc 3 2738 0
 13036 00da 354B     	 ldr r3,.L664
 13037 00dc 344A     	 ldr r2,.L664
 13038 00de 1268     	 ldr r2,[r2]
 13039 00e0 3849     	 ldr r1,.L664+20
 13040 00e2 0A40     	 and r2,r1
 13041 00e4 1A60     	 str r2,[r3]
2739:../XMC1100-LibHaas.c **** 			CCU40_CC42->INS |= 0x1E090011;
 13042              	 .loc 3 2739 0
 13043 00e6 324B     	 ldr r3,.L664
 13044 00e8 314A     	 ldr r2,.L664
 13045 00ea 1268     	 ldr r2,[r2]
 13046 00ec 3649     	 ldr r1,.L664+24
 13047 00ee 0A43     	 orr r2,r1
 13048 00f0 1A60     	 str r2,[r3]
 13049              	.L660:
2740:../XMC1100-LibHaas.c **** 		}
2741:../XMC1100-LibHaas.c **** 
2742:../XMC1100-LibHaas.c **** 		if (Start == FE)   //PIN 8 und fallende Flanke als Start
 13050              	 .loc 3 2742 0
 13051 00f2 BB1D     	 add r3,r7,#6
 13052 00f4 1B78     	 ldrb r3,[r3]
 13053 00f6 002B     	 cmp r3,#0
 13054 00f8 18D1     	 bne .L661
2743:../XMC1100-LibHaas.c **** 		{
2744:../XMC1100-LibHaas.c **** 			CCU40_CC42->CMC &= 0xFFFFFFF9;
 13055              	 .loc 3 2744 0
 13056 00fa 2D4B     	 ldr r3,.L664
 13057 00fc 2C4A     	 ldr r2,.L664
 13058 00fe 5268     	 ldr r2,[r2,#4]
 13059 0100 0621     	 mov r1,#6
 13060 0102 8A43     	 bic r2,r1
 13061 0104 5A60     	 str r2,[r3,#4]
2745:../XMC1100-LibHaas.c **** 			CCU40_CC42->CMC |= 0x00000009;
 13062              	 .loc 3 2745 0
 13063 0106 2A4B     	 ldr r3,.L664
 13064 0108 294A     	 ldr r2,.L664
 13065 010a 5268     	 ldr r2,[r2,#4]
 13066 010c 0921     	 mov r1,#9
 13067 010e 0A43     	 orr r2,r1
 13068 0110 5A60     	 str r2,[r3,#4]
2746:../XMC1100-LibHaas.c **** 
2747:../XMC1100-LibHaas.c **** 			CCU40_CC42->INS &= 0xFF36FF11;
 13069              	 .loc 3 2747 0
 13070 0112 274B     	 ldr r3,.L664
 13071 0114 264A     	 ldr r2,.L664
 13072 0116 1268     	 ldr r2,[r2]
 13073 0118 2C49     	 ldr r1,.L664+28
 13074 011a 0A40     	 and r2,r1
 13075 011c 1A60     	 str r2,[r3]
2748:../XMC1100-LibHaas.c **** 			CCU40_CC42->INS |= 0x1E060011;
 13076              	 .loc 3 2748 0
 13077 011e 244B     	 ldr r3,.L664
 13078 0120 234A     	 ldr r2,.L664
 13079 0122 1268     	 ldr r2,[r2]
 13080 0124 2A49     	 ldr r1,.L664+32
 13081 0126 0A43     	 orr r2,r1
 13082 0128 1A60     	 str r2,[r3]
2749:../XMC1100-LibHaas.c **** 		}
2750:../XMC1100-LibHaas.c **** 		break;
 13083              	 .loc 3 2750 0
 13084 012a 3EE0     	 b .L653
 13085              	.L661:
 13086 012c 3DE0     	 b .L653
 13087              	.L656:
2751:../XMC1100-LibHaas.c **** 
2752:../XMC1100-LibHaas.c **** 	case 12:  //Pin 12 wurde Ausgewählt
2753:../XMC1100-LibHaas.c **** 		bit_init(P0, 12, INP);
 13088              	 .loc 3 2753 0
 13089 012e 0020     	 mov r0,#0
 13090 0130 0C21     	 mov r1,#12
 13091 0132 0022     	 mov r2,#0
 13092 0134 FFF7FEFF 	 bl bit_init
2754:../XMC1100-LibHaas.c **** 		if  (Start == RE)   //PIN 12 und steigende Flanke als Start
 13093              	 .loc 3 2754 0
 13094 0138 BB1D     	 add r3,r7,#6
 13095 013a 1B78     	 ldrb r3,[r3]
 13096 013c 012B     	 cmp r3,#1
 13097 013e 17D1     	 bne .L662
2755:../XMC1100-LibHaas.c **** 		{
2756:../XMC1100-LibHaas.c **** 			CCU40_CC42->CMC &= 0xFFFFFFF9;
 13098              	 .loc 3 2756 0
 13099 0140 1B4B     	 ldr r3,.L664
 13100 0142 1B4A     	 ldr r2,.L664
 13101 0144 5268     	 ldr r2,[r2,#4]
 13102 0146 0621     	 mov r1,#6
 13103 0148 8A43     	 bic r2,r1
 13104 014a 5A60     	 str r2,[r3,#4]
2757:../XMC1100-LibHaas.c **** 			CCU40_CC42->CMC |= 0x00000009;
 13105              	 .loc 3 2757 0
 13106 014c 184B     	 ldr r3,.L664
 13107 014e 184A     	 ldr r2,.L664
 13108 0150 5268     	 ldr r2,[r2,#4]
 13109 0152 0921     	 mov r1,#9
 13110 0154 0A43     	 orr r2,r1
 13111 0156 5A60     	 str r2,[r3,#4]
2758:../XMC1100-LibHaas.c **** 
2759:../XMC1100-LibHaas.c **** 			CCU40_CC42->INS &= 0xFF39FF00;
 13112              	 .loc 3 2759 0
 13113 0158 154B     	 ldr r3,.L664
 13114 015a 154A     	 ldr r2,.L664
 13115 015c 1268     	 ldr r2,[r2]
 13116 015e 1D49     	 ldr r1,.L664+36
 13117 0160 0A40     	 and r2,r1
 13118 0162 1A60     	 str r2,[r3]
2760:../XMC1100-LibHaas.c **** 			CCU40_CC42->INS |= 0x1E090000;
 13119              	 .loc 3 2760 0
 13120 0164 124B     	 ldr r3,.L664
 13121 0166 124A     	 ldr r2,.L664
 13122 0168 1268     	 ldr r2,[r2]
 13123 016a 1B49     	 ldr r1,.L664+40
 13124 016c 0A43     	 orr r2,r1
 13125 016e 1A60     	 str r2,[r3]
 13126              	.L662:
2761:../XMC1100-LibHaas.c **** 		}
2762:../XMC1100-LibHaas.c **** 
2763:../XMC1100-LibHaas.c **** 		if (Start == FE)   //PIN 12 und fallende Flanke als Start
 13127              	 .loc 3 2763 0
 13128 0170 BB1D     	 add r3,r7,#6
 13129 0172 1B78     	 ldrb r3,[r3]
 13130 0174 002B     	 cmp r3,#0
 13131 0176 17D1     	 bne .L663
2764:../XMC1100-LibHaas.c **** 		{
2765:../XMC1100-LibHaas.c **** 			CCU40_CC42->CMC &= 0xFFFFFFF9;
 13132              	 .loc 3 2765 0
 13133 0178 0D4B     	 ldr r3,.L664
 13134 017a 0D4A     	 ldr r2,.L664
 13135 017c 5268     	 ldr r2,[r2,#4]
 13136 017e 0621     	 mov r1,#6
 13137 0180 8A43     	 bic r2,r1
 13138 0182 5A60     	 str r2,[r3,#4]
2766:../XMC1100-LibHaas.c **** 			CCU40_CC42->CMC |= 0x00000009;
 13139              	 .loc 3 2766 0
 13140 0184 0A4B     	 ldr r3,.L664
 13141 0186 0A4A     	 ldr r2,.L664
 13142 0188 5268     	 ldr r2,[r2,#4]
 13143 018a 0921     	 mov r1,#9
 13144 018c 0A43     	 orr r2,r1
 13145 018e 5A60     	 str r2,[r3,#4]
2767:../XMC1100-LibHaas.c **** 
2768:../XMC1100-LibHaas.c **** 			CCU40_CC42->INS &= 0xFF36FF00;
 13146              	 .loc 3 2768 0
 13147 0190 074B     	 ldr r3,.L664
 13148 0192 074A     	 ldr r2,.L664
 13149 0194 1268     	 ldr r2,[r2]
 13150 0196 1149     	 ldr r1,.L664+44
 13151 0198 0A40     	 and r2,r1
 13152 019a 1A60     	 str r2,[r3]
2769:../XMC1100-LibHaas.c **** 			CCU40_CC42->INS |= 0x1E060000;
 13153              	 .loc 3 2769 0
 13154 019c 044B     	 ldr r3,.L664
 13155 019e 044A     	 ldr r2,.L664
 13156 01a0 1268     	 ldr r2,[r2]
 13157 01a2 0F49     	 ldr r1,.L664+48
 13158 01a4 0A43     	 orr r2,r1
 13159 01a6 1A60     	 str r2,[r3]
 13160              	.L663:
2770:../XMC1100-LibHaas.c **** 		}
2771:../XMC1100-LibHaas.c **** 		break;
 13161              	 .loc 3 2771 0
 13162 01a8 C046     	 mov r8,r8
 13163              	.L653:
2772:../XMC1100-LibHaas.c **** 	}
2773:../XMC1100-LibHaas.c **** }
 13164              	 .loc 3 2773 0
 13165 01aa BD46     	 mov sp,r7
 13166 01ac 03B0     	 add sp,sp,#12
 13167              	 
 13168 01ae 90BD     	 pop {r4,r7,pc}
 13169              	.L665:
 13170              	 .align 2
 13171              	.L664:
 13172 01b0 00030448 	 .word 1208222464
 13173 01b4 22FF39FF 	 .word -12976350
 13174 01b8 2200091E 	 .word 503906338
 13175 01bc 22FF36FF 	 .word -13172958
 13176 01c0 2200061E 	 .word 503709730
 13177 01c4 11FF39FF 	 .word -12976367
 13178 01c8 1100091E 	 .word 503906321
 13179 01cc 11FF36FF 	 .word -13172975
 13180 01d0 1100061E 	 .word 503709713
 13181 01d4 00FF39FF 	 .word -12976384
 13182 01d8 0000091E 	 .word 503906304
 13183 01dc 00FF36FF 	 .word -13172992
 13184 01e0 0000061E 	 .word 503709696
 13185              	 .cfi_endproc
 13186              	.LFE173:
 13188              	 .section .text.timer3_extern_controll,"ax",%progbits
 13189              	 .align 2
 13190              	 .global timer3_extern_controll
 13191              	 .code 16
 13192              	 .thumb_func
 13194              	timer3_extern_controll:
 13195              	.LFB174:
2774:../XMC1100-LibHaas.c **** 
2775:../XMC1100-LibHaas.c **** //Extrene kontrolle des Timer 3
2776:../XMC1100-LibHaas.c **** //Auswahl zwischen Pin 3, Pin 9 und Pin 12
2777:../XMC1100-LibHaas.c **** //Auswahl bei Start zwischen RE=Steigende Flanke und FE=Fallende Flanke
2778:../XMC1100-LibHaas.c **** //Auswahl bei Stop zwischen RE=Steigende Flanke und FE=Fallende Flanke
2779:../XMC1100-LibHaas.c **** 
2780:../XMC1100-LibHaas.c **** void timer3_extern_controll(uint8_t PIN, uint8_t Start, uint8_t Stopp)
2781:../XMC1100-LibHaas.c **** {
 13196              	 .loc 3 2781 0
 13197              	 .cfi_startproc
 13198 0000 90B5     	 push {r4,r7,lr}
 13199              	.LCFI366:
 13200              	 .cfi_def_cfa_offset 12
 13201              	 .cfi_offset 4,-12
 13202              	 .cfi_offset 7,-8
 13203              	 .cfi_offset 14,-4
 13204 0002 83B0     	 sub sp,sp,#12
 13205              	.LCFI367:
 13206              	 .cfi_def_cfa_offset 24
 13207 0004 00AF     	 add r7,sp,#0
 13208              	.LCFI368:
 13209              	 .cfi_def_cfa_register 7
 13210 0006 041C     	 mov r4,r0
 13211 0008 081C     	 mov r0,r1
 13212 000a 111C     	 mov r1,r2
 13213 000c FB1D     	 add r3,r7,#7
 13214 000e 221C     	 add r2,r4,#0
 13215 0010 1A70     	 strb r2,[r3]
 13216 0012 BB1D     	 add r3,r7,#6
 13217 0014 021C     	 add r2,r0,#0
 13218 0016 1A70     	 strb r2,[r3]
 13219 0018 7B1D     	 add r3,r7,#5
 13220 001a 0A1C     	 add r2,r1,#0
 13221 001c 1A70     	 strb r2,[r3]
2782:../XMC1100-LibHaas.c **** 	switch (PIN)
 13222              	 .loc 3 2782 0
 13223 001e FB1D     	 add r3,r7,#7
 13224 0020 1B78     	 ldrb r3,[r3]
 13225 0022 092B     	 cmp r3,#9
 13226 0024 44D0     	 beq .L668
 13227 0026 0C2B     	 cmp r3,#12
 13228 0028 00D1     	 bne .LCB11939
 13229 002a 80E0     	 b .L669
 13230              	.LCB11939:
 13231 002c 032B     	 cmp r3,#3
 13232 002e 00D0     	 beq .LCB11941
 13233 0030 BBE0     	 b .L666
 13234              	.LCB11941:
2783:../XMC1100-LibHaas.c **** 	{
2784:../XMC1100-LibHaas.c **** 	case 3 :  //Pin 3 wurde Ausgewählt
2785:../XMC1100-LibHaas.c **** 		bit_init(P0, 3, INP);
 13235              	 .loc 3 2785 0
 13236 0032 0020     	 mov r0,#0
 13237 0034 0321     	 mov r1,#3
 13238 0036 0022     	 mov r2,#0
 13239 0038 FFF7FEFF 	 bl bit_init
2786:../XMC1100-LibHaas.c **** 		if (Start == RE)   //PIN 3 und steigende Flanke als Start
 13240              	 .loc 3 2786 0
 13241 003c BB1D     	 add r3,r7,#6
 13242 003e 1B78     	 ldrb r3,[r3]
 13243 0040 012B     	 cmp r3,#1
 13244 0042 17D1     	 bne .L671
2787:../XMC1100-LibHaas.c **** 		{
2788:../XMC1100-LibHaas.c **** 			CCU40_CC43->CMC &= 0xFFFFFFF9;
 13245              	 .loc 3 2788 0
 13246 0044 5A4B     	 ldr r3,.L677
 13247 0046 5A4A     	 ldr r2,.L677
 13248 0048 5268     	 ldr r2,[r2,#4]
 13249 004a 0621     	 mov r1,#6
 13250 004c 8A43     	 bic r2,r1
 13251 004e 5A60     	 str r2,[r3,#4]
2789:../XMC1100-LibHaas.c **** 			CCU40_CC43->CMC |= 0x00000009;
 13252              	 .loc 3 2789 0
 13253 0050 574B     	 ldr r3,.L677
 13254 0052 574A     	 ldr r2,.L677
 13255 0054 5268     	 ldr r2,[r2,#4]
 13256 0056 0921     	 mov r1,#9
 13257 0058 0A43     	 orr r2,r1
 13258 005a 5A60     	 str r2,[r3,#4]
2790:../XMC1100-LibHaas.c **** 
2791:../XMC1100-LibHaas.c **** 			CCU40_CC43->INS &= 0xFF39FF22;
 13259              	 .loc 3 2791 0
 13260 005c 544B     	 ldr r3,.L677
 13261 005e 544A     	 ldr r2,.L677
 13262 0060 1268     	 ldr r2,[r2]
 13263 0062 5449     	 ldr r1,.L677+4
 13264 0064 0A40     	 and r2,r1
 13265 0066 1A60     	 str r2,[r3]
2792:../XMC1100-LibHaas.c **** 			CCU40_CC43->INS |= 0x1E090022;
 13266              	 .loc 3 2792 0
 13267 0068 514B     	 ldr r3,.L677
 13268 006a 514A     	 ldr r2,.L677
 13269 006c 1268     	 ldr r2,[r2]
 13270 006e 5249     	 ldr r1,.L677+8
 13271 0070 0A43     	 orr r2,r1
 13272 0072 1A60     	 str r2,[r3]
 13273              	.L671:
2793:../XMC1100-LibHaas.c **** 		}
2794:../XMC1100-LibHaas.c **** 
2795:../XMC1100-LibHaas.c **** 		if (Start == FE)  //PIN 3 und fallende Flanke als Start
 13274              	 .loc 3 2795 0
 13275 0074 BB1D     	 add r3,r7,#6
 13276 0076 1B78     	 ldrb r3,[r3]
 13277 0078 002B     	 cmp r3,#0
 13278 007a 18D1     	 bne .L672
2796:../XMC1100-LibHaas.c **** 		{
2797:../XMC1100-LibHaas.c **** 			CCU40_CC43->CMC &= 0xFFFFFFF9;
 13279              	 .loc 3 2797 0
 13280 007c 4C4B     	 ldr r3,.L677
 13281 007e 4C4A     	 ldr r2,.L677
 13282 0080 5268     	 ldr r2,[r2,#4]
 13283 0082 0621     	 mov r1,#6
 13284 0084 8A43     	 bic r2,r1
 13285 0086 5A60     	 str r2,[r3,#4]
2798:../XMC1100-LibHaas.c **** 			CCU40_CC43->CMC |= 0x00000009;
 13286              	 .loc 3 2798 0
 13287 0088 494B     	 ldr r3,.L677
 13288 008a 494A     	 ldr r2,.L677
 13289 008c 5268     	 ldr r2,[r2,#4]
 13290 008e 0921     	 mov r1,#9
 13291 0090 0A43     	 orr r2,r1
 13292 0092 5A60     	 str r2,[r3,#4]
2799:../XMC1100-LibHaas.c **** 
2800:../XMC1100-LibHaas.c **** 			CCU40_CC43->INS &= 0xFF36FF22;
 13293              	 .loc 3 2800 0
 13294 0094 464B     	 ldr r3,.L677
 13295 0096 464A     	 ldr r2,.L677
 13296 0098 1268     	 ldr r2,[r2]
 13297 009a 4849     	 ldr r1,.L677+12
 13298 009c 0A40     	 and r2,r1
 13299 009e 1A60     	 str r2,[r3]
2801:../XMC1100-LibHaas.c **** 			CCU40_CC43->INS |= 0x1E060022;
 13300              	 .loc 3 2801 0
 13301 00a0 434B     	 ldr r3,.L677
 13302 00a2 434A     	 ldr r2,.L677
 13303 00a4 1268     	 ldr r2,[r2]
 13304 00a6 4649     	 ldr r1,.L677+16
 13305 00a8 0A43     	 orr r2,r1
 13306 00aa 1A60     	 str r2,[r3]
2802:../XMC1100-LibHaas.c **** 		}
2803:../XMC1100-LibHaas.c **** 		break;
 13307              	 .loc 3 2803 0
 13308 00ac 7DE0     	 b .L666
 13309              	.L672:
 13310 00ae 7CE0     	 b .L666
 13311              	.L668:
2804:../XMC1100-LibHaas.c **** 
2805:../XMC1100-LibHaas.c **** 	case 9:  //Pin 9 wurde Ausgewählt
2806:../XMC1100-LibHaas.c **** 		bit_init(P0, 9, INP);
 13312              	 .loc 3 2806 0
 13313 00b0 0020     	 mov r0,#0
 13314 00b2 0921     	 mov r1,#9
 13315 00b4 0022     	 mov r2,#0
 13316 00b6 FFF7FEFF 	 bl bit_init
2807:../XMC1100-LibHaas.c **** 		if  (Start == RE)   //PIN 9 und steigende Flanke als Start
 13317              	 .loc 3 2807 0
 13318 00ba BB1D     	 add r3,r7,#6
 13319 00bc 1B78     	 ldrb r3,[r3]
 13320 00be 012B     	 cmp r3,#1
 13321 00c0 17D1     	 bne .L673
2808:../XMC1100-LibHaas.c **** 		{
2809:../XMC1100-LibHaas.c **** 			CCU40_CC43->CMC &= 0xFFFFFFF9;
 13322              	 .loc 3 2809 0
 13323 00c2 3B4B     	 ldr r3,.L677
 13324 00c4 3A4A     	 ldr r2,.L677
 13325 00c6 5268     	 ldr r2,[r2,#4]
 13326 00c8 0621     	 mov r1,#6
 13327 00ca 8A43     	 bic r2,r1
 13328 00cc 5A60     	 str r2,[r3,#4]
2810:../XMC1100-LibHaas.c **** 			CCU40_CC43->CMC |= 0x00000009;
 13329              	 .loc 3 2810 0
 13330 00ce 384B     	 ldr r3,.L677
 13331 00d0 374A     	 ldr r2,.L677
 13332 00d2 5268     	 ldr r2,[r2,#4]
 13333 00d4 0921     	 mov r1,#9
 13334 00d6 0A43     	 orr r2,r1
 13335 00d8 5A60     	 str r2,[r3,#4]
2811:../XMC1100-LibHaas.c **** 
2812:../XMC1100-LibHaas.c **** 			CCU40_CC43->INS &= 0xFF39FF11;
 13336              	 .loc 3 2812 0
 13337 00da 354B     	 ldr r3,.L677
 13338 00dc 344A     	 ldr r2,.L677
 13339 00de 1268     	 ldr r2,[r2]
 13340 00e0 3849     	 ldr r1,.L677+20
 13341 00e2 0A40     	 and r2,r1
 13342 00e4 1A60     	 str r2,[r3]
2813:../XMC1100-LibHaas.c **** 			CCU40_CC43->INS |= 0x1E090011;
 13343              	 .loc 3 2813 0
 13344 00e6 324B     	 ldr r3,.L677
 13345 00e8 314A     	 ldr r2,.L677
 13346 00ea 1268     	 ldr r2,[r2]
 13347 00ec 3649     	 ldr r1,.L677+24
 13348 00ee 0A43     	 orr r2,r1
 13349 00f0 1A60     	 str r2,[r3]
 13350              	.L673:
2814:../XMC1100-LibHaas.c **** 		}
2815:../XMC1100-LibHaas.c **** 
2816:../XMC1100-LibHaas.c **** 		if (Start == FE)   //PIN 9 und fallende Flanke als Start
 13351              	 .loc 3 2816 0
 13352 00f2 BB1D     	 add r3,r7,#6
 13353 00f4 1B78     	 ldrb r3,[r3]
 13354 00f6 002B     	 cmp r3,#0
 13355 00f8 18D1     	 bne .L674
2817:../XMC1100-LibHaas.c **** 		{
2818:../XMC1100-LibHaas.c **** 			CCU40_CC43->CMC &= 0xFFFFFFF9;
 13356              	 .loc 3 2818 0
 13357 00fa 2D4B     	 ldr r3,.L677
 13358 00fc 2C4A     	 ldr r2,.L677
 13359 00fe 5268     	 ldr r2,[r2,#4]
 13360 0100 0621     	 mov r1,#6
 13361 0102 8A43     	 bic r2,r1
 13362 0104 5A60     	 str r2,[r3,#4]
2819:../XMC1100-LibHaas.c **** 			CCU40_CC43->CMC |= 0x00000009;
 13363              	 .loc 3 2819 0
 13364 0106 2A4B     	 ldr r3,.L677
 13365 0108 294A     	 ldr r2,.L677
 13366 010a 5268     	 ldr r2,[r2,#4]
 13367 010c 0921     	 mov r1,#9
 13368 010e 0A43     	 orr r2,r1
 13369 0110 5A60     	 str r2,[r3,#4]
2820:../XMC1100-LibHaas.c **** 
2821:../XMC1100-LibHaas.c **** 			CCU40_CC43->INS &= 0xFF36FF11;
 13370              	 .loc 3 2821 0
 13371 0112 274B     	 ldr r3,.L677
 13372 0114 264A     	 ldr r2,.L677
 13373 0116 1268     	 ldr r2,[r2]
 13374 0118 2C49     	 ldr r1,.L677+28
 13375 011a 0A40     	 and r2,r1
 13376 011c 1A60     	 str r2,[r3]
2822:../XMC1100-LibHaas.c **** 			CCU40_CC43->INS |= 0x1E060011;
 13377              	 .loc 3 2822 0
 13378 011e 244B     	 ldr r3,.L677
 13379 0120 234A     	 ldr r2,.L677
 13380 0122 1268     	 ldr r2,[r2]
 13381 0124 2A49     	 ldr r1,.L677+32
 13382 0126 0A43     	 orr r2,r1
 13383 0128 1A60     	 str r2,[r3]
2823:../XMC1100-LibHaas.c **** 		}
2824:../XMC1100-LibHaas.c **** 		break;
 13384              	 .loc 3 2824 0
 13385 012a 3EE0     	 b .L666
 13386              	.L674:
 13387 012c 3DE0     	 b .L666
 13388              	.L669:
2825:../XMC1100-LibHaas.c **** 
2826:../XMC1100-LibHaas.c **** 	case 12:  //Pin 12 wurde Ausgewählt
2827:../XMC1100-LibHaas.c **** 		bit_init(P0, 12, INP);
 13389              	 .loc 3 2827 0
 13390 012e 0020     	 mov r0,#0
 13391 0130 0C21     	 mov r1,#12
 13392 0132 0022     	 mov r2,#0
 13393 0134 FFF7FEFF 	 bl bit_init
2828:../XMC1100-LibHaas.c **** 		if  (Start == RE)   //PIN 12 und steigende Flanke als Start
 13394              	 .loc 3 2828 0
 13395 0138 BB1D     	 add r3,r7,#6
 13396 013a 1B78     	 ldrb r3,[r3]
 13397 013c 012B     	 cmp r3,#1
 13398 013e 17D1     	 bne .L675
2829:../XMC1100-LibHaas.c **** 		{
2830:../XMC1100-LibHaas.c **** 			CCU40_CC43->CMC &= 0xFFFFFFF9;
 13399              	 .loc 3 2830 0
 13400 0140 1B4B     	 ldr r3,.L677
 13401 0142 1B4A     	 ldr r2,.L677
 13402 0144 5268     	 ldr r2,[r2,#4]
 13403 0146 0621     	 mov r1,#6
 13404 0148 8A43     	 bic r2,r1
 13405 014a 5A60     	 str r2,[r3,#4]
2831:../XMC1100-LibHaas.c **** 			CCU40_CC43->CMC |= 0x00000009;
 13406              	 .loc 3 2831 0
 13407 014c 184B     	 ldr r3,.L677
 13408 014e 184A     	 ldr r2,.L677
 13409 0150 5268     	 ldr r2,[r2,#4]
 13410 0152 0921     	 mov r1,#9
 13411 0154 0A43     	 orr r2,r1
 13412 0156 5A60     	 str r2,[r3,#4]
2832:../XMC1100-LibHaas.c **** 
2833:../XMC1100-LibHaas.c **** 			CCU40_CC43->INS &= 0xFF39FF00;
 13413              	 .loc 3 2833 0
 13414 0158 154B     	 ldr r3,.L677
 13415 015a 154A     	 ldr r2,.L677
 13416 015c 1268     	 ldr r2,[r2]
 13417 015e 1D49     	 ldr r1,.L677+36
 13418 0160 0A40     	 and r2,r1
 13419 0162 1A60     	 str r2,[r3]
2834:../XMC1100-LibHaas.c **** 			CCU40_CC43->INS |= 0x1E090000;
 13420              	 .loc 3 2834 0
 13421 0164 124B     	 ldr r3,.L677
 13422 0166 124A     	 ldr r2,.L677
 13423 0168 1268     	 ldr r2,[r2]
 13424 016a 1B49     	 ldr r1,.L677+40
 13425 016c 0A43     	 orr r2,r1
 13426 016e 1A60     	 str r2,[r3]
 13427              	.L675:
2835:../XMC1100-LibHaas.c **** 		}
2836:../XMC1100-LibHaas.c **** 
2837:../XMC1100-LibHaas.c **** 		if (Start == FE)   //PIN 12 und fallende Flanke als Start
 13428              	 .loc 3 2837 0
 13429 0170 BB1D     	 add r3,r7,#6
 13430 0172 1B78     	 ldrb r3,[r3]
 13431 0174 002B     	 cmp r3,#0
 13432 0176 17D1     	 bne .L676
2838:../XMC1100-LibHaas.c **** 		{
2839:../XMC1100-LibHaas.c **** 			CCU40_CC43->CMC &= 0xFFFFFFF9;
 13433              	 .loc 3 2839 0
 13434 0178 0D4B     	 ldr r3,.L677
 13435 017a 0D4A     	 ldr r2,.L677
 13436 017c 5268     	 ldr r2,[r2,#4]
 13437 017e 0621     	 mov r1,#6
 13438 0180 8A43     	 bic r2,r1
 13439 0182 5A60     	 str r2,[r3,#4]
2840:../XMC1100-LibHaas.c **** 			CCU40_CC43->CMC |= 0x00000009;
 13440              	 .loc 3 2840 0
 13441 0184 0A4B     	 ldr r3,.L677
 13442 0186 0A4A     	 ldr r2,.L677
 13443 0188 5268     	 ldr r2,[r2,#4]
 13444 018a 0921     	 mov r1,#9
 13445 018c 0A43     	 orr r2,r1
 13446 018e 5A60     	 str r2,[r3,#4]
2841:../XMC1100-LibHaas.c **** 
2842:../XMC1100-LibHaas.c **** 			CCU40_CC43->INS &= 0xFF36FF00;
 13447              	 .loc 3 2842 0
 13448 0190 074B     	 ldr r3,.L677
 13449 0192 074A     	 ldr r2,.L677
 13450 0194 1268     	 ldr r2,[r2]
 13451 0196 1149     	 ldr r1,.L677+44
 13452 0198 0A40     	 and r2,r1
 13453 019a 1A60     	 str r2,[r3]
2843:../XMC1100-LibHaas.c **** 			CCU40_CC43->INS |= 0x1E060000;
 13454              	 .loc 3 2843 0
 13455 019c 044B     	 ldr r3,.L677
 13456 019e 044A     	 ldr r2,.L677
 13457 01a0 1268     	 ldr r2,[r2]
 13458 01a2 0F49     	 ldr r1,.L677+48
 13459 01a4 0A43     	 orr r2,r1
 13460 01a6 1A60     	 str r2,[r3]
 13461              	.L676:
2844:../XMC1100-LibHaas.c **** 		}
2845:../XMC1100-LibHaas.c **** 		break;
 13462              	 .loc 3 2845 0
 13463 01a8 C046     	 mov r8,r8
 13464              	.L666:
2846:../XMC1100-LibHaas.c **** 	}
2847:../XMC1100-LibHaas.c **** }
 13465              	 .loc 3 2847 0
 13466 01aa BD46     	 mov sp,r7
 13467 01ac 03B0     	 add sp,sp,#12
 13468              	 
 13469 01ae 90BD     	 pop {r4,r7,pc}
 13470              	.L678:
 13471              	 .align 2
 13472              	.L677:
 13473 01b0 00040448 	 .word 1208222720
 13474 01b4 22FF39FF 	 .word -12976350
 13475 01b8 2200091E 	 .word 503906338
 13476 01bc 22FF36FF 	 .word -13172958
 13477 01c0 2200061E 	 .word 503709730
 13478 01c4 11FF39FF 	 .word -12976367
 13479 01c8 1100091E 	 .word 503906321
 13480 01cc 11FF36FF 	 .word -13172975
 13481 01d0 1100061E 	 .word 503709713
 13482 01d4 00FF39FF 	 .word -12976384
 13483 01d8 0000091E 	 .word 503906304
 13484 01dc 00FF36FF 	 .word -13172992
 13485 01e0 0000061E 	 .word 503709696
 13486              	 .cfi_endproc
 13487              	.LFE174:
 13489              	 .section .text.deepSleep_init,"ax",%progbits
 13490              	 .align 2
 13491              	 .global deepSleep_init
 13492              	 .code 16
 13493              	 .thumb_func
 13495              	deepSleep_init:
 13496              	.LFB175:
2848:../XMC1100-LibHaas.c **** 
2849:../XMC1100-LibHaas.c **** 
2850:../XMC1100-LibHaas.c **** void deepSleep_init(void)
2851:../XMC1100-LibHaas.c **** {
 13497              	 .loc 3 2851 0
 13498              	 .cfi_startproc
 13499 0000 80B5     	 push {r7,lr}
 13500              	.LCFI369:
 13501              	 .cfi_def_cfa_offset 8
 13502              	 .cfi_offset 7,-8
 13503              	 .cfi_offset 14,-4
 13504 0002 00AF     	 add r7,sp,#0
 13505              	.LCFI370:
 13506              	 .cfi_def_cfa_register 7
2852:../XMC1100-LibHaas.c **** 	PPB->SCR |= 0x00000004;
 13507              	 .loc 3 2852 0
 13508 0004 0549     	 ldr r1,.L680
 13509 0006 054A     	 ldr r2,.L680
 13510 0008 D123     	 mov r3,#209
 13511 000a 1B01     	 lsl r3,r3,#4
 13512 000c D358     	 ldr r3,[r2,r3]
 13513 000e 0422     	 mov r2,#4
 13514 0010 1A43     	 orr r2,r3
 13515 0012 D123     	 mov r3,#209
 13516 0014 1B01     	 lsl r3,r3,#4
 13517 0016 CA50     	 str r2,[r1,r3]
2853:../XMC1100-LibHaas.c **** }
 13518              	 .loc 3 2853 0
 13519 0018 BD46     	 mov sp,r7
 13520              	 
 13521 001a 80BD     	 pop {r7,pc}
 13522              	.L681:
 13523              	 .align 2
 13524              	.L680:
 13525 001c 00E000E0 	 .word -536813568
 13526              	 .cfi_endproc
 13527              	.LFE175:
 13529              	 .text
 13530              	.Letext0:
 13531              	 .file 4 "C:/Users/Public/OptiSort/OptiSort/Microcontroller/Libraries/CMSIS/Infineon/XMC1100_series/Include/xmc1100.h"
 13532              	 .file 5 "c:\\infineon\\tools\\dave ide\\4.5.0.202105191637\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\machine\\_default_types.h"
 13533              	 .file 6 "c:\\infineon\\tools\\dave ide\\4.5.0.202105191637\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\stdint.h"
 13534              	 .file 7 "C:/Users/Public/OptiSort/OptiSort/Microcontroller/xmc1100-LibHaas.h"
DEFINED SYMBOLS
                            *ABS*:00000000 XMC1100-LibHaas.c
    {standard input}:18     .text.__NVIC_EnableIRQ:00000000 $t
    {standard input}:22     .text.__NVIC_EnableIRQ:00000000 __NVIC_EnableIRQ
    {standard input}:66     .text.__NVIC_EnableIRQ:00000030 $d
    {standard input}:71     .text.__NVIC_DisableIRQ:00000000 $t
    {standard input}:75     .text.__NVIC_DisableIRQ:00000000 __NVIC_DisableIRQ
    {standard input}:138    .text.__NVIC_DisableIRQ:00000038 $d
    {standard input}:143    .text.__NVIC_ClearPendingIRQ:00000000 $t
    {standard input}:147    .text.__NVIC_ClearPendingIRQ:00000000 __NVIC_ClearPendingIRQ
    {standard input}:191    .text.__NVIC_ClearPendingIRQ:00000030 $d
    {standard input}:196    .text.__NVIC_SetPriority:00000000 $t
    {standard input}:200    .text.__NVIC_SetPriority:00000000 __NVIC_SetPriority
    {standard input}:329    .text.__NVIC_SetPriority:000000cc $d
                            *COM*:00000100 rs232Receivedata
    {standard input}:339    .bss.rs232ReceivedataPointer:00000000 rs232ReceivedataPointer
    {standard input}:340    .bss.rs232ReceivedataPointer:00000000 $d
    {standard input}:345    .bss.rs232EnterReceive:00000000 rs232EnterReceive
    {standard input}:346    .bss.rs232EnterReceive:00000000 $d
                            *COM*:00000100 uartReceivedata
    {standard input}:352    .bss.uartReceivedataPointer:00000000 uartReceivedataPointer
    {standard input}:353    .bss.uartReceivedataPointer:00000000 $d
    {standard input}:358    .bss.uartEnterReceive:00000000 uartEnterReceive
    {standard input}:359    .bss.uartEnterReceive:00000000 $d
    {standard input}:361    .text.bit_init:00000000 $t
    {standard input}:366    .text.bit_init:00000000 bit_init
    {standard input}:904    .text.bit_init:00000374 $d
    {standard input}:911    .text.bit_init_mode:00000000 $t
    {standard input}:916    .text.bit_init_mode:00000000 bit_init_mode
    {standard input}:1480   .text.bit_init_mode:000003cc $d
    {standard input}:1483   .text.bit_init_mode:000003d0 $t
    {standard input}:2007   .text.bit_init_mode:00000744 $d
    {standard input}:2013   .text.bit_init_mode:00000754 $t
    {standard input}:2518   .text.bit_init_mode:00000a94 $d
    {standard input}:2526   .text.bit_init_mode:00000aac $t
    {standard input}:2654   .text.bit_init_mode:00000b74 $d
    {standard input}:2660   .text.bit_set_clr:00000000 $t
    {standard input}:2665   .text.bit_set_clr:00000000 bit_set_clr
    {standard input}:2744   .text.port_init:00000000 $t
    {standard input}:2749   .text.port_init:00000000 port_init
    {standard input}:2900   .text.port_init:000000c4 $d
    {standard input}:2908   .text.bit_read:00000000 $t
    {standard input}:2913   .text.bit_read:00000000 bit_read
    {standard input}:3162   .text.port_read:00000000 port_read
    {standard input}:2966   .text.bit_write:00000000 $t
    {standard input}:2971   .text.bit_write:00000000 bit_write
    {standard input}:3150   .text.bit_write:00000110 $d
    {standard input}:3157   .text.port_read:00000000 $t
    {standard input}:3234   .text.port_read:0000005c $d
    {standard input}:3241   .text.port0_init_maske:00000000 $t
    {standard input}:3246   .text.port0_init_maske:00000000 port0_init_maske
    {standard input}:3314   .text.port_write:00000000 $t
    {standard input}:3319   .text.port_write:00000000 port_write
    {standard input}:3378   .text.port_write:00000048 $d
    {standard input}:3384   .text.clock_init:00000000 $t
    {standard input}:3389   .text.clock_init:00000000 clock_init
    {standard input}:3462   .text.clock_init:0000005c $d
    {standard input}:3470   .text.pwm1_init_8:00000000 $t
    {standard input}:3475   .text.pwm1_init_8:00000000 pwm1_init_8
    {standard input}:3533   .text.pwm1_init_8:00000048 $d
    {standard input}:3543   .text.pwm1_init:00000000 $t
    {standard input}:3548   .text.pwm1_init:00000000 pwm1_init
    {standard input}:3606   .text.pwm1_init:00000048 $d
    {standard input}:3616   .text.pwm2_init_8:00000000 $t
    {standard input}:3621   .text.pwm2_init_8:00000000 pwm2_init_8
    {standard input}:3679   .text.pwm2_init_8:00000048 $d
    {standard input}:3689   .text.pwm2_init:00000000 $t
    {standard input}:3694   .text.pwm2_init:00000000 pwm2_init
    {standard input}:3752   .text.pwm2_init:00000048 $d
    {standard input}:3762   .text.pwm3_init_8:00000000 $t
    {standard input}:3767   .text.pwm3_init_8:00000000 pwm3_init_8
    {standard input}:3825   .text.pwm3_init_8:00000048 $d
    {standard input}:3835   .text.pwm3_init:00000000 $t
    {standard input}:3840   .text.pwm3_init:00000000 pwm3_init
    {standard input}:3898   .text.pwm3_init:00000048 $d
    {standard input}:3908   .text.pwm4_init:00000000 $t
    {standard input}:3913   .text.pwm4_init:00000000 pwm4_init
    {standard input}:3972   .text.pwm4_init:00000048 $d
    {standard input}:3982   .text.pwm1_duty_cycle_8:00000000 $t
    {standard input}:3987   .text.pwm1_duty_cycle_8:00000000 pwm1_duty_cycle_8
    {standard input}:4031   .text.pwm1_duty_cycle_8:00000034 $d
    {standard input}:4038   .text.pwm1_duty_cycle:00000000 $t
    {standard input}:4043   .text.pwm1_duty_cycle:00000000 pwm1_duty_cycle
    {standard input}:4081   .text.pwm1_duty_cycle:00000028 $d
    {standard input}:4087   .text.pwm1_duty_cycle_period_8:00000000 $t
    {standard input}:4092   .text.pwm1_duty_cycle_period_8:00000000 pwm1_duty_cycle_period_8
    {standard input}:4149   .text.pwm1_duty_cycle_period_8:0000004c $d
    {standard input}:4155   .text.pwm1_duty_cycle_period:00000000 $t
    {standard input}:4160   .text.pwm1_duty_cycle_period:00000000 pwm1_duty_cycle_period
    {standard input}:4225   .text.pwm1_duty_cycle_period:00000054 $d
    {standard input}:4231   .text.pwm2_duty_cycle_8:00000000 $t
    {standard input}:4236   .text.pwm2_duty_cycle_8:00000000 pwm2_duty_cycle_8
    {standard input}:4280   .text.pwm2_duty_cycle_8:00000034 $d
    {standard input}:4287   .text.pwm2_duty_cycle:00000000 $t
    {standard input}:4292   .text.pwm2_duty_cycle:00000000 pwm2_duty_cycle
    {standard input}:4330   .text.pwm2_duty_cycle:00000028 $d
    {standard input}:4336   .text.pwm2_duty_cycle_period_8:00000000 $t
    {standard input}:4341   .text.pwm2_duty_cycle_period_8:00000000 pwm2_duty_cycle_period_8
    {standard input}:4398   .text.pwm2_duty_cycle_period_8:0000004c $d
    {standard input}:4404   .text.pwm2_duty_cycle_period:00000000 $t
    {standard input}:4409   .text.pwm2_duty_cycle_period:00000000 pwm2_duty_cycle_period
    {standard input}:4474   .text.pwm2_duty_cycle_period:00000054 $d
    {standard input}:4480   .text.pwm3_duty_cycle_8:00000000 $t
    {standard input}:4485   .text.pwm3_duty_cycle_8:00000000 pwm3_duty_cycle_8
    {standard input}:4530   .text.pwm3_duty_cycle_8:00000034 $d
    {standard input}:4537   .text.pwm3_duty_cycle:00000000 $t
    {standard input}:4542   .text.pwm3_duty_cycle:00000000 pwm3_duty_cycle
    {standard input}:4581   .text.pwm3_duty_cycle:00000028 $d
    {standard input}:4587   .text.pwm3_duty_cycle_period_8:00000000 $t
    {standard input}:4592   .text.pwm3_duty_cycle_period_8:00000000 pwm3_duty_cycle_period_8
    {standard input}:4650   .text.pwm3_duty_cycle_period_8:0000004c $d
    {standard input}:4656   .text.pwm3_duty_cycle_period:00000000 $t
    {standard input}:4661   .text.pwm3_duty_cycle_period:00000000 pwm3_duty_cycle_period
    {standard input}:4727   .text.pwm3_duty_cycle_period:00000058 $d
    {standard input}:4733   .text.pwm4_duty_cycle:00000000 $t
    {standard input}:4738   .text.pwm4_duty_cycle:00000000 pwm4_duty_cycle
    {standard input}:4777   .text.pwm4_duty_cycle:00000028 $d
    {standard input}:4783   .text.pwm4_duty_cycle_period:00000000 $t
    {standard input}:4788   .text.pwm4_duty_cycle_period:00000000 pwm4_duty_cycle_period
    {standard input}:4854   .text.pwm4_duty_cycle_period:00000058 $d
    {standard input}:4860   .text.pwm1_start:00000000 $t
    {standard input}:4865   .text.pwm1_start:00000000 pwm1_start
    {standard input}:4888   .text.pwm1_start:00000010 $d
    {standard input}:4893   .text.pwm1_start_interrupt:00000000 $t
    {standard input}:4898   .text.pwm1_start_interrupt:00000000 pwm1_start_interrupt
    {standard input}:4933   .text.pwm1_start_interrupt:00000024 $d
    {standard input}:4938   .text.pwm2_start:00000000 $t
    {standard input}:4943   .text.pwm2_start:00000000 pwm2_start
    {standard input}:4966   .text.pwm2_start:00000010 $d
    {standard input}:4971   .text.pwm2_start_interrupt:00000000 $t
    {standard input}:4976   .text.pwm2_start_interrupt:00000000 pwm2_start_interrupt
    {standard input}:5011   .text.pwm2_start_interrupt:00000024 $d
    {standard input}:5016   .text.pwm3_start:00000000 $t
    {standard input}:5021   .text.pwm3_start:00000000 pwm3_start
    {standard input}:5044   .text.pwm3_start:00000010 $d
    {standard input}:5049   .text.pwm3_start_interrupt:00000000 $t
    {standard input}:5054   .text.pwm3_start_interrupt:00000000 pwm3_start_interrupt
    {standard input}:5089   .text.pwm3_start_interrupt:00000024 $d
    {standard input}:5094   .text.pwm4_start:00000000 $t
    {standard input}:5099   .text.pwm4_start:00000000 pwm4_start
    {standard input}:5122   .text.pwm4_start:00000010 $d
    {standard input}:5127   .text.pwm4_start_interrupt:00000000 $t
    {standard input}:5132   .text.pwm4_start_interrupt:00000000 pwm4_start_interrupt
    {standard input}:5167   .text.pwm4_start_interrupt:00000024 $d
    {standard input}:5172   .text.pwm1_stop:00000000 $t
    {standard input}:5177   .text.pwm1_stop:00000000 pwm1_stop
    {standard input}:5203   .text.pwm1_stop:00000014 $d
    {standard input}:5208   .text.pwm2_stop:00000000 $t
    {standard input}:5213   .text.pwm2_stop:00000000 pwm2_stop
    {standard input}:5239   .text.pwm2_stop:00000014 $d
    {standard input}:5244   .text.pwm3_stop:00000000 $t
    {standard input}:5249   .text.pwm3_stop:00000000 pwm3_stop
    {standard input}:5275   .text.pwm3_stop:00000014 $d
    {standard input}:5280   .text.pwm4_stop:00000000 $t
    {standard input}:5285   .text.pwm4_stop:00000000 pwm4_stop
    {standard input}:5311   .text.pwm4_stop:00000014 $d
    {standard input}:5316   .text.adc_init:00000000 $t
    {standard input}:5321   .text.adc_init:00000000 adc_init
    {standard input}:5516   .text.adc_init:00000130 $d
    {standard input}:5531   .text.adc_in:00000000 $t
    {standard input}:5536   .text.adc_in:00000000 adc_in
    {standard input}:5614   .text.adc_in:0000006c $d
    {standard input}:5619   .text.delay_10us:00000000 $t
    {standard input}:5624   .text.delay_10us:00000000 delay_10us
    {standard input}:5691   .text.delay_100us:00000000 $t
    {standard input}:5696   .text.delay_100us:00000000 delay_100us
    {standard input}:5763   .text.delay_ms:00000000 $t
    {standard input}:5768   .text.delay_ms:00000000 delay_ms
    {standard input}:5826   .text.i2c_delay:00000000 $t
    {standard input}:5831   .text.i2c_delay:00000000 i2c_delay
    {standard input}:5876   .text.i2c_init:00000000 $t
    {standard input}:5881   .text.i2c_init:00000000 i2c_init
    {standard input}:5933   .text.i2c_init:00000044 $d
    {standard input}:5938   .text.i2c_start:00000000 $t
    {standard input}:5943   .text.i2c_start:00000000 i2c_start
    {standard input}:6002   .text.i2c_start:00000050 $d
    {standard input}:6007   .text.i2c_stop:00000000 $t
    {standard input}:6012   .text.i2c_stop:00000000 i2c_stop
    {standard input}:6071   .text.i2c_stop:00000050 $d
    {standard input}:6076   .text.i2c_write:00000000 $t
    {standard input}:6081   .text.i2c_write:00000000 i2c_write
    {standard input}:6241   .text.i2c_write:000000f4 $d
    {standard input}:6246   .text.i2c_read:00000000 $t
    {standard input}:6251   .text.i2c_read:00000000 i2c_read
    {standard input}:6416   .text.i2c_read:00000100 $d
    {standard input}:6421   .text.rs232_init:00000000 $t
    {standard input}:6426   .text.rs232_init:00000000 rs232_init
    {standard input}:6651   .text.rs232_init:0000016c $d
    {standard input}:6666   .text.rs232_init_bd:00000000 $t
    {standard input}:6671   .text.rs232_init_bd:00000000 rs232_init_bd
    {standard input}:6973   .text.rs232_init_bd:000001e4 $d
    {standard input}:6989   .text.rs232_interrupt_enable:00000000 $t
    {standard input}:6994   .text.rs232_interrupt_enable:00000000 rs232_interrupt_enable
    {standard input}:7039   .text.rs232_interrupt_enable:00000038 $d
    {standard input}:7045   .text.rs232_get:00000000 $t
    {standard input}:7050   .text.rs232_get:00000000 rs232_get
    {standard input}:7102   .text.rs232_get:0000003c $d
    {standard input}:7107   .text.rs232_char_received:00000000 $t
    {standard input}:7112   .text.rs232_char_received:00000000 rs232_char_received
    {standard input}:7146   .text.rs232_char_received:0000001c $d
    {standard input}:7151   .text.rs232_wait_get:00000000 $t
    {standard input}:7156   .text.rs232_wait_get:00000000 rs232_wait_get
    {standard input}:7206   .text.rs232_wait_get:00000038 $d
    {standard input}:7211   .text.rs232_put:00000000 $t
    {standard input}:7216   .text.rs232_put:00000000 rs232_put
    {standard input}:7261   .text.rs232_put:00000030 $d
    {standard input}:7266   .text.rs232_print:00000000 $t
    {standard input}:7271   .text.rs232_print:00000000 rs232_print
    {standard input}:7312   .text.USIC0_0_IRQHandler:00000000 $t
    {standard input}:7317   .text.USIC0_0_IRQHandler:00000000 USIC0_0_IRQHandler
    {standard input}:7381   .text.USIC0_0_IRQHandler:0000004c $d
    {standard input}:7389   .text.rs232_wait_of_enter:00000000 $t
    {standard input}:7394   .text.rs232_wait_of_enter:00000000 rs232_wait_of_enter
    {standard input}:7425   .text.rs232_wait_of_enter:00000018 $d
    {standard input}:7430   .text.rs232_clear_receivedata:00000000 $t
    {standard input}:7435   .text.rs232_clear_receivedata:00000000 rs232_clear_receivedata
    {standard input}:7462   .text.rs232_clear_receivedata:00000014 $d
    {standard input}:7468   .text.rs232_read_number:00000000 $t
    {standard input}:7473   .text.rs232_read_number:00000000 rs232_read_number
    {standard input}:7568   .text.rs232_read_number:00000080 $d
    {standard input}:7573   .text.rs232_read_int_number:00000000 $t
    {standard input}:7578   .text.rs232_read_int_number:00000000 rs232_read_int_number
    {standard input}:7675   .text.rs232_read_int_number:00000084 $d
    {standard input}:7681   .text.rs232_print_number:00000000 $t
    {standard input}:7686   .text.rs232_print_number:00000000 rs232_print_number
    {standard input}:7817   .text.rs232_print_int_number:00000000 $t
    {standard input}:7822   .text.rs232_print_int_number:00000000 rs232_print_int_number
    {standard input}:7933   .text.uart_init:00000000 $t
    {standard input}:7938   .text.uart_init:00000000 uart_init
    {standard input}:8239   .text.uart_init:00000204 $d
    {standard input}:8253   .text.uart_init_bd:00000000 $t
    {standard input}:8258   .text.uart_init_bd:00000000 uart_init_bd
    {standard input}:8638   .text.uart_init_bd:0000027c $d
    {standard input}:8653   .text.uart_interrupt_enable:00000000 $t
    {standard input}:8658   .text.uart_interrupt_enable:00000000 uart_interrupt_enable
    {standard input}:8719   .text.uart_interrupt_enable:00000054 $d
    {standard input}:8724   .text.uart_get:00000000 $t
    {standard input}:8729   .text.uart_get:00000000 uart_get
    {standard input}:8786   .text.uart_char_received:00000000 $t
    {standard input}:8791   .text.uart_char_received:00000000 uart_char_received
    {standard input}:8827   .text.uart_wait_get:00000000 $t
    {standard input}:8832   .text.uart_wait_get:00000000 uart_wait_get
    {standard input}:8887   .text.uart_put:00000000 $t
    {standard input}:8892   .text.uart_put:00000000 uart_put
    {standard input}:8940   .text.uart_print:00000000 $t
    {standard input}:8945   .text.uart_print:00000000 uart_print
    {standard input}:8986   .text.USIC0_1_IRQHandler:00000000 $t
    {standard input}:8991   .text.USIC0_1_IRQHandler:00000000 USIC0_1_IRQHandler
    {standard input}:9056   .text.USIC0_1_IRQHandler:00000050 $d
    {standard input}:9063   .text.uart_wait_of_enter:00000000 $t
    {standard input}:9068   .text.uart_wait_of_enter:00000000 uart_wait_of_enter
    {standard input}:9099   .text.uart_wait_of_enter:00000018 $d
    {standard input}:9104   .text.uart_clear_receivedata:00000000 $t
    {standard input}:9109   .text.uart_clear_receivedata:00000000 uart_clear_receivedata
    {standard input}:9136   .text.uart_clear_receivedata:00000014 $d
    {standard input}:9142   .text.uart_select_channel:00000000 $t
    {standard input}:9147   .text.uart_select_channel:00000000 uart_select_channel
    {standard input}:9255   .text.uart_read_number:00000000 $t
    {standard input}:9260   .text.uart_read_number:00000000 uart_read_number
    {standard input}:9355   .text.uart_read_number:00000080 $d
    {standard input}:9360   .text.uart_print_number:00000000 $t
    {standard input}:9365   .text.uart_print_number:00000000 uart_print_number
    {standard input}:9494   .text.warte_auf_eingabe:00000000 $t
    {standard input}:9499   .text.warte_auf_eingabe:00000000 warte_auf_eingabe
    {standard input}:9572   .text.warte_auf_eingabe:00000050 $d
    {standard input}:9578   .text.send_byte:00000000 $t
    {standard input}:9583   .text.send_byte:00000000 send_byte
    {standard input}:9762   .text.wait_bsy1:00000000 wait_bsy1
    {standard input}:9704   .text.send_byte:000000ac $d
    {standard input}:9709   .text.wait_bsy2:00000000 $t
    {standard input}:9714   .text.wait_bsy2:00000000 wait_bsy2
    {standard input}:9752   .text.wait_bsy2:00000020 $d
    {standard input}:9757   .text.wait_bsy1:00000000 $t
    {standard input}:9800   .text.lcd_befehl:00000000 $t
    {standard input}:9805   .text.lcd_befehl:00000000 lcd_befehl
    {standard input}:9840   .text.lcd_daten:00000000 $t
    {standard input}:9845   .text.lcd_daten:00000000 lcd_daten
    {standard input}:9880   .text.lcd_init:00000000 $t
    {standard input}:9885   .text.lcd_init:00000000 lcd_init
    {standard input}:9970   .text.lcd_init:00000088 $d
    {standard input}:9977   .text.lcd_clear:00000000 $t
    {standard input}:9982   .text.lcd_clear:00000000 lcd_clear
    {standard input}:10012  .text.lcd_setcursor:00000000 $t
    {standard input}:10017  .text.lcd_setcursor:00000000 lcd_setcursor
    {standard input}:10118  .text.lcd_char:00000000 $t
    {standard input}:10123  .text.lcd_char:00000000 lcd_char
    {standard input}:10468  .text.lcd_lookup:00000000 lcd_lookup
    {standard input}:10170  .text.lcd_print:00000000 $t
    {standard input}:10175  .text.lcd_print:00000000 lcd_print
    {standard input}:10216  .text.lcd_byte:00000000 $t
    {standard input}:10221  .text.lcd_byte:00000000 lcd_byte
    {standard input}:10339  .text.lcd_int:00000000 $t
    {standard input}:10344  .text.lcd_int:00000000 lcd_int
    {standard input}:10463  .text.lcd_lookup:00000000 $t
    {standard input}:10532  .text.lcd_clearline:00000000 $t
    {standard input}:10537  .text.lcd_clearline:00000000 lcd_clearline
    {standard input}:10600  .text.ext_interrupt1_init:00000000 $t
    {standard input}:10605  .text.ext_interrupt1_init:00000000 ext_interrupt1_init
    {standard input}:10979  .text.ext_clear_IRQ:00000000 ext_clear_IRQ
    {standard input}:10666  .text.ext_interrupt1_init:0000004c $d
    {standard input}:10671  .text.ext_interrupt2_init:00000000 $t
    {standard input}:10676  .text.ext_interrupt2_init:00000000 ext_interrupt2_init
    {standard input}:10738  .text.ext_interrupt2_init:0000004c $d
    {standard input}:10743  .text.ext_interrupt_init:00000000 $t
    {standard input}:10748  .text.ext_interrupt_init:00000000 ext_interrupt_init
    {standard input}:10774  .text.ext_interrupt1_enable:00000000 $t
    {standard input}:10779  .text.ext_interrupt1_enable:00000000 ext_interrupt1_enable
    {standard input}:10802  .text.ext_interrupt2_enable:00000000 $t
    {standard input}:10807  .text.ext_interrupt2_enable:00000000 ext_interrupt2_enable
    {standard input}:10830  .text.ext_interrupt1_disable:00000000 $t
    {standard input}:10835  .text.ext_interrupt1_disable:00000000 ext_interrupt1_disable
    {standard input}:10858  .text.ext_interrupt2_disable:00000000 $t
    {standard input}:10863  .text.ext_interrupt2_disable:00000000 ext_interrupt2_disable
    {standard input}:10886  .text.ext_interrupt1_prioritaet:00000000 $t
    {standard input}:10891  .text.ext_interrupt1_prioritaet:00000000 ext_interrupt1_prioritaet
    {standard input}:10930  .text.ext_interrupt2_prioritaet:00000000 $t
    {standard input}:10935  .text.ext_interrupt2_prioritaet:00000000 ext_interrupt2_prioritaet
    {standard input}:10974  .text.ext_clear_IRQ:00000000 $t
    {standard input}:11020  .text.timer1ms_init:00000000 $t
    {standard input}:11025  .text.timer1ms_init:00000000 timer1ms_init
    {standard input}:11101  .text.timer1ms_init:00000068 $d
    {standard input}:11108  .text.timer1ms_enable:00000000 $t
    {standard input}:11113  .text.timer1ms_enable:00000000 timer1ms_enable
    {standard input}:11148  .text.timer1ms_enable:00000024 $d
    {standard input}:11153  .text.timer1ms_disable:00000000 $t
    {standard input}:11158  .text.timer1ms_disable:00000000 timer1ms_disable
    {standard input}:11181  .text.timer1ms_disable:00000010 $d
    {standard input}:11186  .text.timer_init:00000000 $t
    {standard input}:11191  .text.timer_init:00000000 timer_init
    {standard input}:11260  .text.timer_init:0000005c $d
    {standard input}:11267  .text.timer_start:00000000 $t
    {standard input}:11272  .text.timer_start:00000000 timer_start
    {standard input}:11295  .text.timer_start:00000010 $d
    {standard input}:11300  .text.timer_start_interrupt:00000000 $t
    {standard input}:11305  .text.timer_start_interrupt:00000000 timer_start_interrupt
    {standard input}:11349  .text.timer_start_interrupt:00000034 $d
    {standard input}:11354  .text.timer_stop:00000000 $t
    {standard input}:11359  .text.timer_stop:00000000 timer_stop
    {standard input}:11382  .text.timer_stop:00000010 $d
    {standard input}:11387  .text.timer_value:00000000 $t
    {standard input}:11392  .text.timer_value:00000000 timer_value
    {standard input}:11424  .text.timer_value:0000001c $d
    {standard input}:11429  .text.timer_reset:00000000 $t
    {standard input}:11434  .text.timer_reset:00000000 timer_reset
    {standard input}:11457  .text.timer_reset:00000010 $d
    {standard input}:11462  .text.timer2_init:00000000 $t
    {standard input}:11467  .text.timer2_init:00000000 timer2_init
    {standard input}:11536  .text.timer2_init:0000005c $d
    {standard input}:11543  .text.timer2_start:00000000 $t
    {standard input}:11548  .text.timer2_start:00000000 timer2_start
    {standard input}:11571  .text.timer2_start:00000010 $d
    {standard input}:11576  .text.timer2_start_interrupt:00000000 $t
    {standard input}:11581  .text.timer2_start_interrupt:00000000 timer2_start_interrupt
    {standard input}:11625  .text.timer2_start_interrupt:00000034 $d
    {standard input}:11630  .text.timer2_stop:00000000 $t
    {standard input}:11635  .text.timer2_stop:00000000 timer2_stop
    {standard input}:11658  .text.timer2_stop:00000010 $d
    {standard input}:11663  .text.timer2_value:00000000 $t
    {standard input}:11668  .text.timer2_value:00000000 timer2_value
    {standard input}:11700  .text.timer2_value:0000001c $d
    {standard input}:11705  .text.timer2_reset:00000000 $t
    {standard input}:11710  .text.timer2_reset:00000000 timer2_reset
    {standard input}:11733  .text.timer2_reset:00000010 $d
    {standard input}:11738  .text.timer1_init:00000000 $t
    {standard input}:11743  .text.timer1_init:00000000 timer1_init
    {standard input}:11811  .text.timer1_init:00000058 $d
    {standard input}:11818  .text.timer1_start:00000000 $t
    {standard input}:11823  .text.timer1_start:00000000 timer1_start
    {standard input}:11846  .text.timer1_start:00000010 $d
    {standard input}:11851  .text.timer1_start_interrupt:00000000 $t
    {standard input}:11856  .text.timer1_start_interrupt:00000000 timer1_start_interrupt
    {standard input}:11900  .text.timer1_start_interrupt:00000034 $d
    {standard input}:11905  .text.timer1_stop:00000000 $t
    {standard input}:11910  .text.timer1_stop:00000000 timer1_stop
    {standard input}:11933  .text.timer1_stop:00000010 $d
    {standard input}:11938  .text.timer1_value:00000000 $t
    {standard input}:11943  .text.timer1_value:00000000 timer1_value
    {standard input}:11975  .text.timer1_value:0000001c $d
    {standard input}:11980  .text.timer1_reset:00000000 $t
    {standard input}:11985  .text.timer1_reset:00000000 timer1_reset
    {standard input}:12008  .text.timer1_reset:00000010 $d
    {standard input}:12013  .text.timer0_init:00000000 $t
    {standard input}:12018  .text.timer0_init:00000000 timer0_init
    {standard input}:12086  .text.timer0_init:00000058 $d
    {standard input}:12093  .text.timer0_start:00000000 $t
    {standard input}:12098  .text.timer0_start:00000000 timer0_start
    {standard input}:12121  .text.timer0_start:00000010 $d
    {standard input}:12126  .text.timer0_start_interrupt:00000000 $t
    {standard input}:12131  .text.timer0_start_interrupt:00000000 timer0_start_interrupt
    {standard input}:12173  .text.timer0_start_interrupt:00000030 $d
    {standard input}:12178  .text.timer0_stop:00000000 $t
    {standard input}:12183  .text.timer0_stop:00000000 timer0_stop
    {standard input}:12206  .text.timer0_stop:00000010 $d
    {standard input}:12211  .text.timer0_value:00000000 $t
    {standard input}:12216  .text.timer0_value:00000000 timer0_value
    {standard input}:12248  .text.timer0_value:0000001c $d
    {standard input}:12253  .text.timer0_reset:00000000 $t
    {standard input}:12258  .text.timer0_reset:00000000 timer0_reset
    {standard input}:12281  .text.timer0_reset:00000010 $d
    {standard input}:12286  .text.timer0_extern_controll:00000000 $t
    {standard input}:12291  .text.timer0_extern_controll:00000000 timer0_extern_controll
    {standard input}:12570  .text.timer0_extern_controll:000001b0 $d
    {standard input}:12587  .text.timer1_extern_controll:00000000 $t
    {standard input}:12592  .text.timer1_extern_controll:00000000 timer1_extern_controll
    {standard input}:12871  .text.timer1_extern_controll:000001b0 $d
    {standard input}:12888  .text.timer2_extern_controll:00000000 $t
    {standard input}:12893  .text.timer2_extern_controll:00000000 timer2_extern_controll
    {standard input}:13172  .text.timer2_extern_controll:000001b0 $d
    {standard input}:13189  .text.timer3_extern_controll:00000000 $t
    {standard input}:13194  .text.timer3_extern_controll:00000000 timer3_extern_controll
    {standard input}:13473  .text.timer3_extern_controll:000001b0 $d
    {standard input}:13490  .text.deepSleep_init:00000000 $t
    {standard input}:13495  .text.deepSleep_init:00000000 deepSleep_init
    {standard input}:13525  .text.deepSleep_init:0000001c $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
__aeabi_uidivmod
__aeabi_uidiv
__aeabi_idiv
__aeabi_idivmod
