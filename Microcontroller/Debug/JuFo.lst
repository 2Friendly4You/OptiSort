
JuFo.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000023b8  10001000  10001000  00001000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .VENEER_Code  00000110  2000000c  100033b8  0000800c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 Stack         00000404  2000011c  00000000  0000011c  2**0
                  ALLOC
  3 .bss          000003a8  20000520  00000404  00008520  2**2
                  ALLOC
  4 .no_init      00000004  20003ffc  00003ee0  0000011c  2**2
                  ALLOC
  5 .debug_aranges 000005f8  00000000  00000000  00008120  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00003959  00000000  00000000  00008718  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000070c  00000000  00000000  0000c071  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001d15  00000000  00000000  0000c77d  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000152c  00000000  00000000  0000e494  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001422  00000000  00000000  0000f9c0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000021f0  00000000  00000000  00010de2  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000005a0  00000000  00000000  00012fd8  2**3
                  CONTENTS, READONLY, DEBUGGING
 13 .build_attributes 0000017e  00000000  00000000  00013578  2**0
                  CONTENTS, READONLY

Disassembly of section .text:

10001000 <__Vectors>:
10001000:	20 05 00 20 19 10 00 10 00 00 00 00 99 10 00 10      .. ............
10001010:	00 04 01 00 00 00 00 80                             ........

10001018 <Reset_Handler>:
    .thumb_func 
    .globl  Reset_Handler
    .type   Reset_Handler, %function
Reset_Handler: 
/* Initialize interrupt veneer */
	ldr	r1, =eROData
10001018:	4911      	ldr	r1, [pc, #68]	; (10001060 <__copy_data+0xe>)
	ldr	r2, =VeneerStart
1000101a:	4a12      	ldr	r2, [pc, #72]	; (10001064 <__copy_data+0x12>)
	ldr	r3, =VeneerEnd
1000101c:	4b12      	ldr	r3, [pc, #72]	; (10001068 <__copy_data+0x16>)
	bl  __copy_data
1000101e:	f000 f818 	bl	10001052 <__copy_data>

    ldr  r0, =SystemInit
10001022:	4812      	ldr	r0, [pc, #72]	; (1000106c <__copy_data+0x1a>)
    blx  r0
10001024:	4780      	blx	r0
	
/* Initialize data */
	ldr	r1, =DataLoadAddr
10001026:	4912      	ldr	r1, [pc, #72]	; (10001070 <__copy_data+0x1e>)
	ldr	r2, =__data_start
10001028:	4a12      	ldr	r2, [pc, #72]	; (10001074 <__copy_data+0x22>)
	ldr	r3, =__data_end
1000102a:	4b13      	ldr	r3, [pc, #76]	; (10001078 <__copy_data+0x26>)
	bl  __copy_data
1000102c:	f000 f811 	bl	10001052 <__copy_data>

/* RAM code */
	ldr	r1, =__ram_code_load
10001030:	4912      	ldr	r1, [pc, #72]	; (1000107c <__copy_data+0x2a>)
	ldr	r2, =__ram_code_start
10001032:	4a13      	ldr	r2, [pc, #76]	; (10001080 <__copy_data+0x2e>)
	ldr	r3, =__ram_code_end
10001034:	4b13      	ldr	r3, [pc, #76]	; (10001084 <__copy_data+0x32>)
	bl  __copy_data
10001036:	f000 f80c 	bl	10001052 <__copy_data>
 *    __bss_end__: end of the BSS section.
 *
 *  Both addresses must be aligned to 4 bytes boundary.
 */
#ifndef __SKIP_BSS_CLEAR
	ldr	r1, =__bss_start
1000103a:	4913      	ldr	r1, [pc, #76]	; (10001088 <__copy_data+0x36>)
	ldr	r2, =__bss_end
1000103c:	4a13      	ldr	r2, [pc, #76]	; (1000108c <__copy_data+0x3a>)

	movs	r0, 0
1000103e:	2000      	movs	r0, #0

	subs	r2, r1
10001040:	1a52      	subs	r2, r2, r1
	ble	.L_loop3_done
10001042:	dd02      	ble.n	1000104a <Reset_Handler+0x32>

.L_loop3:
	subs	r2, #4
10001044:	3a04      	subs	r2, #4
	str	r0, [r1, r2]
10001046:	5088      	str	r0, [r1, r2]
	bgt	.L_loop3
10001048:	dcfc      	bgt.n	10001044 <Reset_Handler+0x2c>
.L_loop3_done:
#endif /* __SKIP_BSS_CLEAR */

#ifndef __SKIP_LIBC_INIT_ARRAY
    ldr  r0, =__libc_init_array
1000104a:	4811      	ldr	r0, [pc, #68]	; (10001090 <__copy_data+0x3e>)
    blx  r0
1000104c:	4780      	blx	r0
#endif

    ldr  r0, =main
1000104e:	4811      	ldr	r0, [pc, #68]	; (10001094 <__copy_data+0x42>)
    blx  r0
10001050:	4780      	blx	r0

10001052 <__copy_data>:
 *    r3: end of the section to copy to
 *
 *  All addresses must be aligned to 4 bytes boundary.
 *  Uses r0
 */
	subs	r3, r2
10001052:	1a9b      	subs	r3, r3, r2
	ble	.L_loop_done
10001054:	dd03      	ble.n	1000105e <__copy_data+0xc>

.L_loop:
	subs	r3, #4
10001056:	3b04      	subs	r3, #4
	ldr	r0, [r1,r3]
10001058:	58c8      	ldr	r0, [r1, r3]
	str	r0, [r2,r3]
1000105a:	50d0      	str	r0, [r2, r3]
	bgt	.L_loop
1000105c:	dcfb      	bgt.n	10001056 <__copy_data+0x4>

.L_loop_done:
	bx  lr
1000105e:	4770      	bx	lr
    .thumb_func 
    .globl  Reset_Handler
    .type   Reset_Handler, %function
Reset_Handler: 
/* Initialize interrupt veneer */
	ldr	r1, =eROData
10001060:	100033b8 	.word	0x100033b8
	ldr	r2, =VeneerStart
10001064:	2000000c 	.word	0x2000000c
	ldr	r3, =VeneerEnd
10001068:	2000011c 	.word	0x2000011c
	bl  __copy_data

    ldr  r0, =SystemInit
1000106c:	1000109d 	.word	0x1000109d
    blx  r0
	
/* Initialize data */
	ldr	r1, =DataLoadAddr
10001070:	100034c8 	.word	0x100034c8
	ldr	r2, =__data_start
10001074:	20000520 	.word	0x20000520
	ldr	r3, =__data_end
10001078:	20000520 	.word	0x20000520
	bl  __copy_data

/* RAM code */
	ldr	r1, =__ram_code_load
1000107c:	100034c8 	.word	0x100034c8
	ldr	r2, =__ram_code_start
10001080:	20000520 	.word	0x20000520
	ldr	r3, =__ram_code_end
10001084:	20000520 	.word	0x20000520
 *    __bss_end__: end of the BSS section.
 *
 *  Both addresses must be aligned to 4 bytes boundary.
 */
#ifndef __SKIP_BSS_CLEAR
	ldr	r1, =__bss_start
10001088:	20000520 	.word	0x20000520
	ldr	r2, =__bss_end
1000108c:	200008c8 	.word	0x200008c8
	bgt	.L_loop3
.L_loop3_done:
#endif /* __SKIP_BSS_CLEAR */

#ifndef __SKIP_LIBC_INIT_ARRAY
    ldr  r0, =__libc_init_array
10001090:	10003351 	.word	0x10003351
    blx  r0
#endif

    ldr  r0, =main
10001094:	10002ea5 	.word	0x10002ea5

10001098 <CCU40_0_IRQHandler>:
    
    .thumb_func
    .weak Default_handler
    .type Default_handler, %function
Default_handler:
    b  .
10001098:	e7fe      	b.n	10001098 <CCU40_0_IRQHandler>
	...

1000109c <SystemInit>:
/*******************************************************************************
 * API IMPLEMENTATION
 *******************************************************************************/

__WEAK void SystemInit(void)
{    
1000109c:	b580      	push	{r7, lr}
1000109e:	af00      	add	r7, sp, #0
  SystemCoreSetup();
100010a0:	f000 f804 	bl	100010ac <SystemCoreSetup>
  SystemCoreClockSetup();
100010a4:	f000 f81c 	bl	100010e0 <SystemCoreClockSetup>
}
100010a8:	46bd      	mov	sp, r7
100010aa:	bd80      	pop	{r7, pc}

100010ac <SystemCoreSetup>:

__WEAK void SystemCoreSetup(void)
{
100010ac:	b580      	push	{r7, lr}
100010ae:	af00      	add	r7, sp, #0
#ifndef USE_DYNAMIC_FLASH_WS
  /* Fix flash wait states to 1 cycle (see DS Addendum) */
  NVM->NVMCONF |= NVM_NVMCONF_WS_Msk;
100010b0:	490a      	ldr	r1, [pc, #40]	; (100010dc <SystemCoreSetup+0x30>)
100010b2:	4b0a      	ldr	r3, [pc, #40]	; (100010dc <SystemCoreSetup+0x30>)
100010b4:	891b      	ldrh	r3, [r3, #8]
100010b6:	b29b      	uxth	r3, r3
100010b8:	2280      	movs	r2, #128	; 0x80
100010ba:	0152      	lsls	r2, r2, #5
100010bc:	4313      	orrs	r3, r2
100010be:	b29b      	uxth	r3, r3
100010c0:	810b      	strh	r3, [r1, #8]
  NVM->CONFIG1 |= NVM_CONFIG1_FIXWS_Msk;
100010c2:	4906      	ldr	r1, [pc, #24]	; (100010dc <SystemCoreSetup+0x30>)
100010c4:	4a05      	ldr	r2, [pc, #20]	; (100010dc <SystemCoreSetup+0x30>)
100010c6:	2348      	movs	r3, #72	; 0x48
100010c8:	5ad3      	ldrh	r3, [r2, r3]
100010ca:	b29b      	uxth	r3, r3
100010cc:	2280      	movs	r2, #128	; 0x80
100010ce:	0112      	lsls	r2, r2, #4
100010d0:	4313      	orrs	r3, r2
100010d2:	b29a      	uxth	r2, r3
100010d4:	2348      	movs	r3, #72	; 0x48
100010d6:	52ca      	strh	r2, [r1, r3]
#endif
}
100010d8:	46bd      	mov	sp, r7
100010da:	bd80      	pop	{r7, pc}
100010dc:	40050000 	.word	0x40050000

100010e0 <SystemCoreClockSetup>:

__WEAK void SystemCoreClockSetup(void)
{
100010e0:	b580      	push	{r7, lr}
100010e2:	af00      	add	r7, sp, #0
  /* Override values of CLOCK_VAL1 and CLOCK_VAL2 defined in vector table */
  /* MCLK = 32MHz, PCLK = 64MHz */
  
  SCU_GENERAL->PASSWD = 0x000000C0UL; /* disable bit protection */
100010e4:	4b09      	ldr	r3, [pc, #36]	; (1000110c <SystemCoreClockSetup+0x2c>)
100010e6:	22c0      	movs	r2, #192	; 0xc0
100010e8:	625a      	str	r2, [r3, #36]	; 0x24
  SCU_CLK->CLKCR = 0x3FF10100UL;
100010ea:	4b09      	ldr	r3, [pc, #36]	; (10001110 <SystemCoreClockSetup+0x30>)
100010ec:	4a09      	ldr	r2, [pc, #36]	; (10001114 <SystemCoreClockSetup+0x34>)
100010ee:	601a      	str	r2, [r3, #0]
  while((SCU_CLK->CLKCR & SCU_CLK_CLKCR_VDDC2LOW_Msk));
100010f0:	46c0      	nop			; (mov r8, r8)
100010f2:	4b07      	ldr	r3, [pc, #28]	; (10001110 <SystemCoreClockSetup+0x30>)
100010f4:	681a      	ldr	r2, [r3, #0]
100010f6:	2380      	movs	r3, #128	; 0x80
100010f8:	05db      	lsls	r3, r3, #23
100010fa:	4013      	ands	r3, r2
100010fc:	d1f9      	bne.n	100010f2 <SystemCoreClockSetup+0x12>
  SCU_GENERAL->PASSWD = 0x000000C3UL; /* enable bit protection */
100010fe:	4b03      	ldr	r3, [pc, #12]	; (1000110c <SystemCoreClockSetup+0x2c>)
10001100:	22c3      	movs	r2, #195	; 0xc3
10001102:	625a      	str	r2, [r3, #36]	; 0x24
  
  SystemCoreClockUpdate();
10001104:	f000 f808 	bl	10001118 <SystemCoreClockUpdate>
}
10001108:	46bd      	mov	sp, r7
1000110a:	bd80      	pop	{r7, pc}
1000110c:	40010000 	.word	0x40010000
10001110:	40010300 	.word	0x40010300
10001114:	3ff10100 	.word	0x3ff10100

10001118 <SystemCoreClockUpdate>:

__WEAK void SystemCoreClockUpdate(void)
{
10001118:	b580      	push	{r7, lr}
1000111a:	af00      	add	r7, sp, #0
  static uint32_t IDIV, FDIV;

  IDIV = ((SCU_CLK->CLKCR) & SCU_CLK_CLKCR_IDIV_Msk) >> SCU_CLK_CLKCR_IDIV_Pos;
1000111c:	4b12      	ldr	r3, [pc, #72]	; (10001168 <SystemCoreClockUpdate+0x50>)
1000111e:	681a      	ldr	r2, [r3, #0]
10001120:	23ff      	movs	r3, #255	; 0xff
10001122:	021b      	lsls	r3, r3, #8
10001124:	4013      	ands	r3, r2
10001126:	0a1a      	lsrs	r2, r3, #8
10001128:	4b10      	ldr	r3, [pc, #64]	; (1000116c <SystemCoreClockUpdate+0x54>)
1000112a:	601a      	str	r2, [r3, #0]
  FDIV = ((SCU_CLK->CLKCR) & SCU_CLK_CLKCR_FDIV_Msk) >> SCU_CLK_CLKCR_FDIV_Pos;
1000112c:	4b0e      	ldr	r3, [pc, #56]	; (10001168 <SystemCoreClockUpdate+0x50>)
1000112e:	681b      	ldr	r3, [r3, #0]
10001130:	22ff      	movs	r2, #255	; 0xff
10001132:	401a      	ands	r2, r3
10001134:	4b0e      	ldr	r3, [pc, #56]	; (10001170 <SystemCoreClockUpdate+0x58>)
10001136:	601a      	str	r2, [r3, #0]
  
  if (IDIV != 0)
10001138:	4b0c      	ldr	r3, [pc, #48]	; (1000116c <SystemCoreClockUpdate+0x54>)
1000113a:	681b      	ldr	r3, [r3, #0]
1000113c:	2b00      	cmp	r3, #0
1000113e:	d00e      	beq.n	1000115e <SystemCoreClockUpdate+0x46>
  {
    /* Fractional divider is enabled and used */
    SystemCoreClock = ((DCO1_FREQUENCY << 6U) / ((IDIV << 8) + FDIV)) << 1U;
10001140:	4b0a      	ldr	r3, [pc, #40]	; (1000116c <SystemCoreClockUpdate+0x54>)
10001142:	681b      	ldr	r3, [r3, #0]
10001144:	021a      	lsls	r2, r3, #8
10001146:	4b0a      	ldr	r3, [pc, #40]	; (10001170 <SystemCoreClockUpdate+0x58>)
10001148:	681b      	ldr	r3, [r3, #0]
1000114a:	18d3      	adds	r3, r2, r3
1000114c:	4809      	ldr	r0, [pc, #36]	; (10001174 <SystemCoreClockUpdate+0x5c>)
1000114e:	1c19      	adds	r1, r3, #0
10001150:	f002 f86c 	bl	1000322c <__aeabi_uidiv>
10001154:	1c03      	adds	r3, r0, #0
10001156:	005a      	lsls	r2, r3, #1
10001158:	4b07      	ldr	r3, [pc, #28]	; (10001178 <SystemCoreClockUpdate+0x60>)
1000115a:	601a      	str	r2, [r3, #0]
1000115c:	e002      	b.n	10001164 <SystemCoreClockUpdate+0x4c>
  }
  else
  {
    /* Fractional divider bypassed. Simply divide DCO_DCLK by 2 */
    SystemCoreClock = DCO1_FREQUENCY >> 1U;
1000115e:	4b06      	ldr	r3, [pc, #24]	; (10001178 <SystemCoreClockUpdate+0x60>)
10001160:	4a06      	ldr	r2, [pc, #24]	; (1000117c <SystemCoreClockUpdate+0x64>)
10001162:	601a      	str	r2, [r3, #0]
  }
}
10001164:	46bd      	mov	sp, r7
10001166:	bd80      	pop	{r7, pc}
10001168:	40010300 	.word	0x40010300
1000116c:	20000520 	.word	0x20000520
10001170:	20000524 	.word	0x20000524
10001174:	f4240000 	.word	0xf4240000
10001178:	20003ffc 	.word	0x20003ffc
1000117c:	01e84800 	.word	0x01e84800

10001180 <_init>:
  }
}

/* Init */
void _init(void)
{}
10001180:	b580      	push	{r7, lr}
10001182:	af00      	add	r7, sp, #0
10001184:	46bd      	mov	sp, r7
10001186:	bd80      	pop	{r7, pc}

10001188 <init>:
#include "XMC1100-LibHaas.h"
#include "HardwareController.h"

void init() {
10001188:	b580      	push	{r7, lr}
1000118a:	af00      	add	r7, sp, #0
	uart_init();
1000118c:	f001 fc82 	bl	10002a94 <uart_init>
	uart_interrupt_enable();
10001190:	f001 fd96 	bl	10002cc0 <uart_interrupt_enable>
	uart_select_channel(UARTCHANNEL_0);
10001194:	2003      	movs	r0, #3
10001196:	f001 fe29 	bl	10002dec <uart_select_channel>

	rs232_init();
1000119a:	f001 fb33 	bl	10002804 <rs232_init>
	rs232_interrupt_enable();
1000119e:	f001 fbfd 	bl	1000299c <rs232_interrupt_enable>

	bit_init(redLEDport, redLEDpin, OUTP);
100011a2:	2001      	movs	r0, #1
100011a4:	2102      	movs	r1, #2
100011a6:	2201      	movs	r2, #1
100011a8:	f000 f9f8 	bl	1000159c <bit_init>
	bit_init(greenLEDport, greenLEDpin, OUTP);
100011ac:	2001      	movs	r0, #1
100011ae:	2103      	movs	r1, #3
100011b0:	2201      	movs	r2, #1
100011b2:	f000 f9f3 	bl	1000159c <bit_init>
	bit_init(LEDstripesport, LEDstripespin, OUTP);
100011b6:	2000      	movs	r0, #0
100011b8:	2104      	movs	r1, #4
100011ba:	2201      	movs	r2, #1
100011bc:	f000 f9ee 	bl	1000159c <bit_init>
	bit_init(laserport, laserpin, OUTP);
100011c0:	2000      	movs	r0, #0
100011c2:	2100      	movs	r1, #0
100011c4:	2201      	movs	r2, #1
100011c6:	f000 f9e9 	bl	1000159c <bit_init>
	bit_init(lightbarrier1port, lightbarrier1pin, INP);
100011ca:	2002      	movs	r0, #2
100011cc:	2103      	movs	r1, #3
100011ce:	2200      	movs	r2, #0
100011d0:	f000 f9e4 	bl	1000159c <bit_init>
	bit_init(lightbarrier2port, lightbarrier2pin, INP);
100011d4:	2002      	movs	r0, #2
100011d6:	2102      	movs	r1, #2
100011d8:	2200      	movs	r2, #0
100011da:	f000 f9df 	bl	1000159c <bit_init>
	bit_init(lightbarrier3port, lightbarrier3pin, INP);
100011de:	2002      	movs	r0, #2
100011e0:	2101      	movs	r1, #1
100011e2:	2200      	movs	r2, #0
100011e4:	f000 f9da 	bl	1000159c <bit_init>
	bit_init(relay1port, relay1pin, OUTP);
100011e8:	2000      	movs	r0, #0
100011ea:	210c      	movs	r1, #12
100011ec:	2201      	movs	r2, #1
100011ee:	f000 f9d5 	bl	1000159c <bit_init>
	bit_init(relay2port, relay2pin, OUTP);
100011f2:	2000      	movs	r0, #0
100011f4:	210d      	movs	r1, #13
100011f6:	2201      	movs	r2, #1
100011f8:	f000 f9d0 	bl	1000159c <bit_init>
	bit_init(pneumatics1port, pneumatics1pin, OUTP);
100011fc:	2000      	movs	r0, #0
100011fe:	2101      	movs	r1, #1
10001200:	2201      	movs	r2, #1
10001202:	f000 f9cb 	bl	1000159c <bit_init>
	bit_init(pneumatics2port, pneumatics2pin, OUTP);
10001206:	2000      	movs	r0, #0
10001208:	2102      	movs	r1, #2
1000120a:	2201      	movs	r2, #1
1000120c:	f000 f9c6 	bl	1000159c <bit_init>
	bit_init_mode(button1port, button1pin, INP, PULLDOWN);
10001210:	2001      	movs	r0, #1
10001212:	2105      	movs	r1, #5
10001214:	2200      	movs	r2, #0
10001216:	2302      	movs	r3, #2
10001218:	f000 fb80 	bl	1000191c <bit_init_mode>
	bit_init_mode(button2port, button2pin, INP, PULLDOWN);
1000121c:	2001      	movs	r0, #1
1000121e:	2104      	movs	r1, #4
10001220:	2200      	movs	r2, #0
10001222:	2302      	movs	r3, #2
10001224:	f000 fb7a 	bl	1000191c <bit_init_mode>
	bit_init(inductivSensor1Port, inductivSensor1Pin, INP);
10001228:	2000      	movs	r0, #0
1000122a:	210a      	movs	r1, #10
1000122c:	2200      	movs	r2, #0
1000122e:	f000 f9b5 	bl	1000159c <bit_init>
	bit_init(inductivSensor2Port, inductivSensor2Pin, INP);
10001232:	2000      	movs	r0, #0
10001234:	210b      	movs	r1, #11
10001236:	2200      	movs	r2, #0
10001238:	f000 f9b0 	bl	1000159c <bit_init>
	bit_init(dir1port, dir1pin, OUTP);
1000123c:	2000      	movs	r0, #0
1000123e:	2107      	movs	r1, #7
10001240:	2201      	movs	r2, #1
10001242:	f000 f9ab 	bl	1000159c <bit_init>

	pwm1_init();
10001246:	f001 fa41 	bl	100026cc <pwm1_init>
	pwm1_start();
1000124a:	f001 fa87 	bl	1000275c <pwm1_start>

	slider(0, SLIDERFORWARD);
1000124e:	2000      	movs	r0, #0
10001250:	2100      	movs	r1, #0
10001252:	f000 f969 	bl	10001528 <slider>

	bit_write(P0, laserport, OFF);
10001256:	2000      	movs	r0, #0
10001258:	2100      	movs	r1, #0
1000125a:	2200      	movs	r2, #0
1000125c:	f001 f93e 	bl	100024dc <bit_write>
	bit_write(LEDstripesport, LEDstripespin, OFF);
10001260:	2000      	movs	r0, #0
10001262:	2104      	movs	r1, #4
10001264:	2200      	movs	r2, #0
10001266:	f001 f939 	bl	100024dc <bit_write>
}
1000126a:	46bd      	mov	sp, r7
1000126c:	bd80      	pop	{r7, pc}
1000126e:	46c0      	nop			; (mov r8, r8)

10001270 <laser>:

void laser(int onOrOff) {
10001270:	b580      	push	{r7, lr}
10001272:	b082      	sub	sp, #8
10001274:	af00      	add	r7, sp, #0
10001276:	6078      	str	r0, [r7, #4]
	onOrOff ?
			bit_write(laserport, laserpin, ON) :
10001278:	687b      	ldr	r3, [r7, #4]
1000127a:	2b00      	cmp	r3, #0
1000127c:	d005      	beq.n	1000128a <laser+0x1a>
1000127e:	2000      	movs	r0, #0
10001280:	2100      	movs	r1, #0
10001282:	2201      	movs	r2, #1
10001284:	f001 f92a 	bl	100024dc <bit_write>
10001288:	e004      	b.n	10001294 <laser+0x24>
			bit_write(laserport, laserpin, OFF);
1000128a:	2000      	movs	r0, #0
1000128c:	2100      	movs	r1, #0
1000128e:	2200      	movs	r2, #0
10001290:	f001 f924 	bl	100024dc <bit_write>
}
10001294:	46bd      	mov	sp, r7
10001296:	b002      	add	sp, #8
10001298:	bd80      	pop	{r7, pc}
1000129a:	46c0      	nop			; (mov r8, r8)

1000129c <LEDStripes>:

void LEDStripes(int onOrOff) {
1000129c:	b580      	push	{r7, lr}
1000129e:	b082      	sub	sp, #8
100012a0:	af00      	add	r7, sp, #0
100012a2:	6078      	str	r0, [r7, #4]
	onOrOff ?
			bit_write(LEDstripesport, LEDstripespin, OFF) :
100012a4:	687b      	ldr	r3, [r7, #4]
100012a6:	2b00      	cmp	r3, #0
100012a8:	d005      	beq.n	100012b6 <LEDStripes+0x1a>
100012aa:	2000      	movs	r0, #0
100012ac:	2104      	movs	r1, #4
100012ae:	2200      	movs	r2, #0
100012b0:	f001 f914 	bl	100024dc <bit_write>
100012b4:	e004      	b.n	100012c0 <LEDStripes+0x24>
			bit_write(LEDstripesport, LEDstripespin, ON);
100012b6:	2000      	movs	r0, #0
100012b8:	2104      	movs	r1, #4
100012ba:	2201      	movs	r2, #1
100012bc:	f001 f90e 	bl	100024dc <bit_write>
}
100012c0:	46bd      	mov	sp, r7
100012c2:	b002      	add	sp, #8
100012c4:	bd80      	pop	{r7, pc}
100012c6:	46c0      	nop			; (mov r8, r8)

100012c8 <redLED>:

void redLED(int onOrOff) {
100012c8:	b580      	push	{r7, lr}
100012ca:	b082      	sub	sp, #8
100012cc:	af00      	add	r7, sp, #0
100012ce:	6078      	str	r0, [r7, #4]
	onOrOff ?
			bit_write(redLEDport, redLEDpin, OFF) :
100012d0:	687b      	ldr	r3, [r7, #4]
100012d2:	2b00      	cmp	r3, #0
100012d4:	d005      	beq.n	100012e2 <redLED+0x1a>
100012d6:	2001      	movs	r0, #1
100012d8:	2102      	movs	r1, #2
100012da:	2200      	movs	r2, #0
100012dc:	f001 f8fe 	bl	100024dc <bit_write>
100012e0:	e004      	b.n	100012ec <redLED+0x24>
			bit_write(redLEDport, redLEDpin, ON);
100012e2:	2001      	movs	r0, #1
100012e4:	2102      	movs	r1, #2
100012e6:	2201      	movs	r2, #1
100012e8:	f001 f8f8 	bl	100024dc <bit_write>
}
100012ec:	46bd      	mov	sp, r7
100012ee:	b002      	add	sp, #8
100012f0:	bd80      	pop	{r7, pc}
100012f2:	46c0      	nop			; (mov r8, r8)

100012f4 <greenLED>:

void greenLED(int onOrOff) {
100012f4:	b580      	push	{r7, lr}
100012f6:	b082      	sub	sp, #8
100012f8:	af00      	add	r7, sp, #0
100012fa:	6078      	str	r0, [r7, #4]
	onOrOff ?
			bit_write(greenLEDport, greenLEDpin, OFF) :
100012fc:	687b      	ldr	r3, [r7, #4]
100012fe:	2b00      	cmp	r3, #0
10001300:	d005      	beq.n	1000130e <greenLED+0x1a>
10001302:	2001      	movs	r0, #1
10001304:	2103      	movs	r1, #3
10001306:	2200      	movs	r2, #0
10001308:	f001 f8e8 	bl	100024dc <bit_write>
1000130c:	e004      	b.n	10001318 <greenLED+0x24>
			bit_write(greenLEDport, greenLEDpin, ON);
1000130e:	2001      	movs	r0, #1
10001310:	2103      	movs	r1, #3
10001312:	2201      	movs	r2, #1
10001314:	f001 f8e2 	bl	100024dc <bit_write>
}
10001318:	46bd      	mov	sp, r7
1000131a:	b002      	add	sp, #8
1000131c:	bd80      	pop	{r7, pc}
1000131e:	46c0      	nop			; (mov r8, r8)

10001320 <productionLine>:

void productionLine(int onOrOff, int direction) {
10001320:	b580      	push	{r7, lr}
10001322:	b082      	sub	sp, #8
10001324:	af00      	add	r7, sp, #0
10001326:	6078      	str	r0, [r7, #4]
10001328:	6039      	str	r1, [r7, #0]
	onOrOff ?
			bit_write(relay1port, relay1pin, OFF) :
1000132a:	687b      	ldr	r3, [r7, #4]
1000132c:	2b00      	cmp	r3, #0
1000132e:	d005      	beq.n	1000133c <productionLine+0x1c>
10001330:	2000      	movs	r0, #0
10001332:	210c      	movs	r1, #12
10001334:	2200      	movs	r2, #0
10001336:	f001 f8d1 	bl	100024dc <bit_write>
1000133a:	e004      	b.n	10001346 <productionLine+0x26>
			bit_write(relay1port, relay1pin, ON);
1000133c:	2000      	movs	r0, #0
1000133e:	210c      	movs	r1, #12
10001340:	2201      	movs	r2, #1
10001342:	f001 f8cb 	bl	100024dc <bit_write>
	direction ?
			bit_write(relay2port, relay2pin, ON) :
10001346:	683b      	ldr	r3, [r7, #0]
10001348:	2b00      	cmp	r3, #0
1000134a:	d005      	beq.n	10001358 <productionLine+0x38>
1000134c:	2000      	movs	r0, #0
1000134e:	210d      	movs	r1, #13
10001350:	2201      	movs	r2, #1
10001352:	f001 f8c3 	bl	100024dc <bit_write>
10001356:	e004      	b.n	10001362 <productionLine+0x42>
			bit_write(relay2port, relay2pin, OFF);
10001358:	2000      	movs	r0, #0
1000135a:	210d      	movs	r1, #13
1000135c:	2200      	movs	r2, #0
1000135e:	f001 f8bd 	bl	100024dc <bit_write>
}
10001362:	46bd      	mov	sp, r7
10001364:	b002      	add	sp, #8
10001366:	bd80      	pop	{r7, pc}

10001368 <lightBarrier1>:

int lightBarrier1(void) {
10001368:	b580      	push	{r7, lr}
1000136a:	b082      	sub	sp, #8
1000136c:	af00      	add	r7, sp, #0
	int temp1 = bit_read(lightbarrier1port, lightbarrier1pin);
1000136e:	2002      	movs	r0, #2
10001370:	2103      	movs	r1, #3
10001372:	f001 f891 	bl	10002498 <bit_read>
10001376:	1c03      	adds	r3, r0, #0
10001378:	607b      	str	r3, [r7, #4]
	delay_ms(LED_TOLERANCE_MILLIS);
1000137a:	2005      	movs	r0, #5
1000137c:	f001 fa20 	bl	100027c0 <delay_ms>
	int temp2 = bit_read(lightbarrier1port, lightbarrier1pin);
10001380:	2002      	movs	r0, #2
10001382:	2103      	movs	r1, #3
10001384:	f001 f888 	bl	10002498 <bit_read>
10001388:	1c03      	adds	r3, r0, #0
1000138a:	603b      	str	r3, [r7, #0]

	// implements tolerance

	while (temp1 != temp2) {
1000138c:	e00a      	b.n	100013a4 <lightBarrier1+0x3c>
		temp1 = temp2;
1000138e:	683b      	ldr	r3, [r7, #0]
10001390:	607b      	str	r3, [r7, #4]
		delay_ms(LED_TOLERANCE_MILLIS);
10001392:	2005      	movs	r0, #5
10001394:	f001 fa14 	bl	100027c0 <delay_ms>
		temp2 = bit_read(lightbarrier1port, lightbarrier1pin);
10001398:	2002      	movs	r0, #2
1000139a:	2103      	movs	r1, #3
1000139c:	f001 f87c 	bl	10002498 <bit_read>
100013a0:	1c03      	adds	r3, r0, #0
100013a2:	603b      	str	r3, [r7, #0]
	delay_ms(LED_TOLERANCE_MILLIS);
	int temp2 = bit_read(lightbarrier1port, lightbarrier1pin);

	// implements tolerance

	while (temp1 != temp2) {
100013a4:	687a      	ldr	r2, [r7, #4]
100013a6:	683b      	ldr	r3, [r7, #0]
100013a8:	429a      	cmp	r2, r3
100013aa:	d1f0      	bne.n	1000138e <lightBarrier1+0x26>
		temp1 = temp2;
		delay_ms(LED_TOLERANCE_MILLIS);
		temp2 = bit_read(lightbarrier1port, lightbarrier1pin);
	}

	if (temp1 == 0) {
100013ac:	687b      	ldr	r3, [r7, #4]
100013ae:	2b00      	cmp	r3, #0
100013b0:	d101      	bne.n	100013b6 <lightBarrier1+0x4e>
		return ON;
100013b2:	2301      	movs	r3, #1
100013b4:	e000      	b.n	100013b8 <lightBarrier1+0x50>
	} else {
		return OFF;
100013b6:	2300      	movs	r3, #0
	}
}
100013b8:	1c18      	adds	r0, r3, #0
100013ba:	46bd      	mov	sp, r7
100013bc:	b002      	add	sp, #8
100013be:	bd80      	pop	{r7, pc}

100013c0 <lightBarrier2>:

int lightBarrier2(void) {
100013c0:	b580      	push	{r7, lr}
100013c2:	b082      	sub	sp, #8
100013c4:	af00      	add	r7, sp, #0
	int temp1 = bit_read(lightbarrier2port, lightbarrier2pin);
100013c6:	2002      	movs	r0, #2
100013c8:	2102      	movs	r1, #2
100013ca:	f001 f865 	bl	10002498 <bit_read>
100013ce:	1c03      	adds	r3, r0, #0
100013d0:	607b      	str	r3, [r7, #4]
	delay_ms(LED_TOLERANCE_MILLIS);
100013d2:	2005      	movs	r0, #5
100013d4:	f001 f9f4 	bl	100027c0 <delay_ms>
	int temp2 = bit_read(lightbarrier2port, lightbarrier2pin);
100013d8:	2002      	movs	r0, #2
100013da:	2102      	movs	r1, #2
100013dc:	f001 f85c 	bl	10002498 <bit_read>
100013e0:	1c03      	adds	r3, r0, #0
100013e2:	603b      	str	r3, [r7, #0]

	// implements tolerance

	while (temp1 != temp2) {
100013e4:	e00a      	b.n	100013fc <lightBarrier2+0x3c>
		temp1 = temp2;
100013e6:	683b      	ldr	r3, [r7, #0]
100013e8:	607b      	str	r3, [r7, #4]
		delay_ms(LED_TOLERANCE_MILLIS);
100013ea:	2005      	movs	r0, #5
100013ec:	f001 f9e8 	bl	100027c0 <delay_ms>
		temp2 = bit_read(lightbarrier2port, lightbarrier2pin);
100013f0:	2002      	movs	r0, #2
100013f2:	2102      	movs	r1, #2
100013f4:	f001 f850 	bl	10002498 <bit_read>
100013f8:	1c03      	adds	r3, r0, #0
100013fa:	603b      	str	r3, [r7, #0]
	delay_ms(LED_TOLERANCE_MILLIS);
	int temp2 = bit_read(lightbarrier2port, lightbarrier2pin);

	// implements tolerance

	while (temp1 != temp2) {
100013fc:	687a      	ldr	r2, [r7, #4]
100013fe:	683b      	ldr	r3, [r7, #0]
10001400:	429a      	cmp	r2, r3
10001402:	d1f0      	bne.n	100013e6 <lightBarrier2+0x26>
		temp1 = temp2;
		delay_ms(LED_TOLERANCE_MILLIS);
		temp2 = bit_read(lightbarrier2port, lightbarrier2pin);
	}

	if (temp1 == 0) {
10001404:	687b      	ldr	r3, [r7, #4]
10001406:	2b00      	cmp	r3, #0
10001408:	d101      	bne.n	1000140e <lightBarrier2+0x4e>
		return ON;
1000140a:	2301      	movs	r3, #1
1000140c:	e000      	b.n	10001410 <lightBarrier2+0x50>
	} else {
		return OFF;
1000140e:	2300      	movs	r3, #0
	}
}
10001410:	1c18      	adds	r0, r3, #0
10001412:	46bd      	mov	sp, r7
10001414:	b002      	add	sp, #8
10001416:	bd80      	pop	{r7, pc}

10001418 <lightBarrier3>:

int lightBarrier3(void) {
10001418:	b580      	push	{r7, lr}
1000141a:	b082      	sub	sp, #8
1000141c:	af00      	add	r7, sp, #0
	int temp1 = bit_read(lightbarrier3port, lightbarrier3pin);
1000141e:	2002      	movs	r0, #2
10001420:	2101      	movs	r1, #1
10001422:	f001 f839 	bl	10002498 <bit_read>
10001426:	1c03      	adds	r3, r0, #0
10001428:	607b      	str	r3, [r7, #4]
	delay_ms(LED_TOLERANCE_MILLIS);
1000142a:	2005      	movs	r0, #5
1000142c:	f001 f9c8 	bl	100027c0 <delay_ms>
	int temp2 = bit_read(lightbarrier3port, lightbarrier3pin);
10001430:	2002      	movs	r0, #2
10001432:	2101      	movs	r1, #1
10001434:	f001 f830 	bl	10002498 <bit_read>
10001438:	1c03      	adds	r3, r0, #0
1000143a:	603b      	str	r3, [r7, #0]

	// implements tolerance

	while (temp1 != temp2) {
1000143c:	e00a      	b.n	10001454 <lightBarrier3+0x3c>
		temp1 = temp2;
1000143e:	683b      	ldr	r3, [r7, #0]
10001440:	607b      	str	r3, [r7, #4]
		delay_ms(LED_TOLERANCE_MILLIS);
10001442:	2005      	movs	r0, #5
10001444:	f001 f9bc 	bl	100027c0 <delay_ms>
		temp2 = bit_read(lightbarrier3port, lightbarrier3pin);
10001448:	2002      	movs	r0, #2
1000144a:	2101      	movs	r1, #1
1000144c:	f001 f824 	bl	10002498 <bit_read>
10001450:	1c03      	adds	r3, r0, #0
10001452:	603b      	str	r3, [r7, #0]
	delay_ms(LED_TOLERANCE_MILLIS);
	int temp2 = bit_read(lightbarrier3port, lightbarrier3pin);

	// implements tolerance

	while (temp1 != temp2) {
10001454:	687a      	ldr	r2, [r7, #4]
10001456:	683b      	ldr	r3, [r7, #0]
10001458:	429a      	cmp	r2, r3
1000145a:	d1f0      	bne.n	1000143e <lightBarrier3+0x26>
		temp1 = temp2;
		delay_ms(LED_TOLERANCE_MILLIS);
		temp2 = bit_read(lightbarrier3port, lightbarrier3pin);
	}

	if (temp1 == 0) {
1000145c:	687b      	ldr	r3, [r7, #4]
1000145e:	2b00      	cmp	r3, #0
10001460:	d101      	bne.n	10001466 <lightBarrier3+0x4e>
		return ON;
10001462:	2301      	movs	r3, #1
10001464:	e000      	b.n	10001468 <lightBarrier3+0x50>
	} else {
		return OFF;
10001466:	2300      	movs	r3, #0
	}
}
10001468:	1c18      	adds	r0, r3, #0
1000146a:	46bd      	mov	sp, r7
1000146c:	b002      	add	sp, #8
1000146e:	bd80      	pop	{r7, pc}

10001470 <pneumatics1>:

void pneumatics1(int outOrIn) {
10001470:	b580      	push	{r7, lr}
10001472:	b082      	sub	sp, #8
10001474:	af00      	add	r7, sp, #0
10001476:	6078      	str	r0, [r7, #4]
	outOrIn ?
			bit_write(pneumatics1port, pneumatics1pin, OUT) :
10001478:	687b      	ldr	r3, [r7, #4]
1000147a:	2b00      	cmp	r3, #0
1000147c:	d005      	beq.n	1000148a <pneumatics1+0x1a>
1000147e:	2000      	movs	r0, #0
10001480:	2101      	movs	r1, #1
10001482:	2201      	movs	r2, #1
10001484:	f001 f82a 	bl	100024dc <bit_write>
10001488:	e004      	b.n	10001494 <pneumatics1+0x24>
			bit_write(pneumatics1port, pneumatics1pin, IN);
1000148a:	2000      	movs	r0, #0
1000148c:	2101      	movs	r1, #1
1000148e:	2200      	movs	r2, #0
10001490:	f001 f824 	bl	100024dc <bit_write>
}
10001494:	46bd      	mov	sp, r7
10001496:	b002      	add	sp, #8
10001498:	bd80      	pop	{r7, pc}
1000149a:	46c0      	nop			; (mov r8, r8)

1000149c <pneumatics2>:

void pneumatics2(int outOrIn) {
1000149c:	b580      	push	{r7, lr}
1000149e:	b082      	sub	sp, #8
100014a0:	af00      	add	r7, sp, #0
100014a2:	6078      	str	r0, [r7, #4]
	outOrIn ?
			bit_write(pneumatics2port, pneumatics2pin, OUT) :
100014a4:	687b      	ldr	r3, [r7, #4]
100014a6:	2b00      	cmp	r3, #0
100014a8:	d005      	beq.n	100014b6 <pneumatics2+0x1a>
100014aa:	2000      	movs	r0, #0
100014ac:	2102      	movs	r1, #2
100014ae:	2201      	movs	r2, #1
100014b0:	f001 f814 	bl	100024dc <bit_write>
100014b4:	e004      	b.n	100014c0 <pneumatics2+0x24>
			bit_write(pneumatics2port, pneumatics2pin, IN);
100014b6:	2000      	movs	r0, #0
100014b8:	2102      	movs	r1, #2
100014ba:	2200      	movs	r2, #0
100014bc:	f001 f80e 	bl	100024dc <bit_write>
}
100014c0:	46bd      	mov	sp, r7
100014c2:	b002      	add	sp, #8
100014c4:	bd80      	pop	{r7, pc}
100014c6:	46c0      	nop			; (mov r8, r8)

100014c8 <readButton1>:

int readButton1(void) {
100014c8:	b580      	push	{r7, lr}
100014ca:	af00      	add	r7, sp, #0
	return !bit_read(button1port, button1pin);
100014cc:	2001      	movs	r0, #1
100014ce:	2105      	movs	r1, #5
100014d0:	f000 ffe2 	bl	10002498 <bit_read>
100014d4:	1c03      	adds	r3, r0, #0
100014d6:	425a      	negs	r2, r3
100014d8:	4153      	adcs	r3, r2
100014da:	b2db      	uxtb	r3, r3
}
100014dc:	1c18      	adds	r0, r3, #0
100014de:	46bd      	mov	sp, r7
100014e0:	bd80      	pop	{r7, pc}
100014e2:	46c0      	nop			; (mov r8, r8)

100014e4 <readButton2>:

int readButton2(void) {
100014e4:	b580      	push	{r7, lr}
100014e6:	af00      	add	r7, sp, #0
	return !bit_read(button2port, button2pin);
100014e8:	2001      	movs	r0, #1
100014ea:	2104      	movs	r1, #4
100014ec:	f000 ffd4 	bl	10002498 <bit_read>
100014f0:	1c03      	adds	r3, r0, #0
100014f2:	425a      	negs	r2, r3
100014f4:	4153      	adcs	r3, r2
100014f6:	b2db      	uxtb	r3, r3
}
100014f8:	1c18      	adds	r0, r3, #0
100014fa:	46bd      	mov	sp, r7
100014fc:	bd80      	pop	{r7, pc}
100014fe:	46c0      	nop			; (mov r8, r8)

10001500 <readInductivSensor1>:

int readInductivSensor1(void) {
10001500:	b580      	push	{r7, lr}
10001502:	af00      	add	r7, sp, #0
	return bit_read(inductivSensor1Port, inductivSensor1Pin);
10001504:	2000      	movs	r0, #0
10001506:	210a      	movs	r1, #10
10001508:	f000 ffc6 	bl	10002498 <bit_read>
1000150c:	1c03      	adds	r3, r0, #0
}
1000150e:	1c18      	adds	r0, r3, #0
10001510:	46bd      	mov	sp, r7
10001512:	bd80      	pop	{r7, pc}

10001514 <readInductivSensor2>:

int readInductivSensor2(void) {
10001514:	b580      	push	{r7, lr}
10001516:	af00      	add	r7, sp, #0
	return bit_read(inductivSensor2Port, inductivSensor2Pin);
10001518:	2000      	movs	r0, #0
1000151a:	210b      	movs	r1, #11
1000151c:	f000 ffbc 	bl	10002498 <bit_read>
10001520:	1c03      	adds	r3, r0, #0
}
10001522:	1c18      	adds	r0, r3, #0
10001524:	46bd      	mov	sp, r7
10001526:	bd80      	pop	{r7, pc}

10001528 <slider>:

void slider(int velocity, int direction) {
10001528:	b580      	push	{r7, lr}
1000152a:	b082      	sub	sp, #8
1000152c:	af00      	add	r7, sp, #0
1000152e:	6078      	str	r0, [r7, #4]
10001530:	6039      	str	r1, [r7, #0]
	direction ?
			bit_write(dir1port, dir1pin, SLIDERBACKWARD) :
10001532:	683b      	ldr	r3, [r7, #0]
10001534:	2b00      	cmp	r3, #0
10001536:	d005      	beq.n	10001544 <slider+0x1c>
10001538:	2000      	movs	r0, #0
1000153a:	2107      	movs	r1, #7
1000153c:	2201      	movs	r2, #1
1000153e:	f000 ffcd 	bl	100024dc <bit_write>
10001542:	e004      	b.n	1000154e <slider+0x26>
			bit_write(dir1port, dir1pin, SLIDERFORWARD);
10001544:	2000      	movs	r0, #0
10001546:	2107      	movs	r1, #7
10001548:	2200      	movs	r2, #0
1000154a:	f000 ffc7 	bl	100024dc <bit_write>
	// inverse velocity by 50000
	pwm1_duty_cycle(50000 - velocity);
1000154e:	687b      	ldr	r3, [r7, #4]
10001550:	b29b      	uxth	r3, r3
10001552:	4a04      	ldr	r2, [pc, #16]	; (10001564 <slider+0x3c>)
10001554:	1ad3      	subs	r3, r2, r3
10001556:	b29b      	uxth	r3, r3
10001558:	1c18      	adds	r0, r3, #0
1000155a:	f001 f8e7 	bl	1000272c <pwm1_duty_cycle>
}
1000155e:	46bd      	mov	sp, r7
10001560:	b002      	add	sp, #8
10001562:	bd80      	pop	{r7, pc}
10001564:	ffffc350 	.word	0xffffc350

10001568 <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
10001568:	b580      	push	{r7, lr}
1000156a:	b082      	sub	sp, #8
1000156c:	af00      	add	r7, sp, #0
1000156e:	1c02      	adds	r2, r0, #0
10001570:	1dfb      	adds	r3, r7, #7
10001572:	701a      	strb	r2, [r3, #0]
  if ((int32_t)(IRQn) >= 0)
10001574:	1dfb      	adds	r3, r7, #7
10001576:	781b      	ldrb	r3, [r3, #0]
10001578:	2b7f      	cmp	r3, #127	; 0x7f
1000157a:	d809      	bhi.n	10001590 <__NVIC_EnableIRQ+0x28>
  {
    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
1000157c:	4b06      	ldr	r3, [pc, #24]	; (10001598 <__NVIC_EnableIRQ+0x30>)
1000157e:	1dfa      	adds	r2, r7, #7
10001580:	7812      	ldrb	r2, [r2, #0]
10001582:	1c11      	adds	r1, r2, #0
10001584:	221f      	movs	r2, #31
10001586:	400a      	ands	r2, r1
10001588:	2101      	movs	r1, #1
1000158a:	4091      	lsls	r1, r2
1000158c:	1c0a      	adds	r2, r1, #0
1000158e:	601a      	str	r2, [r3, #0]
  }
}
10001590:	46bd      	mov	sp, r7
10001592:	b002      	add	sp, #8
10001594:	bd80      	pop	{r7, pc}
10001596:	46c0      	nop			; (mov r8, r8)
10001598:	e000e100 	.word	0xe000e100

1000159c <bit_init>:
// --------------------------------------------------------------
// Einzelnes Bit f√ºr Ein- oder Ausgabe initialisieren
// port: P0,P1,P2 bitnr: 0..15 direction: INP 0, OUTP 1
//---------------------------------------------------------------
void bit_init(uint8_t port, uint8_t bitnr, uint8_t direction)
{
1000159c:	b590      	push	{r4, r7, lr}
1000159e:	b083      	sub	sp, #12
100015a0:	af00      	add	r7, sp, #0
100015a2:	1c04      	adds	r4, r0, #0
100015a4:	1c08      	adds	r0, r1, #0
100015a6:	1c11      	adds	r1, r2, #0
100015a8:	1dfb      	adds	r3, r7, #7
100015aa:	1c22      	adds	r2, r4, #0
100015ac:	701a      	strb	r2, [r3, #0]
100015ae:	1dbb      	adds	r3, r7, #6
100015b0:	1c02      	adds	r2, r0, #0
100015b2:	701a      	strb	r2, [r3, #0]
100015b4:	1d7b      	adds	r3, r7, #5
100015b6:	1c0a      	adds	r2, r1, #0
100015b8:	701a      	strb	r2, [r3, #0]
	switch (port)
100015ba:	1dfb      	adds	r3, r7, #7
100015bc:	781b      	ldrb	r3, [r3, #0]
100015be:	2b01      	cmp	r3, #1
100015c0:	d100      	bne.n	100015c4 <bit_init+0x28>
100015c2:	e0a1      	b.n	10001708 <bit_init+0x16c>
100015c4:	2b02      	cmp	r3, #2
100015c6:	d100      	bne.n	100015ca <bit_init+0x2e>
100015c8:	e0ea      	b.n	100017a0 <bit_init+0x204>
100015ca:	2b00      	cmp	r3, #0
100015cc:	d000      	beq.n	100015d0 <bit_init+0x34>
100015ce:	e19b      	b.n	10001908 <bit_init+0x36c>
	{
		case 0 :
			{if (bitnr < 4 )
100015d0:	1dbb      	adds	r3, r7, #6
100015d2:	781b      	ldrb	r3, [r3, #0]
100015d4:	2b03      	cmp	r3, #3
100015d6:	d81d      	bhi.n	10001614 <bit_init+0x78>
				{ if (direction == 1) PORT0->IOCR0 |=1UL << ((bitnr * 8)+7);
100015d8:	1d7b      	adds	r3, r7, #5
100015da:	781b      	ldrb	r3, [r3, #0]
100015dc:	2b01      	cmp	r3, #1
100015de:	d10c      	bne.n	100015fa <bit_init+0x5e>
100015e0:	4bcb      	ldr	r3, [pc, #812]	; (10001910 <bit_init+0x374>)
100015e2:	4acb      	ldr	r2, [pc, #812]	; (10001910 <bit_init+0x374>)
100015e4:	6911      	ldr	r1, [r2, #16]
100015e6:	1dba      	adds	r2, r7, #6
100015e8:	7812      	ldrb	r2, [r2, #0]
100015ea:	00d2      	lsls	r2, r2, #3
100015ec:	3207      	adds	r2, #7
100015ee:	2001      	movs	r0, #1
100015f0:	4090      	lsls	r0, r2
100015f2:	1c02      	adds	r2, r0, #0
100015f4:	430a      	orrs	r2, r1
100015f6:	611a      	str	r2, [r3, #16]
100015f8:	e00c      	b.n	10001614 <bit_init+0x78>
				  else PORT0->IOCR0 &= ~(1UL << ((bitnr * 8 ) + 7 ));
100015fa:	4bc5      	ldr	r3, [pc, #788]	; (10001910 <bit_init+0x374>)
100015fc:	4ac4      	ldr	r2, [pc, #784]	; (10001910 <bit_init+0x374>)
100015fe:	6912      	ldr	r2, [r2, #16]
10001600:	1db9      	adds	r1, r7, #6
10001602:	7809      	ldrb	r1, [r1, #0]
10001604:	00c9      	lsls	r1, r1, #3
10001606:	3107      	adds	r1, #7
10001608:	2001      	movs	r0, #1
1000160a:	4088      	lsls	r0, r1
1000160c:	1c01      	adds	r1, r0, #0
1000160e:	43c9      	mvns	r1, r1
10001610:	400a      	ands	r2, r1
10001612:	611a      	str	r2, [r3, #16]
				}
			 if ( (bitnr <8) && (bitnr > 3))
10001614:	1dbb      	adds	r3, r7, #6
10001616:	781b      	ldrb	r3, [r3, #0]
10001618:	2b07      	cmp	r3, #7
1000161a:	d823      	bhi.n	10001664 <bit_init+0xc8>
1000161c:	1dbb      	adds	r3, r7, #6
1000161e:	781b      	ldrb	r3, [r3, #0]
10001620:	2b03      	cmp	r3, #3
10001622:	d91f      	bls.n	10001664 <bit_init+0xc8>
					 { if (direction == 1) PORT0->IOCR4 |= 1UL<< (((bitnr-4) * 8)+7);
10001624:	1d7b      	adds	r3, r7, #5
10001626:	781b      	ldrb	r3, [r3, #0]
10001628:	2b01      	cmp	r3, #1
1000162a:	d10d      	bne.n	10001648 <bit_init+0xac>
1000162c:	4bb8      	ldr	r3, [pc, #736]	; (10001910 <bit_init+0x374>)
1000162e:	4ab8      	ldr	r2, [pc, #736]	; (10001910 <bit_init+0x374>)
10001630:	6951      	ldr	r1, [r2, #20]
10001632:	1dba      	adds	r2, r7, #6
10001634:	7812      	ldrb	r2, [r2, #0]
10001636:	3a04      	subs	r2, #4
10001638:	00d2      	lsls	r2, r2, #3
1000163a:	3207      	adds	r2, #7
1000163c:	2001      	movs	r0, #1
1000163e:	4090      	lsls	r0, r2
10001640:	1c02      	adds	r2, r0, #0
10001642:	430a      	orrs	r2, r1
10001644:	615a      	str	r2, [r3, #20]
10001646:	e00d      	b.n	10001664 <bit_init+0xc8>
					   else PORT0->IOCR4 &= ~(1UL << (((bitnr-4) * 8)+7) );
10001648:	4bb1      	ldr	r3, [pc, #708]	; (10001910 <bit_init+0x374>)
1000164a:	4ab1      	ldr	r2, [pc, #708]	; (10001910 <bit_init+0x374>)
1000164c:	6952      	ldr	r2, [r2, #20]
1000164e:	1db9      	adds	r1, r7, #6
10001650:	7809      	ldrb	r1, [r1, #0]
10001652:	3904      	subs	r1, #4
10001654:	00c9      	lsls	r1, r1, #3
10001656:	3107      	adds	r1, #7
10001658:	2001      	movs	r0, #1
1000165a:	4088      	lsls	r0, r1
1000165c:	1c01      	adds	r1, r0, #0
1000165e:	43c9      	mvns	r1, r1
10001660:	400a      	ands	r2, r1
10001662:	615a      	str	r2, [r3, #20]
					 }
			 if ( (bitnr <12) && (bitnr > 7))
10001664:	1dbb      	adds	r3, r7, #6
10001666:	781b      	ldrb	r3, [r3, #0]
10001668:	2b0b      	cmp	r3, #11
1000166a:	d823      	bhi.n	100016b4 <bit_init+0x118>
1000166c:	1dbb      	adds	r3, r7, #6
1000166e:	781b      	ldrb	r3, [r3, #0]
10001670:	2b07      	cmp	r3, #7
10001672:	d91f      	bls.n	100016b4 <bit_init+0x118>
			 		 { if (direction == 1) PORT0->IOCR8 |= 1UL << (((bitnr-8) * 8)+7);
10001674:	1d7b      	adds	r3, r7, #5
10001676:	781b      	ldrb	r3, [r3, #0]
10001678:	2b01      	cmp	r3, #1
1000167a:	d10d      	bne.n	10001698 <bit_init+0xfc>
1000167c:	4ba4      	ldr	r3, [pc, #656]	; (10001910 <bit_init+0x374>)
1000167e:	4aa4      	ldr	r2, [pc, #656]	; (10001910 <bit_init+0x374>)
10001680:	6991      	ldr	r1, [r2, #24]
10001682:	1dba      	adds	r2, r7, #6
10001684:	7812      	ldrb	r2, [r2, #0]
10001686:	3a08      	subs	r2, #8
10001688:	00d2      	lsls	r2, r2, #3
1000168a:	3207      	adds	r2, #7
1000168c:	2001      	movs	r0, #1
1000168e:	4090      	lsls	r0, r2
10001690:	1c02      	adds	r2, r0, #0
10001692:	430a      	orrs	r2, r1
10001694:	619a      	str	r2, [r3, #24]
10001696:	e00d      	b.n	100016b4 <bit_init+0x118>
			 		   else PORT0->IOCR8 &= ~(1UL << (((bitnr-8) * 8)+7) );
10001698:	4b9d      	ldr	r3, [pc, #628]	; (10001910 <bit_init+0x374>)
1000169a:	4a9d      	ldr	r2, [pc, #628]	; (10001910 <bit_init+0x374>)
1000169c:	6992      	ldr	r2, [r2, #24]
1000169e:	1db9      	adds	r1, r7, #6
100016a0:	7809      	ldrb	r1, [r1, #0]
100016a2:	3908      	subs	r1, #8
100016a4:	00c9      	lsls	r1, r1, #3
100016a6:	3107      	adds	r1, #7
100016a8:	2001      	movs	r0, #1
100016aa:	4088      	lsls	r0, r1
100016ac:	1c01      	adds	r1, r0, #0
100016ae:	43c9      	mvns	r1, r1
100016b0:	400a      	ands	r2, r1
100016b2:	619a      	str	r2, [r3, #24]
			 		 }
			 if ( (bitnr <16) && (bitnr > 11))
100016b4:	1dbb      	adds	r3, r7, #6
100016b6:	781b      	ldrb	r3, [r3, #0]
100016b8:	2b0f      	cmp	r3, #15
100016ba:	d824      	bhi.n	10001706 <bit_init+0x16a>
100016bc:	1dbb      	adds	r3, r7, #6
100016be:	781b      	ldrb	r3, [r3, #0]
100016c0:	2b0b      	cmp	r3, #11
100016c2:	d920      	bls.n	10001706 <bit_init+0x16a>
			 		{ if (direction == 1) PORT0->IOCR12 |= 1UL << (((bitnr-12) * 8)+7);
100016c4:	1d7b      	adds	r3, r7, #5
100016c6:	781b      	ldrb	r3, [r3, #0]
100016c8:	2b01      	cmp	r3, #1
100016ca:	d10d      	bne.n	100016e8 <bit_init+0x14c>
100016cc:	4b90      	ldr	r3, [pc, #576]	; (10001910 <bit_init+0x374>)
100016ce:	4a90      	ldr	r2, [pc, #576]	; (10001910 <bit_init+0x374>)
100016d0:	69d1      	ldr	r1, [r2, #28]
100016d2:	1dba      	adds	r2, r7, #6
100016d4:	7812      	ldrb	r2, [r2, #0]
100016d6:	3a0c      	subs	r2, #12
100016d8:	00d2      	lsls	r2, r2, #3
100016da:	3207      	adds	r2, #7
100016dc:	2001      	movs	r0, #1
100016de:	4090      	lsls	r0, r2
100016e0:	1c02      	adds	r2, r0, #0
100016e2:	430a      	orrs	r2, r1
100016e4:	61da      	str	r2, [r3, #28]
100016e6:	e00e      	b.n	10001706 <bit_init+0x16a>
			 		  else PORT0->IOCR12 &= ~(1UL << (((bitnr-12) * 8)+7) );
100016e8:	4b89      	ldr	r3, [pc, #548]	; (10001910 <bit_init+0x374>)
100016ea:	4a89      	ldr	r2, [pc, #548]	; (10001910 <bit_init+0x374>)
100016ec:	69d2      	ldr	r2, [r2, #28]
100016ee:	1db9      	adds	r1, r7, #6
100016f0:	7809      	ldrb	r1, [r1, #0]
100016f2:	390c      	subs	r1, #12
100016f4:	00c9      	lsls	r1, r1, #3
100016f6:	3107      	adds	r1, #7
100016f8:	2001      	movs	r0, #1
100016fa:	4088      	lsls	r0, r1
100016fc:	1c01      	adds	r1, r0, #0
100016fe:	43c9      	mvns	r1, r1
10001700:	400a      	ands	r2, r1
10001702:	61da      	str	r2, [r3, #28]
			 		}
			}
			break;
10001704:	e100      	b.n	10001908 <bit_init+0x36c>
10001706:	e0ff      	b.n	10001908 <bit_init+0x36c>
	  case 1 :
			{
				{if (bitnr < 4 )
10001708:	1dbb      	adds	r3, r7, #6
1000170a:	781b      	ldrb	r3, [r3, #0]
1000170c:	2b03      	cmp	r3, #3
1000170e:	d81d      	bhi.n	1000174c <bit_init+0x1b0>
					{ if (direction == 1) PORT1->IOCR0 |=1UL << ((bitnr * 8)+7);
10001710:	1d7b      	adds	r3, r7, #5
10001712:	781b      	ldrb	r3, [r3, #0]
10001714:	2b01      	cmp	r3, #1
10001716:	d10c      	bne.n	10001732 <bit_init+0x196>
10001718:	4b7e      	ldr	r3, [pc, #504]	; (10001914 <bit_init+0x378>)
1000171a:	4a7e      	ldr	r2, [pc, #504]	; (10001914 <bit_init+0x378>)
1000171c:	6911      	ldr	r1, [r2, #16]
1000171e:	1dba      	adds	r2, r7, #6
10001720:	7812      	ldrb	r2, [r2, #0]
10001722:	00d2      	lsls	r2, r2, #3
10001724:	3207      	adds	r2, #7
10001726:	2001      	movs	r0, #1
10001728:	4090      	lsls	r0, r2
1000172a:	1c02      	adds	r2, r0, #0
1000172c:	430a      	orrs	r2, r1
1000172e:	611a      	str	r2, [r3, #16]
10001730:	e00c      	b.n	1000174c <bit_init+0x1b0>
						else PORT1->IOCR0 &= ~(1UL << ((bitnr * 8 ) + 7 ));
10001732:	4b78      	ldr	r3, [pc, #480]	; (10001914 <bit_init+0x378>)
10001734:	4a77      	ldr	r2, [pc, #476]	; (10001914 <bit_init+0x378>)
10001736:	6912      	ldr	r2, [r2, #16]
10001738:	1db9      	adds	r1, r7, #6
1000173a:	7809      	ldrb	r1, [r1, #0]
1000173c:	00c9      	lsls	r1, r1, #3
1000173e:	3107      	adds	r1, #7
10001740:	2001      	movs	r0, #1
10001742:	4088      	lsls	r0, r1
10001744:	1c01      	adds	r1, r0, #0
10001746:	43c9      	mvns	r1, r1
10001748:	400a      	ands	r2, r1
1000174a:	611a      	str	r2, [r3, #16]
					}
			if ((bitnr < 8) && (bitnr > 3)) {
1000174c:	1dbb      	adds	r3, r7, #6
1000174e:	781b      	ldrb	r3, [r3, #0]
10001750:	2b07      	cmp	r3, #7
10001752:	d824      	bhi.n	1000179e <bit_init+0x202>
10001754:	1dbb      	adds	r3, r7, #6
10001756:	781b      	ldrb	r3, [r3, #0]
10001758:	2b03      	cmp	r3, #3
1000175a:	d920      	bls.n	1000179e <bit_init+0x202>
				if (direction == 1) PORT1->IOCR4 |= 1UL << (((bitnr - 4) * 8) + 7);
1000175c:	1d7b      	adds	r3, r7, #5
1000175e:	781b      	ldrb	r3, [r3, #0]
10001760:	2b01      	cmp	r3, #1
10001762:	d10d      	bne.n	10001780 <bit_init+0x1e4>
10001764:	4b6b      	ldr	r3, [pc, #428]	; (10001914 <bit_init+0x378>)
10001766:	4a6b      	ldr	r2, [pc, #428]	; (10001914 <bit_init+0x378>)
10001768:	6951      	ldr	r1, [r2, #20]
1000176a:	1dba      	adds	r2, r7, #6
1000176c:	7812      	ldrb	r2, [r2, #0]
1000176e:	3a04      	subs	r2, #4
10001770:	00d2      	lsls	r2, r2, #3
10001772:	3207      	adds	r2, #7
10001774:	2001      	movs	r0, #1
10001776:	4090      	lsls	r0, r2
10001778:	1c02      	adds	r2, r0, #0
1000177a:	430a      	orrs	r2, r1
1000177c:	615a      	str	r2, [r3, #20]
1000177e:	e00e      	b.n	1000179e <bit_init+0x202>
				else
					PORT1->IOCR4 &= ~(1UL << (((bitnr - 4) * 8) + 7));
10001780:	4b64      	ldr	r3, [pc, #400]	; (10001914 <bit_init+0x378>)
10001782:	4a64      	ldr	r2, [pc, #400]	; (10001914 <bit_init+0x378>)
10001784:	6952      	ldr	r2, [r2, #20]
10001786:	1db9      	adds	r1, r7, #6
10001788:	7809      	ldrb	r1, [r1, #0]
1000178a:	3904      	subs	r1, #4
1000178c:	00c9      	lsls	r1, r1, #3
1000178e:	3107      	adds	r1, #7
10001790:	2001      	movs	r0, #1
10001792:	4088      	lsls	r0, r1
10001794:	1c01      	adds	r1, r0, #0
10001796:	43c9      	mvns	r1, r1
10001798:	400a      	ands	r2, r1
1000179a:	615a      	str	r2, [r3, #20]
			}

				}
			}
			break;
1000179c:	e0b4      	b.n	10001908 <bit_init+0x36c>
1000179e:	e0b3      	b.n	10001908 <bit_init+0x36c>

	  case 2 : //Achtung!! Nur Pins P2.0, P2.1, P2.10 und P2.11 sind als Out Pin einstellbar
	  	{
	  		if (bitnr < 2 ) {
100017a0:	1dbb      	adds	r3, r7, #6
100017a2:	781b      	ldrb	r3, [r3, #0]
100017a4:	2b01      	cmp	r3, #1
100017a6:	d828      	bhi.n	100017fa <bit_init+0x25e>
	  			CLR_BIT(PORT2->PDISC,bitnr); // digital Pad aktiv
100017a8:	4b5b      	ldr	r3, [pc, #364]	; (10001918 <bit_init+0x37c>)
100017aa:	4a5b      	ldr	r2, [pc, #364]	; (10001918 <bit_init+0x37c>)
100017ac:	6e12      	ldr	r2, [r2, #96]	; 0x60
100017ae:	1db9      	adds	r1, r7, #6
100017b0:	7809      	ldrb	r1, [r1, #0]
100017b2:	2001      	movs	r0, #1
100017b4:	4088      	lsls	r0, r1
100017b6:	1c01      	adds	r1, r0, #0
100017b8:	43c9      	mvns	r1, r1
100017ba:	400a      	ands	r2, r1
100017bc:	661a      	str	r2, [r3, #96]	; 0x60
	  			if (direction == 1) PORT2->IOCR0 |=1UL << ((bitnr * 8)+7);
100017be:	1d7b      	adds	r3, r7, #5
100017c0:	781b      	ldrb	r3, [r3, #0]
100017c2:	2b01      	cmp	r3, #1
100017c4:	d10c      	bne.n	100017e0 <bit_init+0x244>
100017c6:	4b54      	ldr	r3, [pc, #336]	; (10001918 <bit_init+0x37c>)
100017c8:	4a53      	ldr	r2, [pc, #332]	; (10001918 <bit_init+0x37c>)
100017ca:	6911      	ldr	r1, [r2, #16]
100017cc:	1dba      	adds	r2, r7, #6
100017ce:	7812      	ldrb	r2, [r2, #0]
100017d0:	00d2      	lsls	r2, r2, #3
100017d2:	3207      	adds	r2, #7
100017d4:	2001      	movs	r0, #1
100017d6:	4090      	lsls	r0, r2
100017d8:	1c02      	adds	r2, r0, #0
100017da:	430a      	orrs	r2, r1
100017dc:	611a      	str	r2, [r3, #16]
100017de:	e00c      	b.n	100017fa <bit_init+0x25e>
					else PORT2->IOCR0 &= ~(1UL << ((bitnr * 8 ) + 7 ));
100017e0:	4b4d      	ldr	r3, [pc, #308]	; (10001918 <bit_init+0x37c>)
100017e2:	4a4d      	ldr	r2, [pc, #308]	; (10001918 <bit_init+0x37c>)
100017e4:	6912      	ldr	r2, [r2, #16]
100017e6:	1db9      	adds	r1, r7, #6
100017e8:	7809      	ldrb	r1, [r1, #0]
100017ea:	00c9      	lsls	r1, r1, #3
100017ec:	3107      	adds	r1, #7
100017ee:	2001      	movs	r0, #1
100017f0:	4088      	lsls	r0, r1
100017f2:	1c01      	adds	r1, r0, #0
100017f4:	43c9      	mvns	r1, r1
100017f6:	400a      	ands	r2, r1
100017f8:	611a      	str	r2, [r3, #16]
	  		}
				if ((bitnr > 1)&&(bitnr<4)) {
100017fa:	1dbb      	adds	r3, r7, #6
100017fc:	781b      	ldrb	r3, [r3, #0]
100017fe:	2b01      	cmp	r3, #1
10001800:	d91b      	bls.n	1000183a <bit_init+0x29e>
10001802:	1dbb      	adds	r3, r7, #6
10001804:	781b      	ldrb	r3, [r3, #0]
10001806:	2b03      	cmp	r3, #3
10001808:	d817      	bhi.n	1000183a <bit_init+0x29e>
					CLR_BIT(PORT2->PDISC,bitnr); // digital Pad aktiv
1000180a:	4b43      	ldr	r3, [pc, #268]	; (10001918 <bit_init+0x37c>)
1000180c:	4a42      	ldr	r2, [pc, #264]	; (10001918 <bit_init+0x37c>)
1000180e:	6e12      	ldr	r2, [r2, #96]	; 0x60
10001810:	1db9      	adds	r1, r7, #6
10001812:	7809      	ldrb	r1, [r1, #0]
10001814:	2001      	movs	r0, #1
10001816:	4088      	lsls	r0, r1
10001818:	1c01      	adds	r1, r0, #0
1000181a:	43c9      	mvns	r1, r1
1000181c:	400a      	ands	r2, r1
1000181e:	661a      	str	r2, [r3, #96]	; 0x60
					PORT2->IOCR0 &= ~(1UL << ((bitnr * 8) + 7));
10001820:	4b3d      	ldr	r3, [pc, #244]	; (10001918 <bit_init+0x37c>)
10001822:	4a3d      	ldr	r2, [pc, #244]	; (10001918 <bit_init+0x37c>)
10001824:	6912      	ldr	r2, [r2, #16]
10001826:	1db9      	adds	r1, r7, #6
10001828:	7809      	ldrb	r1, [r1, #0]
1000182a:	00c9      	lsls	r1, r1, #3
1000182c:	3107      	adds	r1, #7
1000182e:	2001      	movs	r0, #1
10001830:	4088      	lsls	r0, r1
10001832:	1c01      	adds	r1, r0, #0
10001834:	43c9      	mvns	r1, r1
10001836:	400a      	ands	r2, r1
10001838:	611a      	str	r2, [r3, #16]
				}
	  		if ((bitnr < 8) && (bitnr > 3)) {
1000183a:	1dbb      	adds	r3, r7, #6
1000183c:	781b      	ldrb	r3, [r3, #0]
1000183e:	2b07      	cmp	r3, #7
10001840:	d81c      	bhi.n	1000187c <bit_init+0x2e0>
10001842:	1dbb      	adds	r3, r7, #6
10001844:	781b      	ldrb	r3, [r3, #0]
10001846:	2b03      	cmp	r3, #3
10001848:	d918      	bls.n	1000187c <bit_init+0x2e0>
	  			    CLR_BIT(PORT2->PDISC,bitnr); // digital Pad aktiv
1000184a:	4b33      	ldr	r3, [pc, #204]	; (10001918 <bit_init+0x37c>)
1000184c:	4a32      	ldr	r2, [pc, #200]	; (10001918 <bit_init+0x37c>)
1000184e:	6e12      	ldr	r2, [r2, #96]	; 0x60
10001850:	1db9      	adds	r1, r7, #6
10001852:	7809      	ldrb	r1, [r1, #0]
10001854:	2001      	movs	r0, #1
10001856:	4088      	lsls	r0, r1
10001858:	1c01      	adds	r1, r0, #0
1000185a:	43c9      	mvns	r1, r1
1000185c:	400a      	ands	r2, r1
1000185e:	661a      	str	r2, [r3, #96]	; 0x60
					PORT2->IOCR4 &= ~(1UL << (((bitnr-4) * 8 ) + 7 ));
10001860:	4b2d      	ldr	r3, [pc, #180]	; (10001918 <bit_init+0x37c>)
10001862:	4a2d      	ldr	r2, [pc, #180]	; (10001918 <bit_init+0x37c>)
10001864:	6952      	ldr	r2, [r2, #20]
10001866:	1db9      	adds	r1, r7, #6
10001868:	7809      	ldrb	r1, [r1, #0]
1000186a:	3904      	subs	r1, #4
1000186c:	00c9      	lsls	r1, r1, #3
1000186e:	3107      	adds	r1, #7
10001870:	2001      	movs	r0, #1
10001872:	4088      	lsls	r0, r1
10001874:	1c01      	adds	r1, r0, #0
10001876:	43c9      	mvns	r1, r1
10001878:	400a      	ands	r2, r1
1000187a:	615a      	str	r2, [r3, #20]
				}
	  		if ((bitnr < 10) && (bitnr > 7)) {
1000187c:	1dbb      	adds	r3, r7, #6
1000187e:	781b      	ldrb	r3, [r3, #0]
10001880:	2b09      	cmp	r3, #9
10001882:	d811      	bhi.n	100018a8 <bit_init+0x30c>
10001884:	1dbb      	adds	r3, r7, #6
10001886:	781b      	ldrb	r3, [r3, #0]
10001888:	2b07      	cmp	r3, #7
1000188a:	d90d      	bls.n	100018a8 <bit_init+0x30c>
	  			PORT2->IOCR8 &= ~(1UL << (((bitnr-8) * 8 ) + 7 ));
1000188c:	4b22      	ldr	r3, [pc, #136]	; (10001918 <bit_init+0x37c>)
1000188e:	4a22      	ldr	r2, [pc, #136]	; (10001918 <bit_init+0x37c>)
10001890:	6992      	ldr	r2, [r2, #24]
10001892:	1db9      	adds	r1, r7, #6
10001894:	7809      	ldrb	r1, [r1, #0]
10001896:	3908      	subs	r1, #8
10001898:	00c9      	lsls	r1, r1, #3
1000189a:	3107      	adds	r1, #7
1000189c:	2001      	movs	r0, #1
1000189e:	4088      	lsls	r0, r1
100018a0:	1c01      	adds	r1, r0, #0
100018a2:	43c9      	mvns	r1, r1
100018a4:	400a      	ands	r2, r1
100018a6:	619a      	str	r2, [r3, #24]
	  		}
	  		if (bitnr > 9 ) {
100018a8:	1dbb      	adds	r3, r7, #6
100018aa:	781b      	ldrb	r3, [r3, #0]
100018ac:	2b09      	cmp	r3, #9
100018ae:	d92a      	bls.n	10001906 <bit_init+0x36a>
	  			CLR_BIT(PORT2->PDISC,bitnr); // digital Pad aktiv
100018b0:	4b19      	ldr	r3, [pc, #100]	; (10001918 <bit_init+0x37c>)
100018b2:	4a19      	ldr	r2, [pc, #100]	; (10001918 <bit_init+0x37c>)
100018b4:	6e12      	ldr	r2, [r2, #96]	; 0x60
100018b6:	1db9      	adds	r1, r7, #6
100018b8:	7809      	ldrb	r1, [r1, #0]
100018ba:	2001      	movs	r0, #1
100018bc:	4088      	lsls	r0, r1
100018be:	1c01      	adds	r1, r0, #0
100018c0:	43c9      	mvns	r1, r1
100018c2:	400a      	ands	r2, r1
100018c4:	661a      	str	r2, [r3, #96]	; 0x60
	  			if (direction == 1) PORT2->IOCR8 |=1UL << (((bitnr-8) * 8)+7);
100018c6:	1d7b      	adds	r3, r7, #5
100018c8:	781b      	ldrb	r3, [r3, #0]
100018ca:	2b01      	cmp	r3, #1
100018cc:	d10d      	bne.n	100018ea <bit_init+0x34e>
100018ce:	4b12      	ldr	r3, [pc, #72]	; (10001918 <bit_init+0x37c>)
100018d0:	4a11      	ldr	r2, [pc, #68]	; (10001918 <bit_init+0x37c>)
100018d2:	6991      	ldr	r1, [r2, #24]
100018d4:	1dba      	adds	r2, r7, #6
100018d6:	7812      	ldrb	r2, [r2, #0]
100018d8:	3a08      	subs	r2, #8
100018da:	00d2      	lsls	r2, r2, #3
100018dc:	3207      	adds	r2, #7
100018de:	2001      	movs	r0, #1
100018e0:	4090      	lsls	r0, r2
100018e2:	1c02      	adds	r2, r0, #0
100018e4:	430a      	orrs	r2, r1
100018e6:	619a      	str	r2, [r3, #24]
100018e8:	e00d      	b.n	10001906 <bit_init+0x36a>
	  			else PORT2->IOCR8 &= ~(1UL << (((bitnr-8) * 8 ) + 7 ));
100018ea:	4b0b      	ldr	r3, [pc, #44]	; (10001918 <bit_init+0x37c>)
100018ec:	4a0a      	ldr	r2, [pc, #40]	; (10001918 <bit_init+0x37c>)
100018ee:	6992      	ldr	r2, [r2, #24]
100018f0:	1db9      	adds	r1, r7, #6
100018f2:	7809      	ldrb	r1, [r1, #0]
100018f4:	3908      	subs	r1, #8
100018f6:	00c9      	lsls	r1, r1, #3
100018f8:	3107      	adds	r1, #7
100018fa:	2001      	movs	r0, #1
100018fc:	4088      	lsls	r0, r1
100018fe:	1c01      	adds	r1, r0, #0
10001900:	43c9      	mvns	r1, r1
10001902:	400a      	ands	r2, r1
10001904:	619a      	str	r2, [r3, #24]
	  		}
  			break;
10001906:	46c0      	nop			; (mov r8, r8)
	  	}
	  }
}
10001908:	46bd      	mov	sp, r7
1000190a:	b003      	add	sp, #12
1000190c:	bd90      	pop	{r4, r7, pc}
1000190e:	46c0      	nop			; (mov r8, r8)
10001910:	40040000 	.word	0x40040000
10001914:	40040100 	.word	0x40040100
10001918:	40040200 	.word	0x40040200

1000191c <bit_init_mode>:
* Einzelnes Bit f√ºr Ein- oder Ausgabe initialisieren
* port: P0,P1,P2 bitnr: 0..15 direction: INP 0, OUTP 1
* mode: NO_PULL PULLUP PULLDOWN
*/
void bit_init_mode (uint8_t port, uint8_t bitnr, uint8_t direction, uint8_t mode)
{
1000191c:	b5b0      	push	{r4, r5, r7, lr}
1000191e:	b082      	sub	sp, #8
10001920:	af00      	add	r7, sp, #0
10001922:	1c05      	adds	r5, r0, #0
10001924:	1c0c      	adds	r4, r1, #0
10001926:	1c10      	adds	r0, r2, #0
10001928:	1c19      	adds	r1, r3, #0
1000192a:	1dfb      	adds	r3, r7, #7
1000192c:	1c2a      	adds	r2, r5, #0
1000192e:	701a      	strb	r2, [r3, #0]
10001930:	1dbb      	adds	r3, r7, #6
10001932:	1c22      	adds	r2, r4, #0
10001934:	701a      	strb	r2, [r3, #0]
10001936:	1d7b      	adds	r3, r7, #5
10001938:	1c02      	adds	r2, r0, #0
1000193a:	701a      	strb	r2, [r3, #0]
1000193c:	1d3b      	adds	r3, r7, #4
1000193e:	1c0a      	adds	r2, r1, #0
10001940:	701a      	strb	r2, [r3, #0]
	switch (port)
10001942:	1dfb      	adds	r3, r7, #7
10001944:	781b      	ldrb	r3, [r3, #0]
10001946:	2b01      	cmp	r3, #1
10001948:	d100      	bne.n	1000194c <bit_init_mode+0x30>
1000194a:	e1cf      	b.n	10001cec <bit_init_mode+0x3d0>
1000194c:	2b02      	cmp	r3, #2
1000194e:	d100      	bne.n	10001952 <bit_init_mode+0x36>
10001950:	e2ab      	b.n	10001eaa <bit_init_mode+0x58e>
10001952:	2b00      	cmp	r3, #0
10001954:	d001      	beq.n	1000195a <bit_init_mode+0x3e>
10001956:	f000 fd98 	bl	1000248a <bit_init_mode+0xb6e>
	{
		case 0 :
		{
			if (bitnr < 4 ) {
1000195a:	1dbb      	adds	r3, r7, #6
1000195c:	781b      	ldrb	r3, [r3, #0]
1000195e:	2b03      	cmp	r3, #3
10001960:	d865      	bhi.n	10001a2e <bit_init_mode+0x112>
				if (direction == 1) {
10001962:	1d7b      	adds	r3, r7, #5
10001964:	781b      	ldrb	r3, [r3, #0]
10001966:	2b01      	cmp	r3, #1
10001968:	d119      	bne.n	1000199e <bit_init_mode+0x82>
					PORT0->IOCR0 |=1UL << ((bitnr * 8)+7);
1000196a:	4bdf      	ldr	r3, [pc, #892]	; (10001ce8 <bit_init_mode+0x3cc>)
1000196c:	4ade      	ldr	r2, [pc, #888]	; (10001ce8 <bit_init_mode+0x3cc>)
1000196e:	6911      	ldr	r1, [r2, #16]
10001970:	1dba      	adds	r2, r7, #6
10001972:	7812      	ldrb	r2, [r2, #0]
10001974:	00d2      	lsls	r2, r2, #3
10001976:	3207      	adds	r2, #7
10001978:	2001      	movs	r0, #1
1000197a:	4090      	lsls	r0, r2
1000197c:	1c02      	adds	r2, r0, #0
1000197e:	430a      	orrs	r2, r1
10001980:	611a      	str	r2, [r3, #16]
					PORT0->IOCR0 &= ~(0x0000000F << ((bitnr * 8)+3));
10001982:	4bd9      	ldr	r3, [pc, #868]	; (10001ce8 <bit_init_mode+0x3cc>)
10001984:	4ad8      	ldr	r2, [pc, #864]	; (10001ce8 <bit_init_mode+0x3cc>)
10001986:	6912      	ldr	r2, [r2, #16]
10001988:	1db9      	adds	r1, r7, #6
1000198a:	7809      	ldrb	r1, [r1, #0]
1000198c:	00c9      	lsls	r1, r1, #3
1000198e:	3103      	adds	r1, #3
10001990:	200f      	movs	r0, #15
10001992:	4088      	lsls	r0, r1
10001994:	1c01      	adds	r1, r0, #0
10001996:	43c9      	mvns	r1, r1
10001998:	400a      	ands	r2, r1
1000199a:	611a      	str	r2, [r3, #16]
1000199c:	e047      	b.n	10001a2e <bit_init_mode+0x112>
				}
				else {
					PORT0->IOCR0 &= ~(1UL << ((bitnr * 8 ) + 7 ));
1000199e:	4bd2      	ldr	r3, [pc, #840]	; (10001ce8 <bit_init_mode+0x3cc>)
100019a0:	4ad1      	ldr	r2, [pc, #836]	; (10001ce8 <bit_init_mode+0x3cc>)
100019a2:	6912      	ldr	r2, [r2, #16]
100019a4:	1db9      	adds	r1, r7, #6
100019a6:	7809      	ldrb	r1, [r1, #0]
100019a8:	00c9      	lsls	r1, r1, #3
100019aa:	3107      	adds	r1, #7
100019ac:	2001      	movs	r0, #1
100019ae:	4088      	lsls	r0, r1
100019b0:	1c01      	adds	r1, r0, #0
100019b2:	43c9      	mvns	r1, r1
100019b4:	400a      	ands	r2, r1
100019b6:	611a      	str	r2, [r3, #16]
					if (mode == PULLUP) {
100019b8:	1d3b      	adds	r3, r7, #4
100019ba:	781b      	ldrb	r3, [r3, #0]
100019bc:	2b01      	cmp	r3, #1
100019be:	d119      	bne.n	100019f4 <bit_init_mode+0xd8>
						PORT0->IOCR0 &= ~(0x0000001F << ((bitnr * 8)+3) );
100019c0:	4bc9      	ldr	r3, [pc, #804]	; (10001ce8 <bit_init_mode+0x3cc>)
100019c2:	4ac9      	ldr	r2, [pc, #804]	; (10001ce8 <bit_init_mode+0x3cc>)
100019c4:	6912      	ldr	r2, [r2, #16]
100019c6:	1db9      	adds	r1, r7, #6
100019c8:	7809      	ldrb	r1, [r1, #0]
100019ca:	00c9      	lsls	r1, r1, #3
100019cc:	3103      	adds	r1, #3
100019ce:	201f      	movs	r0, #31
100019d0:	4088      	lsls	r0, r1
100019d2:	1c01      	adds	r1, r0, #0
100019d4:	43c9      	mvns	r1, r1
100019d6:	400a      	ands	r2, r1
100019d8:	611a      	str	r2, [r3, #16]
						PORT0->IOCR0 |= (1UL << ((bitnr * 8)+4) );
100019da:	4bc3      	ldr	r3, [pc, #780]	; (10001ce8 <bit_init_mode+0x3cc>)
100019dc:	4ac2      	ldr	r2, [pc, #776]	; (10001ce8 <bit_init_mode+0x3cc>)
100019de:	6911      	ldr	r1, [r2, #16]
100019e0:	1dba      	adds	r2, r7, #6
100019e2:	7812      	ldrb	r2, [r2, #0]
100019e4:	00d2      	lsls	r2, r2, #3
100019e6:	3204      	adds	r2, #4
100019e8:	2001      	movs	r0, #1
100019ea:	4090      	lsls	r0, r2
100019ec:	1c02      	adds	r2, r0, #0
100019ee:	430a      	orrs	r2, r1
100019f0:	611a      	str	r2, [r3, #16]
100019f2:	e01c      	b.n	10001a2e <bit_init_mode+0x112>
					} else if (mode == PULLDOWN) {
100019f4:	1d3b      	adds	r3, r7, #4
100019f6:	781b      	ldrb	r3, [r3, #0]
100019f8:	2b02      	cmp	r3, #2
100019fa:	d118      	bne.n	10001a2e <bit_init_mode+0x112>
						PORT0->IOCR0 &= ~(0x0000001F << ((bitnr * 8)+3) );
100019fc:	4bba      	ldr	r3, [pc, #744]	; (10001ce8 <bit_init_mode+0x3cc>)
100019fe:	4aba      	ldr	r2, [pc, #744]	; (10001ce8 <bit_init_mode+0x3cc>)
10001a00:	6912      	ldr	r2, [r2, #16]
10001a02:	1db9      	adds	r1, r7, #6
10001a04:	7809      	ldrb	r1, [r1, #0]
10001a06:	00c9      	lsls	r1, r1, #3
10001a08:	3103      	adds	r1, #3
10001a0a:	201f      	movs	r0, #31
10001a0c:	4088      	lsls	r0, r1
10001a0e:	1c01      	adds	r1, r0, #0
10001a10:	43c9      	mvns	r1, r1
10001a12:	400a      	ands	r2, r1
10001a14:	611a      	str	r2, [r3, #16]
						PORT0->IOCR0 |= (1UL << ((bitnr * 8)+3) );
10001a16:	4bb4      	ldr	r3, [pc, #720]	; (10001ce8 <bit_init_mode+0x3cc>)
10001a18:	4ab3      	ldr	r2, [pc, #716]	; (10001ce8 <bit_init_mode+0x3cc>)
10001a1a:	6911      	ldr	r1, [r2, #16]
10001a1c:	1dba      	adds	r2, r7, #6
10001a1e:	7812      	ldrb	r2, [r2, #0]
10001a20:	00d2      	lsls	r2, r2, #3
10001a22:	3203      	adds	r2, #3
10001a24:	2001      	movs	r0, #1
10001a26:	4090      	lsls	r0, r2
10001a28:	1c02      	adds	r2, r0, #0
10001a2a:	430a      	orrs	r2, r1
10001a2c:	611a      	str	r2, [r3, #16]
					}
				}
			}
			if ( (bitnr <8) && (bitnr > 3)) {
10001a2e:	1dbb      	adds	r3, r7, #6
10001a30:	781b      	ldrb	r3, [r3, #0]
10001a32:	2b07      	cmp	r3, #7
10001a34:	d86e      	bhi.n	10001b14 <bit_init_mode+0x1f8>
10001a36:	1dbb      	adds	r3, r7, #6
10001a38:	781b      	ldrb	r3, [r3, #0]
10001a3a:	2b03      	cmp	r3, #3
10001a3c:	d96a      	bls.n	10001b14 <bit_init_mode+0x1f8>
				if (direction == 1) {
10001a3e:	1d7b      	adds	r3, r7, #5
10001a40:	781b      	ldrb	r3, [r3, #0]
10001a42:	2b01      	cmp	r3, #1
10001a44:	d11b      	bne.n	10001a7e <bit_init_mode+0x162>
					PORT0->IOCR4 |= 1UL<< (((bitnr-4) * 8)+7);
10001a46:	4ba8      	ldr	r3, [pc, #672]	; (10001ce8 <bit_init_mode+0x3cc>)
10001a48:	4aa7      	ldr	r2, [pc, #668]	; (10001ce8 <bit_init_mode+0x3cc>)
10001a4a:	6951      	ldr	r1, [r2, #20]
10001a4c:	1dba      	adds	r2, r7, #6
10001a4e:	7812      	ldrb	r2, [r2, #0]
10001a50:	3a04      	subs	r2, #4
10001a52:	00d2      	lsls	r2, r2, #3
10001a54:	3207      	adds	r2, #7
10001a56:	2001      	movs	r0, #1
10001a58:	4090      	lsls	r0, r2
10001a5a:	1c02      	adds	r2, r0, #0
10001a5c:	430a      	orrs	r2, r1
10001a5e:	615a      	str	r2, [r3, #20]
					PORT0->IOCR4 &= ~(0x0000000F << (((bitnr-4) * 8)+3));
10001a60:	4ba1      	ldr	r3, [pc, #644]	; (10001ce8 <bit_init_mode+0x3cc>)
10001a62:	4aa1      	ldr	r2, [pc, #644]	; (10001ce8 <bit_init_mode+0x3cc>)
10001a64:	6952      	ldr	r2, [r2, #20]
10001a66:	1db9      	adds	r1, r7, #6
10001a68:	7809      	ldrb	r1, [r1, #0]
10001a6a:	3904      	subs	r1, #4
10001a6c:	00c9      	lsls	r1, r1, #3
10001a6e:	3103      	adds	r1, #3
10001a70:	200f      	movs	r0, #15
10001a72:	4088      	lsls	r0, r1
10001a74:	1c01      	adds	r1, r0, #0
10001a76:	43c9      	mvns	r1, r1
10001a78:	400a      	ands	r2, r1
10001a7a:	615a      	str	r2, [r3, #20]
10001a7c:	e04a      	b.n	10001b14 <bit_init_mode+0x1f8>
				}
				else {
					PORT0->IOCR4 &= ~(1UL << (((bitnr-4) * 8)+7) );
10001a7e:	4b9a      	ldr	r3, [pc, #616]	; (10001ce8 <bit_init_mode+0x3cc>)
10001a80:	4a99      	ldr	r2, [pc, #612]	; (10001ce8 <bit_init_mode+0x3cc>)
10001a82:	6952      	ldr	r2, [r2, #20]
10001a84:	1db9      	adds	r1, r7, #6
10001a86:	7809      	ldrb	r1, [r1, #0]
10001a88:	3904      	subs	r1, #4
10001a8a:	00c9      	lsls	r1, r1, #3
10001a8c:	3107      	adds	r1, #7
10001a8e:	2001      	movs	r0, #1
10001a90:	4088      	lsls	r0, r1
10001a92:	1c01      	adds	r1, r0, #0
10001a94:	43c9      	mvns	r1, r1
10001a96:	400a      	ands	r2, r1
10001a98:	615a      	str	r2, [r3, #20]
					if (mode == PULLUP) {
10001a9a:	1d3b      	adds	r3, r7, #4
10001a9c:	781b      	ldrb	r3, [r3, #0]
10001a9e:	2b01      	cmp	r3, #1
10001aa0:	d11b      	bne.n	10001ada <bit_init_mode+0x1be>
						PORT0->IOCR4 &= ~(0x0000001F << (((bitnr-4) * 8)+3) );
10001aa2:	4b91      	ldr	r3, [pc, #580]	; (10001ce8 <bit_init_mode+0x3cc>)
10001aa4:	4a90      	ldr	r2, [pc, #576]	; (10001ce8 <bit_init_mode+0x3cc>)
10001aa6:	6952      	ldr	r2, [r2, #20]
10001aa8:	1db9      	adds	r1, r7, #6
10001aaa:	7809      	ldrb	r1, [r1, #0]
10001aac:	3904      	subs	r1, #4
10001aae:	00c9      	lsls	r1, r1, #3
10001ab0:	3103      	adds	r1, #3
10001ab2:	201f      	movs	r0, #31
10001ab4:	4088      	lsls	r0, r1
10001ab6:	1c01      	adds	r1, r0, #0
10001ab8:	43c9      	mvns	r1, r1
10001aba:	400a      	ands	r2, r1
10001abc:	615a      	str	r2, [r3, #20]
						PORT0->IOCR4 |= (1UL << (((bitnr-4) * 8)+4) );
10001abe:	4b8a      	ldr	r3, [pc, #552]	; (10001ce8 <bit_init_mode+0x3cc>)
10001ac0:	4a89      	ldr	r2, [pc, #548]	; (10001ce8 <bit_init_mode+0x3cc>)
10001ac2:	6951      	ldr	r1, [r2, #20]
10001ac4:	1dba      	adds	r2, r7, #6
10001ac6:	7812      	ldrb	r2, [r2, #0]
10001ac8:	3a04      	subs	r2, #4
10001aca:	00d2      	lsls	r2, r2, #3
10001acc:	3204      	adds	r2, #4
10001ace:	2001      	movs	r0, #1
10001ad0:	4090      	lsls	r0, r2
10001ad2:	1c02      	adds	r2, r0, #0
10001ad4:	430a      	orrs	r2, r1
10001ad6:	615a      	str	r2, [r3, #20]
10001ad8:	e01c      	b.n	10001b14 <bit_init_mode+0x1f8>
					}else if (mode == PULLDOWN) {
10001ada:	1d3b      	adds	r3, r7, #4
10001adc:	781b      	ldrb	r3, [r3, #0]
10001ade:	2b02      	cmp	r3, #2
10001ae0:	d118      	bne.n	10001b14 <bit_init_mode+0x1f8>
						PORT0->IOCR4 &= ~(0x0000001F << ((bitnr * 8)+3) );
10001ae2:	4b81      	ldr	r3, [pc, #516]	; (10001ce8 <bit_init_mode+0x3cc>)
10001ae4:	4a80      	ldr	r2, [pc, #512]	; (10001ce8 <bit_init_mode+0x3cc>)
10001ae6:	6952      	ldr	r2, [r2, #20]
10001ae8:	1db9      	adds	r1, r7, #6
10001aea:	7809      	ldrb	r1, [r1, #0]
10001aec:	00c9      	lsls	r1, r1, #3
10001aee:	3103      	adds	r1, #3
10001af0:	201f      	movs	r0, #31
10001af2:	4088      	lsls	r0, r1
10001af4:	1c01      	adds	r1, r0, #0
10001af6:	43c9      	mvns	r1, r1
10001af8:	400a      	ands	r2, r1
10001afa:	615a      	str	r2, [r3, #20]
						PORT0->IOCR4 |= (1UL << ((bitnr * 8)+3) );
10001afc:	4b7a      	ldr	r3, [pc, #488]	; (10001ce8 <bit_init_mode+0x3cc>)
10001afe:	4a7a      	ldr	r2, [pc, #488]	; (10001ce8 <bit_init_mode+0x3cc>)
10001b00:	6951      	ldr	r1, [r2, #20]
10001b02:	1dba      	adds	r2, r7, #6
10001b04:	7812      	ldrb	r2, [r2, #0]
10001b06:	00d2      	lsls	r2, r2, #3
10001b08:	3203      	adds	r2, #3
10001b0a:	2001      	movs	r0, #1
10001b0c:	4090      	lsls	r0, r2
10001b0e:	1c02      	adds	r2, r0, #0
10001b10:	430a      	orrs	r2, r1
10001b12:	615a      	str	r2, [r3, #20]
					}
				}
			}
			if ( (bitnr <12) && (bitnr > 7)) {
10001b14:	1dbb      	adds	r3, r7, #6
10001b16:	781b      	ldrb	r3, [r3, #0]
10001b18:	2b0b      	cmp	r3, #11
10001b1a:	d86e      	bhi.n	10001bfa <bit_init_mode+0x2de>
10001b1c:	1dbb      	adds	r3, r7, #6
10001b1e:	781b      	ldrb	r3, [r3, #0]
10001b20:	2b07      	cmp	r3, #7
10001b22:	d96a      	bls.n	10001bfa <bit_init_mode+0x2de>
				if (direction == 1) {
10001b24:	1d7b      	adds	r3, r7, #5
10001b26:	781b      	ldrb	r3, [r3, #0]
10001b28:	2b01      	cmp	r3, #1
10001b2a:	d11b      	bne.n	10001b64 <bit_init_mode+0x248>
					PORT0->IOCR8 |= 1UL << (((bitnr-8) * 8)+7);
10001b2c:	4b6e      	ldr	r3, [pc, #440]	; (10001ce8 <bit_init_mode+0x3cc>)
10001b2e:	4a6e      	ldr	r2, [pc, #440]	; (10001ce8 <bit_init_mode+0x3cc>)
10001b30:	6991      	ldr	r1, [r2, #24]
10001b32:	1dba      	adds	r2, r7, #6
10001b34:	7812      	ldrb	r2, [r2, #0]
10001b36:	3a08      	subs	r2, #8
10001b38:	00d2      	lsls	r2, r2, #3
10001b3a:	3207      	adds	r2, #7
10001b3c:	2001      	movs	r0, #1
10001b3e:	4090      	lsls	r0, r2
10001b40:	1c02      	adds	r2, r0, #0
10001b42:	430a      	orrs	r2, r1
10001b44:	619a      	str	r2, [r3, #24]
					PORT0->IOCR8 &= ~(0x0000000F << (((bitnr-8) * 8)+3));
10001b46:	4b68      	ldr	r3, [pc, #416]	; (10001ce8 <bit_init_mode+0x3cc>)
10001b48:	4a67      	ldr	r2, [pc, #412]	; (10001ce8 <bit_init_mode+0x3cc>)
10001b4a:	6992      	ldr	r2, [r2, #24]
10001b4c:	1db9      	adds	r1, r7, #6
10001b4e:	7809      	ldrb	r1, [r1, #0]
10001b50:	3908      	subs	r1, #8
10001b52:	00c9      	lsls	r1, r1, #3
10001b54:	3103      	adds	r1, #3
10001b56:	200f      	movs	r0, #15
10001b58:	4088      	lsls	r0, r1
10001b5a:	1c01      	adds	r1, r0, #0
10001b5c:	43c9      	mvns	r1, r1
10001b5e:	400a      	ands	r2, r1
10001b60:	619a      	str	r2, [r3, #24]
10001b62:	e04a      	b.n	10001bfa <bit_init_mode+0x2de>
				}
				else {
					PORT0->IOCR8 &= ~(1UL << (((bitnr-8) * 8)+7) );
10001b64:	4b60      	ldr	r3, [pc, #384]	; (10001ce8 <bit_init_mode+0x3cc>)
10001b66:	4a60      	ldr	r2, [pc, #384]	; (10001ce8 <bit_init_mode+0x3cc>)
10001b68:	6992      	ldr	r2, [r2, #24]
10001b6a:	1db9      	adds	r1, r7, #6
10001b6c:	7809      	ldrb	r1, [r1, #0]
10001b6e:	3908      	subs	r1, #8
10001b70:	00c9      	lsls	r1, r1, #3
10001b72:	3107      	adds	r1, #7
10001b74:	2001      	movs	r0, #1
10001b76:	4088      	lsls	r0, r1
10001b78:	1c01      	adds	r1, r0, #0
10001b7a:	43c9      	mvns	r1, r1
10001b7c:	400a      	ands	r2, r1
10001b7e:	619a      	str	r2, [r3, #24]
					if (mode == PULLUP) {
10001b80:	1d3b      	adds	r3, r7, #4
10001b82:	781b      	ldrb	r3, [r3, #0]
10001b84:	2b01      	cmp	r3, #1
10001b86:	d11b      	bne.n	10001bc0 <bit_init_mode+0x2a4>
						PORT0->IOCR8 &= ~(0x0000001F << (((bitnr-8) * 8)+3) );
10001b88:	4b57      	ldr	r3, [pc, #348]	; (10001ce8 <bit_init_mode+0x3cc>)
10001b8a:	4a57      	ldr	r2, [pc, #348]	; (10001ce8 <bit_init_mode+0x3cc>)
10001b8c:	6992      	ldr	r2, [r2, #24]
10001b8e:	1db9      	adds	r1, r7, #6
10001b90:	7809      	ldrb	r1, [r1, #0]
10001b92:	3908      	subs	r1, #8
10001b94:	00c9      	lsls	r1, r1, #3
10001b96:	3103      	adds	r1, #3
10001b98:	201f      	movs	r0, #31
10001b9a:	4088      	lsls	r0, r1
10001b9c:	1c01      	adds	r1, r0, #0
10001b9e:	43c9      	mvns	r1, r1
10001ba0:	400a      	ands	r2, r1
10001ba2:	619a      	str	r2, [r3, #24]
						PORT0->IOCR8 |= (1UL << (((bitnr-8) * 8)+4) );
10001ba4:	4b50      	ldr	r3, [pc, #320]	; (10001ce8 <bit_init_mode+0x3cc>)
10001ba6:	4a50      	ldr	r2, [pc, #320]	; (10001ce8 <bit_init_mode+0x3cc>)
10001ba8:	6991      	ldr	r1, [r2, #24]
10001baa:	1dba      	adds	r2, r7, #6
10001bac:	7812      	ldrb	r2, [r2, #0]
10001bae:	3a08      	subs	r2, #8
10001bb0:	00d2      	lsls	r2, r2, #3
10001bb2:	3204      	adds	r2, #4
10001bb4:	2001      	movs	r0, #1
10001bb6:	4090      	lsls	r0, r2
10001bb8:	1c02      	adds	r2, r0, #0
10001bba:	430a      	orrs	r2, r1
10001bbc:	619a      	str	r2, [r3, #24]
10001bbe:	e01c      	b.n	10001bfa <bit_init_mode+0x2de>
					} else if (mode == PULLDOWN) {
10001bc0:	1d3b      	adds	r3, r7, #4
10001bc2:	781b      	ldrb	r3, [r3, #0]
10001bc4:	2b02      	cmp	r3, #2
10001bc6:	d118      	bne.n	10001bfa <bit_init_mode+0x2de>
						PORT0->IOCR8 &= ~(0x0000001F << ((bitnr * 8)+3) );
10001bc8:	4b47      	ldr	r3, [pc, #284]	; (10001ce8 <bit_init_mode+0x3cc>)
10001bca:	4a47      	ldr	r2, [pc, #284]	; (10001ce8 <bit_init_mode+0x3cc>)
10001bcc:	6992      	ldr	r2, [r2, #24]
10001bce:	1db9      	adds	r1, r7, #6
10001bd0:	7809      	ldrb	r1, [r1, #0]
10001bd2:	00c9      	lsls	r1, r1, #3
10001bd4:	3103      	adds	r1, #3
10001bd6:	201f      	movs	r0, #31
10001bd8:	4088      	lsls	r0, r1
10001bda:	1c01      	adds	r1, r0, #0
10001bdc:	43c9      	mvns	r1, r1
10001bde:	400a      	ands	r2, r1
10001be0:	619a      	str	r2, [r3, #24]
						PORT0->IOCR8 |= (1UL << ((bitnr * 8)+3) );
10001be2:	4b41      	ldr	r3, [pc, #260]	; (10001ce8 <bit_init_mode+0x3cc>)
10001be4:	4a40      	ldr	r2, [pc, #256]	; (10001ce8 <bit_init_mode+0x3cc>)
10001be6:	6991      	ldr	r1, [r2, #24]
10001be8:	1dba      	adds	r2, r7, #6
10001bea:	7812      	ldrb	r2, [r2, #0]
10001bec:	00d2      	lsls	r2, r2, #3
10001bee:	3203      	adds	r2, #3
10001bf0:	2001      	movs	r0, #1
10001bf2:	4090      	lsls	r0, r2
10001bf4:	1c02      	adds	r2, r0, #0
10001bf6:	430a      	orrs	r2, r1
10001bf8:	619a      	str	r2, [r3, #24]
					}
				}
			}
			if ( (bitnr <16) && (bitnr > 11)) {
10001bfa:	1dbb      	adds	r3, r7, #6
10001bfc:	781b      	ldrb	r3, [r3, #0]
10001bfe:	2b0f      	cmp	r3, #15
10001c00:	d870      	bhi.n	10001ce4 <bit_init_mode+0x3c8>
10001c02:	1dbb      	adds	r3, r7, #6
10001c04:	781b      	ldrb	r3, [r3, #0]
10001c06:	2b0b      	cmp	r3, #11
10001c08:	d96c      	bls.n	10001ce4 <bit_init_mode+0x3c8>
				if (direction == OUTP){
10001c0a:	1d7b      	adds	r3, r7, #5
10001c0c:	781b      	ldrb	r3, [r3, #0]
10001c0e:	2b01      	cmp	r3, #1
10001c10:	d11b      	bne.n	10001c4a <bit_init_mode+0x32e>
					PORT0->IOCR12 |= 1UL << (((bitnr-12) * 8)+7);
10001c12:	4b35      	ldr	r3, [pc, #212]	; (10001ce8 <bit_init_mode+0x3cc>)
10001c14:	4a34      	ldr	r2, [pc, #208]	; (10001ce8 <bit_init_mode+0x3cc>)
10001c16:	69d1      	ldr	r1, [r2, #28]
10001c18:	1dba      	adds	r2, r7, #6
10001c1a:	7812      	ldrb	r2, [r2, #0]
10001c1c:	3a0c      	subs	r2, #12
10001c1e:	00d2      	lsls	r2, r2, #3
10001c20:	3207      	adds	r2, #7
10001c22:	2001      	movs	r0, #1
10001c24:	4090      	lsls	r0, r2
10001c26:	1c02      	adds	r2, r0, #0
10001c28:	430a      	orrs	r2, r1
10001c2a:	61da      	str	r2, [r3, #28]
					PORT0->IOCR12 &= ~(0x0000000F << (((bitnr-12) * 8)+3));
10001c2c:	4b2e      	ldr	r3, [pc, #184]	; (10001ce8 <bit_init_mode+0x3cc>)
10001c2e:	4a2e      	ldr	r2, [pc, #184]	; (10001ce8 <bit_init_mode+0x3cc>)
10001c30:	69d2      	ldr	r2, [r2, #28]
10001c32:	1db9      	adds	r1, r7, #6
10001c34:	7809      	ldrb	r1, [r1, #0]
10001c36:	390c      	subs	r1, #12
10001c38:	00c9      	lsls	r1, r1, #3
10001c3a:	3103      	adds	r1, #3
10001c3c:	200f      	movs	r0, #15
10001c3e:	4088      	lsls	r0, r1
10001c40:	1c01      	adds	r1, r0, #0
10001c42:	43c9      	mvns	r1, r1
10001c44:	400a      	ands	r2, r1
10001c46:	61da      	str	r2, [r3, #28]
10001c48:	e04c      	b.n	10001ce4 <bit_init_mode+0x3c8>
				}
				else {
					PORT0->IOCR12 &= ~(1UL << (((bitnr-12) * 8)+7) );
10001c4a:	4b27      	ldr	r3, [pc, #156]	; (10001ce8 <bit_init_mode+0x3cc>)
10001c4c:	4a26      	ldr	r2, [pc, #152]	; (10001ce8 <bit_init_mode+0x3cc>)
10001c4e:	69d2      	ldr	r2, [r2, #28]
10001c50:	1db9      	adds	r1, r7, #6
10001c52:	7809      	ldrb	r1, [r1, #0]
10001c54:	390c      	subs	r1, #12
10001c56:	00c9      	lsls	r1, r1, #3
10001c58:	3107      	adds	r1, #7
10001c5a:	2001      	movs	r0, #1
10001c5c:	4088      	lsls	r0, r1
10001c5e:	1c01      	adds	r1, r0, #0
10001c60:	43c9      	mvns	r1, r1
10001c62:	400a      	ands	r2, r1
10001c64:	61da      	str	r2, [r3, #28]
					if (mode == PULLUP) {
10001c66:	1d3b      	adds	r3, r7, #4
10001c68:	781b      	ldrb	r3, [r3, #0]
10001c6a:	2b01      	cmp	r3, #1
10001c6c:	d11b      	bne.n	10001ca6 <bit_init_mode+0x38a>
						PORT0->IOCR12 &= ~(0x0000001F << (((bitnr-12) * 8)+3) );
10001c6e:	4b1e      	ldr	r3, [pc, #120]	; (10001ce8 <bit_init_mode+0x3cc>)
10001c70:	4a1d      	ldr	r2, [pc, #116]	; (10001ce8 <bit_init_mode+0x3cc>)
10001c72:	69d2      	ldr	r2, [r2, #28]
10001c74:	1db9      	adds	r1, r7, #6
10001c76:	7809      	ldrb	r1, [r1, #0]
10001c78:	390c      	subs	r1, #12
10001c7a:	00c9      	lsls	r1, r1, #3
10001c7c:	3103      	adds	r1, #3
10001c7e:	201f      	movs	r0, #31
10001c80:	4088      	lsls	r0, r1
10001c82:	1c01      	adds	r1, r0, #0
10001c84:	43c9      	mvns	r1, r1
10001c86:	400a      	ands	r2, r1
10001c88:	61da      	str	r2, [r3, #28]
						PORT0->IOCR12 |= (1UL << (((bitnr-12) * 8)+4) );
10001c8a:	4b17      	ldr	r3, [pc, #92]	; (10001ce8 <bit_init_mode+0x3cc>)
10001c8c:	4a16      	ldr	r2, [pc, #88]	; (10001ce8 <bit_init_mode+0x3cc>)
10001c8e:	69d1      	ldr	r1, [r2, #28]
10001c90:	1dba      	adds	r2, r7, #6
10001c92:	7812      	ldrb	r2, [r2, #0]
10001c94:	3a0c      	subs	r2, #12
10001c96:	00d2      	lsls	r2, r2, #3
10001c98:	3204      	adds	r2, #4
10001c9a:	2001      	movs	r0, #1
10001c9c:	4090      	lsls	r0, r2
10001c9e:	1c02      	adds	r2, r0, #0
10001ca0:	430a      	orrs	r2, r1
10001ca2:	61da      	str	r2, [r3, #28]
10001ca4:	e01e      	b.n	10001ce4 <bit_init_mode+0x3c8>
					}else if (mode == PULLDOWN) {
10001ca6:	1d3b      	adds	r3, r7, #4
10001ca8:	781b      	ldrb	r3, [r3, #0]
10001caa:	2b02      	cmp	r3, #2
10001cac:	d11a      	bne.n	10001ce4 <bit_init_mode+0x3c8>
						PORT0->IOCR12 &= ~(0x0000001F << ((bitnr * 8)+3) );
10001cae:	4b0e      	ldr	r3, [pc, #56]	; (10001ce8 <bit_init_mode+0x3cc>)
10001cb0:	4a0d      	ldr	r2, [pc, #52]	; (10001ce8 <bit_init_mode+0x3cc>)
10001cb2:	69d2      	ldr	r2, [r2, #28]
10001cb4:	1db9      	adds	r1, r7, #6
10001cb6:	7809      	ldrb	r1, [r1, #0]
10001cb8:	00c9      	lsls	r1, r1, #3
10001cba:	3103      	adds	r1, #3
10001cbc:	201f      	movs	r0, #31
10001cbe:	4088      	lsls	r0, r1
10001cc0:	1c01      	adds	r1, r0, #0
10001cc2:	43c9      	mvns	r1, r1
10001cc4:	400a      	ands	r2, r1
10001cc6:	61da      	str	r2, [r3, #28]
						PORT0->IOCR12 |= (1UL << ((bitnr * 8)+3) );
10001cc8:	4b07      	ldr	r3, [pc, #28]	; (10001ce8 <bit_init_mode+0x3cc>)
10001cca:	4a07      	ldr	r2, [pc, #28]	; (10001ce8 <bit_init_mode+0x3cc>)
10001ccc:	69d1      	ldr	r1, [r2, #28]
10001cce:	1dba      	adds	r2, r7, #6
10001cd0:	7812      	ldrb	r2, [r2, #0]
10001cd2:	00d2      	lsls	r2, r2, #3
10001cd4:	3203      	adds	r2, #3
10001cd6:	2001      	movs	r0, #1
10001cd8:	4090      	lsls	r0, r2
10001cda:	1c02      	adds	r2, r0, #0
10001cdc:	430a      	orrs	r2, r1
10001cde:	61da      	str	r2, [r3, #28]
					}
				}
			}
		}
		break;
10001ce0:	f000 fbd3 	bl	1000248a <bit_init_mode+0xb6e>
10001ce4:	f000 fbd1 	bl	1000248a <bit_init_mode+0xb6e>
10001ce8:	40040000 	.word	0x40040000
		case 1 :
		{
			if (bitnr < 4 ) {
10001cec:	1dbb      	adds	r3, r7, #6
10001cee:	781b      	ldrb	r3, [r3, #0]
10001cf0:	2b03      	cmp	r3, #3
10001cf2:	d865      	bhi.n	10001dc0 <bit_init_mode+0x4a4>
				if (direction == 1) {
10001cf4:	1d7b      	adds	r3, r7, #5
10001cf6:	781b      	ldrb	r3, [r3, #0]
10001cf8:	2b01      	cmp	r3, #1
10001cfa:	d119      	bne.n	10001d30 <bit_init_mode+0x414>
					PORT1->IOCR0 |=1UL << ((bitnr * 8)+7);
10001cfc:	4bd8      	ldr	r3, [pc, #864]	; (10002060 <bit_init_mode+0x744>)
10001cfe:	4ad8      	ldr	r2, [pc, #864]	; (10002060 <bit_init_mode+0x744>)
10001d00:	6911      	ldr	r1, [r2, #16]
10001d02:	1dba      	adds	r2, r7, #6
10001d04:	7812      	ldrb	r2, [r2, #0]
10001d06:	00d2      	lsls	r2, r2, #3
10001d08:	3207      	adds	r2, #7
10001d0a:	2001      	movs	r0, #1
10001d0c:	4090      	lsls	r0, r2
10001d0e:	1c02      	adds	r2, r0, #0
10001d10:	430a      	orrs	r2, r1
10001d12:	611a      	str	r2, [r3, #16]
					PORT1->IOCR0 &= ~(0x0000000F << ((bitnr * 8)+3));
10001d14:	4bd2      	ldr	r3, [pc, #840]	; (10002060 <bit_init_mode+0x744>)
10001d16:	4ad2      	ldr	r2, [pc, #840]	; (10002060 <bit_init_mode+0x744>)
10001d18:	6912      	ldr	r2, [r2, #16]
10001d1a:	1db9      	adds	r1, r7, #6
10001d1c:	7809      	ldrb	r1, [r1, #0]
10001d1e:	00c9      	lsls	r1, r1, #3
10001d20:	3103      	adds	r1, #3
10001d22:	200f      	movs	r0, #15
10001d24:	4088      	lsls	r0, r1
10001d26:	1c01      	adds	r1, r0, #0
10001d28:	43c9      	mvns	r1, r1
10001d2a:	400a      	ands	r2, r1
10001d2c:	611a      	str	r2, [r3, #16]
10001d2e:	e047      	b.n	10001dc0 <bit_init_mode+0x4a4>
				}
				else {
					PORT1->IOCR0 &= ~(1UL << ((bitnr * 8 ) + 7 ));
10001d30:	4bcb      	ldr	r3, [pc, #812]	; (10002060 <bit_init_mode+0x744>)
10001d32:	4acb      	ldr	r2, [pc, #812]	; (10002060 <bit_init_mode+0x744>)
10001d34:	6912      	ldr	r2, [r2, #16]
10001d36:	1db9      	adds	r1, r7, #6
10001d38:	7809      	ldrb	r1, [r1, #0]
10001d3a:	00c9      	lsls	r1, r1, #3
10001d3c:	3107      	adds	r1, #7
10001d3e:	2001      	movs	r0, #1
10001d40:	4088      	lsls	r0, r1
10001d42:	1c01      	adds	r1, r0, #0
10001d44:	43c9      	mvns	r1, r1
10001d46:	400a      	ands	r2, r1
10001d48:	611a      	str	r2, [r3, #16]
					if (mode == PULLUP) {
10001d4a:	1d3b      	adds	r3, r7, #4
10001d4c:	781b      	ldrb	r3, [r3, #0]
10001d4e:	2b01      	cmp	r3, #1
10001d50:	d119      	bne.n	10001d86 <bit_init_mode+0x46a>
						PORT1->IOCR0 &= ~(0x0000001F << ((bitnr * 8)+3) );
10001d52:	4bc3      	ldr	r3, [pc, #780]	; (10002060 <bit_init_mode+0x744>)
10001d54:	4ac2      	ldr	r2, [pc, #776]	; (10002060 <bit_init_mode+0x744>)
10001d56:	6912      	ldr	r2, [r2, #16]
10001d58:	1db9      	adds	r1, r7, #6
10001d5a:	7809      	ldrb	r1, [r1, #0]
10001d5c:	00c9      	lsls	r1, r1, #3
10001d5e:	3103      	adds	r1, #3
10001d60:	201f      	movs	r0, #31
10001d62:	4088      	lsls	r0, r1
10001d64:	1c01      	adds	r1, r0, #0
10001d66:	43c9      	mvns	r1, r1
10001d68:	400a      	ands	r2, r1
10001d6a:	611a      	str	r2, [r3, #16]
						PORT1->IOCR0 |= (1UL << ((bitnr * 8)+4) );
10001d6c:	4bbc      	ldr	r3, [pc, #752]	; (10002060 <bit_init_mode+0x744>)
10001d6e:	4abc      	ldr	r2, [pc, #752]	; (10002060 <bit_init_mode+0x744>)
10001d70:	6911      	ldr	r1, [r2, #16]
10001d72:	1dba      	adds	r2, r7, #6
10001d74:	7812      	ldrb	r2, [r2, #0]
10001d76:	00d2      	lsls	r2, r2, #3
10001d78:	3204      	adds	r2, #4
10001d7a:	2001      	movs	r0, #1
10001d7c:	4090      	lsls	r0, r2
10001d7e:	1c02      	adds	r2, r0, #0
10001d80:	430a      	orrs	r2, r1
10001d82:	611a      	str	r2, [r3, #16]
10001d84:	e01c      	b.n	10001dc0 <bit_init_mode+0x4a4>
					} else if (mode == PULLDOWN) {
10001d86:	1d3b      	adds	r3, r7, #4
10001d88:	781b      	ldrb	r3, [r3, #0]
10001d8a:	2b02      	cmp	r3, #2
10001d8c:	d118      	bne.n	10001dc0 <bit_init_mode+0x4a4>
						PORT1->IOCR0 &= ~(0x0000001F << ((bitnr * 8)+3) );
10001d8e:	4bb4      	ldr	r3, [pc, #720]	; (10002060 <bit_init_mode+0x744>)
10001d90:	4ab3      	ldr	r2, [pc, #716]	; (10002060 <bit_init_mode+0x744>)
10001d92:	6912      	ldr	r2, [r2, #16]
10001d94:	1db9      	adds	r1, r7, #6
10001d96:	7809      	ldrb	r1, [r1, #0]
10001d98:	00c9      	lsls	r1, r1, #3
10001d9a:	3103      	adds	r1, #3
10001d9c:	201f      	movs	r0, #31
10001d9e:	4088      	lsls	r0, r1
10001da0:	1c01      	adds	r1, r0, #0
10001da2:	43c9      	mvns	r1, r1
10001da4:	400a      	ands	r2, r1
10001da6:	611a      	str	r2, [r3, #16]
						PORT1->IOCR0 |= (1UL << ((bitnr * 8)+3) );
10001da8:	4bad      	ldr	r3, [pc, #692]	; (10002060 <bit_init_mode+0x744>)
10001daa:	4aad      	ldr	r2, [pc, #692]	; (10002060 <bit_init_mode+0x744>)
10001dac:	6911      	ldr	r1, [r2, #16]
10001dae:	1dba      	adds	r2, r7, #6
10001db0:	7812      	ldrb	r2, [r2, #0]
10001db2:	00d2      	lsls	r2, r2, #3
10001db4:	3203      	adds	r2, #3
10001db6:	2001      	movs	r0, #1
10001db8:	4090      	lsls	r0, r2
10001dba:	1c02      	adds	r2, r0, #0
10001dbc:	430a      	orrs	r2, r1
10001dbe:	611a      	str	r2, [r3, #16]
					}
				}
			}
			if ( (bitnr <8) && (bitnr > 3)) {
10001dc0:	1dbb      	adds	r3, r7, #6
10001dc2:	781b      	ldrb	r3, [r3, #0]
10001dc4:	2b07      	cmp	r3, #7
10001dc6:	d86f      	bhi.n	10001ea8 <bit_init_mode+0x58c>
10001dc8:	1dbb      	adds	r3, r7, #6
10001dca:	781b      	ldrb	r3, [r3, #0]
10001dcc:	2b03      	cmp	r3, #3
10001dce:	d96b      	bls.n	10001ea8 <bit_init_mode+0x58c>
				if (direction == 1) {
10001dd0:	1d7b      	adds	r3, r7, #5
10001dd2:	781b      	ldrb	r3, [r3, #0]
10001dd4:	2b01      	cmp	r3, #1
10001dd6:	d11b      	bne.n	10001e10 <bit_init_mode+0x4f4>
					PORT1->IOCR4 |= 1UL<< (((bitnr-4) * 8)+7);
10001dd8:	4ba1      	ldr	r3, [pc, #644]	; (10002060 <bit_init_mode+0x744>)
10001dda:	4aa1      	ldr	r2, [pc, #644]	; (10002060 <bit_init_mode+0x744>)
10001ddc:	6951      	ldr	r1, [r2, #20]
10001dde:	1dba      	adds	r2, r7, #6
10001de0:	7812      	ldrb	r2, [r2, #0]
10001de2:	3a04      	subs	r2, #4
10001de4:	00d2      	lsls	r2, r2, #3
10001de6:	3207      	adds	r2, #7
10001de8:	2001      	movs	r0, #1
10001dea:	4090      	lsls	r0, r2
10001dec:	1c02      	adds	r2, r0, #0
10001dee:	430a      	orrs	r2, r1
10001df0:	615a      	str	r2, [r3, #20]
					PORT1->IOCR4 &= ~(0x0000000F << (((bitnr-4) * 8)+3));
10001df2:	4b9b      	ldr	r3, [pc, #620]	; (10002060 <bit_init_mode+0x744>)
10001df4:	4a9a      	ldr	r2, [pc, #616]	; (10002060 <bit_init_mode+0x744>)
10001df6:	6952      	ldr	r2, [r2, #20]
10001df8:	1db9      	adds	r1, r7, #6
10001dfa:	7809      	ldrb	r1, [r1, #0]
10001dfc:	3904      	subs	r1, #4
10001dfe:	00c9      	lsls	r1, r1, #3
10001e00:	3103      	adds	r1, #3
10001e02:	200f      	movs	r0, #15
10001e04:	4088      	lsls	r0, r1
10001e06:	1c01      	adds	r1, r0, #0
10001e08:	43c9      	mvns	r1, r1
10001e0a:	400a      	ands	r2, r1
10001e0c:	615a      	str	r2, [r3, #20]
10001e0e:	e04b      	b.n	10001ea8 <bit_init_mode+0x58c>
				}
				else {
					PORT1->IOCR4 &= ~(1UL << (((bitnr-4) * 8)+7) );
10001e10:	4b93      	ldr	r3, [pc, #588]	; (10002060 <bit_init_mode+0x744>)
10001e12:	4a93      	ldr	r2, [pc, #588]	; (10002060 <bit_init_mode+0x744>)
10001e14:	6952      	ldr	r2, [r2, #20]
10001e16:	1db9      	adds	r1, r7, #6
10001e18:	7809      	ldrb	r1, [r1, #0]
10001e1a:	3904      	subs	r1, #4
10001e1c:	00c9      	lsls	r1, r1, #3
10001e1e:	3107      	adds	r1, #7
10001e20:	2001      	movs	r0, #1
10001e22:	4088      	lsls	r0, r1
10001e24:	1c01      	adds	r1, r0, #0
10001e26:	43c9      	mvns	r1, r1
10001e28:	400a      	ands	r2, r1
10001e2a:	615a      	str	r2, [r3, #20]
					if (mode == PULLUP) {
10001e2c:	1d3b      	adds	r3, r7, #4
10001e2e:	781b      	ldrb	r3, [r3, #0]
10001e30:	2b01      	cmp	r3, #1
10001e32:	d11b      	bne.n	10001e6c <bit_init_mode+0x550>
						PORT1->IOCR4 &= ~(0x0000001F << (((bitnr-4) * 8)+3) );
10001e34:	4b8a      	ldr	r3, [pc, #552]	; (10002060 <bit_init_mode+0x744>)
10001e36:	4a8a      	ldr	r2, [pc, #552]	; (10002060 <bit_init_mode+0x744>)
10001e38:	6952      	ldr	r2, [r2, #20]
10001e3a:	1db9      	adds	r1, r7, #6
10001e3c:	7809      	ldrb	r1, [r1, #0]
10001e3e:	3904      	subs	r1, #4
10001e40:	00c9      	lsls	r1, r1, #3
10001e42:	3103      	adds	r1, #3
10001e44:	201f      	movs	r0, #31
10001e46:	4088      	lsls	r0, r1
10001e48:	1c01      	adds	r1, r0, #0
10001e4a:	43c9      	mvns	r1, r1
10001e4c:	400a      	ands	r2, r1
10001e4e:	615a      	str	r2, [r3, #20]
						PORT1->IOCR4 |= (1UL << (((bitnr-4) * 8)+4) );
10001e50:	4b83      	ldr	r3, [pc, #524]	; (10002060 <bit_init_mode+0x744>)
10001e52:	4a83      	ldr	r2, [pc, #524]	; (10002060 <bit_init_mode+0x744>)
10001e54:	6951      	ldr	r1, [r2, #20]
10001e56:	1dba      	adds	r2, r7, #6
10001e58:	7812      	ldrb	r2, [r2, #0]
10001e5a:	3a04      	subs	r2, #4
10001e5c:	00d2      	lsls	r2, r2, #3
10001e5e:	3204      	adds	r2, #4
10001e60:	2001      	movs	r0, #1
10001e62:	4090      	lsls	r0, r2
10001e64:	1c02      	adds	r2, r0, #0
10001e66:	430a      	orrs	r2, r1
10001e68:	615a      	str	r2, [r3, #20]
10001e6a:	e01d      	b.n	10001ea8 <bit_init_mode+0x58c>
					}else if (mode == PULLDOWN) {
10001e6c:	1d3b      	adds	r3, r7, #4
10001e6e:	781b      	ldrb	r3, [r3, #0]
10001e70:	2b02      	cmp	r3, #2
10001e72:	d119      	bne.n	10001ea8 <bit_init_mode+0x58c>
						PORT1->IOCR4 &= ~(0x0000001F << ((bitnr * 8)+3) );
10001e74:	4b7a      	ldr	r3, [pc, #488]	; (10002060 <bit_init_mode+0x744>)
10001e76:	4a7a      	ldr	r2, [pc, #488]	; (10002060 <bit_init_mode+0x744>)
10001e78:	6952      	ldr	r2, [r2, #20]
10001e7a:	1db9      	adds	r1, r7, #6
10001e7c:	7809      	ldrb	r1, [r1, #0]
10001e7e:	00c9      	lsls	r1, r1, #3
10001e80:	3103      	adds	r1, #3
10001e82:	201f      	movs	r0, #31
10001e84:	4088      	lsls	r0, r1
10001e86:	1c01      	adds	r1, r0, #0
10001e88:	43c9      	mvns	r1, r1
10001e8a:	400a      	ands	r2, r1
10001e8c:	615a      	str	r2, [r3, #20]
						PORT1->IOCR4 |= (1UL << ((bitnr * 8)+3) );
10001e8e:	4b74      	ldr	r3, [pc, #464]	; (10002060 <bit_init_mode+0x744>)
10001e90:	4a73      	ldr	r2, [pc, #460]	; (10002060 <bit_init_mode+0x744>)
10001e92:	6951      	ldr	r1, [r2, #20]
10001e94:	1dba      	adds	r2, r7, #6
10001e96:	7812      	ldrb	r2, [r2, #0]
10001e98:	00d2      	lsls	r2, r2, #3
10001e9a:	3203      	adds	r2, #3
10001e9c:	2001      	movs	r0, #1
10001e9e:	4090      	lsls	r0, r2
10001ea0:	1c02      	adds	r2, r0, #0
10001ea2:	430a      	orrs	r2, r1
10001ea4:	615a      	str	r2, [r3, #20]
					}
				}
			}
		}
		break;
10001ea6:	e2f0      	b.n	1000248a <bit_init_mode+0xb6e>
10001ea8:	e2ef      	b.n	1000248a <bit_init_mode+0xb6e>

		case 2 :
			if (bitnr == 0) { //P2.0
10001eaa:	1dbb      	adds	r3, r7, #6
10001eac:	781b      	ldrb	r3, [r3, #0]
10001eae:	2b00      	cmp	r3, #0
10001eb0:	d14c      	bne.n	10001f4c <bit_init_mode+0x630>
			 if (direction == OUTP) {
10001eb2:	1d7b      	adds	r3, r7, #5
10001eb4:	781b      	ldrb	r3, [r3, #0]
10001eb6:	2b01      	cmp	r3, #1
10001eb8:	d112      	bne.n	10001ee0 <bit_init_mode+0x5c4>
				 CLR_BIT(PORT2->PDISC,0); // digital Pad aktiv
10001eba:	4b6a      	ldr	r3, [pc, #424]	; (10002064 <bit_init_mode+0x748>)
10001ebc:	4a69      	ldr	r2, [pc, #420]	; (10002064 <bit_init_mode+0x748>)
10001ebe:	6e12      	ldr	r2, [r2, #96]	; 0x60
10001ec0:	2101      	movs	r1, #1
10001ec2:	438a      	bics	r2, r1
10001ec4:	661a      	str	r2, [r3, #96]	; 0x60
				 PORT2->IOCR0 &= 0xffffff00;
10001ec6:	4b67      	ldr	r3, [pc, #412]	; (10002064 <bit_init_mode+0x748>)
10001ec8:	4a66      	ldr	r2, [pc, #408]	; (10002064 <bit_init_mode+0x748>)
10001eca:	6912      	ldr	r2, [r2, #16]
10001ecc:	21ff      	movs	r1, #255	; 0xff
10001ece:	438a      	bics	r2, r1
10001ed0:	611a      	str	r2, [r3, #16]
				 PORT2->IOCR0 |= 0x00000080;
10001ed2:	4b64      	ldr	r3, [pc, #400]	; (10002064 <bit_init_mode+0x748>)
10001ed4:	4a63      	ldr	r2, [pc, #396]	; (10002064 <bit_init_mode+0x748>)
10001ed6:	6912      	ldr	r2, [r2, #16]
10001ed8:	2180      	movs	r1, #128	; 0x80
10001eda:	430a      	orrs	r2, r1
10001edc:	611a      	str	r2, [r3, #16]
10001ede:	e035      	b.n	10001f4c <bit_init_mode+0x630>
			 } else if (direction == INP) {
10001ee0:	1d7b      	adds	r3, r7, #5
10001ee2:	781b      	ldrb	r3, [r3, #0]
10001ee4:	2b00      	cmp	r3, #0
10001ee6:	d131      	bne.n	10001f4c <bit_init_mode+0x630>
				 CLR_BIT(PORT2->PDISC,0); // digital Pad aktiv
10001ee8:	4b5e      	ldr	r3, [pc, #376]	; (10002064 <bit_init_mode+0x748>)
10001eea:	4a5e      	ldr	r2, [pc, #376]	; (10002064 <bit_init_mode+0x748>)
10001eec:	6e12      	ldr	r2, [r2, #96]	; 0x60
10001eee:	2101      	movs	r1, #1
10001ef0:	438a      	bics	r2, r1
10001ef2:	661a      	str	r2, [r3, #96]	; 0x60
				 if (mode==PULLUP) {
10001ef4:	1d3b      	adds	r3, r7, #4
10001ef6:	781b      	ldrb	r3, [r3, #0]
10001ef8:	2b01      	cmp	r3, #1
10001efa:	d10c      	bne.n	10001f16 <bit_init_mode+0x5fa>
					 PORT2->IOCR0 &= 0xFFFFFF00;
10001efc:	4b59      	ldr	r3, [pc, #356]	; (10002064 <bit_init_mode+0x748>)
10001efe:	4a59      	ldr	r2, [pc, #356]	; (10002064 <bit_init_mode+0x748>)
10001f00:	6912      	ldr	r2, [r2, #16]
10001f02:	21ff      	movs	r1, #255	; 0xff
10001f04:	438a      	bics	r2, r1
10001f06:	611a      	str	r2, [r3, #16]
					 PORT2->IOCR0 |= 0x00000010;
10001f08:	4b56      	ldr	r3, [pc, #344]	; (10002064 <bit_init_mode+0x748>)
10001f0a:	4a56      	ldr	r2, [pc, #344]	; (10002064 <bit_init_mode+0x748>)
10001f0c:	6912      	ldr	r2, [r2, #16]
10001f0e:	2110      	movs	r1, #16
10001f10:	430a      	orrs	r2, r1
10001f12:	611a      	str	r2, [r3, #16]
10001f14:	e01a      	b.n	10001f4c <bit_init_mode+0x630>
				 } else if (mode==PULLDOWN) {
10001f16:	1d3b      	adds	r3, r7, #4
10001f18:	781b      	ldrb	r3, [r3, #0]
10001f1a:	2b02      	cmp	r3, #2
10001f1c:	d10c      	bne.n	10001f38 <bit_init_mode+0x61c>
					 PORT2->IOCR0 &= 0xFFFFFF00;
10001f1e:	4b51      	ldr	r3, [pc, #324]	; (10002064 <bit_init_mode+0x748>)
10001f20:	4a50      	ldr	r2, [pc, #320]	; (10002064 <bit_init_mode+0x748>)
10001f22:	6912      	ldr	r2, [r2, #16]
10001f24:	21ff      	movs	r1, #255	; 0xff
10001f26:	438a      	bics	r2, r1
10001f28:	611a      	str	r2, [r3, #16]
					 PORT2->IOCR0 |= 0x00000008;
10001f2a:	4b4e      	ldr	r3, [pc, #312]	; (10002064 <bit_init_mode+0x748>)
10001f2c:	4a4d      	ldr	r2, [pc, #308]	; (10002064 <bit_init_mode+0x748>)
10001f2e:	6912      	ldr	r2, [r2, #16]
10001f30:	2108      	movs	r1, #8
10001f32:	430a      	orrs	r2, r1
10001f34:	611a      	str	r2, [r3, #16]
10001f36:	e009      	b.n	10001f4c <bit_init_mode+0x630>
				 } else if (mode == ANALOG) {
10001f38:	1d3b      	adds	r3, r7, #4
10001f3a:	781b      	ldrb	r3, [r3, #0]
10001f3c:	2b03      	cmp	r3, #3
10001f3e:	d105      	bne.n	10001f4c <bit_init_mode+0x630>
					SET_BIT(PORT2->PDISC,0); //Analog Modus aktiv
10001f40:	4b48      	ldr	r3, [pc, #288]	; (10002064 <bit_init_mode+0x748>)
10001f42:	4a48      	ldr	r2, [pc, #288]	; (10002064 <bit_init_mode+0x748>)
10001f44:	6e12      	ldr	r2, [r2, #96]	; 0x60
10001f46:	2101      	movs	r1, #1
10001f48:	430a      	orrs	r2, r1
10001f4a:	661a      	str	r2, [r3, #96]	; 0x60
				 }
			 }
		 }
		 if (bitnr == 1) { //P2.1
10001f4c:	1dbb      	adds	r3, r7, #6
10001f4e:	781b      	ldrb	r3, [r3, #0]
10001f50:	2b01      	cmp	r3, #1
10001f52:	d14f      	bne.n	10001ff4 <bit_init_mode+0x6d8>
			 if (direction == OUTP) {
10001f54:	1d7b      	adds	r3, r7, #5
10001f56:	781b      	ldrb	r3, [r3, #0]
10001f58:	2b01      	cmp	r3, #1
10001f5a:	d113      	bne.n	10001f84 <bit_init_mode+0x668>
				 CLR_BIT(PORT2->PDISC,1); // digital Pad aktiv
10001f5c:	4b41      	ldr	r3, [pc, #260]	; (10002064 <bit_init_mode+0x748>)
10001f5e:	4a41      	ldr	r2, [pc, #260]	; (10002064 <bit_init_mode+0x748>)
10001f60:	6e12      	ldr	r2, [r2, #96]	; 0x60
10001f62:	2102      	movs	r1, #2
10001f64:	438a      	bics	r2, r1
10001f66:	661a      	str	r2, [r3, #96]	; 0x60
				 PORT2->IOCR0 &= 0xffff00ff;
10001f68:	4b3e      	ldr	r3, [pc, #248]	; (10002064 <bit_init_mode+0x748>)
10001f6a:	4a3e      	ldr	r2, [pc, #248]	; (10002064 <bit_init_mode+0x748>)
10001f6c:	6912      	ldr	r2, [r2, #16]
10001f6e:	493e      	ldr	r1, [pc, #248]	; (10002068 <bit_init_mode+0x74c>)
10001f70:	400a      	ands	r2, r1
10001f72:	611a      	str	r2, [r3, #16]
				 PORT2->IOCR0 |= 0x00008000;
10001f74:	4b3b      	ldr	r3, [pc, #236]	; (10002064 <bit_init_mode+0x748>)
10001f76:	4a3b      	ldr	r2, [pc, #236]	; (10002064 <bit_init_mode+0x748>)
10001f78:	6912      	ldr	r2, [r2, #16]
10001f7a:	2180      	movs	r1, #128	; 0x80
10001f7c:	0209      	lsls	r1, r1, #8
10001f7e:	430a      	orrs	r2, r1
10001f80:	611a      	str	r2, [r3, #16]
10001f82:	e037      	b.n	10001ff4 <bit_init_mode+0x6d8>
			 } else if (direction == INP) {
10001f84:	1d7b      	adds	r3, r7, #5
10001f86:	781b      	ldrb	r3, [r3, #0]
10001f88:	2b00      	cmp	r3, #0
10001f8a:	d133      	bne.n	10001ff4 <bit_init_mode+0x6d8>
				 CLR_BIT(PORT2->PDISC,1); // digital Pad aktiv
10001f8c:	4b35      	ldr	r3, [pc, #212]	; (10002064 <bit_init_mode+0x748>)
10001f8e:	4a35      	ldr	r2, [pc, #212]	; (10002064 <bit_init_mode+0x748>)
10001f90:	6e12      	ldr	r2, [r2, #96]	; 0x60
10001f92:	2102      	movs	r1, #2
10001f94:	438a      	bics	r2, r1
10001f96:	661a      	str	r2, [r3, #96]	; 0x60
				 if (mode==PULLUP) {
10001f98:	1d3b      	adds	r3, r7, #4
10001f9a:	781b      	ldrb	r3, [r3, #0]
10001f9c:	2b01      	cmp	r3, #1
10001f9e:	d10d      	bne.n	10001fbc <bit_init_mode+0x6a0>
					 PORT2->IOCR0 &= 0xFFFF00ff;
10001fa0:	4b30      	ldr	r3, [pc, #192]	; (10002064 <bit_init_mode+0x748>)
10001fa2:	4a30      	ldr	r2, [pc, #192]	; (10002064 <bit_init_mode+0x748>)
10001fa4:	6912      	ldr	r2, [r2, #16]
10001fa6:	4930      	ldr	r1, [pc, #192]	; (10002068 <bit_init_mode+0x74c>)
10001fa8:	400a      	ands	r2, r1
10001faa:	611a      	str	r2, [r3, #16]
					 PORT2->IOCR0 |= 0x00001000;
10001fac:	4b2d      	ldr	r3, [pc, #180]	; (10002064 <bit_init_mode+0x748>)
10001fae:	4a2d      	ldr	r2, [pc, #180]	; (10002064 <bit_init_mode+0x748>)
10001fb0:	6912      	ldr	r2, [r2, #16]
10001fb2:	2180      	movs	r1, #128	; 0x80
10001fb4:	0149      	lsls	r1, r1, #5
10001fb6:	430a      	orrs	r2, r1
10001fb8:	611a      	str	r2, [r3, #16]
10001fba:	e01b      	b.n	10001ff4 <bit_init_mode+0x6d8>
				 } else if (mode==PULLDOWN) {
10001fbc:	1d3b      	adds	r3, r7, #4
10001fbe:	781b      	ldrb	r3, [r3, #0]
10001fc0:	2b02      	cmp	r3, #2
10001fc2:	d10d      	bne.n	10001fe0 <bit_init_mode+0x6c4>
					 PORT2->IOCR0 &= 0xFFFF00ff;
10001fc4:	4b27      	ldr	r3, [pc, #156]	; (10002064 <bit_init_mode+0x748>)
10001fc6:	4a27      	ldr	r2, [pc, #156]	; (10002064 <bit_init_mode+0x748>)
10001fc8:	6912      	ldr	r2, [r2, #16]
10001fca:	4927      	ldr	r1, [pc, #156]	; (10002068 <bit_init_mode+0x74c>)
10001fcc:	400a      	ands	r2, r1
10001fce:	611a      	str	r2, [r3, #16]
					 PORT2->IOCR0 |= 0x00000800;
10001fd0:	4b24      	ldr	r3, [pc, #144]	; (10002064 <bit_init_mode+0x748>)
10001fd2:	4a24      	ldr	r2, [pc, #144]	; (10002064 <bit_init_mode+0x748>)
10001fd4:	6912      	ldr	r2, [r2, #16]
10001fd6:	2180      	movs	r1, #128	; 0x80
10001fd8:	0109      	lsls	r1, r1, #4
10001fda:	430a      	orrs	r2, r1
10001fdc:	611a      	str	r2, [r3, #16]
10001fde:	e009      	b.n	10001ff4 <bit_init_mode+0x6d8>
				 } else if (mode == ANALOG) {
10001fe0:	1d3b      	adds	r3, r7, #4
10001fe2:	781b      	ldrb	r3, [r3, #0]
10001fe4:	2b03      	cmp	r3, #3
10001fe6:	d105      	bne.n	10001ff4 <bit_init_mode+0x6d8>
					SET_BIT(PORT2->PDISC,1); //Analog Modus aktiv
10001fe8:	4b1e      	ldr	r3, [pc, #120]	; (10002064 <bit_init_mode+0x748>)
10001fea:	4a1e      	ldr	r2, [pc, #120]	; (10002064 <bit_init_mode+0x748>)
10001fec:	6e12      	ldr	r2, [r2, #96]	; 0x60
10001fee:	2102      	movs	r1, #2
10001ff0:	430a      	orrs	r2, r1
10001ff2:	661a      	str	r2, [r3, #96]	; 0x60
				 }
			 }
		 }
		 if (bitnr == 2) { //P2.2
10001ff4:	1dbb      	adds	r3, r7, #6
10001ff6:	781b      	ldrb	r3, [r3, #0]
10001ff8:	2b02      	cmp	r3, #2
10001ffa:	d143      	bne.n	10002084 <bit_init_mode+0x768>
			 if (direction == OUTP) {
10001ffc:	1d7b      	adds	r3, r7, #5
10001ffe:	781b      	ldrb	r3, [r3, #0]
10002000:	2b01      	cmp	r3, #1
10002002:	d03f      	beq.n	10002084 <bit_init_mode+0x768>
				 // nicht moeglich
			 } else if (direction == INP) {
10002004:	1d7b      	adds	r3, r7, #5
10002006:	781b      	ldrb	r3, [r3, #0]
10002008:	2b00      	cmp	r3, #0
1000200a:	d13b      	bne.n	10002084 <bit_init_mode+0x768>
				 CLR_BIT(PORT2->PDISC,2); // digital Pad aktiv
1000200c:	4b15      	ldr	r3, [pc, #84]	; (10002064 <bit_init_mode+0x748>)
1000200e:	4a15      	ldr	r2, [pc, #84]	; (10002064 <bit_init_mode+0x748>)
10002010:	6e12      	ldr	r2, [r2, #96]	; 0x60
10002012:	2104      	movs	r1, #4
10002014:	438a      	bics	r2, r1
10002016:	661a      	str	r2, [r3, #96]	; 0x60
				 if (mode==PULLUP) {
10002018:	1d3b      	adds	r3, r7, #4
1000201a:	781b      	ldrb	r3, [r3, #0]
1000201c:	2b01      	cmp	r3, #1
1000201e:	d10d      	bne.n	1000203c <bit_init_mode+0x720>
					 PORT2->IOCR0 &= 0xFF00ffff;
10002020:	4b10      	ldr	r3, [pc, #64]	; (10002064 <bit_init_mode+0x748>)
10002022:	4a10      	ldr	r2, [pc, #64]	; (10002064 <bit_init_mode+0x748>)
10002024:	6912      	ldr	r2, [r2, #16]
10002026:	4911      	ldr	r1, [pc, #68]	; (1000206c <bit_init_mode+0x750>)
10002028:	400a      	ands	r2, r1
1000202a:	611a      	str	r2, [r3, #16]
					 PORT2->IOCR0 |= 0x00100000;
1000202c:	4b0d      	ldr	r3, [pc, #52]	; (10002064 <bit_init_mode+0x748>)
1000202e:	4a0d      	ldr	r2, [pc, #52]	; (10002064 <bit_init_mode+0x748>)
10002030:	6912      	ldr	r2, [r2, #16]
10002032:	2180      	movs	r1, #128	; 0x80
10002034:	0349      	lsls	r1, r1, #13
10002036:	430a      	orrs	r2, r1
10002038:	611a      	str	r2, [r3, #16]
1000203a:	e023      	b.n	10002084 <bit_init_mode+0x768>
				 } else if (mode==PULLDOWN) {
1000203c:	1d3b      	adds	r3, r7, #4
1000203e:	781b      	ldrb	r3, [r3, #0]
10002040:	2b02      	cmp	r3, #2
10002042:	d115      	bne.n	10002070 <bit_init_mode+0x754>
					 PORT2->IOCR0 &= 0xFF00ffff;
10002044:	4b07      	ldr	r3, [pc, #28]	; (10002064 <bit_init_mode+0x748>)
10002046:	4a07      	ldr	r2, [pc, #28]	; (10002064 <bit_init_mode+0x748>)
10002048:	6912      	ldr	r2, [r2, #16]
1000204a:	4908      	ldr	r1, [pc, #32]	; (1000206c <bit_init_mode+0x750>)
1000204c:	400a      	ands	r2, r1
1000204e:	611a      	str	r2, [r3, #16]
					 PORT2->IOCR0 |= 0x00080000;
10002050:	4b04      	ldr	r3, [pc, #16]	; (10002064 <bit_init_mode+0x748>)
10002052:	4a04      	ldr	r2, [pc, #16]	; (10002064 <bit_init_mode+0x748>)
10002054:	6912      	ldr	r2, [r2, #16]
10002056:	2180      	movs	r1, #128	; 0x80
10002058:	0309      	lsls	r1, r1, #12
1000205a:	430a      	orrs	r2, r1
1000205c:	611a      	str	r2, [r3, #16]
1000205e:	e011      	b.n	10002084 <bit_init_mode+0x768>
10002060:	40040100 	.word	0x40040100
10002064:	40040200 	.word	0x40040200
10002068:	ffff00ff 	.word	0xffff00ff
1000206c:	ff00ffff 	.word	0xff00ffff
				 } else if (mode == ANALOG) {
10002070:	1d3b      	adds	r3, r7, #4
10002072:	781b      	ldrb	r3, [r3, #0]
10002074:	2b03      	cmp	r3, #3
10002076:	d105      	bne.n	10002084 <bit_init_mode+0x768>
					SET_BIT(PORT2->PDISC,2); //Analog Modus aktiv
10002078:	4bcd      	ldr	r3, [pc, #820]	; (100023b0 <bit_init_mode+0xa94>)
1000207a:	4acd      	ldr	r2, [pc, #820]	; (100023b0 <bit_init_mode+0xa94>)
1000207c:	6e12      	ldr	r2, [r2, #96]	; 0x60
1000207e:	2104      	movs	r1, #4
10002080:	430a      	orrs	r2, r1
10002082:	661a      	str	r2, [r3, #96]	; 0x60
				 }
			 }
		 }
		 if (bitnr == 3) { //P2.3
10002084:	1dbb      	adds	r3, r7, #6
10002086:	781b      	ldrb	r3, [r3, #0]
10002088:	2b03      	cmp	r3, #3
1000208a:	d13b      	bne.n	10002104 <bit_init_mode+0x7e8>
			 if (direction == OUTP) {
1000208c:	1d7b      	adds	r3, r7, #5
1000208e:	781b      	ldrb	r3, [r3, #0]
10002090:	2b01      	cmp	r3, #1
10002092:	d037      	beq.n	10002104 <bit_init_mode+0x7e8>
				 // nicht moeglich
			 } else if (direction == INP) {
10002094:	1d7b      	adds	r3, r7, #5
10002096:	781b      	ldrb	r3, [r3, #0]
10002098:	2b00      	cmp	r3, #0
1000209a:	d133      	bne.n	10002104 <bit_init_mode+0x7e8>
				 CLR_BIT(PORT2->PDISC,3); // digital Pad aktiv
1000209c:	4bc4      	ldr	r3, [pc, #784]	; (100023b0 <bit_init_mode+0xa94>)
1000209e:	4ac4      	ldr	r2, [pc, #784]	; (100023b0 <bit_init_mode+0xa94>)
100020a0:	6e12      	ldr	r2, [r2, #96]	; 0x60
100020a2:	2108      	movs	r1, #8
100020a4:	438a      	bics	r2, r1
100020a6:	661a      	str	r2, [r3, #96]	; 0x60
				 if (mode==PULLUP) {
100020a8:	1d3b      	adds	r3, r7, #4
100020aa:	781b      	ldrb	r3, [r3, #0]
100020ac:	2b01      	cmp	r3, #1
100020ae:	d10d      	bne.n	100020cc <bit_init_mode+0x7b0>
					 PORT2->IOCR0 &= 0x00ffffff;
100020b0:	4bbf      	ldr	r3, [pc, #764]	; (100023b0 <bit_init_mode+0xa94>)
100020b2:	4abf      	ldr	r2, [pc, #764]	; (100023b0 <bit_init_mode+0xa94>)
100020b4:	6912      	ldr	r2, [r2, #16]
100020b6:	0212      	lsls	r2, r2, #8
100020b8:	0a12      	lsrs	r2, r2, #8
100020ba:	611a      	str	r2, [r3, #16]
					 PORT2->IOCR0 |= 0x10000000;
100020bc:	4bbc      	ldr	r3, [pc, #752]	; (100023b0 <bit_init_mode+0xa94>)
100020be:	4abc      	ldr	r2, [pc, #752]	; (100023b0 <bit_init_mode+0xa94>)
100020c0:	6912      	ldr	r2, [r2, #16]
100020c2:	2180      	movs	r1, #128	; 0x80
100020c4:	0549      	lsls	r1, r1, #21
100020c6:	430a      	orrs	r2, r1
100020c8:	611a      	str	r2, [r3, #16]
100020ca:	e01b      	b.n	10002104 <bit_init_mode+0x7e8>
				 } else if (mode==PULLDOWN) {
100020cc:	1d3b      	adds	r3, r7, #4
100020ce:	781b      	ldrb	r3, [r3, #0]
100020d0:	2b02      	cmp	r3, #2
100020d2:	d10d      	bne.n	100020f0 <bit_init_mode+0x7d4>
					 PORT2->IOCR0 &= 0x00ffffff;
100020d4:	4bb6      	ldr	r3, [pc, #728]	; (100023b0 <bit_init_mode+0xa94>)
100020d6:	4ab6      	ldr	r2, [pc, #728]	; (100023b0 <bit_init_mode+0xa94>)
100020d8:	6912      	ldr	r2, [r2, #16]
100020da:	0212      	lsls	r2, r2, #8
100020dc:	0a12      	lsrs	r2, r2, #8
100020de:	611a      	str	r2, [r3, #16]
					 PORT2->IOCR0 |= 0x08000000;
100020e0:	4bb3      	ldr	r3, [pc, #716]	; (100023b0 <bit_init_mode+0xa94>)
100020e2:	4ab3      	ldr	r2, [pc, #716]	; (100023b0 <bit_init_mode+0xa94>)
100020e4:	6912      	ldr	r2, [r2, #16]
100020e6:	2180      	movs	r1, #128	; 0x80
100020e8:	0509      	lsls	r1, r1, #20
100020ea:	430a      	orrs	r2, r1
100020ec:	611a      	str	r2, [r3, #16]
100020ee:	e009      	b.n	10002104 <bit_init_mode+0x7e8>
				 } else if (mode == ANALOG) {
100020f0:	1d3b      	adds	r3, r7, #4
100020f2:	781b      	ldrb	r3, [r3, #0]
100020f4:	2b03      	cmp	r3, #3
100020f6:	d105      	bne.n	10002104 <bit_init_mode+0x7e8>
					SET_BIT(PORT2->PDISC,3); //Analog Modus aktiv
100020f8:	4bad      	ldr	r3, [pc, #692]	; (100023b0 <bit_init_mode+0xa94>)
100020fa:	4aad      	ldr	r2, [pc, #692]	; (100023b0 <bit_init_mode+0xa94>)
100020fc:	6e12      	ldr	r2, [r2, #96]	; 0x60
100020fe:	2108      	movs	r1, #8
10002100:	430a      	orrs	r2, r1
10002102:	661a      	str	r2, [r3, #96]	; 0x60
				 }
			 }
		 }
		 if ((bitnr > 3) && (bitnr < 8)) { //P2.4 bis P2.7
10002104:	1dbb      	adds	r3, r7, #6
10002106:	781b      	ldrb	r3, [r3, #0]
10002108:	2b03      	cmp	r3, #3
1000210a:	d960      	bls.n	100021ce <bit_init_mode+0x8b2>
1000210c:	1dbb      	adds	r3, r7, #6
1000210e:	781b      	ldrb	r3, [r3, #0]
10002110:	2b07      	cmp	r3, #7
10002112:	d85c      	bhi.n	100021ce <bit_init_mode+0x8b2>
			 if (direction == OUTP) {
10002114:	1d7b      	adds	r3, r7, #5
10002116:	781b      	ldrb	r3, [r3, #0]
10002118:	2b01      	cmp	r3, #1
1000211a:	d058      	beq.n	100021ce <bit_init_mode+0x8b2>
				 // nicht moeglich
			 } else if (direction == INP) {
1000211c:	1d7b      	adds	r3, r7, #5
1000211e:	781b      	ldrb	r3, [r3, #0]
10002120:	2b00      	cmp	r3, #0
10002122:	d154      	bne.n	100021ce <bit_init_mode+0x8b2>
				 CLR_BIT(PORT2->PDISC,bitnr); // digital Pad aktiv
10002124:	4ba2      	ldr	r3, [pc, #648]	; (100023b0 <bit_init_mode+0xa94>)
10002126:	4aa2      	ldr	r2, [pc, #648]	; (100023b0 <bit_init_mode+0xa94>)
10002128:	6e12      	ldr	r2, [r2, #96]	; 0x60
1000212a:	1db9      	adds	r1, r7, #6
1000212c:	7809      	ldrb	r1, [r1, #0]
1000212e:	2001      	movs	r0, #1
10002130:	4088      	lsls	r0, r1
10002132:	1c01      	adds	r1, r0, #0
10002134:	43c9      	mvns	r1, r1
10002136:	400a      	ands	r2, r1
10002138:	661a      	str	r2, [r3, #96]	; 0x60
				 if (mode==PULLUP) {
1000213a:	1d3b      	adds	r3, r7, #4
1000213c:	781b      	ldrb	r3, [r3, #0]
1000213e:	2b01      	cmp	r3, #1
10002140:	d119      	bne.n	10002176 <bit_init_mode+0x85a>
					 PORT2->IOCR4 &= ~(0xff<<((bitnr-4)*8)); //PORT2->IOCR1 &= 0xffffff00;
10002142:	4b9b      	ldr	r3, [pc, #620]	; (100023b0 <bit_init_mode+0xa94>)
10002144:	4a9a      	ldr	r2, [pc, #616]	; (100023b0 <bit_init_mode+0xa94>)
10002146:	6952      	ldr	r2, [r2, #20]
10002148:	1db9      	adds	r1, r7, #6
1000214a:	7809      	ldrb	r1, [r1, #0]
1000214c:	3904      	subs	r1, #4
1000214e:	00c9      	lsls	r1, r1, #3
10002150:	20ff      	movs	r0, #255	; 0xff
10002152:	4088      	lsls	r0, r1
10002154:	1c01      	adds	r1, r0, #0
10002156:	43c9      	mvns	r1, r1
10002158:	400a      	ands	r2, r1
1000215a:	615a      	str	r2, [r3, #20]
					 PORT2->IOCR4 |= 0x10<<((bitnr-4)*8);    //PORT2->IOCR4 |= 0x00000010;
1000215c:	4b94      	ldr	r3, [pc, #592]	; (100023b0 <bit_init_mode+0xa94>)
1000215e:	4a94      	ldr	r2, [pc, #592]	; (100023b0 <bit_init_mode+0xa94>)
10002160:	6952      	ldr	r2, [r2, #20]
10002162:	1db9      	adds	r1, r7, #6
10002164:	7809      	ldrb	r1, [r1, #0]
10002166:	3904      	subs	r1, #4
10002168:	00c9      	lsls	r1, r1, #3
1000216a:	2010      	movs	r0, #16
1000216c:	4088      	lsls	r0, r1
1000216e:	1c01      	adds	r1, r0, #0
10002170:	430a      	orrs	r2, r1
10002172:	615a      	str	r2, [r3, #20]
10002174:	e02b      	b.n	100021ce <bit_init_mode+0x8b2>
				 } else if (mode==PULLDOWN) {
10002176:	1d3b      	adds	r3, r7, #4
10002178:	781b      	ldrb	r3, [r3, #0]
1000217a:	2b02      	cmp	r3, #2
1000217c:	d119      	bne.n	100021b2 <bit_init_mode+0x896>
					 PORT2->IOCR4 &= ~(0xff<<((bitnr-4)*8)); //PORT2->IOCR1 &= 0xffffff00;
1000217e:	4b8c      	ldr	r3, [pc, #560]	; (100023b0 <bit_init_mode+0xa94>)
10002180:	4a8b      	ldr	r2, [pc, #556]	; (100023b0 <bit_init_mode+0xa94>)
10002182:	6952      	ldr	r2, [r2, #20]
10002184:	1db9      	adds	r1, r7, #6
10002186:	7809      	ldrb	r1, [r1, #0]
10002188:	3904      	subs	r1, #4
1000218a:	00c9      	lsls	r1, r1, #3
1000218c:	20ff      	movs	r0, #255	; 0xff
1000218e:	4088      	lsls	r0, r1
10002190:	1c01      	adds	r1, r0, #0
10002192:	43c9      	mvns	r1, r1
10002194:	400a      	ands	r2, r1
10002196:	615a      	str	r2, [r3, #20]
					 PORT2->IOCR4 |= 0x08<<((bitnr-4)*8);    //PORT2->IOCR4 |= 0x00000010;
10002198:	4b85      	ldr	r3, [pc, #532]	; (100023b0 <bit_init_mode+0xa94>)
1000219a:	4a85      	ldr	r2, [pc, #532]	; (100023b0 <bit_init_mode+0xa94>)
1000219c:	6952      	ldr	r2, [r2, #20]
1000219e:	1db9      	adds	r1, r7, #6
100021a0:	7809      	ldrb	r1, [r1, #0]
100021a2:	3904      	subs	r1, #4
100021a4:	00c9      	lsls	r1, r1, #3
100021a6:	2008      	movs	r0, #8
100021a8:	4088      	lsls	r0, r1
100021aa:	1c01      	adds	r1, r0, #0
100021ac:	430a      	orrs	r2, r1
100021ae:	615a      	str	r2, [r3, #20]
100021b0:	e00d      	b.n	100021ce <bit_init_mode+0x8b2>
				 } else if (mode == ANALOG) {
100021b2:	1d3b      	adds	r3, r7, #4
100021b4:	781b      	ldrb	r3, [r3, #0]
100021b6:	2b03      	cmp	r3, #3
100021b8:	d109      	bne.n	100021ce <bit_init_mode+0x8b2>
					 SET_BIT(PORT2->PDISC,bitnr); //Analog Modus aktiv
100021ba:	4b7d      	ldr	r3, [pc, #500]	; (100023b0 <bit_init_mode+0xa94>)
100021bc:	4a7c      	ldr	r2, [pc, #496]	; (100023b0 <bit_init_mode+0xa94>)
100021be:	6e11      	ldr	r1, [r2, #96]	; 0x60
100021c0:	1dba      	adds	r2, r7, #6
100021c2:	7812      	ldrb	r2, [r2, #0]
100021c4:	2001      	movs	r0, #1
100021c6:	4090      	lsls	r0, r2
100021c8:	1c02      	adds	r2, r0, #0
100021ca:	430a      	orrs	r2, r1
100021cc:	661a      	str	r2, [r3, #96]	; 0x60
				 }
			 }
		 }
		 if (bitnr == 8) { //P2.8
100021ce:	1dbb      	adds	r3, r7, #6
100021d0:	781b      	ldrb	r3, [r3, #0]
100021d2:	2b08      	cmp	r3, #8
100021d4:	d14d      	bne.n	10002272 <bit_init_mode+0x956>
			if (direction == OUTP) {
100021d6:	1d7b      	adds	r3, r7, #5
100021d8:	781b      	ldrb	r3, [r3, #0]
100021da:	2b01      	cmp	r3, #1
100021dc:	d112      	bne.n	10002204 <bit_init_mode+0x8e8>
				CLR_BIT(PORT2->PDISC,8); // digital Pad aktiv
100021de:	4b74      	ldr	r3, [pc, #464]	; (100023b0 <bit_init_mode+0xa94>)
100021e0:	4a73      	ldr	r2, [pc, #460]	; (100023b0 <bit_init_mode+0xa94>)
100021e2:	6e12      	ldr	r2, [r2, #96]	; 0x60
100021e4:	4973      	ldr	r1, [pc, #460]	; (100023b4 <bit_init_mode+0xa98>)
100021e6:	400a      	ands	r2, r1
100021e8:	661a      	str	r2, [r3, #96]	; 0x60
				PORT2->IOCR8 &= 0xffffff00;
100021ea:	4b71      	ldr	r3, [pc, #452]	; (100023b0 <bit_init_mode+0xa94>)
100021ec:	4a70      	ldr	r2, [pc, #448]	; (100023b0 <bit_init_mode+0xa94>)
100021ee:	6992      	ldr	r2, [r2, #24]
100021f0:	21ff      	movs	r1, #255	; 0xff
100021f2:	438a      	bics	r2, r1
100021f4:	619a      	str	r2, [r3, #24]
				PORT2->IOCR8 |= 0x00000080;
100021f6:	4b6e      	ldr	r3, [pc, #440]	; (100023b0 <bit_init_mode+0xa94>)
100021f8:	4a6d      	ldr	r2, [pc, #436]	; (100023b0 <bit_init_mode+0xa94>)
100021fa:	6992      	ldr	r2, [r2, #24]
100021fc:	2180      	movs	r1, #128	; 0x80
100021fe:	430a      	orrs	r2, r1
10002200:	619a      	str	r2, [r3, #24]
10002202:	e036      	b.n	10002272 <bit_init_mode+0x956>
			} else if (direction == INP) {
10002204:	1d7b      	adds	r3, r7, #5
10002206:	781b      	ldrb	r3, [r3, #0]
10002208:	2b00      	cmp	r3, #0
1000220a:	d132      	bne.n	10002272 <bit_init_mode+0x956>
				CLR_BIT(PORT2->PDISC,8); // digital Pad aktiv
1000220c:	4b68      	ldr	r3, [pc, #416]	; (100023b0 <bit_init_mode+0xa94>)
1000220e:	4a68      	ldr	r2, [pc, #416]	; (100023b0 <bit_init_mode+0xa94>)
10002210:	6e12      	ldr	r2, [r2, #96]	; 0x60
10002212:	4968      	ldr	r1, [pc, #416]	; (100023b4 <bit_init_mode+0xa98>)
10002214:	400a      	ands	r2, r1
10002216:	661a      	str	r2, [r3, #96]	; 0x60
				if (mode==PULLUP) {
10002218:	1d3b      	adds	r3, r7, #4
1000221a:	781b      	ldrb	r3, [r3, #0]
1000221c:	2b01      	cmp	r3, #1
1000221e:	d10c      	bne.n	1000223a <bit_init_mode+0x91e>
					PORT2->IOCR8 &= 0xFFFFFF00;
10002220:	4b63      	ldr	r3, [pc, #396]	; (100023b0 <bit_init_mode+0xa94>)
10002222:	4a63      	ldr	r2, [pc, #396]	; (100023b0 <bit_init_mode+0xa94>)
10002224:	6992      	ldr	r2, [r2, #24]
10002226:	21ff      	movs	r1, #255	; 0xff
10002228:	438a      	bics	r2, r1
1000222a:	619a      	str	r2, [r3, #24]
					PORT2->IOCR8 |= 0x00000010;
1000222c:	4b60      	ldr	r3, [pc, #384]	; (100023b0 <bit_init_mode+0xa94>)
1000222e:	4a60      	ldr	r2, [pc, #384]	; (100023b0 <bit_init_mode+0xa94>)
10002230:	6992      	ldr	r2, [r2, #24]
10002232:	2110      	movs	r1, #16
10002234:	430a      	orrs	r2, r1
10002236:	619a      	str	r2, [r3, #24]
10002238:	e01b      	b.n	10002272 <bit_init_mode+0x956>
				} else if (mode==PULLDOWN) {
1000223a:	1d3b      	adds	r3, r7, #4
1000223c:	781b      	ldrb	r3, [r3, #0]
1000223e:	2b02      	cmp	r3, #2
10002240:	d10c      	bne.n	1000225c <bit_init_mode+0x940>
					PORT2->IOCR8 &= 0xFFFFFF00;
10002242:	4b5b      	ldr	r3, [pc, #364]	; (100023b0 <bit_init_mode+0xa94>)
10002244:	4a5a      	ldr	r2, [pc, #360]	; (100023b0 <bit_init_mode+0xa94>)
10002246:	6992      	ldr	r2, [r2, #24]
10002248:	21ff      	movs	r1, #255	; 0xff
1000224a:	438a      	bics	r2, r1
1000224c:	619a      	str	r2, [r3, #24]
					PORT2->IOCR8 |= 0x00000008;
1000224e:	4b58      	ldr	r3, [pc, #352]	; (100023b0 <bit_init_mode+0xa94>)
10002250:	4a57      	ldr	r2, [pc, #348]	; (100023b0 <bit_init_mode+0xa94>)
10002252:	6992      	ldr	r2, [r2, #24]
10002254:	2108      	movs	r1, #8
10002256:	430a      	orrs	r2, r1
10002258:	619a      	str	r2, [r3, #24]
1000225a:	e00a      	b.n	10002272 <bit_init_mode+0x956>
				} else if (mode == ANALOG) {
1000225c:	1d3b      	adds	r3, r7, #4
1000225e:	781b      	ldrb	r3, [r3, #0]
10002260:	2b03      	cmp	r3, #3
10002262:	d106      	bne.n	10002272 <bit_init_mode+0x956>
					SET_BIT(PORT2->PDISC,8); //Analog Modus aktiv
10002264:	4b52      	ldr	r3, [pc, #328]	; (100023b0 <bit_init_mode+0xa94>)
10002266:	4a52      	ldr	r2, [pc, #328]	; (100023b0 <bit_init_mode+0xa94>)
10002268:	6e12      	ldr	r2, [r2, #96]	; 0x60
1000226a:	2180      	movs	r1, #128	; 0x80
1000226c:	0049      	lsls	r1, r1, #1
1000226e:	430a      	orrs	r2, r1
10002270:	661a      	str	r2, [r3, #96]	; 0x60
				}
			}
		 }
		 if (bitnr == 9) { //P2.9
10002272:	1dbb      	adds	r3, r7, #6
10002274:	781b      	ldrb	r3, [r3, #0]
10002276:	2b09      	cmp	r3, #9
10002278:	d150      	bne.n	1000231c <bit_init_mode+0xa00>
			if (direction == OUTP) {
1000227a:	1d7b      	adds	r3, r7, #5
1000227c:	781b      	ldrb	r3, [r3, #0]
1000227e:	2b01      	cmp	r3, #1
10002280:	d113      	bne.n	100022aa <bit_init_mode+0x98e>
				CLR_BIT(PORT2->PDISC,9); // digital Pad aktiv
10002282:	4b4b      	ldr	r3, [pc, #300]	; (100023b0 <bit_init_mode+0xa94>)
10002284:	4a4a      	ldr	r2, [pc, #296]	; (100023b0 <bit_init_mode+0xa94>)
10002286:	6e12      	ldr	r2, [r2, #96]	; 0x60
10002288:	494b      	ldr	r1, [pc, #300]	; (100023b8 <bit_init_mode+0xa9c>)
1000228a:	400a      	ands	r2, r1
1000228c:	661a      	str	r2, [r3, #96]	; 0x60
				PORT2->IOCR8 &= 0xffff00ff;
1000228e:	4b48      	ldr	r3, [pc, #288]	; (100023b0 <bit_init_mode+0xa94>)
10002290:	4a47      	ldr	r2, [pc, #284]	; (100023b0 <bit_init_mode+0xa94>)
10002292:	6992      	ldr	r2, [r2, #24]
10002294:	4949      	ldr	r1, [pc, #292]	; (100023bc <bit_init_mode+0xaa0>)
10002296:	400a      	ands	r2, r1
10002298:	619a      	str	r2, [r3, #24]
				PORT2->IOCR8 |= 0x00008000;
1000229a:	4b45      	ldr	r3, [pc, #276]	; (100023b0 <bit_init_mode+0xa94>)
1000229c:	4a44      	ldr	r2, [pc, #272]	; (100023b0 <bit_init_mode+0xa94>)
1000229e:	6992      	ldr	r2, [r2, #24]
100022a0:	2180      	movs	r1, #128	; 0x80
100022a2:	0209      	lsls	r1, r1, #8
100022a4:	430a      	orrs	r2, r1
100022a6:	619a      	str	r2, [r3, #24]
100022a8:	e038      	b.n	1000231c <bit_init_mode+0xa00>
			} else if (direction == INP) {
100022aa:	1d7b      	adds	r3, r7, #5
100022ac:	781b      	ldrb	r3, [r3, #0]
100022ae:	2b00      	cmp	r3, #0
100022b0:	d134      	bne.n	1000231c <bit_init_mode+0xa00>
				CLR_BIT(PORT2->PDISC,9); // digital Pad aktiv
100022b2:	4b3f      	ldr	r3, [pc, #252]	; (100023b0 <bit_init_mode+0xa94>)
100022b4:	4a3e      	ldr	r2, [pc, #248]	; (100023b0 <bit_init_mode+0xa94>)
100022b6:	6e12      	ldr	r2, [r2, #96]	; 0x60
100022b8:	493f      	ldr	r1, [pc, #252]	; (100023b8 <bit_init_mode+0xa9c>)
100022ba:	400a      	ands	r2, r1
100022bc:	661a      	str	r2, [r3, #96]	; 0x60
				if (mode==PULLUP) {
100022be:	1d3b      	adds	r3, r7, #4
100022c0:	781b      	ldrb	r3, [r3, #0]
100022c2:	2b01      	cmp	r3, #1
100022c4:	d10d      	bne.n	100022e2 <bit_init_mode+0x9c6>
					PORT2->IOCR8 &= 0xFFFF00FF;
100022c6:	4b3a      	ldr	r3, [pc, #232]	; (100023b0 <bit_init_mode+0xa94>)
100022c8:	4a39      	ldr	r2, [pc, #228]	; (100023b0 <bit_init_mode+0xa94>)
100022ca:	6992      	ldr	r2, [r2, #24]
100022cc:	493b      	ldr	r1, [pc, #236]	; (100023bc <bit_init_mode+0xaa0>)
100022ce:	400a      	ands	r2, r1
100022d0:	619a      	str	r2, [r3, #24]
					PORT2->IOCR8 |= 0x00001000;
100022d2:	4b37      	ldr	r3, [pc, #220]	; (100023b0 <bit_init_mode+0xa94>)
100022d4:	4a36      	ldr	r2, [pc, #216]	; (100023b0 <bit_init_mode+0xa94>)
100022d6:	6992      	ldr	r2, [r2, #24]
100022d8:	2180      	movs	r1, #128	; 0x80
100022da:	0149      	lsls	r1, r1, #5
100022dc:	430a      	orrs	r2, r1
100022de:	619a      	str	r2, [r3, #24]
100022e0:	e01c      	b.n	1000231c <bit_init_mode+0xa00>
				} else if (mode==PULLDOWN) {
100022e2:	1d3b      	adds	r3, r7, #4
100022e4:	781b      	ldrb	r3, [r3, #0]
100022e6:	2b02      	cmp	r3, #2
100022e8:	d10d      	bne.n	10002306 <bit_init_mode+0x9ea>
					PORT2->IOCR8 &= 0xFFFF00FF;
100022ea:	4b31      	ldr	r3, [pc, #196]	; (100023b0 <bit_init_mode+0xa94>)
100022ec:	4a30      	ldr	r2, [pc, #192]	; (100023b0 <bit_init_mode+0xa94>)
100022ee:	6992      	ldr	r2, [r2, #24]
100022f0:	4932      	ldr	r1, [pc, #200]	; (100023bc <bit_init_mode+0xaa0>)
100022f2:	400a      	ands	r2, r1
100022f4:	619a      	str	r2, [r3, #24]
					PORT2->IOCR8 |= 0x00000800;
100022f6:	4b2e      	ldr	r3, [pc, #184]	; (100023b0 <bit_init_mode+0xa94>)
100022f8:	4a2d      	ldr	r2, [pc, #180]	; (100023b0 <bit_init_mode+0xa94>)
100022fa:	6992      	ldr	r2, [r2, #24]
100022fc:	2180      	movs	r1, #128	; 0x80
100022fe:	0109      	lsls	r1, r1, #4
10002300:	430a      	orrs	r2, r1
10002302:	619a      	str	r2, [r3, #24]
10002304:	e00a      	b.n	1000231c <bit_init_mode+0xa00>
				} else if (mode == ANALOG) {
10002306:	1d3b      	adds	r3, r7, #4
10002308:	781b      	ldrb	r3, [r3, #0]
1000230a:	2b03      	cmp	r3, #3
1000230c:	d106      	bne.n	1000231c <bit_init_mode+0xa00>
					SET_BIT(PORT2->PDISC,9); //Analog Modus aktiv
1000230e:	4b28      	ldr	r3, [pc, #160]	; (100023b0 <bit_init_mode+0xa94>)
10002310:	4a27      	ldr	r2, [pc, #156]	; (100023b0 <bit_init_mode+0xa94>)
10002312:	6e12      	ldr	r2, [r2, #96]	; 0x60
10002314:	2180      	movs	r1, #128	; 0x80
10002316:	0089      	lsls	r1, r1, #2
10002318:	430a      	orrs	r2, r1
1000231a:	661a      	str	r2, [r3, #96]	; 0x60
				}
			}
		 }
		 if (bitnr == 10) { //P2.10
1000231c:	1dbb      	adds	r3, r7, #6
1000231e:	781b      	ldrb	r3, [r3, #0]
10002320:	2b0a      	cmp	r3, #10
10002322:	d15c      	bne.n	100023de <bit_init_mode+0xac2>
			 if (direction == OUTP) {
10002324:	1d7b      	adds	r3, r7, #5
10002326:	781b      	ldrb	r3, [r3, #0]
10002328:	2b01      	cmp	r3, #1
1000232a:	d113      	bne.n	10002354 <bit_init_mode+0xa38>
				 CLR_BIT(PORT2->PDISC,10); // digital Pad aktiv
1000232c:	4b20      	ldr	r3, [pc, #128]	; (100023b0 <bit_init_mode+0xa94>)
1000232e:	4a20      	ldr	r2, [pc, #128]	; (100023b0 <bit_init_mode+0xa94>)
10002330:	6e12      	ldr	r2, [r2, #96]	; 0x60
10002332:	4923      	ldr	r1, [pc, #140]	; (100023c0 <bit_init_mode+0xaa4>)
10002334:	400a      	ands	r2, r1
10002336:	661a      	str	r2, [r3, #96]	; 0x60
				 PORT2->IOCR8 &= 0xff00ffff;
10002338:	4b1d      	ldr	r3, [pc, #116]	; (100023b0 <bit_init_mode+0xa94>)
1000233a:	4a1d      	ldr	r2, [pc, #116]	; (100023b0 <bit_init_mode+0xa94>)
1000233c:	6992      	ldr	r2, [r2, #24]
1000233e:	4921      	ldr	r1, [pc, #132]	; (100023c4 <bit_init_mode+0xaa8>)
10002340:	400a      	ands	r2, r1
10002342:	619a      	str	r2, [r3, #24]
				 PORT2->IOCR8 |= 0x00800000;
10002344:	4b1a      	ldr	r3, [pc, #104]	; (100023b0 <bit_init_mode+0xa94>)
10002346:	4a1a      	ldr	r2, [pc, #104]	; (100023b0 <bit_init_mode+0xa94>)
10002348:	6992      	ldr	r2, [r2, #24]
1000234a:	2180      	movs	r1, #128	; 0x80
1000234c:	0409      	lsls	r1, r1, #16
1000234e:	430a      	orrs	r2, r1
10002350:	619a      	str	r2, [r3, #24]
10002352:	e044      	b.n	100023de <bit_init_mode+0xac2>
			 } else if (direction == INP) {
10002354:	1d7b      	adds	r3, r7, #5
10002356:	781b      	ldrb	r3, [r3, #0]
10002358:	2b00      	cmp	r3, #0
1000235a:	d140      	bne.n	100023de <bit_init_mode+0xac2>
				 CLR_BIT(PORT2->PDISC,10); // digital Pad aktiv
1000235c:	4b14      	ldr	r3, [pc, #80]	; (100023b0 <bit_init_mode+0xa94>)
1000235e:	4a14      	ldr	r2, [pc, #80]	; (100023b0 <bit_init_mode+0xa94>)
10002360:	6e12      	ldr	r2, [r2, #96]	; 0x60
10002362:	4917      	ldr	r1, [pc, #92]	; (100023c0 <bit_init_mode+0xaa4>)
10002364:	400a      	ands	r2, r1
10002366:	661a      	str	r2, [r3, #96]	; 0x60
				 if (mode==PULLUP) {
10002368:	1d3b      	adds	r3, r7, #4
1000236a:	781b      	ldrb	r3, [r3, #0]
1000236c:	2b01      	cmp	r3, #1
1000236e:	d10d      	bne.n	1000238c <bit_init_mode+0xa70>
					 PORT2->IOCR8 &= 0xFF00FFFF;
10002370:	4b0f      	ldr	r3, [pc, #60]	; (100023b0 <bit_init_mode+0xa94>)
10002372:	4a0f      	ldr	r2, [pc, #60]	; (100023b0 <bit_init_mode+0xa94>)
10002374:	6992      	ldr	r2, [r2, #24]
10002376:	4913      	ldr	r1, [pc, #76]	; (100023c4 <bit_init_mode+0xaa8>)
10002378:	400a      	ands	r2, r1
1000237a:	619a      	str	r2, [r3, #24]
					 PORT2->IOCR8 |= 0x00100000;
1000237c:	4b0c      	ldr	r3, [pc, #48]	; (100023b0 <bit_init_mode+0xa94>)
1000237e:	4a0c      	ldr	r2, [pc, #48]	; (100023b0 <bit_init_mode+0xa94>)
10002380:	6992      	ldr	r2, [r2, #24]
10002382:	2180      	movs	r1, #128	; 0x80
10002384:	0349      	lsls	r1, r1, #13
10002386:	430a      	orrs	r2, r1
10002388:	619a      	str	r2, [r3, #24]
1000238a:	e028      	b.n	100023de <bit_init_mode+0xac2>
				 } else if (mode==PULLDOWN) {
1000238c:	1d3b      	adds	r3, r7, #4
1000238e:	781b      	ldrb	r3, [r3, #0]
10002390:	2b02      	cmp	r3, #2
10002392:	d119      	bne.n	100023c8 <bit_init_mode+0xaac>
					 PORT2->IOCR8 &= 0xFF00FFFF;
10002394:	4b06      	ldr	r3, [pc, #24]	; (100023b0 <bit_init_mode+0xa94>)
10002396:	4a06      	ldr	r2, [pc, #24]	; (100023b0 <bit_init_mode+0xa94>)
10002398:	6992      	ldr	r2, [r2, #24]
1000239a:	490a      	ldr	r1, [pc, #40]	; (100023c4 <bit_init_mode+0xaa8>)
1000239c:	400a      	ands	r2, r1
1000239e:	619a      	str	r2, [r3, #24]
					 PORT2->IOCR8 |= 0x00080000;
100023a0:	4b03      	ldr	r3, [pc, #12]	; (100023b0 <bit_init_mode+0xa94>)
100023a2:	4a03      	ldr	r2, [pc, #12]	; (100023b0 <bit_init_mode+0xa94>)
100023a4:	6992      	ldr	r2, [r2, #24]
100023a6:	2180      	movs	r1, #128	; 0x80
100023a8:	0309      	lsls	r1, r1, #12
100023aa:	430a      	orrs	r2, r1
100023ac:	619a      	str	r2, [r3, #24]
100023ae:	e016      	b.n	100023de <bit_init_mode+0xac2>
100023b0:	40040200 	.word	0x40040200
100023b4:	fffffeff 	.word	0xfffffeff
100023b8:	fffffdff 	.word	0xfffffdff
100023bc:	ffff00ff 	.word	0xffff00ff
100023c0:	fffffbff 	.word	0xfffffbff
100023c4:	ff00ffff 	.word	0xff00ffff
				 } else if (mode == ANALOG) {
100023c8:	1d3b      	adds	r3, r7, #4
100023ca:	781b      	ldrb	r3, [r3, #0]
100023cc:	2b03      	cmp	r3, #3
100023ce:	d106      	bne.n	100023de <bit_init_mode+0xac2>
					 SET_BIT(PORT2->PDISC,10); //Analog Modus aktiv
100023d0:	4b2f      	ldr	r3, [pc, #188]	; (10002490 <bit_init_mode+0xb74>)
100023d2:	4a2f      	ldr	r2, [pc, #188]	; (10002490 <bit_init_mode+0xb74>)
100023d4:	6e12      	ldr	r2, [r2, #96]	; 0x60
100023d6:	2180      	movs	r1, #128	; 0x80
100023d8:	00c9      	lsls	r1, r1, #3
100023da:	430a      	orrs	r2, r1
100023dc:	661a      	str	r2, [r3, #96]	; 0x60
				 }
			 }
		 }
		 if (bitnr == 11) { //P2.11
100023de:	1dbb      	adds	r3, r7, #6
100023e0:	781b      	ldrb	r3, [r3, #0]
100023e2:	2b0b      	cmp	r3, #11
100023e4:	d150      	bne.n	10002488 <bit_init_mode+0xb6c>
			if (direction == OUTP) {
100023e6:	1d7b      	adds	r3, r7, #5
100023e8:	781b      	ldrb	r3, [r3, #0]
100023ea:	2b01      	cmp	r3, #1
100023ec:	d113      	bne.n	10002416 <bit_init_mode+0xafa>
				CLR_BIT(PORT2->PDISC,11); // digital Pad aktiv
100023ee:	4b28      	ldr	r3, [pc, #160]	; (10002490 <bit_init_mode+0xb74>)
100023f0:	4a27      	ldr	r2, [pc, #156]	; (10002490 <bit_init_mode+0xb74>)
100023f2:	6e12      	ldr	r2, [r2, #96]	; 0x60
100023f4:	4927      	ldr	r1, [pc, #156]	; (10002494 <bit_init_mode+0xb78>)
100023f6:	400a      	ands	r2, r1
100023f8:	661a      	str	r2, [r3, #96]	; 0x60
				PORT2->IOCR8 &= 0x00ffffff;
100023fa:	4b25      	ldr	r3, [pc, #148]	; (10002490 <bit_init_mode+0xb74>)
100023fc:	4a24      	ldr	r2, [pc, #144]	; (10002490 <bit_init_mode+0xb74>)
100023fe:	6992      	ldr	r2, [r2, #24]
10002400:	0212      	lsls	r2, r2, #8
10002402:	0a12      	lsrs	r2, r2, #8
10002404:	619a      	str	r2, [r3, #24]
				PORT2->IOCR8 |= 0x80000000;
10002406:	4b22      	ldr	r3, [pc, #136]	; (10002490 <bit_init_mode+0xb74>)
10002408:	4a21      	ldr	r2, [pc, #132]	; (10002490 <bit_init_mode+0xb74>)
1000240a:	6992      	ldr	r2, [r2, #24]
1000240c:	2180      	movs	r1, #128	; 0x80
1000240e:	0609      	lsls	r1, r1, #24
10002410:	430a      	orrs	r2, r1
10002412:	619a      	str	r2, [r3, #24]
10002414:	e038      	b.n	10002488 <bit_init_mode+0xb6c>
			} else if (direction == INP) {
10002416:	1d7b      	adds	r3, r7, #5
10002418:	781b      	ldrb	r3, [r3, #0]
1000241a:	2b00      	cmp	r3, #0
1000241c:	d134      	bne.n	10002488 <bit_init_mode+0xb6c>
				CLR_BIT(PORT2->PDISC,11); // digital Pad aktiv
1000241e:	4b1c      	ldr	r3, [pc, #112]	; (10002490 <bit_init_mode+0xb74>)
10002420:	4a1b      	ldr	r2, [pc, #108]	; (10002490 <bit_init_mode+0xb74>)
10002422:	6e12      	ldr	r2, [r2, #96]	; 0x60
10002424:	491b      	ldr	r1, [pc, #108]	; (10002494 <bit_init_mode+0xb78>)
10002426:	400a      	ands	r2, r1
10002428:	661a      	str	r2, [r3, #96]	; 0x60
				if (mode==PULLUP) {
1000242a:	1d3b      	adds	r3, r7, #4
1000242c:	781b      	ldrb	r3, [r3, #0]
1000242e:	2b01      	cmp	r3, #1
10002430:	d10d      	bne.n	1000244e <bit_init_mode+0xb32>
					PORT2->IOCR8 &= 0x00FFFFFF;
10002432:	4b17      	ldr	r3, [pc, #92]	; (10002490 <bit_init_mode+0xb74>)
10002434:	4a16      	ldr	r2, [pc, #88]	; (10002490 <bit_init_mode+0xb74>)
10002436:	6992      	ldr	r2, [r2, #24]
10002438:	0212      	lsls	r2, r2, #8
1000243a:	0a12      	lsrs	r2, r2, #8
1000243c:	619a      	str	r2, [r3, #24]
					PORT2->IOCR8 |= 0x10000000;
1000243e:	4b14      	ldr	r3, [pc, #80]	; (10002490 <bit_init_mode+0xb74>)
10002440:	4a13      	ldr	r2, [pc, #76]	; (10002490 <bit_init_mode+0xb74>)
10002442:	6992      	ldr	r2, [r2, #24]
10002444:	2180      	movs	r1, #128	; 0x80
10002446:	0549      	lsls	r1, r1, #21
10002448:	430a      	orrs	r2, r1
1000244a:	619a      	str	r2, [r3, #24]
1000244c:	e01c      	b.n	10002488 <bit_init_mode+0xb6c>
				} else if (mode==PULLDOWN) {
1000244e:	1d3b      	adds	r3, r7, #4
10002450:	781b      	ldrb	r3, [r3, #0]
10002452:	2b02      	cmp	r3, #2
10002454:	d10d      	bne.n	10002472 <bit_init_mode+0xb56>
					PORT2->IOCR8 &= 0x00FFFFFF;
10002456:	4b0e      	ldr	r3, [pc, #56]	; (10002490 <bit_init_mode+0xb74>)
10002458:	4a0d      	ldr	r2, [pc, #52]	; (10002490 <bit_init_mode+0xb74>)
1000245a:	6992      	ldr	r2, [r2, #24]
1000245c:	0212      	lsls	r2, r2, #8
1000245e:	0a12      	lsrs	r2, r2, #8
10002460:	619a      	str	r2, [r3, #24]
					PORT2->IOCR8 |= 0x08000000;
10002462:	4b0b      	ldr	r3, [pc, #44]	; (10002490 <bit_init_mode+0xb74>)
10002464:	4a0a      	ldr	r2, [pc, #40]	; (10002490 <bit_init_mode+0xb74>)
10002466:	6992      	ldr	r2, [r2, #24]
10002468:	2180      	movs	r1, #128	; 0x80
1000246a:	0509      	lsls	r1, r1, #20
1000246c:	430a      	orrs	r2, r1
1000246e:	619a      	str	r2, [r3, #24]
10002470:	e00a      	b.n	10002488 <bit_init_mode+0xb6c>
				} else if (mode == ANALOG) {
10002472:	1d3b      	adds	r3, r7, #4
10002474:	781b      	ldrb	r3, [r3, #0]
10002476:	2b03      	cmp	r3, #3
10002478:	d106      	bne.n	10002488 <bit_init_mode+0xb6c>
					SET_BIT(PORT2->PDISC,11); //Analog Modus aktiv
1000247a:	4b05      	ldr	r3, [pc, #20]	; (10002490 <bit_init_mode+0xb74>)
1000247c:	4a04      	ldr	r2, [pc, #16]	; (10002490 <bit_init_mode+0xb74>)
1000247e:	6e12      	ldr	r2, [r2, #96]	; 0x60
10002480:	2180      	movs	r1, #128	; 0x80
10002482:	0109      	lsls	r1, r1, #4
10002484:	430a      	orrs	r2, r1
10002486:	661a      	str	r2, [r3, #96]	; 0x60
				}
			}
		 }
		 break;
10002488:	46c0      	nop			; (mov r8, r8)
	}
}
1000248a:	46bd      	mov	sp, r7
1000248c:	b002      	add	sp, #8
1000248e:	bdb0      	pop	{r4, r5, r7, pc}
10002490:	40040200 	.word	0x40040200
10002494:	fffff7ff 	.word	0xfffff7ff

10002498 <bit_read>:
//---------------------------------------------------------------
// Einzelnes Portbit einlesen
// port: P0,P1,P2 bitnr: 0..15
//---------------------------------------------------------------
uint8_t bit_read(uint8_t port, uint8_t bitnr)
{
10002498:	b590      	push	{r4, r7, lr}
1000249a:	b085      	sub	sp, #20
1000249c:	af00      	add	r7, sp, #0
1000249e:	1c02      	adds	r2, r0, #0
100024a0:	1dfb      	adds	r3, r7, #7
100024a2:	701a      	strb	r2, [r3, #0]
100024a4:	1dbb      	adds	r3, r7, #6
100024a6:	1c0a      	adds	r2, r1, #0
100024a8:	701a      	strb	r2, [r3, #0]
  uint16_t temp;

  temp = port_read(port);
100024aa:	230e      	movs	r3, #14
100024ac:	18fc      	adds	r4, r7, r3
100024ae:	1dfb      	adds	r3, r7, #7
100024b0:	781b      	ldrb	r3, [r3, #0]
100024b2:	1c18      	adds	r0, r3, #0
100024b4:	f000 f8a0 	bl	100025f8 <port_read>
100024b8:	1c03      	adds	r3, r0, #0
100024ba:	8023      	strh	r3, [r4, #0]
  return ((temp>>bitnr) & 0x01);
100024bc:	230e      	movs	r3, #14
100024be:	18fb      	adds	r3, r7, r3
100024c0:	881a      	ldrh	r2, [r3, #0]
100024c2:	1dbb      	adds	r3, r7, #6
100024c4:	781b      	ldrb	r3, [r3, #0]
100024c6:	411a      	asrs	r2, r3
100024c8:	1c13      	adds	r3, r2, #0
100024ca:	b2db      	uxtb	r3, r3
100024cc:	2201      	movs	r2, #1
100024ce:	4013      	ands	r3, r2
100024d0:	b2db      	uxtb	r3, r3
}
100024d2:	1c18      	adds	r0, r3, #0
100024d4:	46bd      	mov	sp, r7
100024d6:	b005      	add	sp, #20
100024d8:	bd90      	pop	{r4, r7, pc}
100024da:	46c0      	nop			; (mov r8, r8)

100024dc <bit_write>:
//---------------------------------------------------------------
// Einzelnes Portbit ausgeben
// port: P0,P1 bitnr: 0..15 P2=>bitnr 9..11
//---------------------------------------------------------------
void bit_write(uint8_t port, uint8_t bitnr, uint8_t value)
{
100024dc:	b590      	push	{r4, r7, lr}
100024de:	b083      	sub	sp, #12
100024e0:	af00      	add	r7, sp, #0
100024e2:	1c04      	adds	r4, r0, #0
100024e4:	1c08      	adds	r0, r1, #0
100024e6:	1c11      	adds	r1, r2, #0
100024e8:	1dfb      	adds	r3, r7, #7
100024ea:	1c22      	adds	r2, r4, #0
100024ec:	701a      	strb	r2, [r3, #0]
100024ee:	1dbb      	adds	r3, r7, #6
100024f0:	1c02      	adds	r2, r0, #0
100024f2:	701a      	strb	r2, [r3, #0]
100024f4:	1d7b      	adds	r3, r7, #5
100024f6:	1c0a      	adds	r2, r1, #0
100024f8:	701a      	strb	r2, [r3, #0]
	//uint32_t temp;
	value &= 0x01;       // value darf nur 0 oder 1 sein!
100024fa:	1d7b      	adds	r3, r7, #5
100024fc:	1d7a      	adds	r2, r7, #5
100024fe:	7812      	ldrb	r2, [r2, #0]
10002500:	2101      	movs	r1, #1
10002502:	400a      	ands	r2, r1
10002504:	701a      	strb	r2, [r3, #0]
	switch (port)
10002506:	1dfb      	adds	r3, r7, #7
10002508:	781b      	ldrb	r3, [r3, #0]
1000250a:	2b01      	cmp	r3, #1
1000250c:	d035      	beq.n	1000257a <bit_write+0x9e>
1000250e:	2b02      	cmp	r3, #2
10002510:	d04e      	beq.n	100025b0 <bit_write+0xd4>
10002512:	2b00      	cmp	r3, #0
10002514:	d167      	bne.n	100025e6 <bit_write+0x10a>
	{
		case 0 :
			if (value == 1) {
10002516:	1d7b      	adds	r3, r7, #5
10002518:	781b      	ldrb	r3, [r3, #0]
1000251a:	2b01      	cmp	r3, #1
1000251c:	d116      	bne.n	1000254c <bit_write+0x70>
				//PORT0->OUT |= 1UL << bitnr ;
				PORT0->OMR &= ~(1UL << (bitnr + 16)); // loeschen des Bits
1000251e:	4b33      	ldr	r3, [pc, #204]	; (100025ec <bit_write+0x110>)
10002520:	4a32      	ldr	r2, [pc, #200]	; (100025ec <bit_write+0x110>)
10002522:	6852      	ldr	r2, [r2, #4]
10002524:	1db9      	adds	r1, r7, #6
10002526:	7809      	ldrb	r1, [r1, #0]
10002528:	3110      	adds	r1, #16
1000252a:	2001      	movs	r0, #1
1000252c:	4088      	lsls	r0, r1
1000252e:	1c01      	adds	r1, r0, #0
10002530:	43c9      	mvns	r1, r1
10002532:	400a      	ands	r2, r1
10002534:	605a      	str	r2, [r3, #4]
				PORT0->OMR |= 1UL << bitnr;      // setzen
10002536:	4b2d      	ldr	r3, [pc, #180]	; (100025ec <bit_write+0x110>)
10002538:	4a2c      	ldr	r2, [pc, #176]	; (100025ec <bit_write+0x110>)
1000253a:	6851      	ldr	r1, [r2, #4]
1000253c:	1dba      	adds	r2, r7, #6
1000253e:	7812      	ldrb	r2, [r2, #0]
10002540:	2001      	movs	r0, #1
10002542:	4090      	lsls	r0, r2
10002544:	1c02      	adds	r2, r0, #0
10002546:	430a      	orrs	r2, r1
10002548:	605a      	str	r2, [r3, #4]
				//temp = PORT0->OMR;
				//temp &= ~(1UL << bitnr);      // Set = 0
				//temp |= 1UL << (bitnr + 16); // Reset = 0
				//PORT0->OMR = temp;
			}
			break;
1000254a:	e04c      	b.n	100025e6 <bit_write+0x10a>
				//temp |= 1UL << bitnr;      // setzen
				//PORT0->OMR = temp;
			}
			else {
				//PORT0->OUT &= ~( 1UL << bitnr);
				PORT0->OMR &= ~(1UL << bitnr);      // Set = 0
1000254c:	4b27      	ldr	r3, [pc, #156]	; (100025ec <bit_write+0x110>)
1000254e:	4a27      	ldr	r2, [pc, #156]	; (100025ec <bit_write+0x110>)
10002550:	6852      	ldr	r2, [r2, #4]
10002552:	1db9      	adds	r1, r7, #6
10002554:	7809      	ldrb	r1, [r1, #0]
10002556:	2001      	movs	r0, #1
10002558:	4088      	lsls	r0, r1
1000255a:	1c01      	adds	r1, r0, #0
1000255c:	43c9      	mvns	r1, r1
1000255e:	400a      	ands	r2, r1
10002560:	605a      	str	r2, [r3, #4]
				PORT0->OMR |= 1UL << (bitnr + 16); // Reset = 0
10002562:	4b22      	ldr	r3, [pc, #136]	; (100025ec <bit_write+0x110>)
10002564:	4a21      	ldr	r2, [pc, #132]	; (100025ec <bit_write+0x110>)
10002566:	6851      	ldr	r1, [r2, #4]
10002568:	1dba      	adds	r2, r7, #6
1000256a:	7812      	ldrb	r2, [r2, #0]
1000256c:	3210      	adds	r2, #16
1000256e:	2001      	movs	r0, #1
10002570:	4090      	lsls	r0, r2
10002572:	1c02      	adds	r2, r0, #0
10002574:	430a      	orrs	r2, r1
10002576:	605a      	str	r2, [r3, #4]
				//temp = PORT0->OMR;
				//temp &= ~(1UL << bitnr);      // Set = 0
				//temp |= 1UL << (bitnr + 16); // Reset = 0
				//PORT0->OMR = temp;
			}
			break;
10002578:	e035      	b.n	100025e6 <bit_write+0x10a>
	    case 1 :
	  	  	  {if (value == 1) PORT1->OUT |= 1UL << bitnr ;
1000257a:	1d7b      	adds	r3, r7, #5
1000257c:	781b      	ldrb	r3, [r3, #0]
1000257e:	2b01      	cmp	r3, #1
10002580:	d10a      	bne.n	10002598 <bit_write+0xbc>
10002582:	4b1b      	ldr	r3, [pc, #108]	; (100025f0 <bit_write+0x114>)
10002584:	4a1a      	ldr	r2, [pc, #104]	; (100025f0 <bit_write+0x114>)
10002586:	6811      	ldr	r1, [r2, #0]
10002588:	1dba      	adds	r2, r7, #6
1000258a:	7812      	ldrb	r2, [r2, #0]
1000258c:	2001      	movs	r0, #1
1000258e:	4090      	lsls	r0, r2
10002590:	1c02      	adds	r2, r0, #0
10002592:	430a      	orrs	r2, r1
10002594:	601a      	str	r2, [r3, #0]
	  		   else PORT1->OUT &= ~( 1UL << bitnr);
	  		  }
			break;
10002596:	e026      	b.n	100025e6 <bit_write+0x10a>
				//PORT0->OMR = temp;
			}
			break;
	    case 1 :
	  	  	  {if (value == 1) PORT1->OUT |= 1UL << bitnr ;
	  		   else PORT1->OUT &= ~( 1UL << bitnr);
10002598:	4b15      	ldr	r3, [pc, #84]	; (100025f0 <bit_write+0x114>)
1000259a:	4a15      	ldr	r2, [pc, #84]	; (100025f0 <bit_write+0x114>)
1000259c:	6812      	ldr	r2, [r2, #0]
1000259e:	1db9      	adds	r1, r7, #6
100025a0:	7809      	ldrb	r1, [r1, #0]
100025a2:	2001      	movs	r0, #1
100025a4:	4088      	lsls	r0, r1
100025a6:	1c01      	adds	r1, r0, #0
100025a8:	43c9      	mvns	r1, r1
100025aa:	400a      	ands	r2, r1
100025ac:	601a      	str	r2, [r3, #0]
	  		  }
			break;
100025ae:	e01a      	b.n	100025e6 <bit_write+0x10a>

	    case 2 :
			  {if (value == 1) PORT2->OUT |= 1UL << bitnr ;
100025b0:	1d7b      	adds	r3, r7, #5
100025b2:	781b      	ldrb	r3, [r3, #0]
100025b4:	2b01      	cmp	r3, #1
100025b6:	d10a      	bne.n	100025ce <bit_write+0xf2>
100025b8:	4b0e      	ldr	r3, [pc, #56]	; (100025f4 <bit_write+0x118>)
100025ba:	4a0e      	ldr	r2, [pc, #56]	; (100025f4 <bit_write+0x118>)
100025bc:	6811      	ldr	r1, [r2, #0]
100025be:	1dba      	adds	r2, r7, #6
100025c0:	7812      	ldrb	r2, [r2, #0]
100025c2:	2001      	movs	r0, #1
100025c4:	4090      	lsls	r0, r2
100025c6:	1c02      	adds	r2, r0, #0
100025c8:	430a      	orrs	r2, r1
100025ca:	601a      	str	r2, [r3, #0]
100025cc:	e00a      	b.n	100025e4 <bit_write+0x108>
			   else PORT2->OUT &= ~( 1UL << bitnr);
100025ce:	4b09      	ldr	r3, [pc, #36]	; (100025f4 <bit_write+0x118>)
100025d0:	4a08      	ldr	r2, [pc, #32]	; (100025f4 <bit_write+0x118>)
100025d2:	6812      	ldr	r2, [r2, #0]
100025d4:	1db9      	adds	r1, r7, #6
100025d6:	7809      	ldrb	r1, [r1, #0]
100025d8:	2001      	movs	r0, #1
100025da:	4088      	lsls	r0, r1
100025dc:	1c01      	adds	r1, r0, #0
100025de:	43c9      	mvns	r1, r1
100025e0:	400a      	ands	r2, r1
100025e2:	601a      	str	r2, [r3, #0]
			  }
			break;
100025e4:	46c0      	nop			; (mov r8, r8)
		}
 }
100025e6:	46bd      	mov	sp, r7
100025e8:	b003      	add	sp, #12
100025ea:	bd90      	pop	{r4, r7, pc}
100025ec:	40040000 	.word	0x40040000
100025f0:	40040100 	.word	0x40040100
100025f4:	40040200 	.word	0x40040200

100025f8 <port_read>:
//---------------------------------------------------------------
// Gesamtes Port einlesen
// port: P0,P1,P2
//---------------------------------------------------------------
uint16_t port_read (uint8_t port)
{
100025f8:	b580      	push	{r7, lr}
100025fa:	b084      	sub	sp, #16
100025fc:	af00      	add	r7, sp, #0
100025fe:	1c02      	adds	r2, r0, #0
10002600:	1dfb      	adds	r3, r7, #7
10002602:	701a      	strb	r2, [r3, #0]
	uint16_t temp;
  switch (port)
10002604:	1dfb      	adds	r3, r7, #7
10002606:	781b      	ldrb	r3, [r3, #0]
10002608:	2b01      	cmp	r3, #1
1000260a:	d00c      	beq.n	10002626 <port_read+0x2e>
1000260c:	2b02      	cmp	r3, #2
1000260e:	d013      	beq.n	10002638 <port_read+0x40>
10002610:	2b00      	cmp	r3, #0
10002612:	d11a      	bne.n	1000264a <port_read+0x52>
  {
    case 0: temp = PORT0->IN; return temp; break;
10002614:	4b0f      	ldr	r3, [pc, #60]	; (10002654 <port_read+0x5c>)
10002616:	6a5a      	ldr	r2, [r3, #36]	; 0x24
10002618:	230e      	movs	r3, #14
1000261a:	18fb      	adds	r3, r7, r3
1000261c:	801a      	strh	r2, [r3, #0]
1000261e:	230e      	movs	r3, #14
10002620:	18fb      	adds	r3, r7, r3
10002622:	881b      	ldrh	r3, [r3, #0]
10002624:	e012      	b.n	1000264c <port_read+0x54>
    case 1: temp = PORT1->IN; return temp; break;
10002626:	4b0c      	ldr	r3, [pc, #48]	; (10002658 <port_read+0x60>)
10002628:	6a5a      	ldr	r2, [r3, #36]	; 0x24
1000262a:	230e      	movs	r3, #14
1000262c:	18fb      	adds	r3, r7, r3
1000262e:	801a      	strh	r2, [r3, #0]
10002630:	230e      	movs	r3, #14
10002632:	18fb      	adds	r3, r7, r3
10002634:	881b      	ldrh	r3, [r3, #0]
10002636:	e009      	b.n	1000264c <port_read+0x54>
    case 2: temp = PORT2->IN; return temp; break;
10002638:	4b08      	ldr	r3, [pc, #32]	; (1000265c <port_read+0x64>)
1000263a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
1000263c:	230e      	movs	r3, #14
1000263e:	18fb      	adds	r3, r7, r3
10002640:	801a      	strh	r2, [r3, #0]
10002642:	230e      	movs	r3, #14
10002644:	18fb      	adds	r3, r7, r3
10002646:	881b      	ldrh	r3, [r3, #0]
10002648:	e000      	b.n	1000264c <port_read+0x54>
    default: return 0; break;
1000264a:	2300      	movs	r3, #0
  }
  //return 0;
}
1000264c:	1c18      	adds	r0, r3, #0
1000264e:	46bd      	mov	sp, r7
10002650:	b004      	add	sp, #16
10002652:	bd80      	pop	{r7, pc}
10002654:	40040000 	.word	0x40040000
10002658:	40040100 	.word	0x40040100
1000265c:	40040200 	.word	0x40040200

10002660 <clock_init>:
//#define periode_pwm 0xffff // max 16-Bit-Periode


//------- Takt f√ºr 8-Bit- und 16-Bit-Funktionen PWM --------------------------------
void clock_init(void)
{
10002660:	b580      	push	{r7, lr}
10002662:	af00      	add	r7, sp, #0
	SCU_GENERAL->PASSWD = 0x000000C0UL;
10002664:	4b15      	ldr	r3, [pc, #84]	; (100026bc <clock_init+0x5c>)
10002666:	22c0      	movs	r2, #192	; 0xc0
10002668:	625a      	str	r2, [r3, #36]	; 0x24
	SCU_CLK->CLKCR = 0x3FF10100;			// Config SCU Clock = 32MHz , PCLK = 64 MHz
1000266a:	4b15      	ldr	r3, [pc, #84]	; (100026c0 <clock_init+0x60>)
1000266c:	4a15      	ldr	r2, [pc, #84]	; (100026c4 <clock_init+0x64>)
1000266e:	601a      	str	r2, [r3, #0]
	while((SCU_CLK->CLKCR)&0x40000000UL);	// wait for VDDC to stabilize
10002670:	46c0      	nop			; (mov r8, r8)
10002672:	4b13      	ldr	r3, [pc, #76]	; (100026c0 <clock_init+0x60>)
10002674:	681a      	ldr	r2, [r3, #0]
10002676:	2380      	movs	r3, #128	; 0x80
10002678:	05db      	lsls	r3, r3, #23
1000267a:	4013      	ands	r3, r2
1000267c:	d1f9      	bne.n	10002672 <clock_init+0x12>
	SCU_GENERAL->PASSWD = 0x000000C3UL;
1000267e:	4b0f      	ldr	r3, [pc, #60]	; (100026bc <clock_init+0x5c>)
10002680:	22c3      	movs	r2, #195	; 0xc3
10002682:	625a      	str	r2, [r3, #36]	; 0x24
	SCU_GENERAL->PASSWD = 0x000000C0UL;
10002684:	4b0d      	ldr	r3, [pc, #52]	; (100026bc <clock_init+0x5c>)
10002686:	22c0      	movs	r2, #192	; 0xc0
10002688:	625a      	str	r2, [r3, #36]	; 0x24
	SCU_CLK->CGATCLR0 |= 0x04;				// Disable CCU4 Gating
1000268a:	4b0d      	ldr	r3, [pc, #52]	; (100026c0 <clock_init+0x60>)
1000268c:	4a0c      	ldr	r2, [pc, #48]	; (100026c0 <clock_init+0x60>)
1000268e:	6912      	ldr	r2, [r2, #16]
10002690:	2104      	movs	r1, #4
10002692:	430a      	orrs	r2, r1
10002694:	611a      	str	r2, [r3, #16]
	while((SCU_CLK->CLKCR)&0x40000000UL);	// wait for VDDC to stabilize
10002696:	46c0      	nop			; (mov r8, r8)
10002698:	4b09      	ldr	r3, [pc, #36]	; (100026c0 <clock_init+0x60>)
1000269a:	681a      	ldr	r2, [r3, #0]
1000269c:	2380      	movs	r3, #128	; 0x80
1000269e:	05db      	lsls	r3, r3, #23
100026a0:	4013      	ands	r3, r2
100026a2:	d1f9      	bne.n	10002698 <clock_init+0x38>
	SCU_GENERAL->PASSWD = 0x000000C3UL;
100026a4:	4b05      	ldr	r3, [pc, #20]	; (100026bc <clock_init+0x5c>)
100026a6:	22c3      	movs	r2, #195	; 0xc3
100026a8:	625a      	str	r2, [r3, #36]	; 0x24
	SCU_CLK->CGATSET0 |= 0xfff;				// Modul  Clock enable , all Modul's
100026aa:	4b05      	ldr	r3, [pc, #20]	; (100026c0 <clock_init+0x60>)
100026ac:	4a04      	ldr	r2, [pc, #16]	; (100026c0 <clock_init+0x60>)
100026ae:	68d2      	ldr	r2, [r2, #12]
100026b0:	4905      	ldr	r1, [pc, #20]	; (100026c8 <clock_init+0x68>)
100026b2:	430a      	orrs	r2, r1
100026b4:	60da      	str	r2, [r3, #12]
}
100026b6:	46bd      	mov	sp, r7
100026b8:	bd80      	pop	{r7, pc}
100026ba:	46c0      	nop			; (mov r8, r8)
100026bc:	40010000 	.word	0x40010000
100026c0:	40010300 	.word	0x40010300
100026c4:	3ff10100 	.word	0x3ff10100
100026c8:	00000fff 	.word	0x00000fff

100026cc <pwm1_init>:
// PWM1-Ausgang P0.6 initialisieren (16-Bit),
// Hinweis: anschlie√üend starten mit pwm1_start oder pwm1_start_interrupt
// eingestellte Periodendauer bei #define periode_pwm 50000
//----------------------------------------------------------------
void pwm1_init(void)
{
100026cc:	b580      	push	{r7, lr}
100026ce:	af00      	add	r7, sp, #0
	clock_init();
100026d0:	f7ff ffc6 	bl	10002660 <clock_init>
	SCU_GENERAL->CCUCON = 1;				// Enable CCU40
100026d4:	4b0f      	ldr	r3, [pc, #60]	; (10002714 <pwm1_init+0x48>)
100026d6:	2201      	movs	r2, #1
100026d8:	631a      	str	r2, [r3, #48]	; 0x30
	// CCU40 Init:
	CCU40->GIDLC = 0x10F; 					// Vorteiler enable,CCU4x enable
100026da:	4b0f      	ldr	r3, [pc, #60]	; (10002718 <pwm1_init+0x4c>)
100026dc:	2210      	movs	r2, #16
100026de:	32ff      	adds	r2, #255	; 0xff
100026e0:	60da      	str	r2, [r3, #12]
	CCU40_CC40->TC = 4;  					// Shadow transfer enable on clear
100026e2:	4b0e      	ldr	r3, [pc, #56]	; (1000271c <pwm1_init+0x50>)
100026e4:	2204      	movs	r2, #4
100026e6:	615a      	str	r2, [r3, #20]
	CCU40_CC40->PSC = 0x1;					// Vorteiler , hier 64Mhz/2
100026e8:	4b0c      	ldr	r3, [pc, #48]	; (1000271c <pwm1_init+0x50>)
100026ea:	2201      	movs	r2, #1
100026ec:	625a      	str	r2, [r3, #36]	; 0x24
	CCU40_CC40->PRS = periode_pwm; 			// Period Register set, hier ca. 640 Hz
100026ee:	4b0b      	ldr	r3, [pc, #44]	; (1000271c <pwm1_init+0x50>)
100026f0:	4a0b      	ldr	r2, [pc, #44]	; (10002720 <pwm1_init+0x54>)
100026f2:	635a      	str	r2, [r3, #52]	; 0x34

	// CCU40 Compare:  (Ausganspin P0.6)
	CCU40_CC40->CRS = 25000;				// Compare Wert,hier 1:1 Imp
100026f4:	4b09      	ldr	r3, [pc, #36]	; (1000271c <pwm1_init+0x50>)
100026f6:	4a0b      	ldr	r2, [pc, #44]	; (10002724 <pwm1_init+0x58>)
100026f8:	63da      	str	r2, [r3, #60]	; 0x3c
	CCU40->GCSS = 1; 						// Shadow transfer request slice 0
100026fa:	4b07      	ldr	r3, [pc, #28]	; (10002718 <pwm1_init+0x4c>)
100026fc:	2201      	movs	r2, #1
100026fe:	611a      	str	r2, [r3, #16]
	//PORT0->IOCR0 = 0xA0;					// Alt4=>OUT bei P0.0
	PORT0->IOCR4 |= 0xA0<<16;				// Alt4=>OUT bei P0.6
10002700:	4b09      	ldr	r3, [pc, #36]	; (10002728 <pwm1_init+0x5c>)
10002702:	4a09      	ldr	r2, [pc, #36]	; (10002728 <pwm1_init+0x5c>)
10002704:	6952      	ldr	r2, [r2, #20]
10002706:	21a0      	movs	r1, #160	; 0xa0
10002708:	0409      	lsls	r1, r1, #16
1000270a:	430a      	orrs	r2, r1
1000270c:	615a      	str	r2, [r3, #20]
	//CCU40_CC40->TCSET = 0x1; //starts counting
}
1000270e:	46bd      	mov	sp, r7
10002710:	bd80      	pop	{r7, pc}
10002712:	46c0      	nop			; (mov r8, r8)
10002714:	40010000 	.word	0x40010000
10002718:	48040000 	.word	0x48040000
1000271c:	48040100 	.word	0x48040100
10002720:	0000c350 	.word	0x0000c350
10002724:	000061a8 	.word	0x000061a8
10002728:	40040000 	.word	0x40040000

1000272c <pwm1_duty_cycle>:
// 16-Bit-Comparewert einstellen, der den Tastgrad des PWM-Singals ver√§ndert
// eingestellte Periodendauer bei #define periode_pwm 50000
// compare = 0...50000, Tastgrad 50% bei compare = 25000
//---------------------------------------------------------------
void pwm1_duty_cycle (uint16_t compare)
{
1000272c:	b580      	push	{r7, lr}
1000272e:	b082      	sub	sp, #8
10002730:	af00      	add	r7, sp, #0
10002732:	1c02      	adds	r2, r0, #0
10002734:	1dbb      	adds	r3, r7, #6
10002736:	801a      	strh	r2, [r3, #0]
	CCU40_CC40->CRS = compare; 	// Compare Wert, hier 1:1 Imp
10002738:	4b06      	ldr	r3, [pc, #24]	; (10002754 <pwm1_duty_cycle+0x28>)
1000273a:	1dba      	adds	r2, r7, #6
1000273c:	8812      	ldrh	r2, [r2, #0]
1000273e:	63da      	str	r2, [r3, #60]	; 0x3c
	CCU40->GCSS |= 1; 					// Shadow transfer request slice 0
10002740:	4b05      	ldr	r3, [pc, #20]	; (10002758 <pwm1_duty_cycle+0x2c>)
10002742:	4a05      	ldr	r2, [pc, #20]	; (10002758 <pwm1_duty_cycle+0x2c>)
10002744:	6912      	ldr	r2, [r2, #16]
10002746:	2101      	movs	r1, #1
10002748:	430a      	orrs	r2, r1
1000274a:	611a      	str	r2, [r3, #16]
}
1000274c:	46bd      	mov	sp, r7
1000274e:	b002      	add	sp, #8
10002750:	bd80      	pop	{r7, pc}
10002752:	46c0      	nop			; (mov r8, r8)
10002754:	48040100 	.word	0x48040100
10002758:	48040000 	.word	0x48040000

1000275c <pwm1_start>:
}
//----------------------------------------------------------------
// PWM1-Ausgang P0.6 Ausgabe starten ohne Interrupt starten, 8- oder 16-Bit
//----------------------------------------------------------------
void pwm1_start(void)
{
1000275c:	b580      	push	{r7, lr}
1000275e:	af00      	add	r7, sp, #0
	 CCU40_CC40->TCSET = 0x1; //starts counting
10002760:	4b02      	ldr	r3, [pc, #8]	; (1000276c <pwm1_start+0x10>)
10002762:	2201      	movs	r2, #1
10002764:	60da      	str	r2, [r3, #12]
}
10002766:	46bd      	mov	sp, r7
10002768:	bd80      	pop	{r7, pc}
1000276a:	46c0      	nop			; (mov r8, r8)
1000276c:	48040100 	.word	0x48040100

10002770 <delay_100us>:
}
//---------------------------------------------------------------
// Zeitverz√∂gerung n mal 100¬µs
//---------------------------------------------------------------
void delay_100us (uint8_t n)
{
10002770:	b580      	push	{r7, lr}
10002772:	b084      	sub	sp, #16
10002774:	af00      	add	r7, sp, #0
10002776:	1c02      	adds	r2, r0, #0
10002778:	1dfb      	adds	r3, r7, #7
1000277a:	701a      	strb	r2, [r3, #0]
	volatile uint16_t z;
	for (;n != 0;--n)
1000277c:	e018      	b.n	100027b0 <delay_100us+0x40>
		for (z = _T_CONST_; 	z!= 0; 	--z);
1000277e:	230e      	movs	r3, #14
10002780:	18fb      	adds	r3, r7, r3
10002782:	226d      	movs	r2, #109	; 0x6d
10002784:	801a      	strh	r2, [r3, #0]
10002786:	e008      	b.n	1000279a <delay_100us+0x2a>
10002788:	230e      	movs	r3, #14
1000278a:	18fb      	adds	r3, r7, r3
1000278c:	881b      	ldrh	r3, [r3, #0]
1000278e:	b29b      	uxth	r3, r3
10002790:	3b01      	subs	r3, #1
10002792:	b29a      	uxth	r2, r3
10002794:	230e      	movs	r3, #14
10002796:	18fb      	adds	r3, r7, r3
10002798:	801a      	strh	r2, [r3, #0]
1000279a:	230e      	movs	r3, #14
1000279c:	18fb      	adds	r3, r7, r3
1000279e:	881b      	ldrh	r3, [r3, #0]
100027a0:	b29b      	uxth	r3, r3
100027a2:	2b00      	cmp	r3, #0
100027a4:	d1f0      	bne.n	10002788 <delay_100us+0x18>
// Zeitverz√∂gerung n mal 100¬µs
//---------------------------------------------------------------
void delay_100us (uint8_t n)
{
	volatile uint16_t z;
	for (;n != 0;--n)
100027a6:	1dfb      	adds	r3, r7, #7
100027a8:	1dfa      	adds	r2, r7, #7
100027aa:	7812      	ldrb	r2, [r2, #0]
100027ac:	3a01      	subs	r2, #1
100027ae:	701a      	strb	r2, [r3, #0]
100027b0:	1dfb      	adds	r3, r7, #7
100027b2:	781b      	ldrb	r3, [r3, #0]
100027b4:	2b00      	cmp	r3, #0
100027b6:	d1e2      	bne.n	1000277e <delay_100us+0xe>
		for (z = _T_CONST_; 	z!= 0; 	--z);
}
100027b8:	46bd      	mov	sp, r7
100027ba:	b004      	add	sp, #16
100027bc:	bd80      	pop	{r7, pc}
100027be:	46c0      	nop			; (mov r8, r8)

100027c0 <delay_ms>:

//---------------------------------------------------------------
// Zeitverz√∂gerung Millisekunden
//---------------------------------------------------------------
void delay_ms( uint16_t millisekunden)
{
100027c0:	b580      	push	{r7, lr}
100027c2:	b084      	sub	sp, #16
100027c4:	af00      	add	r7, sp, #0
100027c6:	1c02      	adds	r2, r0, #0
100027c8:	1dbb      	adds	r3, r7, #6
100027ca:	801a      	strh	r2, [r3, #0]
	volatile uint16_t n = 0;
100027cc:	230e      	movs	r3, #14
100027ce:	18fb      	adds	r3, r7, r3
100027d0:	2200      	movs	r2, #0
100027d2:	801a      	strh	r2, [r3, #0]

	while(n < millisekunden)
100027d4:	e00b      	b.n	100027ee <delay_ms+0x2e>
	{
		delay_100us(10);
100027d6:	200a      	movs	r0, #10
100027d8:	f7ff ffca 	bl	10002770 <delay_100us>
		n++;
100027dc:	230e      	movs	r3, #14
100027de:	18fb      	adds	r3, r7, r3
100027e0:	881b      	ldrh	r3, [r3, #0]
100027e2:	b29b      	uxth	r3, r3
100027e4:	3301      	adds	r3, #1
100027e6:	b29a      	uxth	r2, r3
100027e8:	230e      	movs	r3, #14
100027ea:	18fb      	adds	r3, r7, r3
100027ec:	801a      	strh	r2, [r3, #0]
//---------------------------------------------------------------
void delay_ms( uint16_t millisekunden)
{
	volatile uint16_t n = 0;

	while(n < millisekunden)
100027ee:	230e      	movs	r3, #14
100027f0:	18fb      	adds	r3, r7, r3
100027f2:	881b      	ldrh	r3, [r3, #0]
100027f4:	b29b      	uxth	r3, r3
100027f6:	1dba      	adds	r2, r7, #6
100027f8:	8812      	ldrh	r2, [r2, #0]
100027fa:	429a      	cmp	r2, r3
100027fc:	d8eb      	bhi.n	100027d6 <delay_ms+0x16>
	{
		delay_100us(10);
		n++;
	}
}
100027fe:	46bd      	mov	sp, r7
10002800:	b004      	add	sp, #16
10002802:	bd80      	pop	{r7, pc}

10002804 <rs232_init>:
// Serielle Schnittstelle initialisieren
// RxD auf P1.3 , XMC1100 TxD auf P1.2, 9600 Baud, 8N1
// √ºber USB als virtuelle Schnittstelle COM x am PC verwendbar
//---------------------------------------------------------------
void rs232_init ( void )
{	//USIC0 Cannel 1 wird verwendet:
10002804:	b580      	push	{r7, lr}
10002806:	af00      	add	r7, sp, #0
	SCU_GENERAL->PASSWD = 0x000000C0UL;
10002808:	4b59      	ldr	r3, [pc, #356]	; (10002970 <rs232_init+0x16c>)
1000280a:	22c0      	movs	r2, #192	; 0xc0
1000280c:	625a      	str	r2, [r3, #36]	; 0x24
	SCU_CLK->CGATCLR0 |= 0x00000008;		// stop gating USIC
1000280e:	4b59      	ldr	r3, [pc, #356]	; (10002974 <rs232_init+0x170>)
10002810:	4a58      	ldr	r2, [pc, #352]	; (10002974 <rs232_init+0x170>)
10002812:	6912      	ldr	r2, [r2, #16]
10002814:	2108      	movs	r1, #8
10002816:	430a      	orrs	r2, r1
10002818:	611a      	str	r2, [r3, #16]
		while((SCU_CLK->CLKCR)&0x40000000UL);	// wait for VDDC to stabilize
1000281a:	46c0      	nop			; (mov r8, r8)
1000281c:	4b55      	ldr	r3, [pc, #340]	; (10002974 <rs232_init+0x170>)
1000281e:	681a      	ldr	r2, [r3, #0]
10002820:	2380      	movs	r3, #128	; 0x80
10002822:	05db      	lsls	r3, r3, #23
10002824:	4013      	ands	r3, r2
10002826:	d1f9      	bne.n	1000281c <rs232_init+0x18>
	SCU_GENERAL->PASSWD = 0x000000C3UL;
10002828:	4b51      	ldr	r3, [pc, #324]	; (10002970 <rs232_init+0x16c>)
1000282a:	22c3      	movs	r2, #195	; 0xc3
1000282c:	625a      	str	r2, [r3, #36]	; 0x24

	USIC0_CH1->KSCFG |= 3UL ;	//  Mode enable + Freigabe write
1000282e:	4b52      	ldr	r3, [pc, #328]	; (10002978 <rs232_init+0x174>)
10002830:	4a51      	ldr	r2, [pc, #324]	; (10002978 <rs232_init+0x174>)
10002832:	68d2      	ldr	r2, [r2, #12]
10002834:	2103      	movs	r1, #3
10002836:	430a      	orrs	r2, r1
10002838:	60da      	str	r2, [r3, #12]
	//WR_REG(USIC0_CH1->FDR, USIC_CH_FDR_DM_Msk, USIC_CH_FDR_DM_Pos, 2);
	USIC0_CH1->FDR |= 1UL << 15 ;	//Fractional divider mode selected
1000283a:	4b4f      	ldr	r3, [pc, #316]	; (10002978 <rs232_init+0x174>)
1000283c:	4a4e      	ldr	r2, [pc, #312]	; (10002978 <rs232_init+0x174>)
1000283e:	6912      	ldr	r2, [r2, #16]
10002840:	2180      	movs	r1, #128	; 0x80
10002842:	0209      	lsls	r1, r1, #8
10002844:	430a      	orrs	r2, r1
10002846:	611a      	str	r2, [r3, #16]
		//Step value
	USIC0_CH1->FDR|= FDR_STEP ;
10002848:	4b4b      	ldr	r3, [pc, #300]	; (10002978 <rs232_init+0x174>)
1000284a:	4a4b      	ldr	r2, [pc, #300]	; (10002978 <rs232_init+0x174>)
1000284c:	6912      	ldr	r2, [r2, #16]
1000284e:	2176      	movs	r1, #118	; 0x76
10002850:	430a      	orrs	r2, r1
10002852:	611a      	str	r2, [r3, #16]
		//Vorteiler:
		// Baudrate = 32 MHz * Step/1024 * 1/(PDIV +1)  * 1/ (PCTQ +1) * 1/ (DCTQ +1)
	USIC0_CH1->BRG |= (BRG_PDIV << 16) ;
10002854:	4b48      	ldr	r3, [pc, #288]	; (10002978 <rs232_init+0x174>)
10002856:	4a48      	ldr	r2, [pc, #288]	; (10002978 <rs232_init+0x174>)
10002858:	6952      	ldr	r2, [r2, #20]
1000285a:	21b8      	movs	r1, #184	; 0xb8
1000285c:	0349      	lsls	r1, r1, #13
1000285e:	430a      	orrs	r2, r1
10002860:	615a      	str	r2, [r3, #20]
	USIC0_CH1->BRG |= BRG_DCTQ << 10 ;
10002862:	4b45      	ldr	r3, [pc, #276]	; (10002978 <rs232_init+0x174>)
10002864:	4a44      	ldr	r2, [pc, #272]	; (10002978 <rs232_init+0x174>)
10002866:	6952      	ldr	r2, [r2, #20]
10002868:	21f0      	movs	r1, #240	; 0xf0
1000286a:	0189      	lsls	r1, r1, #6
1000286c:	430a      	orrs	r2, r1
1000286e:	615a      	str	r2, [r3, #20]
	USIC0_CH1->BRG |= BRG_PCTQ << 8 ;
10002870:	4b41      	ldr	r3, [pc, #260]	; (10002978 <rs232_init+0x174>)
10002872:	4a41      	ldr	r2, [pc, #260]	; (10002978 <rs232_init+0x174>)
10002874:	6952      	ldr	r2, [r2, #20]
10002876:	615a      	str	r2, [r3, #20]

		//Configuration of USIC Shift Control
		//Transmit/Receive LSB first is selected, Transmission Mode (TRM) = 1, Passive Data Level (PDL) = 1
	WR_REG(USIC0_CH1->SCTR, USIC_CH_SCTR_PDL_Msk, USIC_CH_SCTR_PDL_Pos, 1);
10002878:	4b3f      	ldr	r3, [pc, #252]	; (10002978 <rs232_init+0x174>)
1000287a:	4a3f      	ldr	r2, [pc, #252]	; (10002978 <rs232_init+0x174>)
1000287c:	6b52      	ldr	r2, [r2, #52]	; 0x34
1000287e:	2102      	movs	r1, #2
10002880:	430a      	orrs	r2, r1
10002882:	635a      	str	r2, [r3, #52]	; 0x34
	WR_REG(USIC0_CH1->SCTR, USIC_CH_SCTR_TRM_Msk, USIC_CH_SCTR_TRM_Pos, 1);
10002884:	4b3c      	ldr	r3, [pc, #240]	; (10002978 <rs232_init+0x174>)
10002886:	4a3c      	ldr	r2, [pc, #240]	; (10002978 <rs232_init+0x174>)
10002888:	6b52      	ldr	r2, [r2, #52]	; 0x34
1000288a:	493c      	ldr	r1, [pc, #240]	; (1000297c <rs232_init+0x178>)
1000288c:	400a      	ands	r2, r1
1000288e:	2180      	movs	r1, #128	; 0x80
10002890:	0049      	lsls	r1, r1, #1
10002892:	430a      	orrs	r2, r1
10002894:	635a      	str	r2, [r3, #52]	; 0x34
		//Set Word Length (WLE) & Frame Length (FLE)
	WR_REG(USIC0_CH1->SCTR, USIC_CH_SCTR_FLE_Msk, USIC_CH_SCTR_FLE_Pos, 7);
10002896:	4b38      	ldr	r3, [pc, #224]	; (10002978 <rs232_init+0x174>)
10002898:	4a37      	ldr	r2, [pc, #220]	; (10002978 <rs232_init+0x174>)
1000289a:	6b52      	ldr	r2, [r2, #52]	; 0x34
1000289c:	4938      	ldr	r1, [pc, #224]	; (10002980 <rs232_init+0x17c>)
1000289e:	400a      	ands	r2, r1
100028a0:	21e0      	movs	r1, #224	; 0xe0
100028a2:	02c9      	lsls	r1, r1, #11
100028a4:	430a      	orrs	r2, r1
100028a6:	635a      	str	r2, [r3, #52]	; 0x34
	WR_REG(USIC0_CH1->SCTR, USIC_CH_SCTR_WLE_Msk, USIC_CH_SCTR_WLE_Pos, 7);
100028a8:	4b33      	ldr	r3, [pc, #204]	; (10002978 <rs232_init+0x174>)
100028aa:	4a33      	ldr	r2, [pc, #204]	; (10002978 <rs232_init+0x174>)
100028ac:	6b52      	ldr	r2, [r2, #52]	; 0x34
100028ae:	4935      	ldr	r1, [pc, #212]	; (10002984 <rs232_init+0x180>)
100028b0:	400a      	ands	r2, r1
100028b2:	21e0      	movs	r1, #224	; 0xe0
100028b4:	04c9      	lsls	r1, r1, #19
100028b6:	430a      	orrs	r2, r1
100028b8:	635a      	str	r2, [r3, #52]	; 0x34

		//Configuration of USIC Transmit Control/Status Register
		//TBUF Data Enable (TDEN) = 1, TBUF Data Single Shot Mode (TDSSM) = 1
	WR_REG(USIC0_CH1->TCSR, USIC_CH_TCSR_TDEN_Msk, USIC_CH_TCSR_TDEN_Pos, 1);
100028ba:	4b2f      	ldr	r3, [pc, #188]	; (10002978 <rs232_init+0x174>)
100028bc:	4a2e      	ldr	r2, [pc, #184]	; (10002978 <rs232_init+0x174>)
100028be:	6b92      	ldr	r2, [r2, #56]	; 0x38
100028c0:	4931      	ldr	r1, [pc, #196]	; (10002988 <rs232_init+0x184>)
100028c2:	400a      	ands	r2, r1
100028c4:	2180      	movs	r1, #128	; 0x80
100028c6:	00c9      	lsls	r1, r1, #3
100028c8:	430a      	orrs	r2, r1
100028ca:	639a      	str	r2, [r3, #56]	; 0x38
	WR_REG(USIC0_CH1->TCSR, USIC_CH_TCSR_TDSSM_Msk, USIC_CH_TCSR_TDSSM_Pos, 1);
100028cc:	4b2a      	ldr	r3, [pc, #168]	; (10002978 <rs232_init+0x174>)
100028ce:	4a2a      	ldr	r2, [pc, #168]	; (10002978 <rs232_init+0x174>)
100028d0:	6b92      	ldr	r2, [r2, #56]	; 0x38
100028d2:	2180      	movs	r1, #128	; 0x80
100028d4:	0049      	lsls	r1, r1, #1
100028d6:	430a      	orrs	r2, r1
100028d8:	639a      	str	r2, [r3, #56]	; 0x38

		//Configuration of Protocol Control Register
		//Sample Mode (SMD) = 1, 1 Stop bit is selected, Sample Point (SP) = 2, Pulse Length (PL) = 0
	WR_REG(USIC0_CH1->PCR_ASCMode, USIC_CH_PCR_ASCMode_SMD_Msk,
100028da:	4b27      	ldr	r3, [pc, #156]	; (10002978 <rs232_init+0x174>)
100028dc:	4a26      	ldr	r2, [pc, #152]	; (10002978 <rs232_init+0x174>)
100028de:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
100028e0:	2101      	movs	r1, #1
100028e2:	430a      	orrs	r2, r1
100028e4:	63da      	str	r2, [r3, #60]	; 0x3c
				USIC_CH_PCR_ASCMode_SMD_Pos, 1);
	WR_REG(USIC0_CH1->PCR_ASCMode, USIC_CH_PCR_ASCMode_STPB_Msk, USIC_CH_PCR_ASCMode_STPB_Pos, 0);
100028e6:	4b24      	ldr	r3, [pc, #144]	; (10002978 <rs232_init+0x174>)
100028e8:	4a23      	ldr	r2, [pc, #140]	; (10002978 <rs232_init+0x174>)
100028ea:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
100028ec:	2102      	movs	r1, #2
100028ee:	438a      	bics	r2, r1
100028f0:	63da      	str	r2, [r3, #60]	; 0x3c
	WR_REG(USIC0_CH1->PCR_ASCMode, USIC_CH_PCR_ASCMode_SP_Msk, USIC_CH_PCR_ASCMode_SP_Pos, 9);
100028f2:	4b21      	ldr	r3, [pc, #132]	; (10002978 <rs232_init+0x174>)
100028f4:	4a20      	ldr	r2, [pc, #128]	; (10002978 <rs232_init+0x174>)
100028f6:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
100028f8:	4924      	ldr	r1, [pc, #144]	; (1000298c <rs232_init+0x188>)
100028fa:	400a      	ands	r2, r1
100028fc:	2190      	movs	r1, #144	; 0x90
100028fe:	0109      	lsls	r1, r1, #4
10002900:	430a      	orrs	r2, r1
10002902:	63da      	str	r2, [r3, #60]	; 0x3c
		//TBIF is set to simplify polling
	WR_REG(USIC0_CH1->PSR_ASCMode, USIC_CH_PSR_TBIF_Msk, USIC_CH_PSR_TBIF_Pos, 1);
10002904:	4b1c      	ldr	r3, [pc, #112]	; (10002978 <rs232_init+0x174>)
10002906:	4a1c      	ldr	r2, [pc, #112]	; (10002978 <rs232_init+0x174>)
10002908:	6c92      	ldr	r2, [r2, #72]	; 0x48
1000290a:	2180      	movs	r1, #128	; 0x80
1000290c:	0189      	lsls	r1, r1, #6
1000290e:	430a      	orrs	r2, r1
10002910:	649a      	str	r2, [r3, #72]	; 0x48
		//Configuration of Transmitter Buffer Control Register
	WR_REG(USIC0_CH1->TBCTR, USIC_CH_TBCTR_LIMIT_Msk, USIC_CH_TBCTR_LIMIT_Pos, 0);
10002912:	4919      	ldr	r1, [pc, #100]	; (10002978 <rs232_init+0x174>)
10002914:	4a18      	ldr	r2, [pc, #96]	; (10002978 <rs232_init+0x174>)
10002916:	2384      	movs	r3, #132	; 0x84
10002918:	005b      	lsls	r3, r3, #1
1000291a:	58d3      	ldr	r3, [r2, r3]
1000291c:	4a1c      	ldr	r2, [pc, #112]	; (10002990 <rs232_init+0x18c>)
1000291e:	401a      	ands	r2, r3
10002920:	2384      	movs	r3, #132	; 0x84
10002922:	005b      	lsls	r3, r3, #1
10002924:	50ca      	str	r2, [r1, r3]

		//Configuration of Channel Control Register
		//parity generation is disabled
	USIC0_CH1->CCR |=  0x02;	// ASC Mode
10002926:	4b14      	ldr	r3, [pc, #80]	; (10002978 <rs232_init+0x174>)
10002928:	4a13      	ldr	r2, [pc, #76]	; (10002978 <rs232_init+0x174>)
1000292a:	6c12      	ldr	r2, [r2, #64]	; 0x40
1000292c:	2102      	movs	r1, #2
1000292e:	430a      	orrs	r2, r1
10002930:	641a      	str	r2, [r3, #64]	; 0x40

		//Data Pointer & Buffer Size for Transmitter Buffer Control - DPTR = 64,  SIZE = 6
	WR_REG(USIC0_CH1->TBCTR, USIC_CH_TBCTR_DPTRSIZE_Msk, USIC_CH_TBCTR_DPTRSIZE_Pos, 0x06000040);
10002932:	4911      	ldr	r1, [pc, #68]	; (10002978 <rs232_init+0x174>)
10002934:	4a10      	ldr	r2, [pc, #64]	; (10002978 <rs232_init+0x174>)
10002936:	2384      	movs	r3, #132	; 0x84
10002938:	005b      	lsls	r3, r3, #1
1000293a:	58d3      	ldr	r3, [r2, r3]
1000293c:	4a15      	ldr	r2, [pc, #84]	; (10002994 <rs232_init+0x190>)
1000293e:	4013      	ands	r3, r2
10002940:	22c0      	movs	r2, #192	; 0xc0
10002942:	04d2      	lsls	r2, r2, #19
10002944:	431a      	orrs	r2, r3
10002946:	2384      	movs	r3, #132	; 0x84
10002948:	005b      	lsls	r3, r3, #1
1000294a:	50ca      	str	r2, [r1, r3]
		// Rx Pin:
	USIC0_CH1->DX0CR = 0x00;	// Kanal: USIC0_CH1 => DXnB auf P1.3 ( siehe Pin Mapping)
1000294c:	4b0a      	ldr	r3, [pc, #40]	; (10002978 <rs232_init+0x174>)
1000294e:	2200      	movs	r2, #0
10002950:	61da      	str	r2, [r3, #28]
	PORT1->IOCR0  |= 0b10111 << 19 ; // ALT 7 fuer P1.2 => TxD d.h. XMC1100 sendet auf P1.2
10002952:	4b11      	ldr	r3, [pc, #68]	; (10002998 <rs232_init+0x194>)
10002954:	4a10      	ldr	r2, [pc, #64]	; (10002998 <rs232_init+0x194>)
10002956:	6912      	ldr	r2, [r2, #16]
10002958:	21b8      	movs	r1, #184	; 0xb8
1000295a:	0409      	lsls	r1, r1, #16
1000295c:	430a      	orrs	r2, r1
1000295e:	611a      	str	r2, [r3, #16]
	PORT1->IOCR0 &= 0x00ffffff;	// P1.3 => INPUT =>  RxD
10002960:	4b0d      	ldr	r3, [pc, #52]	; (10002998 <rs232_init+0x194>)
10002962:	4a0d      	ldr	r2, [pc, #52]	; (10002998 <rs232_init+0x194>)
10002964:	6912      	ldr	r2, [r2, #16]
10002966:	0212      	lsls	r2, r2, #8
10002968:	0a12      	lsrs	r2, r2, #8
1000296a:	611a      	str	r2, [r3, #16]
}
1000296c:	46bd      	mov	sp, r7
1000296e:	bd80      	pop	{r7, pc}
10002970:	40010000 	.word	0x40010000
10002974:	40010300 	.word	0x40010300
10002978:	48000200 	.word	0x48000200
1000297c:	fffffcff 	.word	0xfffffcff
10002980:	ffc0ffff 	.word	0xffc0ffff
10002984:	f0ffffff 	.word	0xf0ffffff
10002988:	fffff3ff 	.word	0xfffff3ff
1000298c:	ffffe0ff 	.word	0xffffe0ff
10002990:	ffffc0ff 	.word	0xffffc0ff
10002994:	f8ffffc0 	.word	0xf8ffffc0
10002998:	40040100 	.word	0x40040100

1000299c <rs232_interrupt_enable>:
	PORT1->IOCR0  |= 0b10111 << 19 ; // ALT 7 fuer P1.2 => TxD d.h. XMC1100 sendet auf P1.2
	PORT1->IOCR0 &= 0x00ffffff;	// P1.3 => INPUT =>  RxD
}

void rs232_interrupt_enable()
{
1000299c:	b580      	push	{r7, lr}
1000299e:	af00      	add	r7, sp, #0
	USIC0_CH1->CCR  |=0x00004000;
100029a0:	4b0c      	ldr	r3, [pc, #48]	; (100029d4 <rs232_interrupt_enable+0x38>)
100029a2:	4a0c      	ldr	r2, [pc, #48]	; (100029d4 <rs232_interrupt_enable+0x38>)
100029a4:	6c12      	ldr	r2, [r2, #64]	; 0x40
100029a6:	2180      	movs	r1, #128	; 0x80
100029a8:	01c9      	lsls	r1, r1, #7
100029aa:	430a      	orrs	r2, r1
100029ac:	641a      	str	r2, [r3, #64]	; 0x40
	USIC0_CH1->INPR &=0xFFFFF8FF;
100029ae:	4b09      	ldr	r3, [pc, #36]	; (100029d4 <rs232_interrupt_enable+0x38>)
100029b0:	4a08      	ldr	r2, [pc, #32]	; (100029d4 <rs232_interrupt_enable+0x38>)
100029b2:	6992      	ldr	r2, [r2, #24]
100029b4:	4908      	ldr	r1, [pc, #32]	; (100029d8 <rs232_interrupt_enable+0x3c>)
100029b6:	400a      	ands	r2, r1
100029b8:	619a      	str	r2, [r3, #24]
	USIC0_CH1->PSCR |=0x00000400;
100029ba:	4b06      	ldr	r3, [pc, #24]	; (100029d4 <rs232_interrupt_enable+0x38>)
100029bc:	4a05      	ldr	r2, [pc, #20]	; (100029d4 <rs232_interrupt_enable+0x38>)
100029be:	6cd2      	ldr	r2, [r2, #76]	; 0x4c
100029c0:	2180      	movs	r1, #128	; 0x80
100029c2:	00c9      	lsls	r1, r1, #3
100029c4:	430a      	orrs	r2, r1
100029c6:	64da      	str	r2, [r3, #76]	; 0x4c
	//NVIC_EnableIRQ(USIC0_0_IRQn); 	// Int Freigabe  SR0 f√ºr empfange Zeichen
	NVIC_EnableIRQ(9); 	// Int Freigabe  SR0 f√ºr empfange Zeichen
100029c8:	2009      	movs	r0, #9
100029ca:	f7fe fdcd 	bl	10001568 <__NVIC_EnableIRQ>
}
100029ce:	46bd      	mov	sp, r7
100029d0:	bd80      	pop	{r7, pc}
100029d2:	46c0      	nop			; (mov r8, r8)
100029d4:	48000200 	.word	0x48000200
100029d8:	fffff8ff 	.word	0xfffff8ff

100029dc <rs232_put>:
}
//---------------------------------------------------------------
// schreibt ein Byte auf COM
//---------------------------------------------------------------
void rs232_put ( char value )
{
100029dc:	b580      	push	{r7, lr}
100029de:	b082      	sub	sp, #8
100029e0:	af00      	add	r7, sp, #0
100029e2:	1c02      	adds	r2, r0, #0
100029e4:	1dfb      	adds	r3, r7, #7
100029e6:	701a      	strb	r2, [r3, #0]
	USIC0_CH1->IN[0] = value;
100029e8:	4908      	ldr	r1, [pc, #32]	; (10002a0c <rs232_put+0x30>)
100029ea:	1dfb      	adds	r3, r7, #7
100029ec:	781a      	ldrb	r2, [r3, #0]
100029ee:	23c0      	movs	r3, #192	; 0xc0
100029f0:	005b      	lsls	r3, r3, #1
100029f2:	50ca      	str	r2, [r1, r3]
	while((USIC0_CH1->TRBSR & (1U<< 11))  == 0);  // Warten , falls Transmit Buffer empty
100029f4:	46c0      	nop			; (mov r8, r8)
100029f6:	4a05      	ldr	r2, [pc, #20]	; (10002a0c <rs232_put+0x30>)
100029f8:	238a      	movs	r3, #138	; 0x8a
100029fa:	005b      	lsls	r3, r3, #1
100029fc:	58d2      	ldr	r2, [r2, r3]
100029fe:	2380      	movs	r3, #128	; 0x80
10002a00:	011b      	lsls	r3, r3, #4
10002a02:	4013      	ands	r3, r2
10002a04:	d0f7      	beq.n	100029f6 <rs232_put+0x1a>

}
10002a06:	46bd      	mov	sp, r7
10002a08:	b002      	add	sp, #8
10002a0a:	bd80      	pop	{r7, pc}
10002a0c:	48000200 	.word	0x48000200

10002a10 <rs232_print>:
//---------------------------------------------------------------
// schreibt eine nullterminierte Zeichenfolge auf COM
//---------------------------------------------------------------
void rs232_print ( char *text )
{
10002a10:	b580      	push	{r7, lr}
10002a12:	b082      	sub	sp, #8
10002a14:	af00      	add	r7, sp, #0
10002a16:	6078      	str	r0, [r7, #4]
  while (*text != '\0')
10002a18:	e006      	b.n	10002a28 <rs232_print+0x18>
    rs232_put(*text++);
10002a1a:	687b      	ldr	r3, [r7, #4]
10002a1c:	1c5a      	adds	r2, r3, #1
10002a1e:	607a      	str	r2, [r7, #4]
10002a20:	781b      	ldrb	r3, [r3, #0]
10002a22:	1c18      	adds	r0, r3, #0
10002a24:	f7ff ffda 	bl	100029dc <rs232_put>
//---------------------------------------------------------------
// schreibt eine nullterminierte Zeichenfolge auf COM
//---------------------------------------------------------------
void rs232_print ( char *text )
{
  while (*text != '\0')
10002a28:	687b      	ldr	r3, [r7, #4]
10002a2a:	781b      	ldrb	r3, [r3, #0]
10002a2c:	2b00      	cmp	r3, #0
10002a2e:	d1f4      	bne.n	10002a1a <rs232_print+0xa>
    rs232_put(*text++);
}
10002a30:	46bd      	mov	sp, r7
10002a32:	b002      	add	sp, #8
10002a34:	bd80      	pop	{r7, pc}
10002a36:	46c0      	nop			; (mov r8, r8)

10002a38 <USIC0_0_IRQHandler>:
* rs232_wait_of_enter(), rs232_clear_receivedata()
* Es werden folgende globale Variablen ben√∂tigt:
* rs232Receivedata, rs232ReceivedataPointer, rs232EnterReceive
*/
void USIC0_0_IRQHandler(void)
{
10002a38:	b580      	push	{r7, lr}
10002a3a:	b082      	sub	sp, #8
10002a3c:	af00      	add	r7, sp, #0
	char temp=USIC0_CH1->RBUF & 0xff;	// Rx-Buffer auslesen
10002a3e:	4b11      	ldr	r3, [pc, #68]	; (10002a84 <USIC0_0_IRQHandler+0x4c>)
10002a40:	6d5a      	ldr	r2, [r3, #84]	; 0x54
10002a42:	1dfb      	adds	r3, r7, #7
10002a44:	701a      	strb	r2, [r3, #0]
	if (temp == '\r') {					// Enterzeichen empfangen?
10002a46:	1dfb      	adds	r3, r7, #7
10002a48:	781b      	ldrb	r3, [r3, #0]
10002a4a:	2b0d      	cmp	r3, #13
10002a4c:	d109      	bne.n	10002a62 <USIC0_0_IRQHandler+0x2a>
		rs232Receivedata[rs232ReceivedataPointer]='\0';
10002a4e:	4b0e      	ldr	r3, [pc, #56]	; (10002a88 <USIC0_0_IRQHandler+0x50>)
10002a50:	781b      	ldrb	r3, [r3, #0]
10002a52:	1c1a      	adds	r2, r3, #0
10002a54:	4b0d      	ldr	r3, [pc, #52]	; (10002a8c <USIC0_0_IRQHandler+0x54>)
10002a56:	2100      	movs	r1, #0
10002a58:	5499      	strb	r1, [r3, r2]
		rs232EnterReceive = 1;
10002a5a:	4b0d      	ldr	r3, [pc, #52]	; (10002a90 <USIC0_0_IRQHandler+0x58>)
10002a5c:	2201      	movs	r2, #1
10002a5e:	701a      	strb	r2, [r3, #0]
10002a60:	e006      	b.n	10002a70 <USIC0_0_IRQHandler+0x38>
	} else {
		rs232Receivedata[rs232ReceivedataPointer]=temp;
10002a62:	4b09      	ldr	r3, [pc, #36]	; (10002a88 <USIC0_0_IRQHandler+0x50>)
10002a64:	781b      	ldrb	r3, [r3, #0]
10002a66:	1c19      	adds	r1, r3, #0
10002a68:	4b08      	ldr	r3, [pc, #32]	; (10002a8c <USIC0_0_IRQHandler+0x54>)
10002a6a:	1dfa      	adds	r2, r7, #7
10002a6c:	7812      	ldrb	r2, [r2, #0]
10002a6e:	545a      	strb	r2, [r3, r1]
	}
	rs232ReceivedataPointer++;
10002a70:	4b05      	ldr	r3, [pc, #20]	; (10002a88 <USIC0_0_IRQHandler+0x50>)
10002a72:	781b      	ldrb	r3, [r3, #0]
10002a74:	3301      	adds	r3, #1
10002a76:	b2da      	uxtb	r2, r3
10002a78:	4b03      	ldr	r3, [pc, #12]	; (10002a88 <USIC0_0_IRQHandler+0x50>)
10002a7a:	701a      	strb	r2, [r3, #0]
	return;
10002a7c:	46c0      	nop			; (mov r8, r8)
}
10002a7e:	46bd      	mov	sp, r7
10002a80:	b002      	add	sp, #8
10002a82:	bd80      	pop	{r7, pc}
10002a84:	48000200 	.word	0x48000200
10002a88:	20000528 	.word	0x20000528
10002a8c:	20000638 	.word	0x20000638
10002a90:	20000529 	.word	0x20000529

10002a94 <uart_init>:
//---------------------------------------------------------------
// Serielle Schnittstelle initialisieren
// RxD auf P1.1 0.6, TxD auf P1.0 0.7, 9600 Baud, 8N1
//---------------------------------------------------------------
void uart_init ( void )
{	//USIC0 Cannel 0 wird verwendet:
10002a94:	b580      	push	{r7, lr}
10002a96:	af00      	add	r7, sp, #0
	SCU_GENERAL->PASSWD = 0x000000C0UL;
10002a98:	4b7f      	ldr	r3, [pc, #508]	; (10002c98 <uart_init+0x204>)
10002a9a:	22c0      	movs	r2, #192	; 0xc0
10002a9c:	625a      	str	r2, [r3, #36]	; 0x24
	SCU_CLK->CGATCLR0 |= 0x00000008;		// stop gating USIC
10002a9e:	4b7f      	ldr	r3, [pc, #508]	; (10002c9c <uart_init+0x208>)
10002aa0:	4a7e      	ldr	r2, [pc, #504]	; (10002c9c <uart_init+0x208>)
10002aa2:	6912      	ldr	r2, [r2, #16]
10002aa4:	2108      	movs	r1, #8
10002aa6:	430a      	orrs	r2, r1
10002aa8:	611a      	str	r2, [r3, #16]
		while((SCU_CLK->CLKCR)&0x40000000UL);	// wait for VDDC to stabilize
10002aaa:	46c0      	nop			; (mov r8, r8)
10002aac:	4b7b      	ldr	r3, [pc, #492]	; (10002c9c <uart_init+0x208>)
10002aae:	681a      	ldr	r2, [r3, #0]
10002ab0:	2380      	movs	r3, #128	; 0x80
10002ab2:	05db      	lsls	r3, r3, #23
10002ab4:	4013      	ands	r3, r2
10002ab6:	d1f9      	bne.n	10002aac <uart_init+0x18>
	SCU_GENERAL->PASSWD = 0x000000C3UL;
10002ab8:	4b77      	ldr	r3, [pc, #476]	; (10002c98 <uart_init+0x204>)
10002aba:	22c3      	movs	r2, #195	; 0xc3
10002abc:	625a      	str	r2, [r3, #36]	; 0x24

	USIC0_CH0->KSCFG |= 3UL ;	//  Mode enable + Freigabe write
10002abe:	2390      	movs	r3, #144	; 0x90
10002ac0:	05db      	lsls	r3, r3, #23
10002ac2:	2290      	movs	r2, #144	; 0x90
10002ac4:	05d2      	lsls	r2, r2, #23
10002ac6:	68d2      	ldr	r2, [r2, #12]
10002ac8:	2103      	movs	r1, #3
10002aca:	430a      	orrs	r2, r1
10002acc:	60da      	str	r2, [r3, #12]
	//WR_REG(USIC0_CH1->FDR, USIC_CH_FDR_DM_Msk, USIC_CH_FDR_DM_Pos, 2);
	USIC0_CH0->FDR |= 1UL << 15 ;	//Fractional divider mode selected
10002ace:	2390      	movs	r3, #144	; 0x90
10002ad0:	05db      	lsls	r3, r3, #23
10002ad2:	2290      	movs	r2, #144	; 0x90
10002ad4:	05d2      	lsls	r2, r2, #23
10002ad6:	6912      	ldr	r2, [r2, #16]
10002ad8:	2180      	movs	r1, #128	; 0x80
10002ada:	0209      	lsls	r1, r1, #8
10002adc:	430a      	orrs	r2, r1
10002ade:	611a      	str	r2, [r3, #16]
		//Step value
	USIC0_CH0->FDR|= FDR_STEP_UART;
10002ae0:	2390      	movs	r3, #144	; 0x90
10002ae2:	05db      	lsls	r3, r3, #23
10002ae4:	2290      	movs	r2, #144	; 0x90
10002ae6:	05d2      	lsls	r2, r2, #23
10002ae8:	6912      	ldr	r2, [r2, #16]
10002aea:	2176      	movs	r1, #118	; 0x76
10002aec:	430a      	orrs	r2, r1
10002aee:	611a      	str	r2, [r3, #16]
		//Vorteiler:
		// Baudrate = 32 MHz * Step/1024 * 1/(PDIV +1)  * 1/ (PCTQ +1) * 1/ (DCTQ +1)
	USIC0_CH0->BRG |= (BRG_PDIV_UART << 16) ;
10002af0:	2390      	movs	r3, #144	; 0x90
10002af2:	05db      	lsls	r3, r3, #23
10002af4:	2290      	movs	r2, #144	; 0x90
10002af6:	05d2      	lsls	r2, r2, #23
10002af8:	6952      	ldr	r2, [r2, #20]
10002afa:	21b8      	movs	r1, #184	; 0xb8
10002afc:	0349      	lsls	r1, r1, #13
10002afe:	430a      	orrs	r2, r1
10002b00:	615a      	str	r2, [r3, #20]
	USIC0_CH0->BRG |= BRG_DCTQ_UART << 10 ;
10002b02:	2390      	movs	r3, #144	; 0x90
10002b04:	05db      	lsls	r3, r3, #23
10002b06:	2290      	movs	r2, #144	; 0x90
10002b08:	05d2      	lsls	r2, r2, #23
10002b0a:	6952      	ldr	r2, [r2, #20]
10002b0c:	21f0      	movs	r1, #240	; 0xf0
10002b0e:	0189      	lsls	r1, r1, #6
10002b10:	430a      	orrs	r2, r1
10002b12:	615a      	str	r2, [r3, #20]
	USIC0_CH0->BRG |= BRG_PCTQ_UART << 8 ;
10002b14:	2390      	movs	r3, #144	; 0x90
10002b16:	05db      	lsls	r3, r3, #23
10002b18:	2290      	movs	r2, #144	; 0x90
10002b1a:	05d2      	lsls	r2, r2, #23
10002b1c:	6952      	ldr	r2, [r2, #20]
10002b1e:	615a      	str	r2, [r3, #20]

		//Configuration of USIC Shift Control
		//Transmit/Receive LSB first is selected, Transmission Mode (TRM) = 1, Passive Data Level (PDL) = 1
	WR_REG(USIC0_CH0->SCTR, USIC_CH_SCTR_PDL_Msk, USIC_CH_SCTR_PDL_Pos, 1);
10002b20:	2390      	movs	r3, #144	; 0x90
10002b22:	05db      	lsls	r3, r3, #23
10002b24:	2290      	movs	r2, #144	; 0x90
10002b26:	05d2      	lsls	r2, r2, #23
10002b28:	6b52      	ldr	r2, [r2, #52]	; 0x34
10002b2a:	2102      	movs	r1, #2
10002b2c:	430a      	orrs	r2, r1
10002b2e:	635a      	str	r2, [r3, #52]	; 0x34
	WR_REG(USIC0_CH0->SCTR, USIC_CH_SCTR_TRM_Msk, USIC_CH_SCTR_TRM_Pos, 1);
10002b30:	2390      	movs	r3, #144	; 0x90
10002b32:	05db      	lsls	r3, r3, #23
10002b34:	2290      	movs	r2, #144	; 0x90
10002b36:	05d2      	lsls	r2, r2, #23
10002b38:	6b52      	ldr	r2, [r2, #52]	; 0x34
10002b3a:	4959      	ldr	r1, [pc, #356]	; (10002ca0 <uart_init+0x20c>)
10002b3c:	400a      	ands	r2, r1
10002b3e:	2180      	movs	r1, #128	; 0x80
10002b40:	0049      	lsls	r1, r1, #1
10002b42:	430a      	orrs	r2, r1
10002b44:	635a      	str	r2, [r3, #52]	; 0x34
		//Set Word Length (WLE) & Frame Length (FLE)
	WR_REG(USIC0_CH0->SCTR, USIC_CH_SCTR_FLE_Msk, USIC_CH_SCTR_FLE_Pos, 7);
10002b46:	2390      	movs	r3, #144	; 0x90
10002b48:	05db      	lsls	r3, r3, #23
10002b4a:	2290      	movs	r2, #144	; 0x90
10002b4c:	05d2      	lsls	r2, r2, #23
10002b4e:	6b52      	ldr	r2, [r2, #52]	; 0x34
10002b50:	4954      	ldr	r1, [pc, #336]	; (10002ca4 <uart_init+0x210>)
10002b52:	400a      	ands	r2, r1
10002b54:	21e0      	movs	r1, #224	; 0xe0
10002b56:	02c9      	lsls	r1, r1, #11
10002b58:	430a      	orrs	r2, r1
10002b5a:	635a      	str	r2, [r3, #52]	; 0x34
	WR_REG(USIC0_CH0->SCTR, USIC_CH_SCTR_WLE_Msk, USIC_CH_SCTR_WLE_Pos, 7);
10002b5c:	2390      	movs	r3, #144	; 0x90
10002b5e:	05db      	lsls	r3, r3, #23
10002b60:	2290      	movs	r2, #144	; 0x90
10002b62:	05d2      	lsls	r2, r2, #23
10002b64:	6b52      	ldr	r2, [r2, #52]	; 0x34
10002b66:	4950      	ldr	r1, [pc, #320]	; (10002ca8 <uart_init+0x214>)
10002b68:	400a      	ands	r2, r1
10002b6a:	21e0      	movs	r1, #224	; 0xe0
10002b6c:	04c9      	lsls	r1, r1, #19
10002b6e:	430a      	orrs	r2, r1
10002b70:	635a      	str	r2, [r3, #52]	; 0x34

		//Configuration of USIC Transmit Control/Status Register
		//TBUF Data Enable (TDEN) = 1, TBUF Data Single Shot Mode (TDSSM) = 1
	WR_REG(USIC0_CH0->TCSR, USIC_CH_TCSR_TDEN_Msk, USIC_CH_TCSR_TDEN_Pos, 1);
10002b72:	2390      	movs	r3, #144	; 0x90
10002b74:	05db      	lsls	r3, r3, #23
10002b76:	2290      	movs	r2, #144	; 0x90
10002b78:	05d2      	lsls	r2, r2, #23
10002b7a:	6b92      	ldr	r2, [r2, #56]	; 0x38
10002b7c:	494b      	ldr	r1, [pc, #300]	; (10002cac <uart_init+0x218>)
10002b7e:	400a      	ands	r2, r1
10002b80:	2180      	movs	r1, #128	; 0x80
10002b82:	00c9      	lsls	r1, r1, #3
10002b84:	430a      	orrs	r2, r1
10002b86:	639a      	str	r2, [r3, #56]	; 0x38
	WR_REG(USIC0_CH0->TCSR, USIC_CH_TCSR_TDSSM_Msk, USIC_CH_TCSR_TDSSM_Pos, 1);
10002b88:	2390      	movs	r3, #144	; 0x90
10002b8a:	05db      	lsls	r3, r3, #23
10002b8c:	2290      	movs	r2, #144	; 0x90
10002b8e:	05d2      	lsls	r2, r2, #23
10002b90:	6b92      	ldr	r2, [r2, #56]	; 0x38
10002b92:	2180      	movs	r1, #128	; 0x80
10002b94:	0049      	lsls	r1, r1, #1
10002b96:	430a      	orrs	r2, r1
10002b98:	639a      	str	r2, [r3, #56]	; 0x38

		//Configuration of Protocol Control Register
		//Sample Mode (SMD) = 1, 1 Stop bit is selected, Sample Point (SP) = 2, Pulse Length (PL) = 0
	WR_REG(USIC0_CH0->PCR_ASCMode, USIC_CH_PCR_ASCMode_SMD_Msk,
10002b9a:	2390      	movs	r3, #144	; 0x90
10002b9c:	05db      	lsls	r3, r3, #23
10002b9e:	2290      	movs	r2, #144	; 0x90
10002ba0:	05d2      	lsls	r2, r2, #23
10002ba2:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
10002ba4:	2101      	movs	r1, #1
10002ba6:	430a      	orrs	r2, r1
10002ba8:	63da      	str	r2, [r3, #60]	; 0x3c
				USIC_CH_PCR_ASCMode_SMD_Pos, 1);
	WR_REG(USIC0_CH0->PCR_ASCMode, USIC_CH_PCR_ASCMode_STPB_Msk, USIC_CH_PCR_ASCMode_STPB_Pos, 0);
10002baa:	2390      	movs	r3, #144	; 0x90
10002bac:	05db      	lsls	r3, r3, #23
10002bae:	2290      	movs	r2, #144	; 0x90
10002bb0:	05d2      	lsls	r2, r2, #23
10002bb2:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
10002bb4:	2102      	movs	r1, #2
10002bb6:	438a      	bics	r2, r1
10002bb8:	63da      	str	r2, [r3, #60]	; 0x3c
	WR_REG(USIC0_CH0->PCR_ASCMode, USIC_CH_PCR_ASCMode_SP_Msk, USIC_CH_PCR_ASCMode_SP_Pos, 9);
10002bba:	2390      	movs	r3, #144	; 0x90
10002bbc:	05db      	lsls	r3, r3, #23
10002bbe:	2290      	movs	r2, #144	; 0x90
10002bc0:	05d2      	lsls	r2, r2, #23
10002bc2:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
10002bc4:	493a      	ldr	r1, [pc, #232]	; (10002cb0 <uart_init+0x21c>)
10002bc6:	400a      	ands	r2, r1
10002bc8:	2190      	movs	r1, #144	; 0x90
10002bca:	0109      	lsls	r1, r1, #4
10002bcc:	430a      	orrs	r2, r1
10002bce:	63da      	str	r2, [r3, #60]	; 0x3c
		//TBIF is set to simplify polling
	WR_REG(USIC0_CH0->PSR_ASCMode, USIC_CH_PSR_TBIF_Msk, USIC_CH_PSR_TBIF_Pos, 1);
10002bd0:	2390      	movs	r3, #144	; 0x90
10002bd2:	05db      	lsls	r3, r3, #23
10002bd4:	2290      	movs	r2, #144	; 0x90
10002bd6:	05d2      	lsls	r2, r2, #23
10002bd8:	6c92      	ldr	r2, [r2, #72]	; 0x48
10002bda:	2180      	movs	r1, #128	; 0x80
10002bdc:	0189      	lsls	r1, r1, #6
10002bde:	430a      	orrs	r2, r1
10002be0:	649a      	str	r2, [r3, #72]	; 0x48
		//Configuration of Transmitter Buffer Control Register
	WR_REG(USIC0_CH0->TBCTR, USIC_CH_TBCTR_LIMIT_Msk, USIC_CH_TBCTR_LIMIT_Pos, 0);
10002be2:	2390      	movs	r3, #144	; 0x90
10002be4:	05da      	lsls	r2, r3, #23
10002be6:	2390      	movs	r3, #144	; 0x90
10002be8:	05d9      	lsls	r1, r3, #23
10002bea:	2384      	movs	r3, #132	; 0x84
10002bec:	005b      	lsls	r3, r3, #1
10002bee:	58cb      	ldr	r3, [r1, r3]
10002bf0:	4930      	ldr	r1, [pc, #192]	; (10002cb4 <uart_init+0x220>)
10002bf2:	4019      	ands	r1, r3
10002bf4:	2384      	movs	r3, #132	; 0x84
10002bf6:	005b      	lsls	r3, r3, #1
10002bf8:	50d1      	str	r1, [r2, r3]

		//Configuration of Channel Control Register
		//parity generation is disabled
	USIC0_CH0->CCR |=  0x02;	// ASC Mode
10002bfa:	2390      	movs	r3, #144	; 0x90
10002bfc:	05db      	lsls	r3, r3, #23
10002bfe:	2290      	movs	r2, #144	; 0x90
10002c00:	05d2      	lsls	r2, r2, #23
10002c02:	6c12      	ldr	r2, [r2, #64]	; 0x40
10002c04:	2102      	movs	r1, #2
10002c06:	430a      	orrs	r2, r1
10002c08:	641a      	str	r2, [r3, #64]	; 0x40

		//Data Pointer & Buffer Size for Transmitter Buffer Control - DPTR = 64,  SIZE = 6
	WR_REG(USIC0_CH0->TBCTR, USIC_CH_TBCTR_DPTRSIZE_Msk_UART, USIC_CH_TBCTR_DPTRSIZE_Pos_UART, 0x06000040);
10002c0a:	2390      	movs	r3, #144	; 0x90
10002c0c:	05da      	lsls	r2, r3, #23
10002c0e:	2390      	movs	r3, #144	; 0x90
10002c10:	05d9      	lsls	r1, r3, #23
10002c12:	2384      	movs	r3, #132	; 0x84
10002c14:	005b      	lsls	r3, r3, #1
10002c16:	58cb      	ldr	r3, [r1, r3]
10002c18:	4927      	ldr	r1, [pc, #156]	; (10002cb8 <uart_init+0x224>)
10002c1a:	400b      	ands	r3, r1
10002c1c:	21c0      	movs	r1, #192	; 0xc0
10002c1e:	04c9      	lsls	r1, r1, #19
10002c20:	4319      	orrs	r1, r3
10002c22:	2384      	movs	r3, #132	; 0x84
10002c24:	005b      	lsls	r3, r3, #1
10002c26:	50d1      	str	r1, [r2, r3]

	// Rx Pin: P1.1
	bit_init(P1,1,INP); //P1.1 als Eingang definieren
10002c28:	2001      	movs	r0, #1
10002c2a:	2101      	movs	r1, #1
10002c2c:	2200      	movs	r2, #0
10002c2e:	f7fe fcb5 	bl	1000159c <bit_init>
	USIC0_CH0->DX0CR &= ~(0x7);	// Kanal: USIC0_CH0 => DX0D auf P1.1 ( siehe Pin Mapping)
10002c32:	2390      	movs	r3, #144	; 0x90
10002c34:	05db      	lsls	r3, r3, #23
10002c36:	2290      	movs	r2, #144	; 0x90
10002c38:	05d2      	lsls	r2, r2, #23
10002c3a:	69d2      	ldr	r2, [r2, #28]
10002c3c:	2107      	movs	r1, #7
10002c3e:	438a      	bics	r2, r1
10002c40:	61da      	str	r2, [r3, #28]
	USIC0_CH0->DX0CR |= 3;
10002c42:	2390      	movs	r3, #144	; 0x90
10002c44:	05db      	lsls	r3, r3, #23
10002c46:	2290      	movs	r2, #144	; 0x90
10002c48:	05d2      	lsls	r2, r2, #23
10002c4a:	69d2      	ldr	r2, [r2, #28]
10002c4c:	2103      	movs	r1, #3
10002c4e:	430a      	orrs	r2, r1
10002c50:	61da      	str	r2, [r3, #28]

	//Tx Pin P1.0
	PORT1->IOCR0 &= 0xffffff07;	// P1.0
10002c52:	4b1a      	ldr	r3, [pc, #104]	; (10002cbc <uart_init+0x228>)
10002c54:	4a19      	ldr	r2, [pc, #100]	; (10002cbc <uart_init+0x228>)
10002c56:	6912      	ldr	r2, [r2, #16]
10002c58:	21f8      	movs	r1, #248	; 0xf8
10002c5a:	438a      	bics	r2, r1
10002c5c:	611a      	str	r2, [r3, #16]
	PORT1->IOCR0  |= 0x000000B8; // ALT 7 fuer P1.0 => TxD d.h. XMC1100 sendet auf P1.0
10002c5e:	4b17      	ldr	r3, [pc, #92]	; (10002cbc <uart_init+0x228>)
10002c60:	4a16      	ldr	r2, [pc, #88]	; (10002cbc <uart_init+0x228>)
10002c62:	6912      	ldr	r2, [r2, #16]
10002c64:	21b8      	movs	r1, #184	; 0xb8
10002c66:	430a      	orrs	r2, r1
10002c68:	611a      	str	r2, [r3, #16]

	//UART Channel Auswahl auf DCE
	bit_init(0,12,OUTP);
10002c6a:	2000      	movs	r0, #0
10002c6c:	210c      	movs	r1, #12
10002c6e:	2201      	movs	r2, #1
10002c70:	f7fe fc94 	bl	1000159c <bit_init>
	bit_write(0,12,1);
10002c74:	2000      	movs	r0, #0
10002c76:	210c      	movs	r1, #12
10002c78:	2201      	movs	r2, #1
10002c7a:	f7ff fc2f 	bl	100024dc <bit_write>
	bit_init(0,13,OUTP);
10002c7e:	2000      	movs	r0, #0
10002c80:	210d      	movs	r1, #13
10002c82:	2201      	movs	r2, #1
10002c84:	f7fe fc8a 	bl	1000159c <bit_init>
	bit_write(0,13,1);
10002c88:	2000      	movs	r0, #0
10002c8a:	210d      	movs	r1, #13
10002c8c:	2201      	movs	r2, #1
10002c8e:	f7ff fc25 	bl	100024dc <bit_write>
}
10002c92:	46bd      	mov	sp, r7
10002c94:	bd80      	pop	{r7, pc}
10002c96:	46c0      	nop			; (mov r8, r8)
10002c98:	40010000 	.word	0x40010000
10002c9c:	40010300 	.word	0x40010300
10002ca0:	fffffcff 	.word	0xfffffcff
10002ca4:	ffc0ffff 	.word	0xffc0ffff
10002ca8:	f0ffffff 	.word	0xf0ffffff
10002cac:	fffff3ff 	.word	0xfffff3ff
10002cb0:	ffffe0ff 	.word	0xffffe0ff
10002cb4:	ffffc0ff 	.word	0xffffc0ff
10002cb8:	f8ffffc0 	.word	0xf8ffffc0
10002cbc:	40040100 	.word	0x40040100

10002cc0 <uart_interrupt_enable>:
	bit_write(0,13,1);
}


void uart_interrupt_enable()
{
10002cc0:	b580      	push	{r7, lr}
10002cc2:	af00      	add	r7, sp, #0
	USIC0_CH0->CCR  |=0x00004000;
10002cc4:	2390      	movs	r3, #144	; 0x90
10002cc6:	05db      	lsls	r3, r3, #23
10002cc8:	2290      	movs	r2, #144	; 0x90
10002cca:	05d2      	lsls	r2, r2, #23
10002ccc:	6c12      	ldr	r2, [r2, #64]	; 0x40
10002cce:	2180      	movs	r1, #128	; 0x80
10002cd0:	01c9      	lsls	r1, r1, #7
10002cd2:	430a      	orrs	r2, r1
10002cd4:	641a      	str	r2, [r3, #64]	; 0x40
	USIC0_CH0->INPR &=0xFFFFF8FF;
10002cd6:	2390      	movs	r3, #144	; 0x90
10002cd8:	05db      	lsls	r3, r3, #23
10002cda:	2290      	movs	r2, #144	; 0x90
10002cdc:	05d2      	lsls	r2, r2, #23
10002cde:	6992      	ldr	r2, [r2, #24]
10002ce0:	490c      	ldr	r1, [pc, #48]	; (10002d14 <uart_interrupt_enable+0x54>)
10002ce2:	400a      	ands	r2, r1
10002ce4:	619a      	str	r2, [r3, #24]
	USIC0_CH0->INPR |=0x00000100; // Interrupt wird auf SR1 gelegt
10002ce6:	2390      	movs	r3, #144	; 0x90
10002ce8:	05db      	lsls	r3, r3, #23
10002cea:	2290      	movs	r2, #144	; 0x90
10002cec:	05d2      	lsls	r2, r2, #23
10002cee:	6992      	ldr	r2, [r2, #24]
10002cf0:	2180      	movs	r1, #128	; 0x80
10002cf2:	0049      	lsls	r1, r1, #1
10002cf4:	430a      	orrs	r2, r1
10002cf6:	619a      	str	r2, [r3, #24]
	USIC0_CH0->PSCR |=0x00000400;
10002cf8:	2390      	movs	r3, #144	; 0x90
10002cfa:	05db      	lsls	r3, r3, #23
10002cfc:	2290      	movs	r2, #144	; 0x90
10002cfe:	05d2      	lsls	r2, r2, #23
10002d00:	6cd2      	ldr	r2, [r2, #76]	; 0x4c
10002d02:	2180      	movs	r1, #128	; 0x80
10002d04:	00c9      	lsls	r1, r1, #3
10002d06:	430a      	orrs	r2, r1
10002d08:	64da      	str	r2, [r3, #76]	; 0x4c
	NVIC_EnableIRQ(USIC0_1_IRQn); 	// Int Freigabe  SR1 f√ºr empfange Zeichen
10002d0a:	200a      	movs	r0, #10
10002d0c:	f7fe fc2c 	bl	10001568 <__NVIC_EnableIRQ>
	//NVIC_EnableIRQ(10); 	// Int Freigabe  SR0 f√ºr empfange Zeichen
}
10002d10:	46bd      	mov	sp, r7
10002d12:	bd80      	pop	{r7, pc}
10002d14:	fffff8ff 	.word	0xfffff8ff

10002d18 <uart_put>:
}
//---------------------------------------------------------------
// schreibt ein Byte auf COM
//---------------------------------------------------------------
void uart_put ( char value )
{
10002d18:	b580      	push	{r7, lr}
10002d1a:	b082      	sub	sp, #8
10002d1c:	af00      	add	r7, sp, #0
10002d1e:	1c02      	adds	r2, r0, #0
10002d20:	1dfb      	adds	r3, r7, #7
10002d22:	701a      	strb	r2, [r3, #0]
	USIC0_CH0->IN[0] = value;
10002d24:	2390      	movs	r3, #144	; 0x90
10002d26:	05da      	lsls	r2, r3, #23
10002d28:	1dfb      	adds	r3, r7, #7
10002d2a:	7819      	ldrb	r1, [r3, #0]
10002d2c:	23c0      	movs	r3, #192	; 0xc0
10002d2e:	005b      	lsls	r3, r3, #1
10002d30:	50d1      	str	r1, [r2, r3]
	while((USIC0_CH0->TRBSR & (1U<< 11))  == 0);  // Warten , bis Transmit Buffer empty
10002d32:	46c0      	nop			; (mov r8, r8)
10002d34:	2390      	movs	r3, #144	; 0x90
10002d36:	05da      	lsls	r2, r3, #23
10002d38:	238a      	movs	r3, #138	; 0x8a
10002d3a:	005b      	lsls	r3, r3, #1
10002d3c:	58d2      	ldr	r2, [r2, r3]
10002d3e:	2380      	movs	r3, #128	; 0x80
10002d40:	011b      	lsls	r3, r3, #4
10002d42:	4013      	ands	r3, r2
10002d44:	d0f6      	beq.n	10002d34 <uart_put+0x1c>

}
10002d46:	46bd      	mov	sp, r7
10002d48:	b002      	add	sp, #8
10002d4a:	bd80      	pop	{r7, pc}

10002d4c <uart_print>:
//---------------------------------------------------------------
// schreibt eine nullterminierte Zeichenfolge auf COM
//---------------------------------------------------------------
void uart_print ( char *text )
{
10002d4c:	b580      	push	{r7, lr}
10002d4e:	b082      	sub	sp, #8
10002d50:	af00      	add	r7, sp, #0
10002d52:	6078      	str	r0, [r7, #4]
  while (*text != '\0')
10002d54:	e006      	b.n	10002d64 <uart_print+0x18>
    uart_put(*text++);
10002d56:	687b      	ldr	r3, [r7, #4]
10002d58:	1c5a      	adds	r2, r3, #1
10002d5a:	607a      	str	r2, [r7, #4]
10002d5c:	781b      	ldrb	r3, [r3, #0]
10002d5e:	1c18      	adds	r0, r3, #0
10002d60:	f7ff ffda 	bl	10002d18 <uart_put>
//---------------------------------------------------------------
// schreibt eine nullterminierte Zeichenfolge auf COM
//---------------------------------------------------------------
void uart_print ( char *text )
{
  while (*text != '\0')
10002d64:	687b      	ldr	r3, [r7, #4]
10002d66:	781b      	ldrb	r3, [r3, #0]
10002d68:	2b00      	cmp	r3, #0
10002d6a:	d1f4      	bne.n	10002d56 <uart_print+0xa>
    uart_put(*text++);
}
10002d6c:	46bd      	mov	sp, r7
10002d6e:	b002      	add	sp, #8
10002d70:	bd80      	pop	{r7, pc}
10002d72:	46c0      	nop			; (mov r8, r8)

10002d74 <USIC0_1_IRQHandler>:
* rs232_wait_of_enter(), rs232_clear_receivedata()
* Es werden folgende globale Variablen ben√∂tigt:
* rs232Receivedata, rs232ReceivedataPointer, rs232EnterReceive
*/
void USIC0_1_IRQHandler(void)
{
10002d74:	b580      	push	{r7, lr}
10002d76:	b082      	sub	sp, #8
10002d78:	af00      	add	r7, sp, #0
	char temp=USIC0_CH0->RBUF & 0xff;	// Rx-Buffer auslesen
10002d7a:	2390      	movs	r3, #144	; 0x90
10002d7c:	05db      	lsls	r3, r3, #23
10002d7e:	6d5a      	ldr	r2, [r3, #84]	; 0x54
10002d80:	1dfb      	adds	r3, r7, #7
10002d82:	701a      	strb	r2, [r3, #0]
	if (temp == '\r') {					// Enterzeichen empfangen?
10002d84:	1dfb      	adds	r3, r7, #7
10002d86:	781b      	ldrb	r3, [r3, #0]
10002d88:	2b0d      	cmp	r3, #13
10002d8a:	d109      	bne.n	10002da0 <USIC0_1_IRQHandler+0x2c>
		uartReceivedata[uartReceivedataPointer]='\0';
10002d8c:	4b0d      	ldr	r3, [pc, #52]	; (10002dc4 <USIC0_1_IRQHandler+0x50>)
10002d8e:	781b      	ldrb	r3, [r3, #0]
10002d90:	1c1a      	adds	r2, r3, #0
10002d92:	4b0d      	ldr	r3, [pc, #52]	; (10002dc8 <USIC0_1_IRQHandler+0x54>)
10002d94:	2100      	movs	r1, #0
10002d96:	5499      	strb	r1, [r3, r2]
		uartEnterReceive = 1;
10002d98:	4b0c      	ldr	r3, [pc, #48]	; (10002dcc <USIC0_1_IRQHandler+0x58>)
10002d9a:	2201      	movs	r2, #1
10002d9c:	701a      	strb	r2, [r3, #0]
10002d9e:	e006      	b.n	10002dae <USIC0_1_IRQHandler+0x3a>
	} else {
		uartReceivedata[uartReceivedataPointer]=temp;
10002da0:	4b08      	ldr	r3, [pc, #32]	; (10002dc4 <USIC0_1_IRQHandler+0x50>)
10002da2:	781b      	ldrb	r3, [r3, #0]
10002da4:	1c19      	adds	r1, r3, #0
10002da6:	4b08      	ldr	r3, [pc, #32]	; (10002dc8 <USIC0_1_IRQHandler+0x54>)
10002da8:	1dfa      	adds	r2, r7, #7
10002daa:	7812      	ldrb	r2, [r2, #0]
10002dac:	545a      	strb	r2, [r3, r1]
	}
	uartReceivedataPointer++;
10002dae:	4b05      	ldr	r3, [pc, #20]	; (10002dc4 <USIC0_1_IRQHandler+0x50>)
10002db0:	781b      	ldrb	r3, [r3, #0]
10002db2:	3301      	adds	r3, #1
10002db4:	b2da      	uxtb	r2, r3
10002db6:	4b03      	ldr	r3, [pc, #12]	; (10002dc4 <USIC0_1_IRQHandler+0x50>)
10002db8:	701a      	strb	r2, [r3, #0]
	//USIC0_CH0->PSCR |=0x00000400;
	return;
10002dba:	46c0      	nop			; (mov r8, r8)
}
10002dbc:	46bd      	mov	sp, r7
10002dbe:	b002      	add	sp, #8
10002dc0:	bd80      	pop	{r7, pc}
10002dc2:	46c0      	nop			; (mov r8, r8)
10002dc4:	2000052a 	.word	0x2000052a
10002dc8:	20000538 	.word	0x20000538
10002dcc:	2000052b 	.word	0x2000052b

10002dd0 <uart_clear_receivedata>:
{
	while (uartEnterReceive==0) {}
	uartEnterReceive=0;
}
void uart_clear_receivedata()
{
10002dd0:	b580      	push	{r7, lr}
10002dd2:	af00      	add	r7, sp, #0
	uartReceivedata[0]='\0';
10002dd4:	4b03      	ldr	r3, [pc, #12]	; (10002de4 <uart_clear_receivedata+0x14>)
10002dd6:	2200      	movs	r2, #0
10002dd8:	701a      	strb	r2, [r3, #0]
	uartReceivedataPointer=0;
10002dda:	4b03      	ldr	r3, [pc, #12]	; (10002de8 <uart_clear_receivedata+0x18>)
10002ddc:	2200      	movs	r2, #0
10002dde:	701a      	strb	r2, [r3, #0]
}
10002de0:	46bd      	mov	sp, r7
10002de2:	bd80      	pop	{r7, pc}
10002de4:	20000538 	.word	0x20000538
10002de8:	2000052a 	.word	0x2000052a

10002dec <uart_select_channel>:
 * UARTCHANNEL_DCE : P0.12=1 und P0.13=1 => Stecker-Ausgang
 * UARTCHANNEL_DTE : P0.12=0 und P0.13=1 => Buchse Ausgang
 * UARTCHANNEL_0 : P0.12=1 und P0.13=0 => TTL Pegel Kanal 0
 * UARTCHANNEL_1 : P0.12=0 und P0.13=0 => TTL Pegel Kanal 1
 */
void uart_select_channel(uint8_t select) {
10002dec:	b580      	push	{r7, lr}
10002dee:	b082      	sub	sp, #8
10002df0:	af00      	add	r7, sp, #0
10002df2:	1c02      	adds	r2, r0, #0
10002df4:	1dfb      	adds	r3, r7, #7
10002df6:	701a      	strb	r2, [r3, #0]
	while((USIC0_CH0->TRBSR & (1U<< 11))  == 0);  // Warten , bis Transmit Buffer empty
10002df8:	46c0      	nop			; (mov r8, r8)
10002dfa:	2390      	movs	r3, #144	; 0x90
10002dfc:	05da      	lsls	r2, r3, #23
10002dfe:	238a      	movs	r3, #138	; 0x8a
10002e00:	005b      	lsls	r3, r3, #1
10002e02:	58d2      	ldr	r2, [r2, r3]
10002e04:	2380      	movs	r3, #128	; 0x80
10002e06:	011b      	lsls	r3, r3, #4
10002e08:	4013      	ands	r3, r2
10002e0a:	d0f6      	beq.n	10002dfa <uart_select_channel+0xe>
	//delay_ms(2);
	switch (select) {
10002e0c:	1dfb      	adds	r3, r7, #7
10002e0e:	781b      	ldrb	r3, [r3, #0]
10002e10:	2b01      	cmp	r3, #1
10002e12:	d013      	beq.n	10002e3c <uart_select_channel+0x50>
10002e14:	dc02      	bgt.n	10002e1c <uart_select_channel+0x30>
10002e16:	2b00      	cmp	r3, #0
10002e18:	d005      	beq.n	10002e26 <uart_select_channel+0x3a>
10002e1a:	e030      	b.n	10002e7e <uart_select_channel+0x92>
10002e1c:	2b02      	cmp	r3, #2
10002e1e:	d018      	beq.n	10002e52 <uart_select_channel+0x66>
10002e20:	2b03      	cmp	r3, #3
10002e22:	d021      	beq.n	10002e68 <uart_select_channel+0x7c>
10002e24:	e02b      	b.n	10002e7e <uart_select_channel+0x92>
	  case UARTCHANNEL_DCE:
	    bit_write(0,12,1);
10002e26:	2000      	movs	r0, #0
10002e28:	210c      	movs	r1, #12
10002e2a:	2201      	movs	r2, #1
10002e2c:	f7ff fb56 	bl	100024dc <bit_write>
	    bit_write(0,13,1);
10002e30:	2000      	movs	r0, #0
10002e32:	210d      	movs	r1, #13
10002e34:	2201      	movs	r2, #1
10002e36:	f7ff fb51 	bl	100024dc <bit_write>
	    break;
10002e3a:	e020      	b.n	10002e7e <uart_select_channel+0x92>
	  case UARTCHANNEL_DTE:
		bit_write(0,12,0);
10002e3c:	2000      	movs	r0, #0
10002e3e:	210c      	movs	r1, #12
10002e40:	2200      	movs	r2, #0
10002e42:	f7ff fb4b 	bl	100024dc <bit_write>
		bit_write(0,13,1);
10002e46:	2000      	movs	r0, #0
10002e48:	210d      	movs	r1, #13
10002e4a:	2201      	movs	r2, #1
10002e4c:	f7ff fb46 	bl	100024dc <bit_write>
		break;
10002e50:	e015      	b.n	10002e7e <uart_select_channel+0x92>
	  case UARTCHANNEL_1:
	    bit_write(0,12,1);
10002e52:	2000      	movs	r0, #0
10002e54:	210c      	movs	r1, #12
10002e56:	2201      	movs	r2, #1
10002e58:	f7ff fb40 	bl	100024dc <bit_write>
	    bit_write(0,13,0);
10002e5c:	2000      	movs	r0, #0
10002e5e:	210d      	movs	r1, #13
10002e60:	2200      	movs	r2, #0
10002e62:	f7ff fb3b 	bl	100024dc <bit_write>
	    break;
10002e66:	e00a      	b.n	10002e7e <uart_select_channel+0x92>
	  case UARTCHANNEL_0:
		bit_write(0,12,0);
10002e68:	2000      	movs	r0, #0
10002e6a:	210c      	movs	r1, #12
10002e6c:	2200      	movs	r2, #0
10002e6e:	f7ff fb35 	bl	100024dc <bit_write>
		bit_write(0,13,0);
10002e72:	2000      	movs	r0, #0
10002e74:	210d      	movs	r1, #13
10002e76:	2200      	movs	r2, #0
10002e78:	f7ff fb30 	bl	100024dc <bit_write>
		break;
10002e7c:	46c0      	nop			; (mov r8, r8)
	}
}
10002e7e:	46bd      	mov	sp, r7
10002e80:	b002      	add	sp, #8
10002e82:	bd80      	pop	{r7, pc}

10002e84 <__NVIC_SystemReset>:
/**
  \brief   System Reset
  \details Initiates a system reset request to reset the MCU.
 */
__STATIC_INLINE void __NVIC_SystemReset(void)
{
10002e84:	b580      	push	{r7, lr}
10002e86:	af00      	add	r7, sp, #0
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
10002e88:	f3bf 8f4f 	dsb	sy
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = ((0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
10002e8c:	4b03      	ldr	r3, [pc, #12]	; (10002e9c <__NVIC_SystemReset+0x18>)
10002e8e:	4a04      	ldr	r2, [pc, #16]	; (10002ea0 <__NVIC_SystemReset+0x1c>)
10002e90:	60da      	str	r2, [r3, #12]
10002e92:	f3bf 8f4f 	dsb	sy
                 SCB_AIRCR_SYSRESETREQ_Msk);
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
10002e96:	46c0      	nop			; (mov r8, r8)
  }
10002e98:	e7fd      	b.n	10002e96 <__NVIC_SystemReset+0x12>
10002e9a:	46c0      	nop			; (mov r8, r8)
10002e9c:	e000ed00 	.word	0xe000ed00
10002ea0:	05fa0004 	.word	0x05fa0004

10002ea4 <main>:

void handleNewObject();
void sortObject();
void test(int onOrOff);

int main(void) {
10002ea4:	b580      	push	{r7, lr}
10002ea6:	af00      	add	r7, sp, #0
	init();
10002ea8:	f7fe f96e 	bl	10001188 <init>
	LEDStripes(OFF);
10002eac:	2000      	movs	r0, #0
10002eae:	f7fe f9f5 	bl	1000129c <LEDStripes>
	productionLine(ON, FORWARD);
10002eb2:	2001      	movs	r0, #1
10002eb4:	2100      	movs	r1, #0
10002eb6:	f7fe fa33 	bl	10001320 <productionLine>
	slider(0, SLIDERFORWARD);
10002eba:	2000      	movs	r0, #0
10002ebc:	2100      	movs	r1, #0
10002ebe:	f7fe fb33 	bl	10001528 <slider>
	test(OFF);
10002ec2:	2000      	movs	r0, #0
10002ec4:	f000 f914 	bl	100030f0 <test>

	while (1U) {
		laser(ON);
10002ec8:	2001      	movs	r0, #1
10002eca:	f7fe f9d1 	bl	10001270 <laser>
		// New object handling
		if (lightBarrier2() == OFF && handleObjectMovingAway == 0) {
10002ece:	f7fe fa77 	bl	100013c0 <lightBarrier2>
10002ed2:	1e03      	subs	r3, r0, #0
10002ed4:	d105      	bne.n	10002ee2 <main+0x3e>
10002ed6:	4b24      	ldr	r3, [pc, #144]	; (10002f68 <main+0xc4>)
10002ed8:	681b      	ldr	r3, [r3, #0]
10002eda:	2b00      	cmp	r3, #0
10002edc:	d101      	bne.n	10002ee2 <main+0x3e>
			handleNewObject();
10002ede:	f000 f84b 	bl	10002f78 <handleNewObject>
		}

		// Object sorting if necessary
		if (lightBarrier1() == OFF && numObjects > 0
10002ee2:	f7fe fa41 	bl	10001368 <lightBarrier1>
10002ee6:	1e03      	subs	r3, r0, #0
10002ee8:	d109      	bne.n	10002efe <main+0x5a>
10002eea:	4b20      	ldr	r3, [pc, #128]	; (10002f6c <main+0xc8>)
10002eec:	681b      	ldr	r3, [r3, #0]
10002eee:	2b00      	cmp	r3, #0
10002ef0:	dd05      	ble.n	10002efe <main+0x5a>
				&& sortObjectMovingAway == 0) {
10002ef2:	4b1f      	ldr	r3, [pc, #124]	; (10002f70 <main+0xcc>)
10002ef4:	681b      	ldr	r3, [r3, #0]
10002ef6:	2b00      	cmp	r3, #0
10002ef8:	d101      	bne.n	10002efe <main+0x5a>
			sortObject();
10002efa:	f000 f8a7 	bl	1000304c <sortObject>
		}

		// Reset flags
		if (lightBarrier2() == ON) {
10002efe:	f7fe fa5f 	bl	100013c0 <lightBarrier2>
10002f02:	1e03      	subs	r3, r0, #0
10002f04:	2b01      	cmp	r3, #1
10002f06:	d102      	bne.n	10002f0e <main+0x6a>
			handleObjectMovingAway = 0;
10002f08:	4b17      	ldr	r3, [pc, #92]	; (10002f68 <main+0xc4>)
10002f0a:	2200      	movs	r2, #0
10002f0c:	601a      	str	r2, [r3, #0]
		}
		if (lightBarrier1() == ON) {
10002f0e:	f7fe fa2b 	bl	10001368 <lightBarrier1>
10002f12:	1e03      	subs	r3, r0, #0
10002f14:	2b01      	cmp	r3, #1
10002f16:	d102      	bne.n	10002f1e <main+0x7a>
			sortObjectMovingAway = 0;
10002f18:	4b15      	ldr	r3, [pc, #84]	; (10002f70 <main+0xcc>)
10002f1a:	2200      	movs	r2, #0
10002f1c:	601a      	str	r2, [r3, #0]
		}

		// Reset the slider if the button is pressed
		if (readButton1() == ON) {
10002f1e:	f7fe fad3 	bl	100014c8 <readButton1>
10002f22:	1e03      	subs	r3, r0, #0
10002f24:	2b01      	cmp	r3, #1
10002f26:	d10d      	bne.n	10002f44 <main+0xa0>
			// slider to max backward position
			slider(50000, SLIDERBACKWARD);
10002f28:	4b12      	ldr	r3, [pc, #72]	; (10002f74 <main+0xd0>)
10002f2a:	1c18      	adds	r0, r3, #0
10002f2c:	2101      	movs	r1, #1
10002f2e:	f7fe fafb 	bl	10001528 <slider>
			while (readInductivSensor1() == 0)
10002f32:	46c0      	nop			; (mov r8, r8)
10002f34:	f7fe fae4 	bl	10001500 <readInductivSensor1>
10002f38:	1e03      	subs	r3, r0, #0
10002f3a:	d0fb      	beq.n	10002f34 <main+0x90>
				;
			// slider stops
			slider(0, SLIDERFORWARD);
10002f3c:	2000      	movs	r0, #0
10002f3e:	2100      	movs	r1, #0
10002f40:	f7fe faf2 	bl	10001528 <slider>
		}

		// reset system, if button 2 is pressed
		if (readButton2() == ON) {
10002f44:	f7fe face 	bl	100014e4 <readButton2>
10002f48:	1e03      	subs	r3, r0, #0
10002f4a:	2b01      	cmp	r3, #1
10002f4c:	d107      	bne.n	10002f5e <main+0xba>
			// wait till the button is released
			while (readButton2() == ON)
10002f4e:	46c0      	nop			; (mov r8, r8)
10002f50:	f7fe fac8 	bl	100014e4 <readButton2>
10002f54:	1e03      	subs	r3, r0, #0
10002f56:	2b01      	cmp	r3, #1
10002f58:	d0fa      	beq.n	10002f50 <main+0xac>
				;
			// reset the system
			NVIC_SystemReset();
10002f5a:	f7ff ff93 	bl	10002e84 <__NVIC_SystemReset>
		}

		productionLine(ON, FORWARD);
10002f5e:	2001      	movs	r0, #1
10002f60:	2100      	movs	r1, #0
10002f62:	f7fe f9dd 	bl	10001320 <productionLine>
	}
10002f66:	e7af      	b.n	10002ec8 <main+0x24>
10002f68:	20000530 	.word	0x20000530
10002f6c:	2000052c 	.word	0x2000052c
10002f70:	20000534 	.word	0x20000534
10002f74:	0000c350 	.word	0x0000c350

10002f78 <handleNewObject>:

	return 0; // Added return statement for formality, though it will never be reached in this loop
}

void handleNewObject() {
10002f78:	b580      	push	{r7, lr}
10002f7a:	af00      	add	r7, sp, #0
	handleObjectMovingAway = 1;
10002f7c:	4b2c      	ldr	r3, [pc, #176]	; (10003030 <handleNewObject+0xb8>)
10002f7e:	2201      	movs	r2, #1
10002f80:	601a      	str	r2, [r3, #0]

	productionLine(OFF, FORWARD);
10002f82:	2000      	movs	r0, #0
10002f84:	2100      	movs	r1, #0
10002f86:	f7fe f9cb 	bl	10001320 <productionLine>

	LEDStripes(ON);
10002f8a:	2001      	movs	r0, #1
10002f8c:	f7fe f986 	bl	1000129c <LEDStripes>
	laser(OFF);
10002f90:	2000      	movs	r0, #0
10002f92:	f7fe f96d 	bl	10001270 <laser>

	pneumatics1(OUT);
10002f96:	2001      	movs	r0, #1
10002f98:	f7fe fa6a 	bl	10001470 <pneumatics1>

	// Get classification
	uart_print("Good or bad?\n\r");
10002f9c:	4b25      	ldr	r3, [pc, #148]	; (10003034 <handleNewObject+0xbc>)
10002f9e:	1c18      	adds	r0, r3, #0
10002fa0:	f7ff fed4 	bl	10002d4c <uart_print>

	// uart_wait_of_enter();
	while (uartEnterReceive == 0) {
10002fa4:	e00c      	b.n	10002fc0 <handleNewObject+0x48>
		if (readButton2() == ON) {
10002fa6:	f7fe fa9d 	bl	100014e4 <readButton2>
10002faa:	1e03      	subs	r3, r0, #0
10002fac:	2b01      	cmp	r3, #1
10002fae:	d107      	bne.n	10002fc0 <handleNewObject+0x48>
			// wait till the button is released
			while (readButton2() == ON)
10002fb0:	46c0      	nop			; (mov r8, r8)
10002fb2:	f7fe fa97 	bl	100014e4 <readButton2>
10002fb6:	1e03      	subs	r3, r0, #0
10002fb8:	2b01      	cmp	r3, #1
10002fba:	d0fa      	beq.n	10002fb2 <handleNewObject+0x3a>
				;
			// reset the system
			NVIC_SystemReset();
10002fbc:	f7ff ff62 	bl	10002e84 <__NVIC_SystemReset>

	// Get classification
	uart_print("Good or bad?\n\r");

	// uart_wait_of_enter();
	while (uartEnterReceive == 0) {
10002fc0:	4b1d      	ldr	r3, [pc, #116]	; (10003038 <handleNewObject+0xc0>)
10002fc2:	781b      	ldrb	r3, [r3, #0]
10002fc4:	2b00      	cmp	r3, #0
10002fc6:	d0ee      	beq.n	10002fa6 <handleNewObject+0x2e>
				;
			// reset the system
			NVIC_SystemReset();
		}
	}
	uartEnterReceive = 0;
10002fc8:	4b1b      	ldr	r3, [pc, #108]	; (10003038 <handleNewObject+0xc0>)
10002fca:	2200      	movs	r2, #0
10002fcc:	701a      	strb	r2, [r3, #0]

	rs232_print(uartReceivedata);
10002fce:	4b1b      	ldr	r3, [pc, #108]	; (1000303c <handleNewObject+0xc4>)
10002fd0:	1c18      	adds	r0, r3, #0
10002fd2:	f7ff fd1d 	bl	10002a10 <rs232_print>

	pneumatics1(IN);
10002fd6:	2000      	movs	r0, #0
10002fd8:	f7fe fa4a 	bl	10001470 <pneumatics1>

	// Save if apple is good or bad in the nextObjects array (append to the end of the array)
	if (uartReceivedata[0] == 'n') {
10002fdc:	4b17      	ldr	r3, [pc, #92]	; (1000303c <handleNewObject+0xc4>)
10002fde:	781b      	ldrb	r3, [r3, #0]
10002fe0:	2b6e      	cmp	r3, #110	; 0x6e
10002fe2:	d104      	bne.n	10002fee <handleNewObject+0x76>
		// do nothing
		rs232_print("Do nothing.");
10002fe4:	4b16      	ldr	r3, [pc, #88]	; (10003040 <handleNewObject+0xc8>)
10002fe6:	1c18      	adds	r0, r3, #0
10002fe8:	f7ff fd12 	bl	10002a10 <rs232_print>
10002fec:	e012      	b.n	10003014 <handleNewObject+0x9c>
	} else if (numObjects < MAX_OBJECTS) {
10002fee:	4b15      	ldr	r3, [pc, #84]	; (10003044 <handleNewObject+0xcc>)
10002ff0:	681b      	ldr	r3, [r3, #0]
10002ff2:	2b63      	cmp	r3, #99	; 0x63
10002ff4:	dc0e      	bgt.n	10003014 <handleNewObject+0x9c>
		nextObjects[numObjects++] = (
10002ff6:	4b13      	ldr	r3, [pc, #76]	; (10003044 <handleNewObject+0xcc>)
10002ff8:	681b      	ldr	r3, [r3, #0]
10002ffa:	1c59      	adds	r1, r3, #1
10002ffc:	4a11      	ldr	r2, [pc, #68]	; (10003044 <handleNewObject+0xcc>)
10002ffe:	6011      	str	r1, [r2, #0]
				uartReceivedata[0] == 'd' ? DONTSORTOUT : SORTOUT); // Fixed logic for good/bad apple
10003000:	4a0e      	ldr	r2, [pc, #56]	; (1000303c <handleNewObject+0xc4>)
10003002:	7812      	ldrb	r2, [r2, #0]
10003004:	3a64      	subs	r2, #100	; 0x64
10003006:	1e51      	subs	r1, r2, #1
10003008:	418a      	sbcs	r2, r1
1000300a:	b2d2      	uxtb	r2, r2
1000300c:	1c11      	adds	r1, r2, #0
	// Save if apple is good or bad in the nextObjects array (append to the end of the array)
	if (uartReceivedata[0] == 'n') {
		// do nothing
		rs232_print("Do nothing.");
	} else if (numObjects < MAX_OBJECTS) {
		nextObjects[numObjects++] = (
1000300e:	4a0e      	ldr	r2, [pc, #56]	; (10003048 <handleNewObject+0xd0>)
10003010:	009b      	lsls	r3, r3, #2
10003012:	5099      	str	r1, [r3, r2]
				uartReceivedata[0] == 'd' ? DONTSORTOUT : SORTOUT); // Fixed logic for good/bad apple
	}
	uart_clear_receivedata();
10003014:	f7ff fedc 	bl	10002dd0 <uart_clear_receivedata>

	laser(ON);
10003018:	2001      	movs	r0, #1
1000301a:	f7fe f929 	bl	10001270 <laser>
	LEDStripes(OFF);
1000301e:	2000      	movs	r0, #0
10003020:	f7fe f93c 	bl	1000129c <LEDStripes>
	productionLine(ON, FORWARD);
10003024:	2001      	movs	r0, #1
10003026:	2100      	movs	r1, #0
10003028:	f7fe f97a 	bl	10001320 <productionLine>
}
1000302c:	46bd      	mov	sp, r7
1000302e:	bd80      	pop	{r7, pc}
10003030:	20000530 	.word	0x20000530
10003034:	1000339c 	.word	0x1000339c
10003038:	2000052b 	.word	0x2000052b
1000303c:	20000538 	.word	0x20000538
10003040:	100033ac 	.word	0x100033ac
10003044:	2000052c 	.word	0x2000052c
10003048:	20000738 	.word	0x20000738

1000304c <sortObject>:

void sortObject() {
1000304c:	b580      	push	{r7, lr}
1000304e:	b082      	sub	sp, #8
10003050:	af00      	add	r7, sp, #0
	sortObjectMovingAway = 1;
10003052:	4b23      	ldr	r3, [pc, #140]	; (100030e0 <sortObject+0x94>)
10003054:	2201      	movs	r2, #1
10003056:	601a      	str	r2, [r3, #0]

	productionLine(OFF, FORWARD);
10003058:	2000      	movs	r0, #0
1000305a:	2100      	movs	r1, #0
1000305c:	f7fe f960 	bl	10001320 <productionLine>
	if (nextObjects[0] == SORTOUT) {
10003060:	4b20      	ldr	r3, [pc, #128]	; (100030e4 <sortObject+0x98>)
10003062:	681b      	ldr	r3, [r3, #0]
10003064:	2b01      	cmp	r3, #1
10003066:	d117      	bne.n	10003098 <sortObject+0x4c>
		slider(50000, SLIDERFORWARD);
10003068:	4b1f      	ldr	r3, [pc, #124]	; (100030e8 <sortObject+0x9c>)
1000306a:	1c18      	adds	r0, r3, #0
1000306c:	2100      	movs	r1, #0
1000306e:	f7fe fa5b 	bl	10001528 <slider>
		while (readInductivSensor2() == 0)
10003072:	46c0      	nop			; (mov r8, r8)
10003074:	f7fe fa4e 	bl	10001514 <readInductivSensor2>
10003078:	1e03      	subs	r3, r0, #0
1000307a:	d0fb      	beq.n	10003074 <sortObject+0x28>
			;
		slider(50000, SLIDERBACKWARD);
1000307c:	4b1a      	ldr	r3, [pc, #104]	; (100030e8 <sortObject+0x9c>)
1000307e:	1c18      	adds	r0, r3, #0
10003080:	2101      	movs	r1, #1
10003082:	f7fe fa51 	bl	10001528 <slider>
		while (readInductivSensor1() == 0)
10003086:	46c0      	nop			; (mov r8, r8)
10003088:	f7fe fa3a 	bl	10001500 <readInductivSensor1>
1000308c:	1e03      	subs	r3, r0, #0
1000308e:	d0fb      	beq.n	10003088 <sortObject+0x3c>
			;
		// slider stops
		slider(0, SLIDERFORWARD);
10003090:	2000      	movs	r0, #0
10003092:	2100      	movs	r1, #0
10003094:	f7fe fa48 	bl	10001528 <slider>
	}
	// Shift the nextObjects array elements left, deleting the first element
	for (int i = 1; i < numObjects; i++) {
10003098:	2301      	movs	r3, #1
1000309a:	607b      	str	r3, [r7, #4]
1000309c:	e00b      	b.n	100030b6 <sortObject+0x6a>
		nextObjects[i - 1] = nextObjects[i];
1000309e:	687b      	ldr	r3, [r7, #4]
100030a0:	1e5a      	subs	r2, r3, #1
100030a2:	4b10      	ldr	r3, [pc, #64]	; (100030e4 <sortObject+0x98>)
100030a4:	6879      	ldr	r1, [r7, #4]
100030a6:	0089      	lsls	r1, r1, #2
100030a8:	58c9      	ldr	r1, [r1, r3]
100030aa:	4b0e      	ldr	r3, [pc, #56]	; (100030e4 <sortObject+0x98>)
100030ac:	0092      	lsls	r2, r2, #2
100030ae:	50d1      	str	r1, [r2, r3]
			;
		// slider stops
		slider(0, SLIDERFORWARD);
	}
	// Shift the nextObjects array elements left, deleting the first element
	for (int i = 1; i < numObjects; i++) {
100030b0:	687b      	ldr	r3, [r7, #4]
100030b2:	3301      	adds	r3, #1
100030b4:	607b      	str	r3, [r7, #4]
100030b6:	4b0d      	ldr	r3, [pc, #52]	; (100030ec <sortObject+0xa0>)
100030b8:	681b      	ldr	r3, [r3, #0]
100030ba:	687a      	ldr	r2, [r7, #4]
100030bc:	429a      	cmp	r2, r3
100030be:	dbee      	blt.n	1000309e <sortObject+0x52>
		nextObjects[i - 1] = nextObjects[i];
	}
	if (numObjects > 0)
100030c0:	4b0a      	ldr	r3, [pc, #40]	; (100030ec <sortObject+0xa0>)
100030c2:	681b      	ldr	r3, [r3, #0]
100030c4:	2b00      	cmp	r3, #0
100030c6:	dd04      	ble.n	100030d2 <sortObject+0x86>
		numObjects--; // Decrease the objects count after sorting one out
100030c8:	4b08      	ldr	r3, [pc, #32]	; (100030ec <sortObject+0xa0>)
100030ca:	681b      	ldr	r3, [r3, #0]
100030cc:	1e5a      	subs	r2, r3, #1
100030ce:	4b07      	ldr	r3, [pc, #28]	; (100030ec <sortObject+0xa0>)
100030d0:	601a      	str	r2, [r3, #0]
	productionLine(ON, FORWARD);
100030d2:	2001      	movs	r0, #1
100030d4:	2100      	movs	r1, #0
100030d6:	f7fe f923 	bl	10001320 <productionLine>
}
100030da:	46bd      	mov	sp, r7
100030dc:	b002      	add	sp, #8
100030de:	bd80      	pop	{r7, pc}
100030e0:	20000534 	.word	0x20000534
100030e4:	20000738 	.word	0x20000738
100030e8:	0000c350 	.word	0x0000c350
100030ec:	2000052c 	.word	0x2000052c

100030f0 <test>:

void test(int onOrOff) {
100030f0:	b580      	push	{r7, lr}
100030f2:	b082      	sub	sp, #8
100030f4:	af00      	add	r7, sp, #0
100030f6:	6078      	str	r0, [r7, #4]
	if (!onOrOff) {
100030f8:	687b      	ldr	r3, [r7, #4]
100030fa:	2b00      	cmp	r3, #0
100030fc:	d110      	bne.n	10003120 <test+0x30>
		// shut everything down
		laser(OFF);
100030fe:	2000      	movs	r0, #0
10003100:	f7fe f8b6 	bl	10001270 <laser>
		LEDStripes(OFF);
10003104:	2000      	movs	r0, #0
10003106:	f7fe f8c9 	bl	1000129c <LEDStripes>
		redLED(OFF);
1000310a:	2000      	movs	r0, #0
1000310c:	f7fe f8dc 	bl	100012c8 <redLED>
		greenLED(OFF);
10003110:	2000      	movs	r0, #0
10003112:	f7fe f8ef 	bl	100012f4 <greenLED>
		productionLine(OFF, FORWARD);
10003116:	2000      	movs	r0, #0
10003118:	2100      	movs	r1, #0
1000311a:	f7fe f901 	bl	10001320 <productionLine>
		return;
1000311e:	e07f      	b.n	10003220 <test+0x130>
	}

	// light test: manual check
	laser(ON);
10003120:	2001      	movs	r0, #1
10003122:	f7fe f8a5 	bl	10001270 <laser>
	LEDStripes(ON);
10003126:	2001      	movs	r0, #1
10003128:	f7fe f8b8 	bl	1000129c <LEDStripes>
	redLED(ON);
1000312c:	2001      	movs	r0, #1
1000312e:	f7fe f8cb 	bl	100012c8 <redLED>
	greenLED(ON);
10003132:	2001      	movs	r0, #1
10003134:	f7fe f8de 	bl	100012f4 <greenLED>
	delay_ms(5000);
10003138:	4b3b      	ldr	r3, [pc, #236]	; (10003228 <test+0x138>)
1000313a:	1c18      	adds	r0, r3, #0
1000313c:	f7ff fb40 	bl	100027c0 <delay_ms>
	LEDStripes(OFF);
10003140:	2000      	movs	r0, #0
10003142:	f7fe f8ab 	bl	1000129c <LEDStripes>
	redLED(OFF);
10003146:	2000      	movs	r0, #0
10003148:	f7fe f8be 	bl	100012c8 <redLED>
	greenLED(OFF);
1000314c:	2000      	movs	r0, #0
1000314e:	f7fe f8d1 	bl	100012f4 <greenLED>
	delay_ms(2000);
10003152:	23fa      	movs	r3, #250	; 0xfa
10003154:	00db      	lsls	r3, r3, #3
10003156:	1c18      	adds	r0, r3, #0
10003158:	f7ff fb32 	bl	100027c0 <delay_ms>

	// check lightbarriers: automatic check
	if (lightBarrier1()) {
1000315c:	f7fe f904 	bl	10001368 <lightBarrier1>
10003160:	1e03      	subs	r3, r0, #0
10003162:	d003      	beq.n	1000316c <test+0x7c>
		greenLED(ON);
10003164:	2001      	movs	r0, #1
10003166:	f7fe f8c5 	bl	100012f4 <greenLED>
1000316a:	e002      	b.n	10003172 <test+0x82>
	} else {
		redLED(ON);
1000316c:	2001      	movs	r0, #1
1000316e:	f7fe f8ab 	bl	100012c8 <redLED>
	}
	delay_ms(1000);
10003172:	23fa      	movs	r3, #250	; 0xfa
10003174:	009b      	lsls	r3, r3, #2
10003176:	1c18      	adds	r0, r3, #0
10003178:	f7ff fb22 	bl	100027c0 <delay_ms>
	redLED(OFF);
1000317c:	2000      	movs	r0, #0
1000317e:	f7fe f8a3 	bl	100012c8 <redLED>
	greenLED(OFF);
10003182:	2000      	movs	r0, #0
10003184:	f7fe f8b6 	bl	100012f4 <greenLED>
	delay_ms(500);
10003188:	23fa      	movs	r3, #250	; 0xfa
1000318a:	005b      	lsls	r3, r3, #1
1000318c:	1c18      	adds	r0, r3, #0
1000318e:	f7ff fb17 	bl	100027c0 <delay_ms>
	if (lightBarrier2()) {
10003192:	f7fe f915 	bl	100013c0 <lightBarrier2>
10003196:	1e03      	subs	r3, r0, #0
10003198:	d003      	beq.n	100031a2 <test+0xb2>
		greenLED(ON);
1000319a:	2001      	movs	r0, #1
1000319c:	f7fe f8aa 	bl	100012f4 <greenLED>
100031a0:	e002      	b.n	100031a8 <test+0xb8>
	} else {
		redLED(ON);
100031a2:	2001      	movs	r0, #1
100031a4:	f7fe f890 	bl	100012c8 <redLED>
	}
	delay_ms(1000);
100031a8:	23fa      	movs	r3, #250	; 0xfa
100031aa:	009b      	lsls	r3, r3, #2
100031ac:	1c18      	adds	r0, r3, #0
100031ae:	f7ff fb07 	bl	100027c0 <delay_ms>
	redLED(OFF);
100031b2:	2000      	movs	r0, #0
100031b4:	f7fe f888 	bl	100012c8 <redLED>
	greenLED(OFF);
100031b8:	2000      	movs	r0, #0
100031ba:	f7fe f89b 	bl	100012f4 <greenLED>
	delay_ms(500);
100031be:	23fa      	movs	r3, #250	; 0xfa
100031c0:	005b      	lsls	r3, r3, #1
100031c2:	1c18      	adds	r0, r3, #0
100031c4:	f7ff fafc 	bl	100027c0 <delay_ms>
	if (lightBarrier3()) {
100031c8:	f7fe f926 	bl	10001418 <lightBarrier3>
100031cc:	1e03      	subs	r3, r0, #0
100031ce:	d003      	beq.n	100031d8 <test+0xe8>
		greenLED(ON);
100031d0:	2001      	movs	r0, #1
100031d2:	f7fe f88f 	bl	100012f4 <greenLED>
100031d6:	e002      	b.n	100031de <test+0xee>
	} else {
		redLED(ON);
100031d8:	2001      	movs	r0, #1
100031da:	f7fe f875 	bl	100012c8 <redLED>
	}
	delay_ms(1000);
100031de:	23fa      	movs	r3, #250	; 0xfa
100031e0:	009b      	lsls	r3, r3, #2
100031e2:	1c18      	adds	r0, r3, #0
100031e4:	f7ff faec 	bl	100027c0 <delay_ms>
	redLED(OFF);
100031e8:	2000      	movs	r0, #0
100031ea:	f7fe f86d 	bl	100012c8 <redLED>
	greenLED(OFF);
100031ee:	2000      	movs	r0, #0
100031f0:	f7fe f880 	bl	100012f4 <greenLED>
	 delay_ms(1000);
	 productionLine(OFF, FORWARD);
	 */

	// check pneumatics1
	pneumatics1(OUT);
100031f4:	2001      	movs	r0, #1
100031f6:	f7fe f93b 	bl	10001470 <pneumatics1>
	delay_ms(1000);
100031fa:	23fa      	movs	r3, #250	; 0xfa
100031fc:	009b      	lsls	r3, r3, #2
100031fe:	1c18      	adds	r0, r3, #0
10003200:	f7ff fade 	bl	100027c0 <delay_ms>
	pneumatics1(IN);
10003204:	2000      	movs	r0, #0
10003206:	f7fe f933 	bl	10001470 <pneumatics1>
	pneumatics2(OUT);
1000320a:	2001      	movs	r0, #1
1000320c:	f7fe f946 	bl	1000149c <pneumatics2>
	delay_ms(1000);
10003210:	23fa      	movs	r3, #250	; 0xfa
10003212:	009b      	lsls	r3, r3, #2
10003214:	1c18      	adds	r0, r3, #0
10003216:	f7ff fad3 	bl	100027c0 <delay_ms>
	pneumatics2(IN);
1000321a:	2000      	movs	r0, #0
1000321c:	f7fe f93e 	bl	1000149c <pneumatics2>
}
10003220:	46bd      	mov	sp, r7
10003222:	b002      	add	sp, #8
10003224:	bd80      	pop	{r7, pc}
10003226:	46c0      	nop			; (mov r8, r8)
10003228:	00001388 	.word	0x00001388

1000322c <__aeabi_uidiv>:
1000322c:	2200      	movs	r2, #0
1000322e:	0843      	lsrs	r3, r0, #1
10003230:	428b      	cmp	r3, r1
10003232:	d374      	bcc.n	1000331e <__aeabi_uidiv+0xf2>
10003234:	0903      	lsrs	r3, r0, #4
10003236:	428b      	cmp	r3, r1
10003238:	d35f      	bcc.n	100032fa <__aeabi_uidiv+0xce>
1000323a:	0a03      	lsrs	r3, r0, #8
1000323c:	428b      	cmp	r3, r1
1000323e:	d344      	bcc.n	100032ca <__aeabi_uidiv+0x9e>
10003240:	0b03      	lsrs	r3, r0, #12
10003242:	428b      	cmp	r3, r1
10003244:	d328      	bcc.n	10003298 <__aeabi_uidiv+0x6c>
10003246:	0c03      	lsrs	r3, r0, #16
10003248:	428b      	cmp	r3, r1
1000324a:	d30d      	bcc.n	10003268 <__aeabi_uidiv+0x3c>
1000324c:	22ff      	movs	r2, #255	; 0xff
1000324e:	0209      	lsls	r1, r1, #8
10003250:	ba12      	rev	r2, r2
10003252:	0c03      	lsrs	r3, r0, #16
10003254:	428b      	cmp	r3, r1
10003256:	d302      	bcc.n	1000325e <__aeabi_uidiv+0x32>
10003258:	1212      	asrs	r2, r2, #8
1000325a:	0209      	lsls	r1, r1, #8
1000325c:	d065      	beq.n	1000332a <__aeabi_uidiv+0xfe>
1000325e:	0b03      	lsrs	r3, r0, #12
10003260:	428b      	cmp	r3, r1
10003262:	d319      	bcc.n	10003298 <__aeabi_uidiv+0x6c>
10003264:	e000      	b.n	10003268 <__aeabi_uidiv+0x3c>
10003266:	0a09      	lsrs	r1, r1, #8
10003268:	0bc3      	lsrs	r3, r0, #15
1000326a:	428b      	cmp	r3, r1
1000326c:	d301      	bcc.n	10003272 <__aeabi_uidiv+0x46>
1000326e:	03cb      	lsls	r3, r1, #15
10003270:	1ac0      	subs	r0, r0, r3
10003272:	4152      	adcs	r2, r2
10003274:	0b83      	lsrs	r3, r0, #14
10003276:	428b      	cmp	r3, r1
10003278:	d301      	bcc.n	1000327e <__aeabi_uidiv+0x52>
1000327a:	038b      	lsls	r3, r1, #14
1000327c:	1ac0      	subs	r0, r0, r3
1000327e:	4152      	adcs	r2, r2
10003280:	0b43      	lsrs	r3, r0, #13
10003282:	428b      	cmp	r3, r1
10003284:	d301      	bcc.n	1000328a <__aeabi_uidiv+0x5e>
10003286:	034b      	lsls	r3, r1, #13
10003288:	1ac0      	subs	r0, r0, r3
1000328a:	4152      	adcs	r2, r2
1000328c:	0b03      	lsrs	r3, r0, #12
1000328e:	428b      	cmp	r3, r1
10003290:	d301      	bcc.n	10003296 <__aeabi_uidiv+0x6a>
10003292:	030b      	lsls	r3, r1, #12
10003294:	1ac0      	subs	r0, r0, r3
10003296:	4152      	adcs	r2, r2
10003298:	0ac3      	lsrs	r3, r0, #11
1000329a:	428b      	cmp	r3, r1
1000329c:	d301      	bcc.n	100032a2 <__aeabi_uidiv+0x76>
1000329e:	02cb      	lsls	r3, r1, #11
100032a0:	1ac0      	subs	r0, r0, r3
100032a2:	4152      	adcs	r2, r2
100032a4:	0a83      	lsrs	r3, r0, #10
100032a6:	428b      	cmp	r3, r1
100032a8:	d301      	bcc.n	100032ae <__aeabi_uidiv+0x82>
100032aa:	028b      	lsls	r3, r1, #10
100032ac:	1ac0      	subs	r0, r0, r3
100032ae:	4152      	adcs	r2, r2
100032b0:	0a43      	lsrs	r3, r0, #9
100032b2:	428b      	cmp	r3, r1
100032b4:	d301      	bcc.n	100032ba <__aeabi_uidiv+0x8e>
100032b6:	024b      	lsls	r3, r1, #9
100032b8:	1ac0      	subs	r0, r0, r3
100032ba:	4152      	adcs	r2, r2
100032bc:	0a03      	lsrs	r3, r0, #8
100032be:	428b      	cmp	r3, r1
100032c0:	d301      	bcc.n	100032c6 <__aeabi_uidiv+0x9a>
100032c2:	020b      	lsls	r3, r1, #8
100032c4:	1ac0      	subs	r0, r0, r3
100032c6:	4152      	adcs	r2, r2
100032c8:	d2cd      	bcs.n	10003266 <__aeabi_uidiv+0x3a>
100032ca:	09c3      	lsrs	r3, r0, #7
100032cc:	428b      	cmp	r3, r1
100032ce:	d301      	bcc.n	100032d4 <__aeabi_uidiv+0xa8>
100032d0:	01cb      	lsls	r3, r1, #7
100032d2:	1ac0      	subs	r0, r0, r3
100032d4:	4152      	adcs	r2, r2
100032d6:	0983      	lsrs	r3, r0, #6
100032d8:	428b      	cmp	r3, r1
100032da:	d301      	bcc.n	100032e0 <__aeabi_uidiv+0xb4>
100032dc:	018b      	lsls	r3, r1, #6
100032de:	1ac0      	subs	r0, r0, r3
100032e0:	4152      	adcs	r2, r2
100032e2:	0943      	lsrs	r3, r0, #5
100032e4:	428b      	cmp	r3, r1
100032e6:	d301      	bcc.n	100032ec <__aeabi_uidiv+0xc0>
100032e8:	014b      	lsls	r3, r1, #5
100032ea:	1ac0      	subs	r0, r0, r3
100032ec:	4152      	adcs	r2, r2
100032ee:	0903      	lsrs	r3, r0, #4
100032f0:	428b      	cmp	r3, r1
100032f2:	d301      	bcc.n	100032f8 <__aeabi_uidiv+0xcc>
100032f4:	010b      	lsls	r3, r1, #4
100032f6:	1ac0      	subs	r0, r0, r3
100032f8:	4152      	adcs	r2, r2
100032fa:	08c3      	lsrs	r3, r0, #3
100032fc:	428b      	cmp	r3, r1
100032fe:	d301      	bcc.n	10003304 <__aeabi_uidiv+0xd8>
10003300:	00cb      	lsls	r3, r1, #3
10003302:	1ac0      	subs	r0, r0, r3
10003304:	4152      	adcs	r2, r2
10003306:	0883      	lsrs	r3, r0, #2
10003308:	428b      	cmp	r3, r1
1000330a:	d301      	bcc.n	10003310 <__aeabi_uidiv+0xe4>
1000330c:	008b      	lsls	r3, r1, #2
1000330e:	1ac0      	subs	r0, r0, r3
10003310:	4152      	adcs	r2, r2
10003312:	0843      	lsrs	r3, r0, #1
10003314:	428b      	cmp	r3, r1
10003316:	d301      	bcc.n	1000331c <__aeabi_uidiv+0xf0>
10003318:	004b      	lsls	r3, r1, #1
1000331a:	1ac0      	subs	r0, r0, r3
1000331c:	4152      	adcs	r2, r2
1000331e:	1a41      	subs	r1, r0, r1
10003320:	d200      	bcs.n	10003324 <__aeabi_uidiv+0xf8>
10003322:	4601      	mov	r1, r0
10003324:	4152      	adcs	r2, r2
10003326:	4610      	mov	r0, r2
10003328:	4770      	bx	lr
1000332a:	e7ff      	b.n	1000332c <__aeabi_uidiv+0x100>
1000332c:	b501      	push	{r0, lr}
1000332e:	2000      	movs	r0, #0
10003330:	f000 f80c 	bl	1000334c <__aeabi_idiv0>
10003334:	bd02      	pop	{r1, pc}
10003336:	46c0      	nop			; (mov r8, r8)

10003338 <__aeabi_uidivmod>:
10003338:	2900      	cmp	r1, #0
1000333a:	d0f7      	beq.n	1000332c <__aeabi_uidiv+0x100>
1000333c:	b503      	push	{r0, r1, lr}
1000333e:	f7ff ff75 	bl	1000322c <__aeabi_uidiv>
10003342:	bc0e      	pop	{r1, r2, r3}
10003344:	4342      	muls	r2, r0
10003346:	1a89      	subs	r1, r1, r2
10003348:	4718      	bx	r3
1000334a:	46c0      	nop			; (mov r8, r8)

1000334c <__aeabi_idiv0>:
1000334c:	4770      	bx	lr
1000334e:	46c0      	nop			; (mov r8, r8)

10003350 <__libc_init_array>:
10003350:	4b0e      	ldr	r3, [pc, #56]	; (1000338c <__libc_init_array+0x3c>)
10003352:	b570      	push	{r4, r5, r6, lr}
10003354:	2500      	movs	r5, #0
10003356:	1c1e      	adds	r6, r3, #0
10003358:	4c0d      	ldr	r4, [pc, #52]	; (10003390 <__libc_init_array+0x40>)
1000335a:	1ae4      	subs	r4, r4, r3
1000335c:	10a4      	asrs	r4, r4, #2
1000335e:	42a5      	cmp	r5, r4
10003360:	d004      	beq.n	1000336c <__libc_init_array+0x1c>
10003362:	00ab      	lsls	r3, r5, #2
10003364:	58f3      	ldr	r3, [r6, r3]
10003366:	4798      	blx	r3
10003368:	3501      	adds	r5, #1
1000336a:	e7f8      	b.n	1000335e <__libc_init_array+0xe>
1000336c:	f7fd ff08 	bl	10001180 <_init>
10003370:	4b08      	ldr	r3, [pc, #32]	; (10003394 <__libc_init_array+0x44>)
10003372:	2500      	movs	r5, #0
10003374:	1c1e      	adds	r6, r3, #0
10003376:	4c08      	ldr	r4, [pc, #32]	; (10003398 <__libc_init_array+0x48>)
10003378:	1ae4      	subs	r4, r4, r3
1000337a:	10a4      	asrs	r4, r4, #2
1000337c:	42a5      	cmp	r5, r4
1000337e:	d004      	beq.n	1000338a <__libc_init_array+0x3a>
10003380:	00ab      	lsls	r3, r5, #2
10003382:	58f3      	ldr	r3, [r6, r3]
10003384:	4798      	blx	r3
10003386:	3501      	adds	r5, #1
10003388:	e7f8      	b.n	1000337c <__libc_init_array+0x2c>
1000338a:	bd70      	pop	{r4, r5, r6, pc}
1000338c:	20000520 	.word	0x20000520
10003390:	20000520 	.word	0x20000520
10003394:	20000520 	.word	0x20000520
10003398:	20000520 	.word	0x20000520
1000339c:	646f6f47 	.word	0x646f6f47
100033a0:	20726f20 	.word	0x20726f20
100033a4:	3f646162 	.word	0x3f646162
100033a8:	00000d0a 	.word	0x00000d0a
100033ac:	6e206f44 	.word	0x6e206f44
100033b0:	6968746f 	.word	0x6968746f
100033b4:	002e676e 	.word	0x002e676e

Disassembly of section .VENEER_Code:

2000000c <HardFault_Veneer>:
    
    .align 1
    
    .globl HardFault_Veneer
HardFault_Veneer:
    LDR R0, =HardFault_Handler
2000000c:	482c      	ldr	r0, [pc, #176]	; (200000c0 <CCU40_3_Veneer+0x20>)
    MOV PC,R0
2000000e:	4687      	mov	pc, r0
	...

2000002c <SVC_Veneer>:
    .long 0
    
/* ======================================================================== */
    .globl SVC_Veneer
SVC_Veneer:
    LDR R0, =SVC_Handler
2000002c:	4825      	ldr	r0, [pc, #148]	; (200000c4 <CCU40_3_Veneer+0x24>)
    MOV PC,R0
2000002e:	4687      	mov	pc, r0
	...

20000038 <PendSV_Veneer>:
    .long 0
    .long 0
/* ======================================================================== */
    .globl PendSV_Veneer
PendSV_Veneer:
    LDR R0, =PendSV_Handler
20000038:	4823      	ldr	r0, [pc, #140]	; (200000c8 <CCU40_3_Veneer+0x28>)
    MOV PC,R0
2000003a:	4687      	mov	pc, r0

2000003c <SysTick_Veneer>:
/* ======================================================================== */
    .globl SysTick_Veneer 
SysTick_Veneer:
    LDR R0, =SysTick_Handler
2000003c:	4823      	ldr	r0, [pc, #140]	; (200000cc <CCU40_3_Veneer+0x2c>)
    MOV PC,R0
2000003e:	4687      	mov	pc, r0

20000040 <SCU_0_Veneer>:
/* ======================================================================== */
    .globl SCU_0_Veneer 
SCU_0_Veneer:
    LDR R0, =SCU_0_IRQHandler
20000040:	4823      	ldr	r0, [pc, #140]	; (200000d0 <CCU40_3_Veneer+0x30>)
    MOV PC,R0
20000042:	4687      	mov	pc, r0

20000044 <SCU_1_Veneer>:
/* ======================================================================== */
    .globl SCU_1_Veneer 
SCU_1_Veneer:
    LDR R0, =SCU_1_IRQHandler
20000044:	4823      	ldr	r0, [pc, #140]	; (200000d4 <CCU40_3_Veneer+0x34>)
    MOV PC,R0
20000046:	4687      	mov	pc, r0

20000048 <SCU_2_Veneer>:
/* ======================================================================== */
    .globl SCU_2_Veneer
SCU_2_Veneer:
    LDR R0, =SCU_2_IRQHandler
20000048:	4823      	ldr	r0, [pc, #140]	; (200000d8 <CCU40_3_Veneer+0x38>)
    MOV PC,R0
2000004a:	4687      	mov	pc, r0

2000004c <SCU_3_Veneer>:
/* ======================================================================== */
    .globl SCU_3_Veneer 
SCU_3_Veneer:
    LDR R0, =ERU0_0_IRQHandler
2000004c:	4823      	ldr	r0, [pc, #140]	; (200000dc <CCU40_3_Veneer+0x3c>)
    MOV PC,R0
2000004e:	4687      	mov	pc, r0

20000050 <SCU_4_Veneer>:
/* ======================================================================== */
    .globl SCU_4_Veneer 
SCU_4_Veneer:
    LDR R0, =ERU0_1_IRQHandler
20000050:	4823      	ldr	r0, [pc, #140]	; (200000e0 <CCU40_3_Veneer+0x40>)
    MOV PC,R0
20000052:	4687      	mov	pc, r0

20000054 <SCU_5_Veneer>:
/* ======================================================================== */
    .globl SCU_5_Veneer 
SCU_5_Veneer:
    LDR R0, =ERU0_2_IRQHandler
20000054:	4823      	ldr	r0, [pc, #140]	; (200000e4 <CCU40_3_Veneer+0x44>)
    MOV PC,R0
20000056:	4687      	mov	pc, r0

20000058 <SCU_6_Veneer>:
/* ======================================================================== */
    .globl SCU_6_Veneer 
SCU_6_Veneer:
    LDR R0, =ERU0_3_IRQHandler
20000058:	4823      	ldr	r0, [pc, #140]	; (200000e8 <CCU40_3_Veneer+0x48>)
    MOV PC,R0
2000005a:	4687      	mov	pc, r0
	...

20000064 <USIC0_0_Veneer>:
    .long 0
    .long 0
/* ======================================================================== */
    .globl USIC0_0_Veneer
USIC0_0_Veneer:
    LDR R0, =USIC0_0_IRQHandler
20000064:	4821      	ldr	r0, [pc, #132]	; (200000ec <CCU40_3_Veneer+0x4c>)
    MOV PC,R0
20000066:	4687      	mov	pc, r0

20000068 <USIC0_1_Veneer>:
/* ======================================================================== */
    .globl USIC0_1_Veneer
USIC0_1_Veneer:
    LDR R0, =USIC0_1_IRQHandler
20000068:	4821      	ldr	r0, [pc, #132]	; (200000f0 <CCU40_3_Veneer+0x50>)
    MOV PC,R0
2000006a:	4687      	mov	pc, r0

2000006c <USIC0_2_Veneer>:
/* ======================================================================== */
    .globl USIC0_2_Veneer
USIC0_2_Veneer:
    LDR R0, =USIC0_2_IRQHandler
2000006c:	4821      	ldr	r0, [pc, #132]	; (200000f4 <CCU40_3_Veneer+0x54>)
    MOV PC,R0
2000006e:	4687      	mov	pc, r0

20000070 <USIC0_3_Veneer>:
/* ======================================================================== */
    .globl USIC0_3_Veneer
USIC0_3_Veneer:
    LDR R0, =USIC0_3_IRQHandler
20000070:	4821      	ldr	r0, [pc, #132]	; (200000f8 <CCU40_3_Veneer+0x58>)
    MOV PC,R0
20000072:	4687      	mov	pc, r0

20000074 <USIC0_4_Veneer>:
/* ======================================================================== */
    .globl USIC0_4_Veneer
USIC0_4_Veneer:
    LDR R0, =USIC0_4_IRQHandler
20000074:	4821      	ldr	r0, [pc, #132]	; (200000fc <CCU40_3_Veneer+0x5c>)
    MOV PC,R0
20000076:	4687      	mov	pc, r0

20000078 <USIC0_5_Veneer>:
/* ======================================================================== */
    .globl USIC0_5_Veneer
USIC0_5_Veneer:
    LDR R0, =USIC0_5_IRQHandler
20000078:	4821      	ldr	r0, [pc, #132]	; (20000100 <CCU40_3_Veneer+0x60>)
    MOV PC,R0
2000007a:	4687      	mov	pc, r0

2000007c <VADC0_C0_0_Veneer>:
/* ======================================================================== */
    .globl VADC0_C0_0_Veneer 
VADC0_C0_0_Veneer:
    LDR R0, =VADC0_C0_0_IRQHandler
2000007c:	4821      	ldr	r0, [pc, #132]	; (20000104 <CCU40_3_Veneer+0x64>)
    MOV PC,R0
2000007e:	4687      	mov	pc, r0

20000080 <VADC0_C0_1_Veneer>:
/* ======================================================================== */
    .globl VADC0_C0_1_Veneer
VADC0_C0_1_Veneer:
    LDR R0, =VADC0_C0_1_IRQHandler
20000080:	4821      	ldr	r0, [pc, #132]	; (20000108 <CCU40_3_Veneer+0x68>)
    MOV PC,R0
20000082:	4687      	mov	pc, r0
	...

20000094 <CCU40_0_Veneer>:
    .long 0
    .long 0
/* ======================================================================== */
    .globl CCU40_0_Veneer
CCU40_0_Veneer:
    LDR R0, =CCU40_0_IRQHandler
20000094:	481d      	ldr	r0, [pc, #116]	; (2000010c <CCU40_3_Veneer+0x6c>)
    MOV PC,R0
20000096:	4687      	mov	pc, r0

20000098 <CCU40_1_Veneer>:
/* ======================================================================== */
    .globl CCU40_1_Veneer
CCU40_1_Veneer:
    LDR R0, =CCU40_1_IRQHandler
20000098:	481d      	ldr	r0, [pc, #116]	; (20000110 <CCU40_3_Veneer+0x70>)
    MOV PC,R0
2000009a:	4687      	mov	pc, r0

2000009c <CCU40_2_Veneer>:
/* ======================================================================== */
    .globl CCU40_2_Veneer
CCU40_2_Veneer:
    LDR R0, =CCU40_2_IRQHandler
2000009c:	481d      	ldr	r0, [pc, #116]	; (20000114 <CCU40_3_Veneer+0x74>)
    MOV PC,R0
2000009e:	4687      	mov	pc, r0

200000a0 <CCU40_3_Veneer>:
/* ======================================================================== */
    .globl CCU40_3_Veneer
CCU40_3_Veneer:
    LDR R0, =CCU40_3_IRQHandler
200000a0:	481d      	ldr	r0, [pc, #116]	; (20000118 <CCU40_3_Veneer+0x78>)
    MOV PC,R0
200000a2:	4687      	mov	pc, r0
	...
    
    .align 1
    
    .globl HardFault_Veneer
HardFault_Veneer:
    LDR R0, =HardFault_Handler
200000c0:	10001099 	.word	0x10001099
    .long 0
    
/* ======================================================================== */
    .globl SVC_Veneer
SVC_Veneer:
    LDR R0, =SVC_Handler
200000c4:	10001099 	.word	0x10001099
    .long 0
    .long 0
/* ======================================================================== */
    .globl PendSV_Veneer
PendSV_Veneer:
    LDR R0, =PendSV_Handler
200000c8:	10001099 	.word	0x10001099
    MOV PC,R0
/* ======================================================================== */
    .globl SysTick_Veneer 
SysTick_Veneer:
    LDR R0, =SysTick_Handler
200000cc:	10001099 	.word	0x10001099
    MOV PC,R0
/* ======================================================================== */
    .globl SCU_0_Veneer 
SCU_0_Veneer:
    LDR R0, =SCU_0_IRQHandler
200000d0:	10001099 	.word	0x10001099
    MOV PC,R0
/* ======================================================================== */
    .globl SCU_1_Veneer 
SCU_1_Veneer:
    LDR R0, =SCU_1_IRQHandler
200000d4:	10001099 	.word	0x10001099
    MOV PC,R0
/* ======================================================================== */
    .globl SCU_2_Veneer
SCU_2_Veneer:
    LDR R0, =SCU_2_IRQHandler
200000d8:	10001099 	.word	0x10001099
    MOV PC,R0
/* ======================================================================== */
    .globl SCU_3_Veneer 
SCU_3_Veneer:
    LDR R0, =ERU0_0_IRQHandler
200000dc:	10001099 	.word	0x10001099
    MOV PC,R0
/* ======================================================================== */
    .globl SCU_4_Veneer 
SCU_4_Veneer:
    LDR R0, =ERU0_1_IRQHandler
200000e0:	10001099 	.word	0x10001099
    MOV PC,R0
/* ======================================================================== */
    .globl SCU_5_Veneer 
SCU_5_Veneer:
    LDR R0, =ERU0_2_IRQHandler
200000e4:	10001099 	.word	0x10001099
    MOV PC,R0
/* ======================================================================== */
    .globl SCU_6_Veneer 
SCU_6_Veneer:
    LDR R0, =ERU0_3_IRQHandler
200000e8:	10001099 	.word	0x10001099
    .long 0
    .long 0
/* ======================================================================== */
    .globl USIC0_0_Veneer
USIC0_0_Veneer:
    LDR R0, =USIC0_0_IRQHandler
200000ec:	10002a39 	.word	0x10002a39
    MOV PC,R0
/* ======================================================================== */
    .globl USIC0_1_Veneer
USIC0_1_Veneer:
    LDR R0, =USIC0_1_IRQHandler
200000f0:	10002d75 	.word	0x10002d75
    MOV PC,R0
/* ======================================================================== */
    .globl USIC0_2_Veneer
USIC0_2_Veneer:
    LDR R0, =USIC0_2_IRQHandler
200000f4:	10001099 	.word	0x10001099
    MOV PC,R0
/* ======================================================================== */
    .globl USIC0_3_Veneer
USIC0_3_Veneer:
    LDR R0, =USIC0_3_IRQHandler
200000f8:	10001099 	.word	0x10001099
    MOV PC,R0
/* ======================================================================== */
    .globl USIC0_4_Veneer
USIC0_4_Veneer:
    LDR R0, =USIC0_4_IRQHandler
200000fc:	10001099 	.word	0x10001099
    MOV PC,R0
/* ======================================================================== */
    .globl USIC0_5_Veneer
USIC0_5_Veneer:
    LDR R0, =USIC0_5_IRQHandler
20000100:	10001099 	.word	0x10001099
    MOV PC,R0
/* ======================================================================== */
    .globl VADC0_C0_0_Veneer 
VADC0_C0_0_Veneer:
    LDR R0, =VADC0_C0_0_IRQHandler
20000104:	10001099 	.word	0x10001099
    MOV PC,R0
/* ======================================================================== */
    .globl VADC0_C0_1_Veneer
VADC0_C0_1_Veneer:
    LDR R0, =VADC0_C0_1_IRQHandler
20000108:	10001099 	.word	0x10001099
    .long 0
    .long 0
/* ======================================================================== */
    .globl CCU40_0_Veneer
CCU40_0_Veneer:
    LDR R0, =CCU40_0_IRQHandler
2000010c:	10001099 	.word	0x10001099
    MOV PC,R0
/* ======================================================================== */
    .globl CCU40_1_Veneer
CCU40_1_Veneer:
    LDR R0, =CCU40_1_IRQHandler
20000110:	10001099 	.word	0x10001099
    MOV PC,R0
/* ======================================================================== */
    .globl CCU40_2_Veneer
CCU40_2_Veneer:
    LDR R0, =CCU40_2_IRQHandler
20000114:	10001099 	.word	0x10001099
    MOV PC,R0
/* ======================================================================== */
    .globl CCU40_3_Veneer
CCU40_3_Veneer:
    LDR R0, =CCU40_3_IRQHandler
20000118:	10001099 	.word	0x10001099
